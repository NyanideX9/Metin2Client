; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\scriptLib\Distribute\PythonMarshal.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadObjectFromFile
PUBLIC	?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadLastObjectFromFile
PUBLIC	?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z	; _PyMarshal_ReadLongFromFile
PUBLIC	?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z	; _PyMarshal_ReadShortFromFile
PUBLIC	?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z ; _PyMarshal_ReadObjectFromString
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@ ; `string'
PUBLIC	??_C@_0BB@DCKILJJE@bad?5marshal?5data@		; `string'
PUBLIC	??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@ ; `string'
PUBLIC	??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@ ; `string'
PUBLIC	??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_atof:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	__fileno:PROC
EXTRN	_fread:PROC
EXTRN	_getc:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	__fstat64i32:PROC
EXTRN	__imp__PyUnicodeUCS2_DecodeUTF8:PROC
EXTRN	__imp__PyInt_FromLong:PROC
EXTRN	__imp___PyLong_FromByteArray:PROC
EXTRN	__imp__PyFloat_FromDouble:PROC
EXTRN	__imp__PyComplex_FromCComplex:PROC
EXTRN	__imp__PyString_FromStringAndSize:PROC
EXTRN	__imp__PyTuple_New:PROC
EXTRN	__imp__PyList_New:PROC
EXTRN	__imp__PyList_SetItem:PROC
EXTRN	__imp__PyDict_New:PROC
EXTRN	__imp__PyDict_SetItem:PROC
EXTRN	__imp__PyErr_SetString:PROC
EXTRN	__imp__PyErr_Occurred:PROC
EXTRN	__imp__PyErr_NoMemory:PROC
EXTRN	__imp__PyEval_GetRestricted:PROC
EXTRN	__imp__PyCode_New:PROC
EXTRN	__imp__PyMarshal_ReadObjectFromString:PROC
EXTRN	__imp___PyLong_New:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp___Py_NoneStruct:QWORD
EXTRN	__imp___Py_EllipsisObject:QWORD
EXTRN	__imp__PyExc_StopIteration:DWORD
EXTRN	__imp__PyExc_EOFError:DWORD
EXTRN	__imp__PyExc_RuntimeError:DWORD
EXTRN	__imp__PyExc_ValueError:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@
CONST	SEGMENT
??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@ DB 'XXX rds_objec'
	DB	't called with exception set', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
CONST	SEGMENT
??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@ DB 'XXX rd_object '
	DB	'called with exception set', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@
CONST	SEGMENT
??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@ DB 'cannot unmars'
	DB	'hal code objects in restricted execution mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
CONST	SEGMENT
??_C@_0BB@DCKILJJE@bad?5marshal?5data@ DB 'bad marshal data', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
CONST	SEGMENT
??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@ DB 'EOF read where'
	DB	' object expected', 00H			; `string'
CONST	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_str$ = 8						; size = 4
_len$ = 12						; size = 4
?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z PROC ; _PyMarshal_ReadObjectFromString, COMDAT

; 467  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 468  : 	RFILE rf;
; 469  : 	if (PyErr_Occurred()) {

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN2@PyMarshal_

; 470  : 		fprintf(stderr, "XXX rds_object called with exception set\n");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@PCMIHNOG@XXX?5rds_object?5called?5with?5exce@
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ___acrt_iob_func
  0001c	83 c4 04	 add	 esp, 4
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _fprintf
  00025	83 c4 08	 add	 esp, 8

; 471  : 		return NULL;

  00028	33 c0		 xor	 eax, eax

; 478  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN2@PyMarshal_:

; 472  : 	}
; 473  : 	rf.fp = NULL;
; 474  : 	rf.str = NULL;
; 475  : 	rf.ptr = str;

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR _str$[ebp]

; 476  : 	rf.end = str + len;

  00031	8b 45 0c	 mov	 eax, DWORD PTR _len$[ebp]
  00034	03 c1		 add	 eax, ecx
  00036	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _rf$[ebp], 0
  0003d	89 45 fc	 mov	 DWORD PTR _rf$[ebp+20], eax

; 477  : 	return r_object(&rf);

  00040	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  00043	50		 push	 eax
  00044	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _rf$[ebp+12], 0
  0004b	89 4d f8	 mov	 DWORD PTR _rf$[ebp+16], ecx
  0004e	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  00053	83 c4 04	 add	 esp, 4

; 478  : }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?_PyMarshal_ReadObjectFromString@@YAPAU_object@@PADH@Z ENDP ; _PyMarshal_ReadObjectFromString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\sys\stat.h
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\sys\stat.h
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?getfilesize@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT
_st$ = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
?getfilesize@@YAJPAU_iobuf@@@Z PROC			; getfilesize, COMDAT

; 398  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]

; 400  : 	if (fstat(fileno(fp), &st) != 0)

  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 __fileno
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\sys\stat.h

; 236  :             return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);

  00019	8d 4d cc	 lea	 ecx, DWORD PTR _st$[ebp]
  0001c	51		 push	 ecx
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 __fstat64i32
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp

; 400  : 	if (fstat(fileno(fp), &st) != 0)

  00023	8b 4d e0	 mov	 ecx, DWORD PTR _st$[ebp+20]
  00026	83 ca ff	 or	 edx, -1
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\sys\stat.h

; 236  :             return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);

  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp

; 400  : 	if (fstat(fileno(fp), &st) != 0)

  0002c	85 c0		 test	 eax, eax
  0002e	0f 45 ca	 cmovne	 ecx, edx
  00031	8b c1		 mov	 eax, ecx

; 401  : 		return -1;
; 402  : 	else
; 403  : 		return st.st_size;
; 404  : }

  00033	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00036	33 cd		 xor	 ecx, ebp
  00038	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?getfilesize@@YAJPAU_iobuf@@@Z ENDP			; getfilesize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z PROC	; _PyMarshal_ReadShortFromFile, COMDAT

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 384  : 	RFILE rf;
; 385  : 	rf.fp = fp;

  00006	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00009	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 386  : 	return r_short(&rf);

  0000c	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?r_short@@YAHPAUSWFILE@@@Z ; r_short
  00015	83 c4 04	 add	 esp, 4

; 387  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_PyMarshal_ReadShortFromFile@@YAHPAU_iobuf@@@Z ENDP	; _PyMarshal_ReadShortFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_object@@YAPAU_object@@PAUSWFILE@@@Z
_TEXT	SEGMENT
_nlocals$1$ = -316					; size = 4
_stacksize$1$ = -312					; size = 4
_flags$1$ = -308					; size = 4
_freevars$1$ = -304					; size = 4
_varnames$1$ = -300					; size = 4
_names$1$ = -296					; size = 4
_consts$1$ = -292					; size = 4
_c$1 = -288						; size = 16
_dx$2 = -280						; size = 8
tv851 = -276						; size = 4
tv881 = -276						; size = 4
tv871 = -276						; size = 4
tv861 = -276						; size = 4
tv808 = -276						; size = 4
tv831 = -276						; size = 4
tv841 = -276						; size = 4
tv755 = -276						; size = 4
tv778 = -276						; size = 4
tv787 = -276						; size = 4
tv798 = -276						; size = 4
tv891 = -276						; size = 4
tv901 = -276						; size = 4
tv912 = -276						; size = 4
_argcount$1$ = -276					; size = 4
_v$6$ = -272						; size = 4
_firstlineno$1$ = -272					; size = 4
_n$7$ = -268						; size = 4
_ob$1$ = -268						; size = 4
_code$1$ = -268						; size = 4
_v$3$ = -264						; size = 4
_v$5$ = -264						; size = 4
$T3 = -264						; size = 4
_cellvars$1$ = -264					; size = 4
_n$8$ = -264						; size = 4
_buf$4 = -260						; size = 256
_buf$5 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
?r_object@@YAPAU_object@@PAUSWFILE@@@Z PROC		; r_object, COMDAT

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00018	57		 push	 edi

; 124  : 	PyObject *v, *v2;
; 125  : 	long i, n;
; 126  : 	int type = r_byte(p);

  00019	8b 06		 mov	 eax, DWORD PTR [esi]
  0001b	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  0001e	89 8d f8 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  00024	85 c0		 test	 eax, eax
  00026	74 10		 je	 SHORT $LN187@r_object
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _getc
  0002e	83 c4 04	 add	 esp, 4
  00031	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00034	8b d0		 mov	 edx, eax
  00036	eb 18		 jmp	 SHORT $LN186@r_object
$LN187@r_object:
  00038	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0003b	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0003d	0f 84 2a 08 00
	00		 je	 $LN88@r_object
  00043	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00046	40		 inc	 eax
  00047	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0004a	89 8d f8 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
$LN186@r_object:

; 127  : 
; 128  : 	switch (type) {

  00050	42		 inc	 edx
  00051	83 fa 7c	 cmp	 edx, 124		; 0000007cH
  00054	0f 87 9e 02 00
	00		 ja	 $LN321@r_object
  0005a	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN236@r_object[edx]
  00061	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN237@r_object[eax*4]
$LN90@r_object:

; 129  : 
; 130  : 	case EOF:
; 131  : 		PyErr_SetString(PyExc_EOFError,
; 132  : 				"EOF read where object expected");
; 133  : 		return NULL;
; 134  : 
; 135  : 	case TYPE_NULL:
; 136  : 		return NULL;
; 137  : 
; 138  : 	case TYPE_NONE:
; 139  : 		Py_INCREF(Py_None);

  00068	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct
  0006d	ff 00		 inc	 DWORD PTR [eax]

; 140  : 		return Py_None;

  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_NoneStruct

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007a	33 cd		 xor	 ecx, ebp
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
$LN91@r_object:

; 141  : 
; 142  : 	case TYPE_STOPITER:
; 143  : 		Py_INCREF(PyExc_StopIteration);

  00085	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_StopIteration
  0008a	8b 00		 mov	 eax, DWORD PTR [eax]
  0008c	ff 00		 inc	 DWORD PTR [eax]

; 144  : 		return PyExc_StopIteration;

  0008e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_StopIteration
  00093	8b 00		 mov	 eax, DWORD PTR [eax]

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009b	33 cd		 xor	 ecx, ebp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
$LN92@r_object:

; 145  : 
; 146  : 	case TYPE_ELLIPSIS:
; 147  : 		Py_INCREF(Py_Ellipsis);

  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_EllipsisObject
  000ab	ff 00		 inc	 DWORD PTR [eax]

; 148  : 		return Py_Ellipsis;

  000ad	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp___Py_EllipsisObject

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	33 cd		 xor	 ecx, ebp
  000ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
$LN93@r_object:

; 149  : 
; 150  : 	case TYPE_INT:
; 151  : 		return PyInt_FromLong(r_long(p));

  000c3	56		 push	 esi
  000c4	e8 00 00 00 00	 call	 ?r_long@@YAJPAUSWFILE@@@Z ; r_long
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyInt_FromLong
  000d0	83 c4 08	 add	 esp, 8

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  000d3	5f		 pop	 edi
  000d4	5e		 pop	 esi
  000d5	5b		 pop	 ebx
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
$LN94@r_object:

; 152  : 
; 153  : 	case TYPE_INT64:
; 154  : 		return r_long64(p);

  000e4	56		 push	 esi
  000e5	e8 00 00 00 00	 call	 ?r_long64@@YAPAU_object@@PAUSWFILE@@@Z ; r_long64
  000ea	83 c4 04	 add	 esp, 4

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	5b		 pop	 ebx
  000f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f3	33 cd		 xor	 ecx, ebp
  000f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c3		 ret	 0
$LN95@r_object:

; 155  : 
; 156  : 	case TYPE_LONG:
; 157  : 		{
; 158  : 			int size;
; 159  : 			PyLongObject* ob;
; 160  : 			n = r_long(p);

  000fe	56		 push	 esi
  000ff	e8 00 00 00 00	 call	 ?r_long@@YAJPAUSWFILE@@@Z ; r_long
  00104	8b d8		 mov	 ebx, eax

; 161  : 			size = n<0 ? -n : n;

  00106	99		 cdq
  00107	8b f8		 mov	 edi, eax
  00109	33 fa		 xor	 edi, edx
  0010b	2b fa		 sub	 edi, edx

; 162  : 			ob = _PyLong_New(size);

  0010d	57		 push	 edi
  0010e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___PyLong_New
  00114	83 c4 08	 add	 esp, 8
  00117	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _ob$1$[ebp], eax

; 163  : 			if (ob == NULL)

  0011d	85 c0		 test	 eax, eax
  0011f	0f 84 5d 07 00
	00		 je	 $LN319@r_object

; 164  : 				return NULL;
; 165  : 			ob->ob_size = n;

  00125	89 58 08	 mov	 DWORD PTR [eax+8], ebx

; 166  : 			for (i = 0; i < size; i++)

  00128	85 ff		 test	 edi, edi
  0012a	0f 8e 54 07 00
	00		 jle	 $LN1@r_object

; 164  : 				return NULL;
; 165  : 			ob->ob_size = n;

  00130	8d 58 0c	 lea	 ebx, DWORD PTR [eax+12]
$LL6@r_object:

; 167  : 				ob->ob_digit[i] = (short) r_short(p);

  00133	56		 push	 esi
  00134	e8 00 00 00 00	 call	 ?r_short@@YAHPAUSWFILE@@@Z ; r_short
  00139	83 c4 04	 add	 esp, 4
  0013c	66 89 03	 mov	 WORD PTR [ebx], ax
  0013f	8d 5b 02	 lea	 ebx, DWORD PTR [ebx+2]
  00142	83 ef 01	 sub	 edi, 1
  00145	75 ec		 jne	 SHORT $LL6@r_object
  00147	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR _ob$1$[ebp]

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  0014d	5f		 pop	 edi
  0014e	5e		 pop	 esi
  0014f	5b		 pop	 ebx
  00150	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00153	33 cd		 xor	 ecx, ebp
  00155	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015a	8b e5		 mov	 esp, ebp
  0015c	5d		 pop	 ebp
  0015d	c3		 ret	 0
$LN97@r_object:

; 168  : 			return (PyObject *) ob;
; 169  : 		}
; 170  : 
; 171  : 	case TYPE_FLOAT:
; 172  : 		{
; 173  : 			char buf[256];
; 174  : 			double dx;
; 175  : 			n = r_byte(p);

  0015e	8b 06		 mov	 eax, DWORD PTR [esi]
  00160	85 c0		 test	 eax, eax
  00162	74 0d		 je	 SHORT $LN191@r_object
  00164	50		 push	 eax
  00165	e8 00 00 00 00	 call	 _getc
  0016a	83 c4 04	 add	 esp, 4
  0016d	8b d8		 mov	 ebx, eax
  0016f	eb 13		 jmp	 SHORT $LN190@r_object
$LN191@r_object:
  00171	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00174	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00176	74 09		 je	 SHORT $LN189@r_object
  00178	0f b6 18	 movzx	 ebx, BYTE PTR [eax]
  0017b	40		 inc	 eax
  0017c	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0017f	eb 03		 jmp	 SHORT $LN190@r_object
$LN189@r_object:
  00181	83 cb ff	 or	 ebx, -1
$LN190@r_object:

; 176  : 			if (r_string(buf, (int)n, p) != n) {

  00184	56		 push	 esi
  00185	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  0018b	53		 push	 ebx
  0018c	50		 push	 eax
  0018d	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUSWFILE@@@Z ; r_string
  00192	83 c4 0c	 add	 esp, 12			; 0000000cH
  00195	3b c3		 cmp	 eax, ebx
  00197	0f 85 d0 06 00
	00		 jne	 $LN88@r_object

; 177  : 				PyErr_SetString(PyExc_EOFError,
; 178  : 					"EOF read where object expected");
; 179  : 				return NULL;
; 180  : 			}
; 181  : 			buf[n] = '\0';

  0019d	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  001a3	0f 83 ec 06 00
	00		 jae	 $LN193@r_object

; 182  : 			PyFPE_START_PROTECT("atof", return 0)
; 183  : 			dx = atof(buf);

  001a9	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$5[ebp]
  001af	c6 84 1d fc fe
	ff ff 00	 mov	 BYTE PTR _buf$5[ebp+ebx], 0
  001b7	50		 push	 eax
  001b8	e8 00 00 00 00	 call	 _atof
  001bd	dd 9d e8 fe ff
	ff		 fstp	 QWORD PTR _dx$2[ebp]

; 184  : 			PyFPE_END_PROTECT(dx)
; 185  : 			return PyFloat_FromDouble(dx);

  001c3	f2 0f 10 85 e8
	fe ff ff	 movsd	 xmm0, QWORD PTR _dx$2[ebp]
  001cb	51		 push	 ecx
  001cc	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyFloat_FromDouble
  001d7	83 c4 08	 add	 esp, 8

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx
  001dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001e0	33 cd		 xor	 ecx, ebp
  001e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e7	8b e5		 mov	 esp, ebp
  001e9	5d		 pop	 ebp
  001ea	c3		 ret	 0
$LN99@r_object:

; 186  : 		}
; 187  : 
; 188  : #ifndef WITHOUT_COMPLEX
; 189  : 	case TYPE_COMPLEX:
; 190  : 		{
; 191  : 			char buf[256];
; 192  : 			Py_complex c;
; 193  : 			n = r_byte(p);

  001eb	8b 06		 mov	 eax, DWORD PTR [esi]
  001ed	85 c0		 test	 eax, eax
  001ef	74 0d		 je	 SHORT $LN197@r_object
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 _getc
  001f7	83 c4 04	 add	 esp, 4
  001fa	8b d8		 mov	 ebx, eax
  001fc	eb 13		 jmp	 SHORT $LN196@r_object
$LN197@r_object:
  001fe	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00201	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00203	74 09		 je	 SHORT $LN195@r_object
  00205	0f b6 18	 movzx	 ebx, BYTE PTR [eax]
  00208	40		 inc	 eax
  00209	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0020c	eb 03		 jmp	 SHORT $LN196@r_object
$LN195@r_object:
  0020e	83 cb ff	 or	 ebx, -1
$LN196@r_object:

; 194  : 			if (r_string(buf, (int)n, p) != n) {

  00211	56		 push	 esi
  00212	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$4[ebp]
  00218	53		 push	 ebx
  00219	50		 push	 eax
  0021a	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUSWFILE@@@Z ; r_string
  0021f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00222	3b c3		 cmp	 eax, ebx
  00224	0f 85 43 06 00
	00		 jne	 $LN88@r_object

; 195  : 				PyErr_SetString(PyExc_EOFError,
; 196  : 					"EOF read where object expected");
; 197  : 				return NULL;
; 198  : 			}
; 199  : 			buf[n] = '\0';

  0022a	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  00230	0f 83 5f 06 00
	00		 jae	 $LN193@r_object

; 200  : 			PyFPE_START_PROTECT("atof", return 0)
; 201  : 			c.real = atof(buf);

  00236	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$4[ebp]
  0023c	c6 84 1d fc fe
	ff ff 00	 mov	 BYTE PTR _buf$4[ebp+ebx], 0
  00244	50		 push	 eax
  00245	e8 00 00 00 00	 call	 _atof

; 202  : 			PyFPE_END_PROTECT(c)
; 203  : 			n = r_byte(p);

  0024a	8b 06		 mov	 eax, DWORD PTR [esi]
  0024c	83 c4 04	 add	 esp, 4
  0024f	dd 9d e0 fe ff
	ff		 fstp	 QWORD PTR _c$1[ebp]
  00255	85 c0		 test	 eax, eax
  00257	74 0d		 je	 SHORT $LN203@r_object
  00259	50		 push	 eax
  0025a	e8 00 00 00 00	 call	 _getc
  0025f	83 c4 04	 add	 esp, 4
  00262	8b d8		 mov	 ebx, eax
  00264	eb 1b		 jmp	 SHORT $LN202@r_object
$LN203@r_object:
  00266	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0026c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0026f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00271	74 0b		 je	 SHORT $LN201@r_object
  00273	0f b6 19	 movzx	 ebx, BYTE PTR [ecx]
  00276	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00279	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0027c	eb 03		 jmp	 SHORT $LN202@r_object
$LN201@r_object:
  0027e	83 cb ff	 or	 ebx, -1
$LN202@r_object:

; 204  : 			if (r_string(buf, (int)n, p) != n) {

  00281	56		 push	 esi
  00282	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$4[ebp]
  00288	53		 push	 ebx
  00289	50		 push	 eax
  0028a	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUSWFILE@@@Z ; r_string
  0028f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00292	3b c3		 cmp	 eax, ebx
  00294	0f 85 d3 05 00
	00		 jne	 $LN88@r_object

; 205  : 				PyErr_SetString(PyExc_EOFError,
; 206  : 					"EOF read where object expected");
; 207  : 				return NULL;
; 208  : 			}
; 209  : 			buf[n] = '\0';

  0029a	81 fb 00 01 00
	00		 cmp	 ebx, 256		; 00000100H
  002a0	0f 83 ef 05 00
	00		 jae	 $LN193@r_object

; 210  : 			PyFPE_START_PROTECT("atof", return 0)
; 211  : 			c.imag = atof(buf);

  002a6	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _buf$4[ebp]
  002ac	c6 84 1d fc fe
	ff ff 00	 mov	 BYTE PTR _buf$4[ebp+ebx], 0
  002b4	50		 push	 eax
  002b5	e8 00 00 00 00	 call	 _atof

; 212  : 			PyFPE_END_PROTECT(c)
; 213  : 			return PyComplex_FromCComplex(c);

  002ba	83 ec 0c	 sub	 esp, 12			; 0000000cH
  002bd	8b c4		 mov	 eax, esp
  002bf	dd 9d e8 fe ff
	ff		 fstp	 QWORD PTR _c$1[ebp+8]
  002c5	0f 10 85 e0 fe
	ff ff		 movups	 xmm0, XMMWORD PTR _c$1[ebp]
  002cc	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  002cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyComplex_FromCComplex
  002d5	83 c4 10	 add	 esp, 16			; 00000010H

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  002d8	5f		 pop	 edi
  002d9	5e		 pop	 esi
  002da	5b		 pop	 ebx
  002db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002de	33 cd		 xor	 ecx, ebp
  002e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002e5	8b e5		 mov	 esp, ebp
  002e7	5d		 pop	 ebp
  002e8	c3		 ret	 0
$LN102@r_object:

; 214  : 		}
; 215  : #endif
; 216  : 
; 217  : 	case TYPE_STRING:
; 218  : 		n = r_long(p);

  002e9	56		 push	 esi
  002ea	e8 00 00 00 00	 call	 ?r_long@@YAJPAUSWFILE@@@Z ; r_long
  002ef	8b d8		 mov	 ebx, eax
  002f1	83 c4 04	 add	 esp, 4

; 219  : 		if (n < 0) {

  002f4	85 db		 test	 ebx, ebx
  002f6	79 0f		 jns	 SHORT $LN103@r_object
$LN321@r_object:

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  002f8	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_ValueError
  002fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@DCKILJJE@bad?5marshal?5data@
  00302	e9 70 05 00 00	 jmp	 $LN318@r_object
$LN103@r_object:

; 220  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 221  : 			return NULL;
; 222  : 		}
; 223  : 		v = PyString_FromStringAndSize((char *)NULL, n);

  00307	53		 push	 ebx
  00308	6a 00		 push	 0
  0030a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyString_FromStringAndSize
  00310	8b f8		 mov	 edi, eax
  00312	83 c4 08	 add	 esp, 8

; 224  : 		if (v != NULL) {

  00315	85 ff		 test	 edi, edi
  00317	74 3a		 je	 SHORT $LN105@r_object

; 225  : 			if (r_string(PyString_AS_STRING(v), (int)n, p) != n) {

  00319	56		 push	 esi
  0031a	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  0031d	53		 push	 ebx
  0031e	51		 push	 ecx
  0031f	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUSWFILE@@@Z ; r_string
  00324	83 c4 0c	 add	 esp, 12			; 0000000cH
  00327	3b c3		 cmp	 eax, ebx
  00329	74 28		 je	 SHORT $LN105@r_object

; 226  : 				Py_DECREF(v);

  0032b	83 07 ff	 add	 DWORD PTR [edi], -1
  0032e	75 0c		 jne	 SHORT $LN7@r_object
  00330	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00333	57		 push	 edi
  00334	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00337	ff d0		 call	 eax
  00339	83 c4 04	 add	 esp, 4
$LN7@r_object:

; 227  : 				v = NULL;
; 228  : 				PyErr_SetString(PyExc_EOFError,

  0033c	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  00341	33 ff		 xor	 edi, edi
  00343	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  00348	ff 30		 push	 DWORD PTR [eax]
  0034a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  00350	83 c4 08	 add	 esp, 8
$LN105@r_object:

; 229  : 					"EOF read where object expected");
; 230  : 			}
; 231  : 		}
; 232  : 		return v;

  00353	8b c7		 mov	 eax, edi

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00355	5f		 pop	 edi
  00356	5e		 pop	 esi
  00357	5b		 pop	 ebx
  00358	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0035b	33 cd		 xor	 ecx, ebp
  0035d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00362	8b e5		 mov	 esp, ebp
  00364	5d		 pop	 ebp
  00365	c3		 ret	 0
$LN108@r_object:

; 233  : 
; 234  : #ifdef Py_USING_UNICODE
; 235  : 	case TYPE_UNICODE:
; 236  : 	    {
; 237  : 		char *buffer;
; 238  : 
; 239  : 		n = r_long(p);

  00366	56		 push	 esi
  00367	e8 00 00 00 00	 call	 ?r_long@@YAJPAUSWFILE@@@Z ; r_long
  0036c	8b f8		 mov	 edi, eax
  0036e	83 c4 04	 add	 esp, 4

; 240  : 		if (n < 0) {

  00371	85 ff		 test	 edi, edi
  00373	78 83		 js	 SHORT $LN321@r_object

; 241  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 242  : 			return NULL;
; 243  : 		}
; 244  : 		buffer = PyMem_NEW(char, n);

  00375	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  0037b	77 7e		 ja	 SHORT $LN230@r_object
  0037d	85 ff		 test	 edi, edi
  0037f	b8 01 00 00 00	 mov	 eax, 1
  00384	0f 45 c7	 cmovne	 eax, edi
  00387	50		 push	 eax
  00388	e8 00 00 00 00	 call	 _malloc
  0038d	8b d8		 mov	 ebx, eax
  0038f	83 c4 04	 add	 esp, 4

; 245  : 		if (buffer == NULL)

  00392	85 db		 test	 ebx, ebx
  00394	74 65		 je	 SHORT $LN230@r_object

; 247  : 		if (r_string(buffer, (int)n, p) != n) {

  00396	56		 push	 esi
  00397	57		 push	 edi
  00398	53		 push	 ebx
  00399	e8 00 00 00 00	 call	 ?r_string@@YAHPADHPAUSWFILE@@@Z ; r_string
  0039e	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a1	3b c7		 cmp	 eax, edi
  003a3	74 2e		 je	 SHORT $LN111@r_object

; 248  : 			PyMem_DEL(buffer);

  003a5	53		 push	 ebx
  003a6	e8 00 00 00 00	 call	 _free

; 249  : 			PyErr_SetString(PyExc_EOFError,

  003ab	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  003b0	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
  003b5	ff 30		 push	 DWORD PTR [eax]
  003b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  003bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  003c0	33 c0		 xor	 eax, eax
  003c2	5f		 pop	 edi
  003c3	5e		 pop	 esi
  003c4	5b		 pop	 ebx
  003c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003c8	33 cd		 xor	 ecx, ebp
  003ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c3		 ret	 0
$LN111@r_object:

; 250  : 				"EOF read where object expected");
; 251  : 			return NULL;
; 252  : 		}
; 253  : 		v = PyUnicode_DecodeUTF8(buffer, n, NULL);

  003d3	6a 00		 push	 0
  003d5	57		 push	 edi
  003d6	53		 push	 ebx
  003d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyUnicodeUCS2_DecodeUTF8

; 254  : 		PyMem_DEL(buffer);

  003dd	53		 push	 ebx
  003de	8b f0		 mov	 esi, eax
  003e0	e8 00 00 00 00	 call	 _free
  003e5	83 c4 10	 add	 esp, 16			; 00000010H

; 255  : 		return v;

  003e8	8b c6		 mov	 eax, esi

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  003ea	5f		 pop	 edi
  003eb	5e		 pop	 esi
  003ec	5b		 pop	 ebx
  003ed	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f0	33 cd		 xor	 ecx, ebp
  003f2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003f7	8b e5		 mov	 esp, ebp
  003f9	5d		 pop	 ebp
  003fa	c3		 ret	 0
$LN230@r_object:

; 246  : 			return PyErr_NoMemory();

  003fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_NoMemory

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00401	5f		 pop	 edi
  00402	5e		 pop	 esi
  00403	5b		 pop	 ebx
  00404	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00407	33 cd		 xor	 ecx, ebp
  00409	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0040e	8b e5		 mov	 esp, ebp
  00410	5d		 pop	 ebp
  00411	c3		 ret	 0
$LN112@r_object:

; 256  : 	    }
; 257  : #endif
; 258  : 
; 259  : 	case TYPE_TUPLE:
; 260  : 		n = r_long(p);

  00412	56		 push	 esi
  00413	e8 00 00 00 00	 call	 ?r_long@@YAJPAUSWFILE@@@Z ; r_long
  00418	8b d8		 mov	 ebx, eax
  0041a	83 c4 04	 add	 esp, 4
  0041d	89 9d f4 fe ff
	ff		 mov	 DWORD PTR _n$7$[ebp], ebx

; 261  : 		if (n < 0) {

  00423	85 db		 test	 ebx, ebx
  00425	0f 88 cd fe ff
	ff		 js	 $LN321@r_object

; 262  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 263  : 			return NULL;
; 264  : 		}
; 265  : 		v = PyTuple_New((int)n);

  0042b	53		 push	 ebx
  0042c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyTuple_New
  00432	83 c4 04	 add	 esp, 4
  00435	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _v$3$[ebp], eax

; 266  : 		if (v == NULL)

  0043b	85 c0		 test	 eax, eax
  0043d	0f 84 3f 04 00
	00		 je	 $LN319@r_object

; 267  : 			return v;
; 268  : 		for (i = 0; i < n; i++) {

  00443	33 ff		 xor	 edi, edi
  00445	85 db		 test	 ebx, ebx
  00447	0f 8e 37 04 00
	00		 jle	 $LN1@r_object
  0044d	8d 58 0c	 lea	 ebx, DWORD PTR [eax+12]
$LL12@r_object:

; 269  : 			v2 = r_object(p);

  00450	56		 push	 esi
  00451	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  00456	83 c4 04	 add	 esp, 4

; 270  : 			if ( v2 == NULL ) {

  00459	85 c0		 test	 eax, eax
  0045b	74 25		 je	 SHORT $LN215@r_object

; 272  : 				v = NULL;
; 273  : 				break;
; 274  : 			}
; 275  : 			PyTuple_SET_ITEM(v, (int)i, v2);

  0045d	89 03		 mov	 DWORD PTR [ebx], eax
  0045f	47		 inc	 edi
  00460	83 c3 04	 add	 ebx, 4
  00463	3b bd f4 fe ff
	ff		 cmp	 edi, DWORD PTR _n$7$[ebp]
  00469	7c e5		 jl	 SHORT $LL12@r_object

; 306  : 			if (key == NULL)

  0046b	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _v$3$[ebp]

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00471	5f		 pop	 edi
  00472	5e		 pop	 esi
  00473	5b		 pop	 ebx
  00474	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00477	33 cd		 xor	 ecx, ebp
  00479	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0047e	8b e5		 mov	 esp, ebp
  00480	5d		 pop	 ebp
  00481	c3		 ret	 0
$LN215@r_object:

; 271  : 				Py_DECREF(v);

  00482	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _v$3$[ebp]
  00488	83 01 ff	 add	 DWORD PTR [ecx], -1
  0048b	0f 85 f1 03 00
	00		 jne	 $LN319@r_object
  00491	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00494	51		 push	 ecx
  00495	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00498	ff d0		 call	 eax
  0049a	83 c4 04	 add	 esp, 4

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  0049d	33 c0		 xor	 eax, eax
  0049f	5f		 pop	 edi
  004a0	5e		 pop	 esi
  004a1	5b		 pop	 ebx
  004a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004a5	33 cd		 xor	 ecx, ebp
  004a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004ac	8b e5		 mov	 esp, ebp
  004ae	5d		 pop	 ebp
  004af	c3		 ret	 0
$LN118@r_object:

; 276  : 		}
; 277  : 		return v;
; 278  : 
; 279  : 	case TYPE_LIST:
; 280  : 		n = r_long(p);

  004b0	56		 push	 esi
  004b1	e8 00 00 00 00	 call	 ?r_long@@YAJPAUSWFILE@@@Z ; r_long
  004b6	83 c4 04	 add	 esp, 4
  004b9	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _n$8$[ebp], eax

; 281  : 		if (n < 0) {

  004bf	85 c0		 test	 eax, eax
  004c1	0f 88 31 fe ff
	ff		 js	 $LN321@r_object

; 282  : 			PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 283  : 			return NULL;
; 284  : 		}
; 285  : 		v = PyList_New((int)n);

  004c7	50		 push	 eax
  004c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyList_New
  004ce	8b d8		 mov	 ebx, eax
  004d0	83 c4 04	 add	 esp, 4

; 286  : 		if (v == NULL)

  004d3	85 db		 test	 ebx, ebx
  004d5	0f 84 a7 03 00
	00		 je	 $LN319@r_object

; 287  : 			return v;
; 288  : 		for (i = 0; i < n; i++) {

  004db	33 ff		 xor	 edi, edi
  004dd	39 bd f8 fe ff
	ff		 cmp	 DWORD PTR _n$8$[ebp], edi
  004e3	7e 48		 jle	 SHORT $LN17@r_object
$LL18@r_object:

; 289  : 			v2 = r_object(p);

  004e5	56		 push	 esi
  004e6	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  004eb	83 c4 04	 add	 esp, 4

; 290  : 			if ( v2 == NULL ) {

  004ee	85 c0		 test	 eax, eax
  004f0	74 28		 je	 SHORT $LN216@r_object

; 293  : 				break;
; 294  : 			}
; 295  : 			PyList_SetItem(v, (int)i, v2);

  004f2	50		 push	 eax
  004f3	57		 push	 edi
  004f4	53		 push	 ebx
  004f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyList_SetItem
  004fb	47		 inc	 edi
  004fc	83 c4 0c	 add	 esp, 12			; 0000000cH
  004ff	3b bd f8 fe ff
	ff		 cmp	 edi, DWORD PTR _n$8$[ebp]
  00505	7c de		 jl	 SHORT $LL18@r_object

; 296  : 		}
; 297  : 		return v;

  00507	8b c3		 mov	 eax, ebx

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  00509	5f		 pop	 edi
  0050a	5e		 pop	 esi
  0050b	5b		 pop	 ebx
  0050c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0050f	33 cd		 xor	 ecx, ebp
  00511	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00516	8b e5		 mov	 esp, ebp
  00518	5d		 pop	 ebp
  00519	c3		 ret	 0
$LN216@r_object:

; 291  : 				Py_DECREF(v);

  0051a	83 03 ff	 add	 DWORD PTR [ebx], -1
  0051d	75 0c		 jne	 SHORT $LN19@r_object
  0051f	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00522	53		 push	 ebx
  00523	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00526	ff d0		 call	 eax
  00528	83 c4 04	 add	 esp, 4
$LN19@r_object:

; 292  : 				v = NULL;

  0052b	33 db		 xor	 ebx, ebx
$LN17@r_object:

; 296  : 		}
; 297  : 		return v;

  0052d	8b c3		 mov	 eax, ebx

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  0052f	5f		 pop	 edi
  00530	5e		 pop	 esi
  00531	5b		 pop	 ebx
  00532	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00535	33 cd		 xor	 ecx, ebp
  00537	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0053c	8b e5		 mov	 esp, ebp
  0053e	5d		 pop	 ebp
  0053f	c3		 ret	 0
$LN124@r_object:

; 298  : 
; 299  : 	case TYPE_DICT:
; 300  : 		v = PyDict_New();

  00540	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyDict_New
  00546	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _v$5$[ebp], eax

; 301  : 		if (v == NULL)

  0054c	85 c0		 test	 eax, eax
  0054e	0f 84 2e 03 00
	00		 je	 $LN319@r_object

; 302  : 			return NULL;
; 303  : 		for (;;) {
; 304  : 			PyObject *key, *val;
; 305  : 			key = r_object(p);

  00554	56		 push	 esi
  00555	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  0055a	8b d8		 mov	 ebx, eax
  0055c	83 c4 04	 add	 esp, 4

; 306  : 			if (key == NULL)

  0055f	85 db		 test	 ebx, ebx
  00561	74 55		 je	 SHORT $LN217@r_object
$LL24@r_object:

; 307  : 				break; /* XXX Assume TYPE_NULL, not an error */
; 308  : 			val = r_object(p);

  00563	56		 push	 esi
  00564	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  00569	8b f8		 mov	 edi, eax
  0056b	83 c4 04	 add	 esp, 4

; 309  : 			if (val != NULL)

  0056e	85 ff		 test	 edi, edi
  00570	74 11		 je	 SHORT $LN27@r_object

; 310  : 				PyDict_SetItem(v, key, val);

  00572	57		 push	 edi
  00573	53		 push	 ebx
  00574	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _v$5$[ebp]
  0057a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyDict_SetItem
  00580	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN27@r_object:

; 311  : 			Py_DECREF(key);

  00583	83 03 ff	 add	 DWORD PTR [ebx], -1
  00586	75 0c		 jne	 SHORT $LN25@r_object
  00588	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0058b	53		 push	 ebx
  0058c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0058f	ff d0		 call	 eax
  00591	83 c4 04	 add	 esp, 4
$LN25@r_object:

; 312  : 			Py_XDECREF(val);

  00594	85 ff		 test	 edi, edi
  00596	74 11		 je	 SHORT $LN32@r_object
  00598	83 07 ff	 add	 DWORD PTR [edi], -1
  0059b	75 0c		 jne	 SHORT $LN32@r_object
  0059d	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  005a0	57		 push	 edi
  005a1	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  005a4	ff d0		 call	 eax
  005a6	83 c4 04	 add	 esp, 4
$LN32@r_object:

; 302  : 			return NULL;
; 303  : 		for (;;) {
; 304  : 			PyObject *key, *val;
; 305  : 			key = r_object(p);

  005a9	56		 push	 esi
  005aa	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  005af	8b d8		 mov	 ebx, eax
  005b1	83 c4 04	 add	 esp, 4

; 306  : 			if (key == NULL)

  005b4	85 db		 test	 ebx, ebx
  005b6	75 ab		 jne	 SHORT $LL24@r_object
$LN217@r_object:

; 313  : 		}
; 314  : 		return v;

  005b8	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _v$5$[ebp]

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  005be	5f		 pop	 edi
  005bf	5e		 pop	 esi
  005c0	5b		 pop	 ebx
  005c1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005c4	33 cd		 xor	 ecx, ebp
  005c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005cb	8b e5		 mov	 esp, ebp
  005cd	5d		 pop	 ebp
  005ce	c3		 ret	 0
$LN134@r_object:

; 315  : 
; 316  : 	case TYPE_CODE:
; 317  : 		if (PyEval_GetRestricted()) {

  005cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyEval_GetRestricted
  005d5	85 c0		 test	 eax, eax
  005d7	74 0f		 je	 SHORT $LN135@r_object

; 318  : 			PyErr_SetString(PyExc_RuntimeError,

  005d9	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_RuntimeError
  005de	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@GCEHJGML@cannot?5unmarshal?5code?5objects?5i@

; 319  : 				"cannot unmarshal code objects in "
; 320  : 				"restricted execution mode");
; 321  : 			return NULL;

  005e3	e9 8f 02 00 00	 jmp	 $LN318@r_object
$LN135@r_object:

; 322  : 		}
; 323  : 		else {
; 324  : 			int argcount = r_short(p);

  005e8	56		 push	 esi
  005e9	e8 00 00 00 00	 call	 ?r_short@@YAHPAUSWFILE@@@Z ; r_short

; 325  : 			int nlocals = r_short(p);

  005ee	56		 push	 esi
  005ef	89 85 ec fe ff
	ff		 mov	 DWORD PTR _argcount$1$[ebp], eax
  005f5	e8 00 00 00 00	 call	 ?r_short@@YAHPAUSWFILE@@@Z ; r_short

; 326  : 			int stacksize = r_short(p);

  005fa	56		 push	 esi
  005fb	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _nlocals$1$[ebp], eax
  00601	e8 00 00 00 00	 call	 ?r_short@@YAHPAUSWFILE@@@Z ; r_short

; 327  : 			int flags = r_short(p);

  00606	56		 push	 esi
  00607	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _stacksize$1$[ebp], eax
  0060d	e8 00 00 00 00	 call	 ?r_short@@YAHPAUSWFILE@@@Z ; r_short

; 328  : 			PyObject *code = NULL;
; 329  : 			PyObject *consts = NULL;
; 330  : 			PyObject *names = NULL;
; 331  : 			PyObject *varnames = NULL;
; 332  : 			PyObject *freevars = NULL;
; 333  : 			PyObject *cellvars = NULL;
; 334  : 			PyObject *filename = NULL;

  00612	33 db		 xor	 ebx, ebx
  00614	89 85 cc fe ff
	ff		 mov	 DWORD PTR _flags$1$[ebp], eax

; 335  : 			PyObject *name = NULL;
; 336  : 			int firstlineno = 0;
; 337  : 			PyObject *lnotab = NULL;
; 338  : 
; 339  : 			code = r_object(p);

  0061a	56		 push	 esi
  0061b	c7 85 dc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _consts$1$[ebp], 0
  00625	33 ff		 xor	 edi, edi
  00627	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _names$1$[ebp], 0
  00631	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _varnames$1$[ebp], 0
  0063b	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _freevars$1$[ebp], 0
  00645	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _cellvars$1$[ebp], 0
  0064f	89 9d f0 fe ff
	ff		 mov	 DWORD PTR _firstlineno$1$[ebp], ebx
  00655	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  0065a	83 c4 14	 add	 esp, 20			; 00000014H
  0065d	89 85 f4 fe ff
	ff		 mov	 DWORD PTR _code$1$[ebp], eax

; 340  : 			if (code) consts = r_object(p);

  00663	85 c0		 test	 eax, eax
  00665	0f 84 9e 00 00
	00		 je	 $LN245@r_object
  0066b	56		 push	 esi
  0066c	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  00671	83 c4 04	 add	 esp, 4
  00674	89 85 dc fe ff
	ff		 mov	 DWORD PTR _consts$1$[ebp], eax

; 341  : 			if (consts) names = r_object(p);

  0067a	85 c0		 test	 eax, eax
  0067c	0f 84 87 00 00
	00		 je	 $LN245@r_object
  00682	56		 push	 esi
  00683	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  00688	83 c4 04	 add	 esp, 4
  0068b	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _names$1$[ebp], eax

; 342  : 			if (names) varnames = r_object(p);

  00691	85 c0		 test	 eax, eax
  00693	0f 84 70 00 00
	00		 je	 $LN245@r_object
  00699	56		 push	 esi
  0069a	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  0069f	83 c4 04	 add	 esp, 4
  006a2	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _varnames$1$[ebp], eax

; 343  : 			if (varnames) freevars = r_object(p);

  006a8	85 c0		 test	 eax, eax
  006aa	74 5d		 je	 SHORT $LN245@r_object
  006ac	56		 push	 esi
  006ad	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  006b2	83 c4 04	 add	 esp, 4
  006b5	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _freevars$1$[ebp], eax

; 344  : 			if (freevars) cellvars = r_object(p);

  006bb	85 c0		 test	 eax, eax
  006bd	74 4a		 je	 SHORT $LN245@r_object
  006bf	56		 push	 esi
  006c0	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  006c5	83 c4 04	 add	 esp, 4
  006c8	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _cellvars$1$[ebp], eax

; 345  : 			if (cellvars) filename = r_object(p);

  006ce	85 c0		 test	 eax, eax
  006d0	74 37		 je	 SHORT $LN245@r_object
  006d2	56		 push	 esi
  006d3	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  006d8	8b d8		 mov	 ebx, eax
  006da	83 c4 04	 add	 esp, 4

; 346  : 			if (filename) name = r_object(p);

  006dd	85 db		 test	 ebx, ebx
  006df	74 28		 je	 SHORT $LN245@r_object
  006e1	56		 push	 esi
  006e2	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  006e7	8b f8		 mov	 edi, eax
  006e9	83 c4 04	 add	 esp, 4

; 347  : 			if (name) {

  006ec	85 ff		 test	 edi, edi
  006ee	74 19		 je	 SHORT $LN245@r_object

; 348  : 				firstlineno = r_short(p);

  006f0	56		 push	 esi
  006f1	e8 00 00 00 00	 call	 ?r_short@@YAHPAUSWFILE@@@Z ; r_short

; 349  : 				lnotab = r_object(p);

  006f6	56		 push	 esi
  006f7	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _firstlineno$1$[ebp], eax
  006fd	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  00702	83 c4 08	 add	 esp, 8
  00705	8b f0		 mov	 esi, eax
  00707	eb 02		 jmp	 SHORT $LN144@r_object
$LN245@r_object:

; 350  : 			}
; 351  : 
; 352  : 			if (!PyErr_Occurred()) {

  00709	33 f6		 xor	 esi, esi
$LN144@r_object:
  0070b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  00711	85 c0		 test	 eax, eax
  00713	75 56		 jne	 SHORT $LN145@r_object

; 353  : 				v = (PyObject *) PyCode_New(

  00715	56		 push	 esi
  00716	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _firstlineno$1$[ebp]
  0071c	57		 push	 edi
  0071d	53		 push	 ebx
  0071e	ff b5 f8 fe ff
	ff		 push	 DWORD PTR _cellvars$1$[ebp]
  00724	ff b5 d0 fe ff
	ff		 push	 DWORD PTR _freevars$1$[ebp]
  0072a	ff b5 d4 fe ff
	ff		 push	 DWORD PTR _varnames$1$[ebp]
  00730	ff b5 d8 fe ff
	ff		 push	 DWORD PTR _names$1$[ebp]
  00736	ff b5 dc fe ff
	ff		 push	 DWORD PTR _consts$1$[ebp]
  0073c	ff b5 f4 fe ff
	ff		 push	 DWORD PTR _code$1$[ebp]
  00742	ff b5 cc fe ff
	ff		 push	 DWORD PTR _flags$1$[ebp]
  00748	ff b5 c8 fe ff
	ff		 push	 DWORD PTR _stacksize$1$[ebp]
  0074e	ff b5 c4 fe ff
	ff		 push	 DWORD PTR _nlocals$1$[ebp]
  00754	ff b5 ec fe ff
	ff		 push	 DWORD PTR _argcount$1$[ebp]
  0075a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyCode_New
  00760	83 c4 38	 add	 esp, 56			; 00000038H
  00763	89 85 f0 fe ff
	ff		 mov	 DWORD PTR _v$6$[ebp], eax

; 354  : 					argcount, nlocals, stacksize, flags,
; 355  : 					code, consts, names, varnames,
; 356  : 					freevars, cellvars, filename, name,
; 357  : 					firstlineno, lnotab);
; 358  : 			}

  00769	eb 0a		 jmp	 SHORT $LN36@r_object
$LN145@r_object:

; 359  : 			else
; 360  : 				v = NULL;

  0076b	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v$6$[ebp], 0
$LN36@r_object:

; 361  : 			Py_XDECREF(code);

  00775	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR _code$1$[ebp]
  0077b	85 c9		 test	 ecx, ecx
  0077d	74 11		 je	 SHORT $LN38@r_object
  0077f	83 01 ff	 add	 DWORD PTR [ecx], -1
  00782	75 0c		 jne	 SHORT $LN38@r_object
  00784	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00787	51		 push	 ecx
  00788	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0078b	ff d0		 call	 eax
  0078d	83 c4 04	 add	 esp, 4
$LN38@r_object:

; 362  : 			Py_XDECREF(consts);

  00790	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _consts$1$[ebp]
  00796	85 c9		 test	 ecx, ecx
  00798	74 11		 je	 SHORT $LN44@r_object
  0079a	83 01 ff	 add	 DWORD PTR [ecx], -1
  0079d	75 0c		 jne	 SHORT $LN44@r_object
  0079f	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007a2	51		 push	 ecx
  007a3	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007a6	ff d0		 call	 eax
  007a8	83 c4 04	 add	 esp, 4
$LN44@r_object:

; 363  : 			Py_XDECREF(names);

  007ab	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _names$1$[ebp]
  007b1	85 c9		 test	 ecx, ecx
  007b3	74 11		 je	 SHORT $LN50@r_object
  007b5	83 01 ff	 add	 DWORD PTR [ecx], -1
  007b8	75 0c		 jne	 SHORT $LN50@r_object
  007ba	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007bd	51		 push	 ecx
  007be	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007c1	ff d0		 call	 eax
  007c3	83 c4 04	 add	 esp, 4
$LN50@r_object:

; 364  : 			Py_XDECREF(varnames);

  007c6	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _varnames$1$[ebp]
  007cc	85 c9		 test	 ecx, ecx
  007ce	74 11		 je	 SHORT $LN56@r_object
  007d0	83 01 ff	 add	 DWORD PTR [ecx], -1
  007d3	75 0c		 jne	 SHORT $LN56@r_object
  007d5	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007d8	51		 push	 ecx
  007d9	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007dc	ff d0		 call	 eax
  007de	83 c4 04	 add	 esp, 4
$LN56@r_object:

; 365  : 			Py_XDECREF(freevars);

  007e1	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR _freevars$1$[ebp]
  007e7	85 c9		 test	 ecx, ecx
  007e9	74 11		 je	 SHORT $LN62@r_object
  007eb	83 01 ff	 add	 DWORD PTR [ecx], -1
  007ee	75 0c		 jne	 SHORT $LN62@r_object
  007f0	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  007f3	51		 push	 ecx
  007f4	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  007f7	ff d0		 call	 eax
  007f9	83 c4 04	 add	 esp, 4
$LN62@r_object:

; 366  : 			Py_XDECREF(cellvars);

  007fc	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _cellvars$1$[ebp]
  00802	85 c9		 test	 ecx, ecx
  00804	74 11		 je	 SHORT $LN68@r_object
  00806	83 01 ff	 add	 DWORD PTR [ecx], -1
  00809	75 0c		 jne	 SHORT $LN68@r_object
  0080b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0080e	51		 push	 ecx
  0080f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00812	ff d0		 call	 eax
  00814	83 c4 04	 add	 esp, 4
$LN68@r_object:

; 367  : 			Py_XDECREF(filename);

  00817	85 db		 test	 ebx, ebx
  00819	74 11		 je	 SHORT $LN74@r_object
  0081b	83 03 ff	 add	 DWORD PTR [ebx], -1
  0081e	75 0c		 jne	 SHORT $LN74@r_object
  00820	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00823	53		 push	 ebx
  00824	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00827	ff d0		 call	 eax
  00829	83 c4 04	 add	 esp, 4
$LN74@r_object:

; 368  : 			Py_XDECREF(name);

  0082c	85 ff		 test	 edi, edi
  0082e	74 11		 je	 SHORT $LN80@r_object
  00830	83 07 ff	 add	 DWORD PTR [edi], -1
  00833	75 0c		 jne	 SHORT $LN80@r_object
  00835	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00838	57		 push	 edi
  00839	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0083c	ff d0		 call	 eax
  0083e	83 c4 04	 add	 esp, 4
$LN80@r_object:

; 369  : 			Py_XDECREF(lnotab);

  00841	85 f6		 test	 esi, esi
  00843	74 11		 je	 SHORT $LN86@r_object
  00845	83 06 ff	 add	 DWORD PTR [esi], -1
  00848	75 0c		 jne	 SHORT $LN86@r_object
  0084a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0084d	56		 push	 esi
  0084e	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00851	ff d0		 call	 eax
  00853	83 c4 04	 add	 esp, 4
$LN86@r_object:

; 370  : 
; 371  : 		}
; 372  : 		return v;

  00856	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR _v$6$[ebp]

; 373  : 
; 374  : 	default:
; 375  : 		/* Bogus data got written, which isn't ideal.
; 376  : 		   This will let you keep working and recover. */
; 377  : 		PyErr_SetString(PyExc_ValueError, "bad marshal data");
; 378  : 		return NULL;
; 379  : 	}
; 380  : }

  0085c	5f		 pop	 edi
  0085d	5e		 pop	 esi
  0085e	5b		 pop	 ebx
  0085f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00862	33 cd		 xor	 ecx, ebp
  00864	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00869	8b e5		 mov	 esp, ebp
  0086b	5d		 pop	 ebp
  0086c	c3		 ret	 0
$LN88@r_object:
  0086d	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__PyExc_EOFError
  00872	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OFPCODJP@EOF?5read?5where?5object?5expected@
$LN318@r_object:
  00877	ff 30		 push	 DWORD PTR [eax]
  00879	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_SetString
  0087f	83 c4 08	 add	 esp, 8
$LN319@r_object:
  00882	33 c0		 xor	 eax, eax
$LN1@r_object:
  00884	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00887	5f		 pop	 edi
  00888	5e		 pop	 esi
  00889	33 cd		 xor	 ecx, ebp
  0088b	5b		 pop	 ebx
  0088c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00891	8b e5		 mov	 esp, ebp
  00893	5d		 pop	 ebp
  00894	c3		 ret	 0
$LN193@r_object:
  00895	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN317@r_object:
  0089a	66 90		 npad	 2
$LN237@r_object:
  0089c	00 00 00 00	 DD	 $LN88@r_object
  008a0	00 00 00 00	 DD	 $LN112@r_object
  008a4	00 00 00 00	 DD	 $LN92@r_object
  008a8	00 00 00 00	 DD	 $LN319@r_object
  008ac	00 00 00 00	 DD	 $LN94@r_object
  008b0	00 00 00 00	 DD	 $LN90@r_object
  008b4	00 00 00 00	 DD	 $LN91@r_object
  008b8	00 00 00 00	 DD	 $LN118@r_object
  008bc	00 00 00 00	 DD	 $LN134@r_object
  008c0	00 00 00 00	 DD	 $LN97@r_object
  008c4	00 00 00 00	 DD	 $LN93@r_object
  008c8	00 00 00 00	 DD	 $LN95@r_object
  008cc	00 00 00 00	 DD	 $LN102@r_object
  008d0	00 00 00 00	 DD	 $LN108@r_object
  008d4	00 00 00 00	 DD	 $LN99@r_object
  008d8	00 00 00 00	 DD	 $LN124@r_object
  008dc	00 00 00 00	 DD	 $LN321@r_object
$LN236@r_object:
  008e0	00		 DB	 0
  008e1	10		 DB	 16			; 00000010H
  008e2	10		 DB	 16			; 00000010H
  008e3	10		 DB	 16			; 00000010H
  008e4	10		 DB	 16			; 00000010H
  008e5	10		 DB	 16			; 00000010H
  008e6	10		 DB	 16			; 00000010H
  008e7	10		 DB	 16			; 00000010H
  008e8	10		 DB	 16			; 00000010H
  008e9	10		 DB	 16			; 00000010H
  008ea	10		 DB	 16			; 00000010H
  008eb	10		 DB	 16			; 00000010H
  008ec	10		 DB	 16			; 00000010H
  008ed	10		 DB	 16			; 00000010H
  008ee	10		 DB	 16			; 00000010H
  008ef	10		 DB	 16			; 00000010H
  008f0	10		 DB	 16			; 00000010H
  008f1	10		 DB	 16			; 00000010H
  008f2	10		 DB	 16			; 00000010H
  008f3	10		 DB	 16			; 00000010H
  008f4	10		 DB	 16			; 00000010H
  008f5	10		 DB	 16			; 00000010H
  008f6	10		 DB	 16			; 00000010H
  008f7	10		 DB	 16			; 00000010H
  008f8	10		 DB	 16			; 00000010H
  008f9	10		 DB	 16			; 00000010H
  008fa	10		 DB	 16			; 00000010H
  008fb	10		 DB	 16			; 00000010H
  008fc	10		 DB	 16			; 00000010H
  008fd	10		 DB	 16			; 00000010H
  008fe	10		 DB	 16			; 00000010H
  008ff	10		 DB	 16			; 00000010H
  00900	10		 DB	 16			; 00000010H
  00901	10		 DB	 16			; 00000010H
  00902	10		 DB	 16			; 00000010H
  00903	10		 DB	 16			; 00000010H
  00904	10		 DB	 16			; 00000010H
  00905	10		 DB	 16			; 00000010H
  00906	10		 DB	 16			; 00000010H
  00907	10		 DB	 16			; 00000010H
  00908	10		 DB	 16			; 00000010H
  00909	01		 DB	 1
  0090a	10		 DB	 16			; 00000010H
  0090b	10		 DB	 16			; 00000010H
  0090c	10		 DB	 16			; 00000010H
  0090d	10		 DB	 16			; 00000010H
  0090e	10		 DB	 16			; 00000010H
  0090f	02		 DB	 2
  00910	10		 DB	 16			; 00000010H
  00911	03		 DB	 3
  00912	10		 DB	 16			; 00000010H
  00913	10		 DB	 16			; 00000010H
  00914	10		 DB	 16			; 00000010H
  00915	10		 DB	 16			; 00000010H
  00916	10		 DB	 16			; 00000010H
  00917	10		 DB	 16			; 00000010H
  00918	10		 DB	 16			; 00000010H
  00919	10		 DB	 16			; 00000010H
  0091a	10		 DB	 16			; 00000010H
  0091b	10		 DB	 16			; 00000010H
  0091c	10		 DB	 16			; 00000010H
  0091d	10		 DB	 16			; 00000010H
  0091e	10		 DB	 16			; 00000010H
  0091f	10		 DB	 16			; 00000010H
  00920	10		 DB	 16			; 00000010H
  00921	10		 DB	 16			; 00000010H
  00922	10		 DB	 16			; 00000010H
  00923	10		 DB	 16			; 00000010H
  00924	10		 DB	 16			; 00000010H
  00925	10		 DB	 16			; 00000010H
  00926	10		 DB	 16			; 00000010H
  00927	10		 DB	 16			; 00000010H
  00928	10		 DB	 16			; 00000010H
  00929	10		 DB	 16			; 00000010H
  0092a	04		 DB	 4
  0092b	10		 DB	 16			; 00000010H
  0092c	10		 DB	 16			; 00000010H
  0092d	10		 DB	 16			; 00000010H
  0092e	10		 DB	 16			; 00000010H
  0092f	05		 DB	 5
  00930	10		 DB	 16			; 00000010H
  00931	10		 DB	 16			; 00000010H
  00932	10		 DB	 16			; 00000010H
  00933	10		 DB	 16			; 00000010H
  00934	06		 DB	 6
  00935	10		 DB	 16			; 00000010H
  00936	10		 DB	 16			; 00000010H
  00937	10		 DB	 16			; 00000010H
  00938	10		 DB	 16			; 00000010H
  00939	10		 DB	 16			; 00000010H
  0093a	10		 DB	 16			; 00000010H
  0093b	10		 DB	 16			; 00000010H
  0093c	07		 DB	 7
  0093d	10		 DB	 16			; 00000010H
  0093e	10		 DB	 16			; 00000010H
  0093f	10		 DB	 16			; 00000010H
  00940	10		 DB	 16			; 00000010H
  00941	10		 DB	 16			; 00000010H
  00942	10		 DB	 16			; 00000010H
  00943	10		 DB	 16			; 00000010H
  00944	08		 DB	 8
  00945	10		 DB	 16			; 00000010H
  00946	10		 DB	 16			; 00000010H
  00947	09		 DB	 9
  00948	10		 DB	 16			; 00000010H
  00949	10		 DB	 16			; 00000010H
  0094a	0a		 DB	 10			; 0000000aH
  0094b	10		 DB	 16			; 00000010H
  0094c	10		 DB	 16			; 00000010H
  0094d	0b		 DB	 11			; 0000000bH
  0094e	10		 DB	 16			; 00000010H
  0094f	10		 DB	 16			; 00000010H
  00950	10		 DB	 16			; 00000010H
  00951	10		 DB	 16			; 00000010H
  00952	10		 DB	 16			; 00000010H
  00953	10		 DB	 16			; 00000010H
  00954	0c		 DB	 12			; 0000000cH
  00955	10		 DB	 16			; 00000010H
  00956	0d		 DB	 13			; 0000000dH
  00957	10		 DB	 16			; 00000010H
  00958	10		 DB	 16			; 00000010H
  00959	0e		 DB	 14			; 0000000eH
  0095a	10		 DB	 16			; 00000010H
  0095b	10		 DB	 16			; 00000010H
  0095c	0f		 DB	 15			; 0000000fH
?r_object@@YAPAU_object@@PAUSWFILE@@@Z ENDP		; r_object
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_long64@@YAPAU_object@@PAUSWFILE@@@Z
_TEXT	SEGMENT
_buf$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
?r_long64@@YAPAU_object@@PAUSWFILE@@@Z PROC		; r_long64, COMDAT

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 7d 08	 mov	 edi, DWORD PTR _p$[ebp]

; 101  : 	long lo4 = r_long(p);

  00015	57		 push	 edi
  00016	e8 00 00 00 00	 call	 ?r_long@@YAJPAUSWFILE@@@Z ; r_long

; 102  : 	long hi4 = r_long(p);

  0001b	57		 push	 edi
  0001c	8b f0		 mov	 esi, eax
  0001e	e8 00 00 00 00	 call	 ?r_long@@YAJPAUSWFILE@@@Z ; r_long

; 103  : #if SIZEOF_LONG > 4
; 104  : 	long x = (hi4 << 32) | (lo4 & 0xFFFFFFFFL);
; 105  : 	return PyInt_FromLong(x);
; 106  : #else
; 107  : 	unsigned char buf[8];
; 108  : 	int one = 1;
; 109  : 	int is_little_endian = (int)*(char*)&one;
; 110  : 	if (is_little_endian) {
; 111  : 		memcpy(buf, &lo4, 4);
; 112  : 		memcpy(buf+4, &hi4, 4);
; 113  : 	}
; 114  : 	else {
; 115  : 		memcpy(buf, &hi4, 4);
; 116  : 		memcpy(buf+4, &lo4, 4);
; 117  : 	}
; 118  : 	return _PyLong_FromByteArray(buf, 8, is_little_endian, 1);

  00023	6a 01		 push	 1
  00025	6a 01		 push	 1
  00027	89 45 f8	 mov	 DWORD PTR _buf$[ebp+4], eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR _buf$[ebp]
  0002d	6a 08		 push	 8
  0002f	50		 push	 eax
  00030	89 75 f4	 mov	 DWORD PTR _buf$[ebp], esi
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___PyLong_FromByteArray

; 119  : #endif
; 120  : }

  00039	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003c	83 c4 18	 add	 esp, 24			; 00000018H
  0003f	33 cd		 xor	 ecx, ebp
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?r_long64@@YAPAU_object@@PAUSWFILE@@@Z ENDP		; r_long64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_long@@YAJPAUSWFILE@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?r_long@@YAJPAUSWFILE@@@Z PROC				; r_long, COMDAT

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 71   : 	register long x;
; 72   : 	register FILE *fp = p->fp;

  00003	8b 55 08	 mov	 edx, DWORD PTR _p$[ebp]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b 3a		 mov	 edi, DWORD PTR [edx]

; 73   : 	if (fp) {

  0000a	85 ff		 test	 edi, edi
  0000c	74 30		 je	 SHORT $LN2@r_long

; 74   : 		x = getc(fp);

  0000e	57		 push	 edi
  0000f	e8 00 00 00 00	 call	 _getc

; 75   : 		x |= (long)getc(fp) << 8;

  00014	57		 push	 edi
  00015	8b f0		 mov	 esi, eax
  00017	e8 00 00 00 00	 call	 _getc
  0001c	c1 e0 08	 shl	 eax, 8

; 76   : 		x |= (long)getc(fp) << 16;

  0001f	57		 push	 edi
  00020	0b f0		 or	 esi, eax
  00022	e8 00 00 00 00	 call	 _getc
  00027	c1 e0 10	 shl	 eax, 16			; 00000010H

; 77   : 		x |= (long)getc(fp) << 24;

  0002a	57		 push	 edi
  0002b	0b f0		 or	 esi, eax
  0002d	e8 00 00 00 00	 call	 _getc
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	c1 e0 18	 shl	 eax, 24			; 00000018H
  00038	0b c6		 or	 eax, esi
  0003a	5f		 pop	 edi

; 90   : }

  0003b	5e		 pop	 esi
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN2@r_long:

; 78   : 	}
; 79   : 	else {
; 80   : 		x = rs_byte(p);

  0003e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00041	8b 72 14	 mov	 esi, DWORD PTR [edx+20]
  00044	3b ce		 cmp	 ecx, esi
  00046	74 41		 je	 SHORT $LN5@r_long
  00048	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0004b	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
  0004e	89 7a 10	 mov	 DWORD PTR [edx+16], edi

; 81   : 		x |= (long)rs_byte(p) << 8;

  00051	3b fe		 cmp	 edi, esi
  00053	74 37		 je	 SHORT $LN7@r_long
  00055	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00058	47		 inc	 edi
  00059	c1 e1 08	 shl	 ecx, 8
  0005c	0b c8		 or	 ecx, eax
  0005e	89 7a 10	 mov	 DWORD PTR [edx+16], edi

; 82   : 		x |= (long)rs_byte(p) << 16;

  00061	3b fe		 cmp	 edi, esi
  00063	74 2e		 je	 SHORT $LN9@r_long
  00065	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00068	47		 inc	 edi
  00069	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006c	0b c8		 or	 ecx, eax
  0006e	89 7a 10	 mov	 DWORD PTR [edx+16], edi

; 83   : 		x |= (long)rs_byte(p) << 24;

  00071	3b fe		 cmp	 edi, esi
  00073	74 24		 je	 SHORT $LN11@r_long
  00075	0f b6 37	 movzx	 esi, BYTE PTR [edi]
  00078	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
  0007b	c1 e6 18	 shl	 esi, 24			; 00000018H
  0007e	0b ce		 or	 ecx, esi
  00080	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00083	5f		 pop	 edi

; 84   : 	}
; 85   : #if SIZEOF_LONG > 4
; 86   : 	/* Sign extension for 64-bit machines */
; 87   : 	x |= -(x & 0x80000000L);
; 88   : #endif
; 89   : 	return x;

  00084	8b c1		 mov	 eax, ecx

; 90   : }

  00086	5e		 pop	 esi
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
$LN5@r_long:

; 78   : 	}
; 79   : 	else {
; 80   : 		x = rs_byte(p);

  00089	83 c8 ff	 or	 eax, -1
$LN7@r_long:

; 81   : 		x |= (long)rs_byte(p) << 8;

  0008c	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  00091	8b c8		 mov	 ecx, eax
$LN9@r_long:

; 82   : 		x |= (long)rs_byte(p) << 16;

  00093	81 c9 00 00 ff
	ff		 or	 ecx, -65536		; ffff0000H
$LN11@r_long:

; 83   : 		x |= (long)rs_byte(p) << 24;

  00099	83 ce ff	 or	 esi, -1
  0009c	c1 e6 18	 shl	 esi, 24			; 00000018H
  0009f	0b ce		 or	 ecx, esi
  000a1	5f		 pop	 edi

; 84   : 	}
; 85   : #if SIZEOF_LONG > 4
; 86   : 	/* Sign extension for 64-bit machines */
; 87   : 	x |= -(x & 0x80000000L);
; 88   : #endif
; 89   : 	return x;

  000a2	8b c1		 mov	 eax, ecx

; 90   : }

  000a4	5e		 pop	 esi
  000a5	5d		 pop	 ebp
  000a6	c3		 ret	 0
?r_long@@YAJPAUSWFILE@@@Z ENDP				; r_long
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_short@@YAHPAUSWFILE@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?r_short@@YAHPAUSWFILE@@@Z PROC				; r_short, COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 08	 mov	 esi, DWORD PTR _p$[ebp]
  00007	57		 push	 edi

; 61   : 	register short x;
; 62   : 	x = (short) r_byte(p);

  00008	8b 06		 mov	 eax, DWORD PTR [esi]
  0000a	85 c0		 test	 eax, eax
  0000c	74 11		 je	 SHORT $LN5@r_short
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _getc
  00014	83 c4 04	 add	 esp, 4
  00017	0f b7 f8	 movzx	 edi, ax
  0001a	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  0001d	eb 18		 jmp	 SHORT $LN15@r_short
$LN5@r_short:
  0001f	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  00022	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00025	3b 56 14	 cmp	 edx, DWORD PTR [esi+20]
  00028	74 0a		 je	 SHORT $LN3@r_short
  0002a	0f b6 3a	 movzx	 edi, BYTE PTR [edx]
  0002d	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  00030	89 01		 mov	 DWORD PTR [ecx], eax
  00032	eb 03		 jmp	 SHORT $LN15@r_short
$LN3@r_short:
  00034	83 cf ff	 or	 edi, -1
$LN15@r_short:

; 63   : 	x |= (short) r_byte(p) << 8;

  00037	8b c6		 mov	 eax, esi
  00039	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  0003e	03 d0		 add	 edx, eax
  00040	8b 06		 mov	 eax, DWORD PTR [esi]
  00042	85 c0		 test	 eax, eax
  00044	74 0d		 je	 SHORT $LN9@r_short
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 _getc
  0004c	83 c4 04	 add	 esp, 4
  0004f	8b d0		 mov	 edx, eax
  00051	eb 11		 jmp	 SHORT $LN8@r_short
$LN9@r_short:
  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	3b 02		 cmp	 eax, DWORD PTR [edx]
  00057	74 08		 je	 SHORT $LN7@r_short
  00059	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0005c	40		 inc	 eax
  0005d	89 01		 mov	 DWORD PTR [ecx], eax
  0005f	eb 03		 jmp	 SHORT $LN8@r_short
$LN7@r_short:
  00061	83 ca ff	 or	 edx, -1
$LN8@r_short:
  00064	c1 e2 08	 shl	 edx, 8
  00067	0b fa		 or	 edi, edx

; 64   : 	/* Sign-extension, in case short greater than 16 bits */
; 65   : 	x |= -(x & 0x8000);

  00069	8b c7		 mov	 eax, edi
  0006b	0f bf cf	 movsx	 ecx, di
  0006e	25 00 80 ff ff	 and	 eax, -32768		; ffff8000H
  00073	f7 d8		 neg	 eax
  00075	98		 cwde

; 66   : 	return x;

  00076	5f		 pop	 edi
  00077	0b c1		 or	 eax, ecx
  00079	5e		 pop	 esi

; 67   : }

  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
?r_short@@YAHPAUSWFILE@@@Z ENDP				; r_short
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?r_string@@YAHPADHPAUSWFILE@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
_n$ = 12						; size = 4
_p$ = 16						; size = 4
?r_string@@YAHPADHPAUSWFILE@@@Z PROC			; r_string, COMDAT

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 50   : 	if (p->fp != NULL)

  00004	8b 7d 10	 mov	 edi, DWORD PTR _p$[ebp]
  00007	8b 07		 mov	 eax, DWORD PTR [edi]
  00009	85 c0		 test	 eax, eax
  0000b	74 14		 je	 SHORT $LN2@r_string

; 51   : 		return fread(s, 1, n, p->fp);

  0000d	50		 push	 eax
  0000e	ff 75 0c	 push	 DWORD PTR _n$[ebp]
  00011	6a 01		 push	 1
  00013	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00016	e8 00 00 00 00	 call	 _fread
  0001b	83 c4 10	 add	 esp, 16			; 00000010H
  0001e	5f		 pop	 edi

; 57   : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN2@r_string:

; 52   : 	if (p->end - p->ptr < n)

  00021	8b 57 10	 mov	 edx, DWORD PTR [edi+16]
  00024	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  00027	56		 push	 esi
  00028	8b 75 0c	 mov	 esi, DWORD PTR _n$[ebp]
  0002b	2b ca		 sub	 ecx, edx
  0002d	3b ce		 cmp	 ecx, esi
  0002f	0f 4c f1	 cmovl	 esi, ecx

; 53   : 		n = p->end - p->ptr;
; 54   : 	memcpy(s, p->ptr, n);

  00032	56		 push	 esi
  00033	52		 push	 edx
  00034	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00037	e8 00 00 00 00	 call	 _memcpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 55   : 	p->ptr += n;
; 56   : 	return n;

  0003f	8b c6		 mov	 eax, esi
  00041	01 77 10	 add	 DWORD PTR [edi+16], esi
  00044	5e		 pop	 esi
  00045	5f		 pop	 edi

; 57   : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?r_string@@YAHPADHPAUSWFILE@@@Z ENDP			; r_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z PROC	; _PyMarshal_ReadLongFromFile, COMDAT

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 391  : 	RFILE rf;
; 392  : 	rf.fp = fp;

  00006	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00009	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 393  : 	return r_long(&rf);

  0000c	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ?r_long@@YAJPAUSWFILE@@@Z ; r_long
  00015	83 c4 04	 add	 esp, 4

; 394  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_PyMarshal_ReadLongFromFile@@YAJPAU_iobuf@@@Z ENDP	; _PyMarshal_ReadLongFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_buf$1 = -16388						; size = 16384
__$ArrayPad$ = -4					; size = 4
_fp$ = 8						; size = 4
?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z PROC ; _PyMarshal_ReadLastObjectFromFile, COMDAT

; 413  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 04 40 00 00	 mov	 eax, 16388		; 00004004H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	53		 push	 ebx
  00018	8b 5d 08	 mov	 ebx, DWORD PTR _fp$[ebp]

; 414  : 	/* 75% of 2.1's .pyc files can exploit SMALL_FILE_LIMIT.
; 415  : 	 * REASONABLE_FILE_LIMIT is by defn something big enough for Tkinter.pyc.
; 416  : 	 */
; 417  : #define SMALL_FILE_LIMIT (1L << 14)
; 418  : #define REASONABLE_FILE_LIMIT (1L << 18)
; 419  : 
; 420  : 	off_t filesize;
; 421  : 
; 422  : 	if (PyErr_Occurred())

  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  00021	85 c0		 test	 eax, eax
  00023	74 29		 je	 SHORT $LN2@PyMarshal_

; 423  : 	{
; 424  : 		fprintf(stderr, "XXX rd_object called with exception set\n");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
  0002a	6a 02		 push	 2
  0002c	e8 00 00 00 00	 call	 ___acrt_iob_func
  00031	83 c4 04	 add	 esp, 4
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _fprintf
  0003a	83 c4 08	 add	 esp, 8

; 425  : 		return NULL;

  0003d	33 c0		 xor	 eax, eax
  0003f	5b		 pop	 ebx

; 451  : #undef SMALL_FILE_LIMIT
; 452  : #undef REASONABLE_FILE_LIMIT
; 453  : }

  00040	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00043	33 cd		 xor	 ecx, ebp
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN2@PyMarshal_:
  0004e	56		 push	 esi
  0004f	57		 push	 edi

; 426  : 	}
; 427  : 
; 428  : 	filesize = getfilesize(fp);

  00050	53		 push	 ebx
  00051	e8 00 00 00 00	 call	 ?getfilesize@@YAJPAU_iobuf@@@Z ; getfilesize
  00056	8b f0		 mov	 esi, eax
  00058	83 c4 04	 add	 esp, 4

; 429  : 	if (filesize > 0) {

  0005b	85 f6		 test	 esi, esi
  0005d	0f 8e 92 00 00
	00		 jle	 $LN7@PyMarshal_

; 430  : 		char buf[SMALL_FILE_LIMIT];
; 431  : 		char* pBuf = NULL;
; 432  : 		if (filesize <= SMALL_FILE_LIMIT)

  00063	81 fe 00 40 00
	00		 cmp	 esi, 16384		; 00004000H
  00069	7f 2e		 jg	 SHORT $LN4@PyMarshal_

; 433  : 			pBuf = buf;

  0006b	53		 push	 ebx
  0006c	56		 push	 esi
  0006d	8d bd fc bf ff
	ff		 lea	 edi, DWORD PTR _buf$1[ebp]
  00073	6a 01		 push	 1
  00075	57		 push	 edi
  00076	e8 00 00 00 00	 call	 _fread
  0007b	50		 push	 eax
  0007c	57		 push	 edi
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyMarshal_ReadObjectFromString
  00083	83 c4 18	 add	 esp, 24			; 00000018H
  00086	8b f0		 mov	 esi, eax
  00088	5f		 pop	 edi
  00089	5e		 pop	 esi
  0008a	5b		 pop	 ebx

; 451  : #undef SMALL_FILE_LIMIT
; 452  : #undef REASONABLE_FILE_LIMIT
; 453  : }

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
$LN4@PyMarshal_:

; 434  : 		else if (filesize <= REASONABLE_FILE_LIMIT)

  00099	81 fe 00 00 04
	00		 cmp	 esi, 262144		; 00040000H
  0009f	7f 54		 jg	 SHORT $LN7@PyMarshal_

; 435  : 			pBuf = (char *)PyMem_MALLOC(filesize);

  000a1	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  000a7	77 4c		 ja	 SHORT $LN7@PyMarshal_
  000a9	56		 push	 esi
  000aa	e8 00 00 00 00	 call	 _malloc
  000af	8b f8		 mov	 edi, eax
  000b1	83 c4 04	 add	 esp, 4

; 436  : 		if (pBuf != NULL) {

  000b4	85 ff		 test	 edi, edi
  000b6	74 3d		 je	 SHORT $LN7@PyMarshal_

; 437  : 			PyObject* v;
; 438  : 			size_t n = fread(pBuf, 1, filesize, fp);

  000b8	53		 push	 ebx
  000b9	56		 push	 esi
  000ba	6a 01		 push	 1
  000bc	57		 push	 edi
  000bd	e8 00 00 00 00	 call	 _fread

; 439  : 			v = PyMarshal_ReadObjectFromString(pBuf, n);

  000c2	50		 push	 eax
  000c3	57		 push	 edi
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyMarshal_ReadObjectFromString
  000ca	8b f0		 mov	 esi, eax
  000cc	83 c4 18	 add	 esp, 24			; 00000018H

; 440  : 			if (pBuf != buf)

  000cf	8d 85 fc bf ff
	ff		 lea	 eax, DWORD PTR _buf$1[ebp]
  000d5	3b f8		 cmp	 edi, eax
  000d7	74 09		 je	 SHORT $LN8@PyMarshal_

; 441  : 				PyMem_FREE(pBuf);

  000d9	57		 push	 edi
  000da	e8 00 00 00 00	 call	 _free
  000df	83 c4 04	 add	 esp, 4
$LN8@PyMarshal_:

; 442  : 			return v;

  000e2	5f		 pop	 edi
  000e3	8b c6		 mov	 eax, esi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx

; 451  : #undef SMALL_FILE_LIMIT
; 452  : #undef REASONABLE_FILE_LIMIT
; 453  : }

  000e7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ea	33 cd		 xor	 ecx, ebp
  000ec	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
$LN7@PyMarshal_:

; 443  : 		}
; 444  : 
; 445  : 	}
; 446  : 
; 447  : 	/* We don't have fstat, or we do but the file is larger than
; 448  : 	 * REASONABLE_FILE_LIMIT or malloc failed -- read a byte at a time.
; 449  : 	 */
; 450  : 	return _PyMarshal_ReadObjectFromFile(fp);

  000f5	53		 push	 ebx
  000f6	e8 00 00 00 00	 call	 ?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ; _PyMarshal_ReadObjectFromFile

; 451  : #undef SMALL_FILE_LIMIT
; 452  : #undef REASONABLE_FILE_LIMIT
; 453  : }

  000fb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	83 c4 04	 add	 esp, 4
  00101	33 cd		 xor	 ecx, ebp
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010b	8b e5		 mov	 esp, ebp
  0010d	5d		 pop	 ebp
  0010e	c3		 ret	 0
?_PyMarshal_ReadLastObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ENDP ; _PyMarshal_ReadLastObjectFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\scriptLib\PythonMarshal.cpp
;	COMDAT ?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z
_TEXT	SEGMENT
_rf$ = -24						; size = 24
_fp$ = 8						; size = 4
?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z PROC ; _PyMarshal_ReadObjectFromFile, COMDAT

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 457  : 	RFILE rf;
; 458  : 	if (PyErr_Occurred()) {

  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PyErr_Occurred
  0000c	85 c0		 test	 eax, eax
  0000e	74 1e		 je	 SHORT $LN2@PyMarshal_

; 459  : 		fprintf(stderr, "XXX rd_object called with exception set\n");

  00010	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@IABJNOI@XXX?5rd_object?5called?5with?5excep@
  00015	6a 02		 push	 2
  00017	e8 00 00 00 00	 call	 ___acrt_iob_func
  0001c	83 c4 04	 add	 esp, 4
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _fprintf
  00025	83 c4 08	 add	 esp, 8

; 460  : 		return NULL;

  00028	33 c0		 xor	 eax, eax

; 464  : }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
$LN2@PyMarshal_:

; 461  : 	}
; 462  : 	rf.fp = fp;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _fp$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _rf$[ebp], eax

; 463  : 	return r_object(&rf);

  00034	8d 45 e8	 lea	 eax, DWORD PTR _rf$[ebp]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?r_object@@YAPAU_object@@PAUSWFILE@@@Z ; r_object
  0003d	83 c4 04	 add	 esp, 4

; 464  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_PyMarshal_ReadObjectFromFile@@YAPAU_object@@PAU_iobuf@@@Z ENDP ; _PyMarshal_ReadObjectFromFile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);
; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
