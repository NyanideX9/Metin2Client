; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\EffectLib\Distribute\EffectMesh.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_7?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ ; CDynamicPool<CEffectMesh::SEffectMeshData>::`vftable'
PUBLIC	??_G?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z ; CDynamicPool<CEffectMesh::SEffectMeshData>::`scalar deleting destructor'
PUBLIC	??_R4?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCEffectMeshScript@@@@6B@	; CDynamicPool<CEffectMeshScript>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCEffectMeshScript@@@@@8	; CDynamicPool<CEffectMeshScript> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCEffectMeshScript@@@@8	; CDynamicPool<CEffectMeshScript>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCEffectMeshScript@@@@8	; CDynamicPool<CEffectMeshScript>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshScript@@@@8 ; CDynamicPool<CEffectMeshScript>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$CDynamicPool@VCEffectMeshScript@@@@6B@	; CDynamicPool<CEffectMeshScript>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z ; CDynamicPool<CEffectMeshScript>::`scalar deleting destructor'
EXTRN	??_E?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z:PROC ; CDynamicPool<CEffectMesh::SEffectMeshData>::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z:PROC ; CDynamicPool<CEffectMeshScript>::`vector deleting destructor'
;	COMDAT ??_7?$CDynamicPool@VCEffectMeshScript@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCEffectMeshScript@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCEffectMeshScript@@@@6B@ ; CDynamicPool<CEffectMeshScript>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshScript@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCEffectMeshScript@@@@@8 ; CDynamicPool<CEffectMeshScript>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCEffectMeshScript@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCEffectMeshScript@@@@8 ; CDynamicPool<CEffectMeshScript>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCEffectMeshScript@@@@8 DD 00H	; CDynamicPool<CEffectMeshScript>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCEffectMeshScript@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCEffectMeshScript@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CEffectMeshScript> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCEffectMeshScript@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCEffectMeshScript@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCEffectMeshScript@@@@6B@ DD 00H	; CDynamicPool<CEffectMeshScript>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCEffectMeshScript@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCEffectMeshScript@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8 DD 00H ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CEffectMesh::SEffectMeshData> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ DD 00H ; CDynamicPool<CEffectMesh::SEffectMeshData>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@8
rdata$r	ENDS
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ DD FLAT:??_R4?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ ; CDynamicPool<CEffectMesh::SEffectMeshData>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1CGotoChild@CTextFileLoader@@QAE@XZ		; CTextFileLoader::CGotoChild::~CGotoChild
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
PUBLIC	?_Xlength@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@CAXXZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Xlength
PUBLIC	??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::~vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >
PUBLIC	?_Xlength@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@CAXXZ ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Xlength
PUBLIC	?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength
PUBLIC	?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ	; CEffectMesh::SEffectMeshData::New
PUBLIC	?Delete@SEffectMeshData@CEffectMesh@@SAXPAU12@@Z ; CEffectMesh::SEffectMeshData::Delete
PUBLIC	?DestroySystem@SEffectMeshData@CEffectMesh@@SAXXZ ; CEffectMesh::SEffectMeshData::DestroySystem
PUBLIC	?Type@CEffectMesh@@SAKXZ			; CEffectMesh::Type
PUBLIC	??0CEffectMesh@@QAE@PBD@Z			; CEffectMesh::CEffectMesh
PUBLIC	??1CEffectMesh@@UAE@XZ				; CEffectMesh::~CEffectMesh
PUBLIC	?GetFrameCount@CEffectMesh@@QAEKXZ		; CEffectMesh::GetFrameCount
PUBLIC	?GetMeshCount@CEffectMesh@@QAEKXZ		; CEffectMesh::GetMeshCount
PUBLIC	?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z ; CEffectMesh::GetMeshDataPointer
PUBLIC	?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z ; CEffectMesh::GetTextureVectorPointer
PUBLIC	?GetTextureVectorReference@CEffectMesh@@QAEAAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z ; CEffectMesh::GetTextureVectorReference
PUBLIC	?GetMeshElementPointer@CEffectMesh@@QAEHKPAPAUSEffectMeshData@1@@Z ; CEffectMesh::GetMeshElementPointer
PUBLIC	?OnLoad@CEffectMesh@@MAE_NHPBX@Z		; CEffectMesh::OnLoad
PUBLIC	?OnClear@CEffectMesh@@MAEXXZ			; CEffectMesh::OnClear
PUBLIC	?OnIsEmpty@CEffectMesh@@MBE_NXZ			; CEffectMesh::OnIsEmpty
PUBLIC	?OnIsType@CEffectMesh@@MAE_NK@Z			; CEffectMesh::OnIsType
PUBLIC	?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z	; CEffectMesh::__LoadData_Ver001
PUBLIC	?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z	; CEffectMesh::__LoadData_Ver002
PUBLIC	?push_back@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXABQAUSEffectMeshData@CEffectMesh@@@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::push_back
PUBLIC	?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::resize
PUBLIC	?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Xlength
PUBLIC	??_GCEffectMesh@@UAEPAXI@Z			; CEffectMesh::`scalar deleting destructor'
PUBLIC	??0CEffectMeshScript@@QAE@XZ			; CEffectMeshScript::CEffectMeshScript
PUBLIC	??1CEffectMeshScript@@UAE@XZ			; CEffectMeshScript::~CEffectMeshScript
PUBLIC	?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ	; CEffectMeshScript::GetMeshFileName
PUBLIC	?ReserveMeshData@CEffectMeshScript@@QAEXK@Z	; CEffectMeshScript::ReserveMeshData
PUBLIC	?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z	; CEffectMeshScript::CheckMeshIndex
PUBLIC	?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z ; CEffectMeshScript::GetMeshDataPointer
PUBLIC	?GetMeshDataCount@CEffectMeshScript@@QAEHXZ	; CEffectMeshScript::GetMeshDataCount
PUBLIC	?GetBillboardType@CEffectMeshScript@@QAEHK@Z	; CEffectMeshScript::GetBillboardType
PUBLIC	?isBlendingEnable@CEffectMeshScript@@QAEHK@Z	; CEffectMeshScript::isBlendingEnable
PUBLIC	?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z	; CEffectMeshScript::GetBlendingSrcType
PUBLIC	?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z	; CEffectMeshScript::GetBlendingDestType
PUBLIC	?isTextureAlphaEnable@CEffectMeshScript@@QAEHK@Z ; CEffectMeshScript::isTextureAlphaEnable
PUBLIC	?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z ; CEffectMeshScript::GetColorOperationType
PUBLIC	?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z ; CEffectMeshScript::GetColorFactor
PUBLIC	?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z ; CEffectMeshScript::GetTimeTableAlphaPointer
PUBLIC	?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ	; CEffectMeshScript::isMeshAnimationLoop
PUBLIC	?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ ; CEffectMeshScript::GetMeshAnimationLoopCount
PUBLIC	?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ ; CEffectMeshScript::GetMeshAnimationFrameDelay
PUBLIC	?isTextureAnimationLoop@CEffectMeshScript@@QAEHK@Z ; CEffectMeshScript::isTextureAnimationLoop
PUBLIC	?GetTextureAnimationFrameDelay@CEffectMeshScript@@QAEMK@Z ; CEffectMeshScript::GetTextureAnimationFrameDelay
PUBLIC	?GetTextureAnimationStartFrame@CEffectMeshScript@@QAEKK@Z ; CEffectMeshScript::GetTextureAnimationStartFrame
PUBLIC	?OnClear@CEffectMeshScript@@MAEXXZ		; CEffectMeshScript::OnClear
PUBLIC	?OnIsData@CEffectMeshScript@@MAE_NXZ		; CEffectMeshScript::OnIsData
PUBLIC	?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z ; CEffectMeshScript::OnLoadScript
PUBLIC	??1?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::~vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >
PUBLIC	?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::resize
PUBLIC	?_Xlength@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Xlength
PUBLIC	?DestroySystem@CEffectMeshScript@@SAXXZ		; CEffectMeshScript::DestroySystem
PUBLIC	?New@CEffectMeshScript@@SAPAV1@XZ		; CEffectMeshScript::New
PUBLIC	?Delete@CEffectMeshScript@@SAXPAV1@@Z		; CEffectMeshScript::Delete
PUBLIC	??_GCEffectMeshScript@@UAEPAXI@Z		; CEffectMeshScript::`scalar deleting destructor'
PUBLIC	??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ ; CDynamicPool<CEffectMesh::SEffectMeshData>::~CDynamicPool<CEffectMesh::SEffectMeshData>
PUBLIC	??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
PUBLIC	?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
PUBLIC	?_Xlength@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlength
PUBLIC	??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ	; CDynamicPool<CEffectMeshScript>::~CDynamicPool<CEffectMeshScript>
PUBLIC	?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAPAUSMeshData@CEffectMeshScript@@PAU12@IAAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMeshScript::SMeshData> >
PUBLIC	??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@YAPAUSEffectFrameData@CEffectMesh@@PAU12@IAAV?$allocator@USEffectFrameData@CEffectMesh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMesh::SEffectFrameData> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@AAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
PUBLIC	??$_Zero_range@PAH@std@@YAPAHQAH0@Z		; std::_Zero_range<int *>
PUBLIC	??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z ; std::_Zero_range<CEffectMesh::SEffectMeshData * *>
PUBLIC	??$_Copy_memmove@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z ; std::_Copy_memmove<D3DXVECTOR2 *,D3DXVECTOR2 *>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>
PUBLIC	??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>
PUBLIC	??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>
PUBLIC	??$_Copy_memmove@PAUSPTVertex@@PAU1@@std@@YAPAUSPTVertex@@PAU1@00@Z ; std::_Copy_memmove<SPTVertex *,SPTVertex *>
PUBLIC	??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>
PUBLIC	??$_Copy_memmove_tail@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<D3DXVECTOR2 *>
PUBLIC	??$_Copy_memmove_tail@PAH@std@@YAPAHQBDQAHII@Z	; std::_Copy_memmove_tail<int *>
PUBLIC	??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<D3DXVECTOR3 *>
PUBLIC	??$_Copy_memmove_tail@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QBDQAPAU12@II@Z ; std::_Copy_memmove_tail<CEffectMesh::SEffectMeshData * *>
PUBLIC	??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CGraphicImage * *>
PUBLIC	??$_Copy_memmove_tail@PAUSPTVertex@@@std@@YAPAUSPTVertex@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<SPTVertex *>
PUBLIC	??$_Copy_memmove_tail@PAPAVCEffectMeshScript@@@std@@YAPAPAVCEffectMeshScript@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CEffectMeshScript * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A ; CEffectMesh::SEffectMeshData::ms_kPool
PUBLIC	??_7CEffectMesh@@6B@				; CEffectMesh::`vftable'
PUBLIC	?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A ; CEffectMeshScript::ms_kPool
PUBLIC	??_7CEffectMeshScript@@6B@			; CEffectMeshScript::`vftable'
PUBLIC	??_C@_0M@HCKGHODL@CEffectMesh@			; `string'
PUBLIC	??_C@_0L@HDPGDEFC@EffectData@			; `string'
PUBLIC	??_C@_0L@HDHCIEF@MDEData002@			; `string'
PUBLIC	??_C@_03BNIHALFD@ifl@				; `string'
PUBLIC	??_C@_0N@KFLKANCO@meshfilename@			; `string'
PUBLIC	??_C@_0BI@HOBONKKC@meshanimationloopenable@	; `string'
PUBLIC	??_C@_0BH@CNDNOBIC@meshanimationloopcount@	; `string'
PUBLIC	??_C@_0BI@DLPGELIN@meshanimationframedelay@	; `string'
PUBLIC	??_C@_0BB@IMKDGDDP@meshelementcount@		; `string'
PUBLIC	??_C@_0O@EJACNAIE@billboardtype@		; `string'
PUBLIC	??_C@_0P@LCDJDIBK@blendingenable@		; `string'
PUBLIC	??_C@_0BA@CALCJEKJ@blendingsrctype@		; `string'
PUBLIC	??_C@_0BB@PBNEFHNO@blendingdesttype@		; `string'
PUBLIC	??_C@_0BL@INILLDMC@textureanimationloopenable@	; `string'
PUBLIC	??_C@_0BL@MIGDCCON@textureanimationframedelay@	; `string'
PUBLIC	??_C@_0BL@PMOBBIKD@textureanimationstartframe@	; `string'
PUBLIC	??_C@_0BD@DAMHAFBJ@coloroperationtype@		; `string'
PUBLIC	??_C@_0M@PBDNNBOP@colorfactor@			; `string'
PUBLIC	??_C@_0P@KALIPJCI@timeeventalpha@		; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CEffectMesh@@6B@				; CEffectMesh::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEffectMesh@@@8				; CEffectMesh `RTTI Type Descriptor'
PUBLIC	??_R3CEffectMesh@@8				; CEffectMesh::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectMesh@@8				; CEffectMesh::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEffectMesh@@8			; CEffectMesh::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CResource@@8			; CResource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCResource@@@8				; CResource `RTTI Type Descriptor'
PUBLIC	??_R3CResource@@8				; CResource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CResource@@8				; CResource::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CReferenceObject@@8		; CReferenceObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCReferenceObject@@@8			; CReferenceObject `RTTI Type Descriptor'
PUBLIC	??_R3CReferenceObject@@8			; CReferenceObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CReferenceObject@@8			; CReferenceObject::`RTTI Base Class Array'
PUBLIC	??_R4CEffectMeshScript@@6B@			; CEffectMeshScript::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEffectMeshScript@@@8			; CEffectMeshScript `RTTI Type Descriptor'
PUBLIC	??_R3CEffectMeshScript@@8			; CEffectMeshScript::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectMeshScript@@8			; CEffectMeshScript::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEffectMeshScript@@8		; CEffectMeshScript::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CEffectElementBase@@8		; CEffectElementBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCEffectElementBase@@@8			; CEffectElementBase `RTTI Type Descriptor'
PUBLIC	??_R3CEffectElementBase@@8			; CEffectElementBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEffectElementBase@@8			; CEffectElementBase::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@bf800000
PUBLIC	__xmm@3f8000003f8000003f8000003f800000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?GetFileExtension@@YAXPBDHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GetFileExtension
EXTRN	?stl_lowers@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; stl_lowers
EXTRN	?GetOnlyPathName@@YAXPBDAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GetOnlyPathName
EXTRN	?GetOnlyPathName@@YAPBDPBD@Z:PROC		; GetOnlyPathName
EXTRN	?IsGlobalFileName@@YA_NPBD@Z:PROC		; IsGlobalFileName
EXTRN	??0CMemoryTextFileLoader@@QAE@XZ:PROC		; CMemoryTextFileLoader::CMemoryTextFileLoader
EXTRN	??1CMemoryTextFileLoader@@UAE@XZ:PROC		; CMemoryTextFileLoader::~CMemoryTextFileLoader
EXTRN	?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z:PROC	; CMemoryTextFileLoader::Bind
EXTRN	?GetLineCount@CMemoryTextFileLoader@@QAEKXZ:PROC ; CMemoryTextFileLoader::GetLineCount
EXTRN	?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z:PROC ; CMemoryTextFileLoader::GetLineString
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	?GetFileName@CTextFileLoader@@QAEPBDXZ:PROC	; CTextFileLoader::GetFileName
EXTRN	?SetChildNode@CTextFileLoader@@QAEHK@Z:PROC	; CTextFileLoader::SetChildNode
EXTRN	?SetParentNode@CTextFileLoader@@QAEHXZ:PROC	; CTextFileLoader::SetParentNode
EXTRN	?GetTokenBoolean@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z:PROC ; CTextFileLoader::GetTokenBoolean
EXTRN	?GetTokenByte@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z:PROC ; CTextFileLoader::GetTokenByte
EXTRN	?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z:PROC ; CTextFileLoader::GetTokenInteger
EXTRN	?GetTokenDoubleWord@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAK@Z:PROC ; CTextFileLoader::GetTokenDoubleWord
EXTRN	?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z:PROC ; CTextFileLoader::GetTokenFloat
EXTRN	?GetTokenColor@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXCOLOR@@@Z:PROC ; CTextFileLoader::GetTokenColor
EXTRN	?GetTokenString@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV23@@Z:PROC ; CTextFileLoader::GetTokenString
EXTRN	?StringToType@CResource@@SAKPBD@Z:PROC		; CResource::StringToType
EXTRN	?CreateDeviceObjects@CResource@@UAE_NXZ:PROC	; CResource::CreateDeviceObjects
EXTRN	?DestroyDeviceObjects@CResource@@UAEXXZ:PROC	; CResource::DestroyDeviceObjects
EXTRN	??0CResource@@QAE@PBD@Z:PROC			; CResource::CResource
EXTRN	??1CResource@@UAE@XZ:PROC			; CResource::~CResource
EXTRN	?OnIsType@CResource@@MAE_NK@Z:PROC		; CResource::OnIsType
EXTRN	?OnConstruct@CResource@@MAEXXZ:PROC		; CResource::OnConstruct
EXTRN	?OnSelfDestruct@CResource@@MAEXXZ:PROC		; CResource::OnSelfDestruct
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z:PROC ; CEterPackManager::Get
EXTRN	?GetTokenTimeEventFloat@@YAHAAVCTextFileLoader@@PBDPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z:PROC ; GetTokenTimeEventFloat
EXTRN	??0CEffectElementBase@@QAE@XZ:PROC		; CEffectElementBase::CEffectElementBase
EXTRN	??1CEffectElementBase@@UAE@XZ:PROC		; CEffectElementBase::~CEffectElementBase
EXTRN	?Clear@CEffectElementBase@@QAEXXZ:PROC		; CEffectElementBase::Clear
EXTRN	??_ECEffectMesh@@UAEPAXI@Z:PROC			; CEffectMesh::`vector deleting destructor'
EXTRN	??_ECEffectMeshScript@@UAEPAXI@Z:PROC		; CEffectMeshScript::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_type@?1??Type@CEffectMesh@@SAKXZ@4KA
_BSS	SEGMENT
?s_type@?1??Type@CEffectMesh@@SAKXZ@4KA DD 01H DUP (?)	; `CEffectMesh::Type'::`2'::s_type
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA
_BSS	SEGMENT
?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA DD 01H DUP (?)	; `CEffectMesh::Type'::`2'::$TSS0
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@SEffectMeshData@CEffectMesh@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ ; ??ms_kPool$initializer$@SEffectMeshData@CEffectMesh@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@3f8000003f8000003f8000003f800000
CONST	SEGMENT
__xmm@3f8000003f8000003f8000003f800000 DB 00H, 00H, 080H, '?', 00H, 00H, 080H
	DB	'?', 00H, 00H, 080H, '?', 00H, 00H, 080H, '?'
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2CEffectElementBase@@8
rdata$r	SEGMENT
??_R2CEffectElementBase@@8 DD FLAT:??_R1A@?0A@EA@CEffectElementBase@@8 ; CEffectElementBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CEffectElementBase@@8
rdata$r	SEGMENT
??_R3CEffectElementBase@@8 DD 00H			; CEffectElementBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CEffectElementBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectElementBase@@@8
data$rs	SEGMENT
??_R0?AVCEffectElementBase@@@8 DD FLAT:??_7type_info@@6B@ ; CEffectElementBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectElementBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectElementBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectElementBase@@8 DD FLAT:??_R0?AVCEffectElementBase@@@8 ; CEffectElementBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectElementBase@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectMeshScript@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectMeshScript@@8 DD FLAT:??_R0?AVCEffectMeshScript@@@8 ; CEffectMeshScript::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectMeshScript@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectMeshScript@@8
rdata$r	SEGMENT
??_R2CEffectMeshScript@@8 DD FLAT:??_R1A@?0A@EA@CEffectMeshScript@@8 ; CEffectMeshScript::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CEffectElementBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CEffectMeshScript@@8
rdata$r	SEGMENT
??_R3CEffectMeshScript@@8 DD 00H			; CEffectMeshScript::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CEffectMeshScript@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectMeshScript@@@8
data$rs	SEGMENT
??_R0?AVCEffectMeshScript@@@8 DD FLAT:??_7type_info@@6B@ ; CEffectMeshScript `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectMeshScript@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CEffectMeshScript@@6B@
rdata$r	SEGMENT
??_R4CEffectMeshScript@@6B@ DD 00H			; CEffectMeshScript::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEffectMeshScript@@@8
	DD	FLAT:??_R3CEffectMeshScript@@8
rdata$r	ENDS
;	COMDAT ??_R2CReferenceObject@@8
rdata$r	SEGMENT
??_R2CReferenceObject@@8 DD FLAT:??_R1A@?0A@EA@CReferenceObject@@8 ; CReferenceObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CReferenceObject@@8
rdata$r	SEGMENT
??_R3CReferenceObject@@8 DD 00H				; CReferenceObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CReferenceObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCReferenceObject@@@8
data$rs	SEGMENT
??_R0?AVCReferenceObject@@@8 DD FLAT:??_7type_info@@6B@	; CReferenceObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCReferenceObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CReferenceObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CReferenceObject@@8 DD FLAT:??_R0?AVCReferenceObject@@@8 ; CReferenceObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CReferenceObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CResource@@8
rdata$r	SEGMENT
??_R2CResource@@8 DD FLAT:??_R1A@?0A@EA@CResource@@8	; CResource::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CReferenceObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CResource@@8
rdata$r	SEGMENT
??_R3CResource@@8 DD 00H				; CResource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CResource@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCResource@@@8
data$rs	SEGMENT
??_R0?AVCResource@@@8 DD FLAT:??_7type_info@@6B@	; CResource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCResource@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CResource@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CResource@@8 DD FLAT:??_R0?AVCResource@@@8 ; CResource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CResource@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CEffectMesh@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEffectMesh@@8 DD FLAT:??_R0?AVCEffectMesh@@@8 ; CEffectMesh::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEffectMesh@@8
rdata$r	ENDS
;	COMDAT ??_R2CEffectMesh@@8
rdata$r	SEGMENT
??_R2CEffectMesh@@8 DD FLAT:??_R1A@?0A@EA@CEffectMesh@@8 ; CEffectMesh::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CResource@@8
	DD	FLAT:??_R1A@?0A@EA@CReferenceObject@@8
rdata$r	ENDS
;	COMDAT ??_R3CEffectMesh@@8
rdata$r	SEGMENT
??_R3CEffectMesh@@8 DD 00H				; CEffectMesh::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CEffectMesh@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEffectMesh@@@8
data$rs	SEGMENT
??_R0?AVCEffectMesh@@@8 DD FLAT:??_7type_info@@6B@	; CEffectMesh `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEffectMesh@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CEffectMesh@@6B@
rdata$r	SEGMENT
??_R4CEffectMesh@@6B@ DD 00H				; CEffectMesh::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEffectMesh@@@8
	DD	FLAT:??_R3CEffectMesh@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@KALIPJCI@timeeventalpha@
CONST	SEGMENT
??_C@_0P@KALIPJCI@timeeventalpha@ DB 'timeeventalpha', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PBDNNBOP@colorfactor@
CONST	SEGMENT
??_C@_0M@PBDNNBOP@colorfactor@ DB 'colorfactor', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DAMHAFBJ@coloroperationtype@
CONST	SEGMENT
??_C@_0BD@DAMHAFBJ@coloroperationtype@ DB 'coloroperationtype', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@PMOBBIKD@textureanimationstartframe@
CONST	SEGMENT
??_C@_0BL@PMOBBIKD@textureanimationstartframe@ DB 'textureanimationstartf'
	DB	'rame', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MIGDCCON@textureanimationframedelay@
CONST	SEGMENT
??_C@_0BL@MIGDCCON@textureanimationframedelay@ DB 'textureanimationframed'
	DB	'elay', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@INILLDMC@textureanimationloopenable@
CONST	SEGMENT
??_C@_0BL@INILLDMC@textureanimationloopenable@ DB 'textureanimationloopen'
	DB	'able', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PBNEFHNO@blendingdesttype@
CONST	SEGMENT
??_C@_0BB@PBNEFHNO@blendingdesttype@ DB 'blendingdesttype', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CALCJEKJ@blendingsrctype@
CONST	SEGMENT
??_C@_0BA@CALCJEKJ@blendingsrctype@ DB 'blendingsrctype', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LCDJDIBK@blendingenable@
CONST	SEGMENT
??_C@_0P@LCDJDIBK@blendingenable@ DB 'blendingenable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@EJACNAIE@billboardtype@
CONST	SEGMENT
??_C@_0O@EJACNAIE@billboardtype@ DB 'billboardtype', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IMKDGDDP@meshelementcount@
CONST	SEGMENT
??_C@_0BB@IMKDGDDP@meshelementcount@ DB 'meshelementcount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DLPGELIN@meshanimationframedelay@
CONST	SEGMENT
??_C@_0BI@DLPGELIN@meshanimationframedelay@ DB 'meshanimationframedelay', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CNDNOBIC@meshanimationloopcount@
CONST	SEGMENT
??_C@_0BH@CNDNOBIC@meshanimationloopcount@ DB 'meshanimationloopcount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HOBONKKC@meshanimationloopenable@
CONST	SEGMENT
??_C@_0BI@HOBONKKC@meshanimationloopenable@ DB 'meshanimationloopenable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KFLKANCO@meshfilename@
CONST	SEGMENT
??_C@_0N@KFLKANCO@meshfilename@ DB 'meshfilename', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03BNIHALFD@ifl@
CONST	SEGMENT
??_C@_03BNIHALFD@ifl@ DB 'ifl', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDHCIEF@MDEData002@
CONST	SEGMENT
??_C@_0L@HDHCIEF@MDEData002@ DB 'MDEData002', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HDPGDEFC@EffectData@
CONST	SEGMENT
??_C@_0L@HDPGDEFC@EffectData@ DB 'EffectData', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HCKGHODL@CEffectMesh@
CONST	SEGMENT
??_C@_0M@HCKGHODL@CEffectMesh@ DB 'CEffectMesh', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7CEffectMeshScript@@6B@
CONST	SEGMENT
??_7CEffectMeshScript@@6B@ DD FLAT:??_R4CEffectMeshScript@@6B@ ; CEffectMeshScript::`vftable'
	DD	FLAT:??_ECEffectMeshScript@@UAEPAXI@Z
	DD	FLAT:?OnClear@CEffectMeshScript@@MAEXXZ
	DD	FLAT:?OnIsData@CEffectMeshScript@@MAE_NXZ
	DD	FLAT:?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z
CONST	ENDS
;	COMDAT ??_7CEffectMesh@@6B@
CONST	SEGMENT
??_7CEffectMesh@@6B@ DD FLAT:??_R4CEffectMesh@@6B@	; CEffectMesh::`vftable'
	DD	FLAT:??_ECEffectMesh@@UAEPAXI@Z
	DD	FLAT:?OnConstruct@CResource@@MAEXXZ
	DD	FLAT:?OnSelfDestruct@CResource@@MAEXXZ
	DD	FLAT:?CreateDeviceObjects@CResource@@UAE_NXZ
	DD	FLAT:?DestroyDeviceObjects@CResource@@UAEXXZ
	DD	FLAT:?OnLoad@CEffectMesh@@MAE_NHPBX@Z
	DD	FLAT:?OnClear@CEffectMesh@@MAEXXZ
	DD	FLAT:?OnIsEmpty@CEffectMesh@@MBE_NXZ
	DD	FLAT:?OnIsType@CEffectMesh@@MAE_NK@Z
CONST	ENDS
_DATA	SEGMENT
?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A DD FLAT:??_7?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@ ; CEffectMesh::SEffectMeshData::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A DD FLAT:??_7?$CDynamicPool@VCEffectMeshScript@@@@6B@ ; CEffectMeshScript::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCEffectMeshScript@@@@QAEPAVCEffectMeshScript@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCEffectMeshScript@@@@QAEPAVCEffectMeshScript@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCEffectMeshScript@@@@QAEPAVCEffectMeshScript@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCEffectMeshScript@@@@QAEPAVCEffectMeshScript@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@CEffectMeshScript@@SAPAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@CEffectMeshScript@@SAPAV1@XZ$0
__ehfuncinfo$?New@CEffectMeshScript@@SAPAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@CEffectMeshScript@@SAPAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z DD 019930522H
	DD	016H
	DD	FLAT:__unwindtable$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$7
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$8
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$9
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$10
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$11
	DD	0ffffffffH
	DD	00H
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$12
	DD	0ffffffffH
	DD	FLAT:___std_terminate
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$13
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$14
	DD	05H
	DD	FLAT:__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$15
	DD	0ffffffffH
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Type@CEffectMesh@@SAKXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Type@CEffectMesh@@SAKXZ$0
__ehfuncinfo$?Type@CEffectMesh@@SAKXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Type@CEffectMesh@@SAKXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CGotoChild@CTextFileLoader@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CEffectMeshScript@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CEffectMeshScript@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAVCEffectMeshScript@@@std@@YAPAPAVCEffectMeshScript@@QBDQAPAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAVCEffectMeshScript@@@std@@YAPAPAVCEffectMeshScript@@QBDQAPAV1@II@Z PROC ; std::_Copy_memmove_tail<CEffectMeshScript * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAVCEffectMeshScript@@@std@@YAPAPAVCEffectMeshScript@@QBDQAPAV1@II@Z ENDP ; std::_Copy_memmove_tail<CEffectMeshScript * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAUSPTVertex@@@std@@YAPAUSPTVertex@@QBDQAU1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAUSPTVertex@@@std@@YAPAUSPTVertex@@QBDQAU1@II@Z PROC ; std::_Copy_memmove_tail<SPTVertex *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAUSPTVertex@@@std@@YAPAUSPTVertex@@QBDQAU1@II@Z ENDP ; std::_Copy_memmove_tail<SPTVertex *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z PROC ; std::_Copy_memmove_tail<CGraphicImage * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z ENDP ; std::_Copy_memmove_tail<CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QBDQAPAU12@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QBDQAPAU12@II@Z PROC ; std::_Copy_memmove_tail<CEffectMesh::SEffectMeshData * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QBDQAPAU12@II@Z ENDP ; std::_Copy_memmove_tail<CEffectMesh::SEffectMeshData * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z PROC ; std::_Copy_memmove_tail<D3DXVECTOR3 *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z ENDP ; std::_Copy_memmove_tail<D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAH@std@@YAPAHQBDQAHII@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAH@std@@YAPAHQBDQAHII@Z PROC	; std::_Copy_memmove_tail<int *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAH@std@@YAPAHQBDQAHII@Z ENDP	; std::_Copy_memmove_tail<int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@QBDQAU1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@QBDQAU1@II@Z PROC ; std::_Copy_memmove_tail<D3DXVECTOR2 *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@QBDQAU1@II@Z ENDP ; std::_Copy_memmove_tail<D3DXVECTOR2 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCEffectMeshScript@@@std@@YAPAPAVCEffectMeshScript@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CEffectMeshScript * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAUSPTVertex@@PAU1@@std@@YAPAUSPTVertex@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUSPTVertex@@PAU1@@std@@YAPAUSPTVertex@@PAU1@00@Z PROC ; std::_Copy_memmove<SPTVertex *,SPTVertex *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0000b	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  0000e	f7 e9		 imul	 ecx
  00010	c1 fa 03	 sar	 edx, 3
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  0001a	50		 push	 eax
  0001b	51		 push	 ecx
  0001c	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00022	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAUSPTVertex@@@std@@YAPAUSPTVertex@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<SPTVertex *>
  00027	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Copy_memmove@PAUSPTVertex@@PAU1@@std@@YAPAUSPTVertex@@PAU1@00@Z ENDP ; std::_Copy_memmove<SPTVertex *,SPTVertex *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CGraphicImage * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z PROC ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QBDQAPAU12@II@Z ; std::_Copy_memmove_tail<CEffectMesh::SEffectMeshData * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z ENDP ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z PROC ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  0000e	f7 e9		 imul	 ecx
  00010	d1 fa		 sar	 edx, 1
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<D3DXVECTOR3 *>
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ENDP ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAH@std@@YAPAHQBDQAHII@Z ; std::_Copy_memmove_tail<int *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z PROC ; std::_Copy_memmove<D3DXVECTOR2 *,D3DXVECTOR2 *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 03	 sar	 eax, 3

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAUD3DXVECTOR2@@@std@@YAPAUD3DXVECTOR2@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<D3DXVECTOR2 *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z ENDP ; std::_Copy_memmove<D3DXVECTOR2 *,D3DXVECTOR2 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z PROC ; std::_Zero_range<CEffectMesh::SEffectMeshData * *>, COMDAT

; 2032 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2033 :     char* const _First_ch = reinterpret_cast<char*>(_STD _To_address(_First));
; 2034 :     char* const _Last_ch  = reinterpret_cast<char*>(_STD _To_address(_Last));
; 2035 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 2036 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2037 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z ENDP ; std::_Zero_range<CEffectMesh::SEffectMeshData * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Zero_range@PAH@std@@YAPAHQAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAH@std@@YAPAHQAH0@Z PROC		; std::_Zero_range<int *>, COMDAT

; 2032 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2033 :     char* const _First_ch = reinterpret_cast<char*>(_STD _To_address(_First));
; 2034 :     char* const _Last_ch  = reinterpret_cast<char*>(_STD _To_address(_Last));
; 2035 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 2036 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2037 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAH@std@@YAPAHQAH0@Z ENDP		; std::_Zero_range<int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@AAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv652 = -8						; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@AAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 09 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004a	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv652[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00069	0f 87 c7 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00076	89 45 f8	 mov	 DWORD PTR tv652[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a1	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv650[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	3b d8		 cmp	 ebx, eax
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>
  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCEffectMeshScript@@PAPAV1@@std@@YAPAPAVCEffectMeshScript@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectMeshScript * *,CEffectMeshScript * *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00116	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00118	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR tv652[ebp]
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@AAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -8					; size = 4
tv487 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1537 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1538 :         if (_Newsize > max_size()) {

  00006	81 7d 08 cc cc
	cc 0c		 cmp	 DWORD PTR __Newsize$[ebp], 214748364 ; 0cccccccH
  0000d	53		 push	 ebx
  0000e	57		 push	 edi
  0000f	8b d9		 mov	 ebx, ecx
  00011	0f 87 2e 01 00
	00		 ja	 $LN119@Resize_rea

; 1540 :         }
; 1541 : 
; 1542 :         auto& _Al         = _Getal();
; 1543 :         auto& _My_data    = _Mypair._Myval2;
; 1544 :         pointer& _Myfirst = _My_data._Myfirst;
; 1545 :         pointer& _Mylast  = _My_data._Mylast;
; 1546 : 
; 1547 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

  00017	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0001a	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0001f	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00021	f7 e9		 imul	 ecx

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00023	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00026	2b 0b		 sub	 ecx, DWORD PTR [ebx]

; 1540 :         }
; 1541 : 
; 1542 :         auto& _Al         = _Getal();
; 1543 :         auto& _My_data    = _Mypair._Myval2;
; 1544 :         pointer& _Myfirst = _My_data._Myfirst;
; 1545 :         pointer& _Mylast  = _My_data._Mylast;
; 1546 : 
; 1547 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

  00028	c1 fa 03	 sar	 edx, 3
  0002b	8b c2		 mov	 eax, edx
  0002d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00030	03 c2		 add	 eax, edx
  00032	89 45 f8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00035	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0003a	f7 e9		 imul	 ecx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0003c	b8 cc cc cc 0c	 mov	 eax, 214748364		; 0cccccccH

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00041	c1 fa 03	 sar	 edx, 3
  00044	8b ca		 mov	 ecx, edx
  00046	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00049	03 ca		 add	 ecx, edx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004b	8b d1		 mov	 edx, ecx
  0004d	d1 ea		 shr	 edx, 1
  0004f	2b c2		 sub	 eax, edx
  00051	56		 push	 esi
  00052	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00055	3b c8		 cmp	 ecx, eax
  00057	76 14		 jbe	 SHORT $LN6@Resize_rea

; 1997 :             return _Max; // geometric growth would overflow

  00059	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  0005e	c7 45 fc f0 ff
	ff ff		 mov	 DWORD PTR tv487[ebp], -16 ; fffffff0H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006b	eb 3c		 jmp	 SHORT $LN117@Resize_rea
$LN6@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006d	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00070	3b c6		 cmp	 eax, esi
  00072	73 13		 jae	 SHORT $LN7@Resize_rea

; 2003 :             return _Newsize; // geometric growth would be insufficient

  00074	8b c6		 mov	 eax, esi
$LN17@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  00076	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  00079	c1 e0 02	 shl	 eax, 2
  0007c	89 45 fc	 mov	 DWORD PTR tv487[ebp], eax

; 227  :     if (_Bytes == 0) {

  0007f	85 c0		 test	 eax, eax
  00081	75 11		 jne	 SHORT $LN21@Resize_rea

; 228  :         return nullptr;

  00083	33 ff		 xor	 edi, edi
  00085	eb 27		 jmp	 SHORT $LN20@Resize_rea
$LN7@Resize_rea:

; 117  :         if (_Count > _Max_possible) {

  00087	3d cc cc cc 0c	 cmp	 eax, 214748364		; 0cccccccH
  0008c	0f 87 b8 00 00
	00		 ja	 $LN120@Resize_rea
  00092	eb e2		 jmp	 SHORT $LN17@Resize_rea
$LN21@Resize_rea:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00094	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00099	72 08		 jb	 SHORT $LN22@Resize_rea

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a1	eb 06		 jmp	 SHORT $LN117@Resize_rea
$LN22@Resize_rea:

; 136  :         return ::operator new(_Bytes);

  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN117@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000a9	8b f8		 mov	 edi, eax
  000ab	83 c4 04	 add	 esp, 4
$LN20@Resize_rea:
  000ae	8b 4d f8	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]
  000b1	8d 04 89	 lea	 eax, DWORD PTR [ecx+ecx*4]
  000b4	8d 14 87	 lea	 edx, DWORD PTR [edi+eax*4]

; 1560 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

  000b7	2b f1		 sub	 esi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  000b9	74 12		 je	 SHORT $LN31@Resize_rea
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1560 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

  000bb	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  000be	c1 e0 02	 shl	 eax, 2
  000c1	50		 push	 eax
  000c2	6a 00		 push	 0
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 _memset
  000ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN31@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cd	57		 push	 edi
  000ce	ff 73 04	 push	 DWORD PTR [ebx+4]
  000d1	ff 33		 push	 DWORD PTR [ebx]
  000d3	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSPTVertex@@PAU1@@std@@YAPAUSPTVertex@@PAU1@00@Z ; std::_Copy_memmove<SPTVertex *,SPTVertex *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d8	8b 33		 mov	 esi, DWORD PTR [ebx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000da	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000dd	85 f6		 test	 esi, esi
  000df	74 40		 je	 SHORT $LN63@Resize_rea

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e1	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  000e4	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  000e9	2b ce		 sub	 ecx, esi
  000eb	f7 e9		 imul	 ecx
  000ed	c1 fa 03	 sar	 edx, 3
  000f0	8b c2		 mov	 eax, edx
  000f2	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000f5	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f7	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  000fa	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000fd	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00103	72 12		 jb	 SHORT $LN74@Resize_rea

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00105	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00108	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0010b	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010d	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00110	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00113	77 2b		 ja	 SHORT $LN71@Resize_rea

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00115	8b f2		 mov	 esi, edx
$LN74@Resize_rea:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00117	51		 push	 ecx
  00118	56		 push	 esi
  00119	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0011e	83 c4 08	 add	 esp, 8
$LN63@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00121	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00124	89 3b		 mov	 DWORD PTR [ebx], edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00126	5e		 pop	 esi
  00127	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  0012a	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  0012d	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00130	8b 45 fc	 mov	 eax, DWORD PTR tv487[ebp]
  00133	03 c7		 add	 eax, edi

; 1571 :     }

  00135	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00136	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1571 :     }

  00139	5b		 pop	 ebx
  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	c2 08 00	 ret	 8
$LN71@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00140	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN119@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1539 :             _Xlength();

  00145	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@CAXXZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Xlength
$LN120@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0014a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN116@Resize_rea:
  0014f	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@YAPAUSEffectFrameData@CEffectMesh@@PAU12@IAAV?$allocator@USEffectFrameData@CEffectMesh@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@YAPAUSEffectFrameData@CEffectMesh@@PAU12@IAAV?$allocator@USEffectFrameData@CEffectMesh@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMesh::SEffectFrameData> >, COMDAT

; 2041 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2056 :     for (; 0 < _Count; --_Count) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2056 :     for (; 0 < _Count; --_Count) {

  00009	85 d2		 test	 edx, edx
  0000b	74 2d		 je	 SHORT $LN3@Uninitiali
  0000d	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
$LL4@Uninitiali:
  00010	0f 57 c0	 xorps	 xmm0, xmm0

; 1808 :         ++_Last;

  00013	8d 49 20	 lea	 ecx, DWORD PTR [ecx+32]

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00016	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00019	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0

; 1808 :         ++_Last;

  0001d	83 c0 20	 add	 eax, 32			; 00000020H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00020	c7 41 d8 00 00
	00 00		 mov	 DWORD PTR [ecx-40], 0
  00027	c7 41 dc 00 00
	00 00		 mov	 DWORD PTR [ecx-36], 0
  0002e	c7 41 e0 00 00
	00 00		 mov	 DWORD PTR [ecx-32], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  00035	83 ea 01	 sub	 edx, 1
  00038	75 d6		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 2057 :         _Backout._Emplace_back();
; 2058 :     }
; 2059 : 
; 2060 :     return _Backout._Release();
; 2061 : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@YAPAUSEffectFrameData@CEffectMesh@@PAU12@IAAV?$allocator@USEffectFrameData@CEffectMesh@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMesh::SEffectFrameData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_this$1$ = -20						; size = 4
__Last$1$ = -20						; size = 4
__ULast$1$ = -16					; size = 4
__Oldsize$1$ = -12					; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1537 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 1538 :         if (_Newsize > max_size()) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	89 7d ec	 mov	 DWORD PTR _this$1$[ebp], edi
  00010	81 fb ff ff ff
	07		 cmp	 ebx, 134217727		; 07ffffffH
  00016	0f 87 87 01 00
	00		 ja	 $LN198@Resize_rea

; 1540 :         }
; 1541 : 
; 1542 :         auto& _Al         = _Getal();
; 1543 :         auto& _My_data    = _Mypair._Myval2;
; 1544 :         pointer& _Myfirst = _My_data._Myfirst;
; 1545 :         pointer& _Mylast  = _My_data._Mylast;
; 1546 : 
; 1547 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

  0001c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0001f	b8 ff ff ff 07	 mov	 eax, 134217727		; 07ffffffH

; 1540 :         }
; 1541 : 
; 1542 :         auto& _Al         = _Getal();
; 1543 :         auto& _My_data    = _Mypair._Myval2;
; 1544 :         pointer& _Myfirst = _My_data._Myfirst;
; 1545 :         pointer& _Mylast  = _My_data._Mylast;
; 1546 : 
; 1547 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

  00024	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00026	c1 f9 05	 sar	 ecx, 5
  00029	89 4d f4	 mov	 DWORD PTR __Oldsize$1$[ebp], ecx

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0002f	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00031	c1 f9 05	 sar	 ecx, 5

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00034	8b d1		 mov	 edx, ecx
  00036	d1 ea		 shr	 edx, 1
  00038	2b c2		 sub	 eax, edx
  0003a	56		 push	 esi
  0003b	3b c8		 cmp	 ecx, eax
  0003d	76 19		 jbe	 SHORT $LN6@Resize_rea

; 1997 :             return _Max; // geometric growth would overflow

  0003f	be e0 ff ff ff	 mov	 esi, -32		; ffffffe0H
  00044	c7 45 f8 e0 ff
	ff ff		 mov	 DWORD PTR $T2[ebp], -32	; ffffffe0H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00051	8b f0		 mov	 esi, eax
  00053	89 75 fc	 mov	 DWORD PTR $T3[ebp], esi
  00056	eb 46		 jmp	 SHORT $LN196@Resize_rea
$LN6@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00058	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  0005b	3b f3		 cmp	 esi, ebx
  0005d	73 11		 jae	 SHORT $LN7@Resize_rea

; 2003 :             return _Newsize; // geometric growth would be insufficient

  0005f	8b f3		 mov	 esi, ebx
$LN17@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  00061	c1 e6 05	 shl	 esi, 5
  00064	89 75 f8	 mov	 DWORD PTR $T2[ebp], esi

; 227  :     if (_Bytes == 0) {

  00067	85 f6		 test	 esi, esi
  00069	75 13		 jne	 SHORT $LN21@Resize_rea

; 228  :         return nullptr;

  0006b	89 75 fc	 mov	 DWORD PTR $T3[ebp], esi
  0006e	eb 31		 jmp	 SHORT $LN20@Resize_rea
$LN7@Resize_rea:

; 117  :         if (_Count > _Max_possible) {

  00070	81 fe ff ff ff
	07		 cmp	 esi, 134217727		; 07ffffffH
  00076	0f 87 2c 01 00
	00		 ja	 $LN199@Resize_rea
  0007c	eb e3		 jmp	 SHORT $LN17@Resize_rea
$LN21@Resize_rea:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0007e	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  00084	72 0d		 jb	 SHORT $LN22@Resize_rea

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00086	56		 push	 esi
  00087	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008c	8b f0		 mov	 esi, eax
  0008e	89 75 fc	 mov	 DWORD PTR $T3[ebp], esi
  00091	eb 0b		 jmp	 SHORT $LN196@Resize_rea
$LN22@Resize_rea:

; 136  :         return ::operator new(_Bytes);

  00093	56		 push	 esi
  00094	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 256  :         return _Traits::_Allocate(_Bytes);

  00099	8b f0		 mov	 esi, eax
  0009b	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
$LN196@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  0009e	83 c4 04	 add	 esp, 4
$LN20@Resize_rea:
  000a1	8b 4d f4	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]

; 1560 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

  000a4	8b c3		 mov	 eax, ebx
  000a6	2b 45 f4	 sub	 eax, DWORD PTR __Oldsize$1$[ebp]
  000a9	c1 e1 05	 shl	 ecx, 5
  000ac	57		 push	 edi
  000ad	03 ce		 add	 ecx, esi
  000af	50		 push	 eax
  000b0	51		 push	 ecx
  000b1	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@YAPAUSEffectFrameData@CEffectMesh@@PAU12@IAAV?$allocator@USEffectFrameData@CEffectMesh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMesh::SEffectFrameData> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

  000b6	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1560 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bc	8b 07		 mov	 eax, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

  000be	89 4d f0	 mov	 DWORD PTR __ULast$1$[ebp], ecx

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  000c1	3b c1		 cmp	 eax, ecx
  000c3	74 63		 je	 SHORT $LN30@Resize_rea
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000c5	8b f8		 mov	 edi, eax
  000c7	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
  000ca	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  000cd	0f 1f 00	 npad	 3
$LL31@Resize_rea:
  000d0	8a 07		 mov	 al, BYTE PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  000d2	8d 5b 20	 lea	 ebx, DWORD PTR [ebx+32]
  000d5	88 43 c4	 mov	 BYTE PTR [ebx-60], al

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  000d8	8d 76 20	 lea	 esi, DWORD PTR [esi+32]
  000db	8b 46 cc	 mov	 eax, DWORD PTR [esi-52]
  000de	83 c7 20	 add	 edi, 32			; 00000020H
  000e1	89 43 c8	 mov	 DWORD PTR [ebx-56], eax
  000e4	8b 46 d0	 mov	 eax, DWORD PTR [esi-48]
  000e7	89 43 cc	 mov	 DWORD PTR [ebx-52], eax
  000ea	8b 46 d4	 mov	 eax, DWORD PTR [esi-44]
  000ed	89 43 d0	 mov	 DWORD PTR [ebx-48], eax
  000f0	8b 46 d8	 mov	 eax, DWORD PTR [esi-40]
  000f3	89 43 d4	 mov	 DWORD PTR [ebx-44], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000f6	8b 56 e4	 mov	 edx, DWORD PTR [esi-28]
  000f9	8b 4e e0	 mov	 ecx, DWORD PTR [esi-32]
  000fc	8b 46 dc	 mov	 eax, DWORD PTR [esi-36]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

  000ff	c7 46 e4 00 00
	00 00		 mov	 DWORD PTR [esi-28], 0
  00106	c7 46 e0 00 00
	00 00		 mov	 DWORD PTR [esi-32], 0
  0010d	c7 46 dc 00 00
	00 00		 mov	 DWORD PTR [esi-36], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00114	89 43 d8	 mov	 DWORD PTR [ebx-40], eax
  00117	89 4b dc	 mov	 DWORD PTR [ebx-36], ecx
  0011a	89 53 e0	 mov	 DWORD PTR [ebx-32], edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  0011d	3b 7d f0	 cmp	 edi, DWORD PTR __ULast$1$[ebp]
  00120	75 ae		 jne	 SHORT $LL31@Resize_rea
  00122	8b 7d ec	 mov	 edi, DWORD PTR _this$1$[ebp]
  00125	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
$LN30@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00128	8b 37		 mov	 esi, DWORD PTR [edi]
  0012a	85 f6		 test	 esi, esi
  0012c	74 52		 je	 SHORT $LN110@Resize_rea

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0012e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00131	89 45 ec	 mov	 DWORD PTR __Last$1$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00134	3b f0		 cmp	 esi, eax
  00136	74 1a		 je	 SHORT $LN90@Resize_rea
  00138	8b d8		 mov	 ebx, eax
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL91@Resize_rea:
  00140	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00143	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  00148	83 c6 20	 add	 esi, 32			; 00000020H
  0014b	3b f3		 cmp	 esi, ebx
  0014d	75 f1		 jne	 SHORT $LL91@Resize_rea
  0014f	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
$LN90@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00152	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00155	8b 07		 mov	 eax, DWORD PTR [edi]
  00157	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00159	83 e1 e0	 and	 ecx, -32		; ffffffe0H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0015c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00162	72 12		 jb	 SHORT $LN121@Resize_rea

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00164	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00167	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0016a	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0016c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0016f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00172	77 2a		 ja	 SHORT $LN118@Resize_rea

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00174	8b c2		 mov	 eax, edx
$LN121@Resize_rea:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00176	51		 push	 ecx
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0017d	83 c4 08	 add	 esp, 8
$LN110@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2060 :         _Myfirst = _Newvec;

  00180	8b 4d fc	 mov	 ecx, DWORD PTR $T3[ebp]

; 2061 :         _Mylast  = _Newvec + _Newsize;
; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00183	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00186	c1 e3 05	 shl	 ebx, 5
  00189	03 d9		 add	 ebx, ecx
  0018b	89 0f		 mov	 DWORD PTR [edi], ecx
  0018d	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  00190	03 c1		 add	 eax, ecx
  00192	5e		 pop	 esi
  00193	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1571 :     }

  00196	5f		 pop	 edi
  00197	5b		 pop	 ebx
  00198	8b e5		 mov	 esp, ebp
  0019a	5d		 pop	 ebp
  0019b	c2 08 00	 ret	 8
$LN118@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0019e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN198@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1539 :             _Xlength();

  001a3	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@CAXXZ ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Xlength
$LN199@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  001a8	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN195@Resize_rea:
  001ad	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv652 = -8						; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 09 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004a	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv652[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00069	0f 87 c7 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00076	89 45 f8	 mov	 DWORD PTR tv652[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a1	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv650[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	3b d8		 cmp	 ebx, eax
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>
  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00116	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00118	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR tv652[ebp]
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAPAUSMeshData@CEffectMeshScript@@PAU12@IAAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAPAUSMeshData@CEffectMeshScript@@PAU12@IAAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMeshScript::SMeshData> >, COMDAT

; 2041 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2056 :     for (; 0 < _Count; --_Count) {

  00003	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00006	56		 push	 esi

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 2056 :     for (; 0 < _Count; --_Count) {

  0000a	85 d2		 test	 edx, edx
  0000c	74 2f		 je	 SHORT $LN3@Uninitiali
  0000e	8b ca		 mov	 ecx, edx
  00010	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  00013	c1 e1 04	 shl	 ecx, 4
  00016	2b ca		 sub	 ecx, edx
  00018	8d 34 8e	 lea	 esi, DWORD PTR [esi+ecx*4]
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@Uninitiali:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00020	c7 40 f8 00 00
	00 00		 mov	 DWORD PTR [eax-8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  00027	8d 40 3c	 lea	 eax, DWORD PTR [eax+60]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002a	c7 40 c0 00 00
	00 00		 mov	 DWORD PTR [eax-64], 0
  00031	c7 40 c4 00 00
	00 00		 mov	 DWORD PTR [eax-60], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  00038	83 ea 01	 sub	 edx, 1
  0003b	75 e3		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  0003d	ff 75 10	 push	 DWORD PTR __Al$[ebp]
  00040	56		 push	 esi
  00041	56		 push	 esi
  00042	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2057 :         _Backout._Emplace_back();
; 2058 :     }
; 2059 : 
; 2060 :     return _Backout._Release();

  0004a	8b c6		 mov	 eax, esi
  0004c	5e		 pop	 esi

; 2061 : }

  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAPAUSMeshData@CEffectMeshScript@@PAU12@IAAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMeshScript::SMeshData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
__ULast$1$ = -20					; size = 4
tv1528 = -12						; size = 4
__Oldsize$1$ = -8					; size = 4
__Backout$1$sroa$234$1$ = -8				; size = 4
$T2 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1537 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx

; 1538 :         if (_Newsize > max_size()) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	89 7d e8	 mov	 DWORD PTR _this$1$[ebp], edi
  00010	81 fb 44 44 44
	04		 cmp	 ebx, 71582788		; 04444444H
  00016	0f 87 f6 01 00
	00		 ja	 $LN133@Resize_rea

; 1540 :         }
; 1541 : 
; 1542 :         auto& _Al         = _Getal();
; 1543 :         auto& _My_data    = _Mypair._Myval2;
; 1544 :         pointer& _Myfirst = _My_data._Myfirst;
; 1545 :         pointer& _Mylast  = _My_data._Mylast;
; 1546 : 
; 1547 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

  0001c	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0001f	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00024	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00026	f7 e9		 imul	 ecx
  00028	56		 push	 esi
  00029	03 d1		 add	 edx, ecx

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0002e	2b 0f		 sub	 ecx, DWORD PTR [edi]

; 1540 :         }
; 1541 : 
; 1542 :         auto& _Al         = _Getal();
; 1543 :         auto& _My_data    = _Mypair._Myval2;
; 1544 :         pointer& _Myfirst = _My_data._Myfirst;
; 1545 :         pointer& _Mylast  = _My_data._Mylast;
; 1546 : 
; 1547 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

  00030	c1 fa 05	 sar	 edx, 5
  00033	8b c2		 mov	 eax, edx
  00035	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00038	03 c2		 add	 eax, edx
  0003a	89 45 f8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0003d	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00042	f7 e9		 imul	 ecx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00044	b8 44 44 44 04	 mov	 eax, 71582788		; 04444444H

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00049	03 d1		 add	 edx, ecx
  0004b	c1 fa 05	 sar	 edx, 5
  0004e	8b ca		 mov	 ecx, edx
  00050	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00053	03 ca		 add	 ecx, edx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00055	8b d1		 mov	 edx, ecx
  00057	d1 ea		 shr	 edx, 1
  00059	2b c2		 sub	 eax, edx
  0005b	3b c8		 cmp	 ecx, eax
  0005d	76 19		 jbe	 SHORT $LN6@Resize_rea

; 1997 :             return _Max; // geometric growth would overflow

  0005f	bb f0 ff ff ff	 mov	 ebx, -16		; fffffff0H
  00064	c7 45 f4 f0 ff
	ff ff		 mov	 DWORD PTR tv1528[ebp], -16 ; fffffff0H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0006b	53		 push	 ebx
  0006c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00071	8b d8		 mov	 ebx, eax
  00073	89 5d fc	 mov	 DWORD PTR $T2[ebp], ebx
  00076	eb 4c		 jmp	 SHORT $LN131@Resize_rea
$LN6@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00078	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  0007b	3b c3		 cmp	 eax, ebx
  0007d	73 18		 jae	 SHORT $LN7@Resize_rea

; 2003 :             return _Newsize; // geometric growth would be insufficient

  0007f	8b c3		 mov	 eax, ebx
$LN17@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  00081	8b d8		 mov	 ebx, eax
  00083	c1 e3 04	 shl	 ebx, 4
  00086	2b d8		 sub	 ebx, eax
  00088	c1 e3 02	 shl	 ebx, 2
  0008b	89 5d f4	 mov	 DWORD PTR tv1528[ebp], ebx

; 227  :     if (_Bytes == 0) {

  0008e	85 db		 test	 ebx, ebx
  00090	75 12		 jne	 SHORT $LN21@Resize_rea

; 228  :         return nullptr;

  00092	89 5d fc	 mov	 DWORD PTR $T2[ebp], ebx
  00095	eb 30		 jmp	 SHORT $LN20@Resize_rea
$LN7@Resize_rea:

; 117  :         if (_Count > _Max_possible) {

  00097	3d 44 44 44 04	 cmp	 eax, 71582788		; 04444444H
  0009c	0f 87 75 01 00
	00		 ja	 $LN134@Resize_rea
  000a2	eb dd		 jmp	 SHORT $LN17@Resize_rea
$LN21@Resize_rea:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000a4	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  000aa	72 0d		 jb	 SHORT $LN22@Resize_rea

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000ac	53		 push	 ebx
  000ad	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000b2	8b d8		 mov	 ebx, eax
  000b4	89 5d fc	 mov	 DWORD PTR $T2[ebp], ebx
  000b7	eb 0b		 jmp	 SHORT $LN131@Resize_rea
$LN22@Resize_rea:

; 136  :         return ::operator new(_Bytes);

  000b9	53		 push	 ebx
  000ba	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 256  :         return _Traits::_Allocate(_Bytes);

  000bf	8b d8		 mov	 ebx, eax
  000c1	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
$LN131@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000c4	83 c4 04	 add	 esp, 4
$LN20@Resize_rea:
  000c7	8b 55 f8	 mov	 edx, DWORD PTR __Oldsize$1$[ebp]
  000ca	8b c2		 mov	 eax, edx
  000cc	c1 e0 04	 shl	 eax, 4
  000cf	2b c2		 sub	 eax, edx

; 1560 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

  000d1	57		 push	 edi
  000d2	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]
  000d5	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000d8	2b c2		 sub	 eax, edx
  000da	50		 push	 eax
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAPAUSMeshData@CEffectMeshScript@@PAU12@IAAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMeshScript::SMeshData> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

  000e1	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1560 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e7	8b 07		 mov	 eax, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000e9	8b cb		 mov	 ecx, ebx

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

  000eb	89 55 ec	 mov	 DWORD PTR __ULast$1$[ebp], edx

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000ee	89 4d f8	 mov	 DWORD PTR __Backout$1$sroa$234$1$[ebp], ecx

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  000f1	3b c2		 cmp	 eax, edx
  000f3	0f 84 8c 00 00
	00		 je	 $LN30@Resize_rea
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000f9	8b f8		 mov	 edi, eax
  000fb	83 c3 38	 add	 ebx, 56			; 00000038H
  000fe	8d 77 34	 lea	 esi, DWORD PTR [edi+52]
$LL31@Resize_rea:
  00101	0f b6 07	 movzx	 eax, BYTE PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  00104	8d 5b 3c	 lea	 ebx, DWORD PTR [ebx+60]
  00107	88 01		 mov	 BYTE PTR [ecx], al

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  00109	8d 76 3c	 lea	 esi, DWORD PTR [esi+60]
  0010c	8b 46 94	 mov	 eax, DWORD PTR [esi-108]
  0010f	83 c7 3c	 add	 edi, 60			; 0000003cH
  00112	89 43 90	 mov	 DWORD PTR [ebx-112], eax
  00115	0f b6 46 98	 movzx	 eax, BYTE PTR [esi-104]
  00119	88 43 94	 mov	 BYTE PTR [ebx-108], al
  0011c	0f b6 46 99	 movzx	 eax, BYTE PTR [esi-103]
  00120	88 43 95	 mov	 BYTE PTR [ebx-107], al
  00123	8b 46 9c	 mov	 eax, DWORD PTR [esi-100]
  00126	89 43 98	 mov	 DWORD PTR [ebx-104], eax
  00129	0f b6 46 a0	 movzx	 eax, BYTE PTR [esi-96]
  0012d	88 43 9c	 mov	 BYTE PTR [ebx-100], al
  00130	0f 10 46 a4	 movups	 xmm0, XMMWORD PTR [esi-92]
  00134	0f 11 43 a0	 movups	 XMMWORD PTR [ebx-96], xmm0
  00138	8b 46 b4	 mov	 eax, DWORD PTR [esi-76]
  0013b	89 43 b0	 mov	 DWORD PTR [ebx-80], eax
  0013e	8b 46 b8	 mov	 eax, DWORD PTR [esi-72]
  00141	89 43 b4	 mov	 DWORD PTR [ebx-76], eax
  00144	8b 46 bc	 mov	 eax, DWORD PTR [esi-68]
  00147	89 43 b8	 mov	 DWORD PTR [ebx-72], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0014a	8b 4e c4	 mov	 ecx, DWORD PTR [esi-60]
  0014d	8b 56 c8	 mov	 edx, DWORD PTR [esi-56]
  00150	8b 46 c0	 mov	 eax, DWORD PTR [esi-64]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

  00153	c7 46 c8 00 00
	00 00		 mov	 DWORD PTR [esi-56], 0
  0015a	c7 46 c4 00 00
	00 00		 mov	 DWORD PTR [esi-60], 0
  00161	c7 46 c0 00 00
	00 00		 mov	 DWORD PTR [esi-64], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00168	89 4b c0	 mov	 DWORD PTR [ebx-64], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  0016b	8b 4d f8	 mov	 ecx, DWORD PTR __Backout$1$sroa$234$1$[ebp]
  0016e	83 c1 3c	 add	 ecx, 60			; 0000003cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00171	89 43 bc	 mov	 DWORD PTR [ebx-68], eax
  00174	89 53 c4	 mov	 DWORD PTR [ebx-60], edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  00177	89 4d f8	 mov	 DWORD PTR __Backout$1$sroa$234$1$[ebp], ecx

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  0017a	3b 7d ec	 cmp	 edi, DWORD PTR __ULast$1$[ebp]
  0017d	75 82		 jne	 SHORT $LL31@Resize_rea
  0017f	8b 7d e8	 mov	 edi, DWORD PTR _this$1$[ebp]
  00182	8b 5d fc	 mov	 ebx, DWORD PTR $T2[ebp]
$LN30@Resize_rea:

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  00185	57		 push	 edi
  00186	51		 push	 ecx
  00187	51		 push	 ecx
  00188	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  0018d	8b 0f		 mov	 ecx, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  0018f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00192	85 c9		 test	 ecx, ecx
  00194	74 55		 je	 SHORT $LN76@Resize_rea

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  00196	57		 push	 edi
  00197	ff 77 04	 push	 DWORD PTR [edi+4]
  0019a	51		 push	 ecx
  0019b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  001a0	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  001a3	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  001a8	8b 37		 mov	 esi, DWORD PTR [edi]
  001aa	83 c4 0c	 add	 esp, 12			; 0000000cH
  001ad	2b ce		 sub	 ecx, esi
  001af	f7 e9		 imul	 ecx
  001b1	03 d1		 add	 edx, ecx
  001b3	c1 fa 05	 sar	 edx, 5
  001b6	8b c2		 mov	 eax, edx
  001b8	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001bb	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001bd	8b c8		 mov	 ecx, eax
  001bf	c1 e1 04	 shl	 ecx, 4
  001c2	2b c8		 sub	 ecx, eax
  001c4	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001c7	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001cd	72 12		 jb	 SHORT $LN87@Resize_rea

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001cf	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  001d2	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001d5	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001d7	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  001da	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001dd	77 2e		 ja	 SHORT $LN84@Resize_rea

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001df	8b f2		 mov	 esi, edx
$LN87@Resize_rea:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001e1	51		 push	 ecx
  001e2	56		 push	 esi
  001e3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001e8	83 c4 08	 add	 esp, 8
$LN76@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  001eb	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  001ee	c1 e0 04	 shl	 eax, 4
  001f1	2b 45 08	 sub	 eax, DWORD PTR __Newsize$[ebp]
  001f4	89 1f		 mov	 DWORD PTR [edi], ebx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  001f6	5e		 pop	 esi
  001f7	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  001fa	89 47 04	 mov	 DWORD PTR [edi+4], eax
  001fd	8b 45 f4	 mov	 eax, DWORD PTR tv1528[ebp]
  00200	03 c3		 add	 eax, ebx
  00202	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1571 :     }

  00205	5f		 pop	 edi
  00206	5b		 pop	 ebx
  00207	8b e5		 mov	 esp, ebp
  00209	5d		 pop	 ebp
  0020a	c2 08 00	 ret	 8
$LN84@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0020d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN133@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1539 :             _Xlength();

  00212	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@CAXXZ ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Xlength
$LN134@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00217	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN130@Resize_rea:
  0021c	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
tv480 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1537 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1538 :         if (_Newsize > max_size()) {

  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	81 fb 55 55 55
	15		 cmp	 ebx, 357913941		; 15555555H
  00012	0f 87 f2 00 00
	00		 ja	 $LN116@Resize_rea

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00018	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001b	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00020	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00022	f7 e9		 imul	 ecx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00024	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00029	d1 fa		 sar	 edx, 1
  0002b	8b ca		 mov	 ecx, edx
  0002d	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00030	03 ca		 add	 ecx, edx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00032	8b d1		 mov	 edx, ecx
  00034	d1 ea		 shr	 edx, 1
  00036	2b c2		 sub	 eax, edx
  00038	3b c8		 cmp	 ecx, eax
  0003a	76 14		 jbe	 SHORT $LN6@Resize_rea

; 1997 :             return _Max; // geometric growth would overflow

  0003c	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00041	c7 45 fc fc ff
	ff ff		 mov	 DWORD PTR tv480[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0004e	eb 3e		 jmp	 SHORT $LN114@Resize_rea
$LN6@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00050	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00053	3b c3		 cmp	 eax, ebx
  00055	73 15		 jae	 SHORT $LN7@Resize_rea

; 2003 :             return _Newsize; // geometric growth would be insufficient

  00057	8b c3		 mov	 eax, ebx
$LN17@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  00059	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  0005c	c1 e6 02	 shl	 esi, 2

; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005f	8b c6		 mov	 eax, esi

; 122  :     return _Count * _Ty_size;

  00061	89 75 fc	 mov	 DWORD PTR tv480[ebp], esi

; 227  :     if (_Bytes == 0) {

  00064	85 c0		 test	 eax, eax
  00066	75 11		 jne	 SHORT $LN21@Resize_rea

; 228  :         return nullptr;

  00068	33 db		 xor	 ebx, ebx
  0006a	eb 27		 jmp	 SHORT $LN31@Resize_rea
$LN7@Resize_rea:

; 117  :         if (_Count > _Max_possible) {

  0006c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00071	0f 87 98 00 00
	00		 ja	 $LN117@Resize_rea
  00077	eb e0		 jmp	 SHORT $LN17@Resize_rea
$LN21@Resize_rea:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00079	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007e	72 08		 jb	 SHORT $LN22@Resize_rea

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00086	eb 06		 jmp	 SHORT $LN114@Resize_rea
$LN22@Resize_rea:

; 136  :         return ::operator new(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN114@Resize_rea:

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  0008e	8b d8		 mov	 ebx, eax
  00090	83 c4 04	 add	 esp, 4
$LN31@Resize_rea:
  00093	53		 push	 ebx
  00094	ff 77 04	 push	 DWORD PTR [edi+4]
  00097	ff 37		 push	 DWORD PTR [edi]
  00099	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  0009e	8b 37		 mov	 esi, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000a3	85 f6		 test	 esi, esi
  000a5	74 3f		 je	 SHORT $LN61@Resize_rea

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000a7	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000aa	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000af	2b ce		 sub	 ecx, esi
  000b1	f7 e9		 imul	 ecx
  000b3	d1 fa		 sar	 edx, 1
  000b5	8b c2		 mov	 eax, edx
  000b7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ba	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bc	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  000bf	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000c2	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000c8	72 12		 jb	 SHORT $LN72@Resize_rea

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ca	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000cd	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000d0	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000d2	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  000d5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000d8	77 2b		 ja	 SHORT $LN69@Resize_rea

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000da	8b f2		 mov	 esi, edx
$LN72@Resize_rea:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000dc	51		 push	 ecx
  000dd	56		 push	 esi
  000de	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000e3	83 c4 08	 add	 esp, 8
$LN61@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  000e6	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000e9	89 1f		 mov	 DWORD PTR [edi], ebx
  000eb	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000ee	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  000f1	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  000f4	8b 45 fc	 mov	 eax, DWORD PTR tv480[ebp]
  000f7	03 c3		 add	 eax, ebx
  000f9	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1571 :     }

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 08 00	 ret	 8
$LN69@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00105	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN116@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1539 :             _Xlength();

  0010a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
$LN117@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0010f	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN113@Resize_rea:
  00114	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1098 :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 53		 je	 SHORT $LN52@Destroy_ra
  0000f	83 c6 38	 add	 esi, 56			; 00000038H
$LL4@Destroy_ra:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00012	8b 46 f8	 mov	 eax, DWORD PTR [esi-8]
  00015	85 c0		 test	 eax, eax
  00017	74 3f		 je	 SHORT $LN22@Destroy_ra

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00019	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001d	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00020	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00026	72 12		 jb	 SHORT $LN41@Destroy_ra

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00028	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00030	83 c0 fc	 add	 eax, -4			; fffffffcH
  00033	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00036	77 2e		 ja	 SHORT $LN38@Destroy_ra

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00038	8b c2		 mov	 eax, edx
$LN41@Destroy_ra:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0003a	51		 push	 ecx
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00041	c7 46 f8 00 00
	00 00		 mov	 DWORD PTR [esi-8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00048	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0004b	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0

; 2082 :             _Myend   = nullptr;

  00052	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN22@Destroy_ra:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00058	83 c6 3c	 add	 esi, 60			; 0000003cH
  0005b	8d 46 c8	 lea	 eax, DWORD PTR [esi-56]
  0005e	3b c7		 cmp	 eax, edi
  00060	75 b0		 jne	 SHORT $LL4@Destroy_ra
$LN52@Destroy_ra:
  00062	5f		 pop	 edi

; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1100 :         }
; 1101 :     }
; 1102 : }

  00063	5e		 pop	 esi
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
$LN38@Destroy_ra:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00066	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN59@Destroy_ra:
  0006b	cc		 int	 3
??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
tv674 = -4						; size = 4
__Newsize$ = 8						; size = 4
$T2 = 8							; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1574 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1575 :         // trim or append elements, provide strong guarantee
; 1576 :         auto& _Al           = _Getal();
; 1577 :         auto& _My_data      = _Mypair._Myval2;
; 1578 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1579 :         pointer& _Mylast    = _My_data._Mylast;
; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1581 :         if (_Newsize < _Oldsize) { // trim

  00006	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  0000f	8b d8		 mov	 ebx, eax
  00011	8b 17		 mov	 edx, DWORD PTR [edi]
  00013	2b da		 sub	 ebx, edx
  00015	c1 fb 02	 sar	 ebx, 2
  00018	3b f3		 cmp	 esi, ebx
  0001a	73 0f		 jae	 SHORT $LN2@Resize

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  0001c	8d 04 b2	 lea	 eax, DWORD PTR [edx+esi*4]

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1585 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1586 :             _Mylast = _Newlast;

  0001f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00022	5f		 pop	 edi

; 1610 :     }

  00023	5e		 pop	 esi
  00024	5b		 pop	 ebx
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN2@Resize:

; 1587 :             return;
; 1588 :         }
; 1589 : 
; 1590 :         if (_Newsize > _Oldsize) { // append

  0002b	0f 86 fb 00 00
	00		 jbe	 $LN3@Resize

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00031	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00034	2b ca		 sub	 ecx, edx
  00036	c1 f9 02	 sar	 ecx, 2

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  00039	3b f1		 cmp	 esi, ecx
  0003b	0f 86 d9 00 00
	00		 jbe	 $LN4@Resize

; 1538 :         if (_Newsize > max_size()) {

  00041	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  00047	0f 87 e8 00 00
	00		 ja	 $LN135@Resize

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004d	8b d1		 mov	 edx, ecx
  0004f	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00054	d1 ea		 shr	 edx, 1
  00056	2b c2		 sub	 eax, edx
  00058	3b c8		 cmp	 ecx, eax
  0005a	76 14		 jbe	 SHORT $LN11@Resize

; 1997 :             return _Max; // geometric growth would overflow

  0005c	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00061	c7 45 fc fc ff
	ff ff		 mov	 DWORD PTR tv674[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006e	eb 37		 jmp	 SHORT $LN133@Resize
$LN11@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00070	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00073	3b c6		 cmp	 eax, esi
  00075	73 0e		 jae	 SHORT $LN12@Resize

; 2003 :             return _Newsize; // geometric growth would be insufficient

  00077	8b c6		 mov	 eax, esi
$LN22@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  00079	c1 e0 02	 shl	 eax, 2
  0007c	89 45 fc	 mov	 DWORD PTR tv674[ebp], eax

; 227  :     if (_Bytes == 0) {

  0007f	85 c0		 test	 eax, eax
  00081	75 0f		 jne	 SHORT $LN26@Resize

; 228  :         return nullptr;

  00083	eb 25		 jmp	 SHORT $LN132@Resize
$LN12@Resize:

; 117  :         if (_Count > _Max_possible) {

  00085	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0008a	0f 87 aa 00 00
	00		 ja	 $LN136@Resize
  00090	eb e7		 jmp	 SHORT $LN22@Resize
$LN26@Resize:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00092	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00097	72 08		 jb	 SHORT $LN27@Resize

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009f	eb 06		 jmp	 SHORT $LN133@Resize
$LN27@Resize:

; 136  :         return ::operator new(_Bytes);

  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN133@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000a7	83 c4 04	 add	 esp, 4
$LN132@Resize:
  000aa	8d 0c 98	 lea	 ecx, DWORD PTR [eax+ebx*4]
  000ad	89 45 08	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  000b0	8b c6		 mov	 eax, esi
  000b2	2b c3		 sub	 eax, ebx
  000b4	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b7	50		 push	 eax
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 ??$_Zero_range@PAH@std@@YAPAHQAH0@Z ; std::_Zero_range<int *>

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000be	8b 5d 08	 mov	 ebx, DWORD PTR $T2[ebp]
  000c1	53		 push	 ebx
  000c2	ff 77 04	 push	 DWORD PTR [edi+4]
  000c5	ff 37		 push	 DWORD PTR [edi]
  000c7	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000cc	8b 07		 mov	 eax, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000ce	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d1	85 c0		 test	 eax, eax
  000d3	74 2c		 je	 SHORT $LN66@Resize

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000d5	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000d8	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000da	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000dd	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000e3	72 12		 jb	 SHORT $LN77@Resize

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000e5	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000e8	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000eb	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ed	83 c0 fc	 add	 eax, -4			; fffffffcH
  000f0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f3	77 4a		 ja	 SHORT $LN74@Resize

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000f5	8b c2		 mov	 eax, edx
$LN77@Resize:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000f7	51		 push	 ecx
  000f8	50		 push	 eax
  000f9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000fe	83 c4 08	 add	 esp, 8
$LN66@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00101	8d 04 b3	 lea	 eax, DWORD PTR [ebx+esi*4]
  00104	89 1f		 mov	 DWORD PTR [edi], ebx
  00106	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00109	8b 45 fc	 mov	 eax, DWORD PTR tv674[ebp]
  0010c	03 c3		 add	 eax, ebx
  0010e	89 47 08	 mov	 DWORD PTR [edi+8], eax
  00111	5f		 pop	 edi

; 1610 :     }

  00112	5e		 pop	 esi
  00113	5b		 pop	 ebx
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c2 08 00	 ret	 8
$LN4@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  0011a	2b f3		 sub	 esi, ebx
  0011c	8d 34 b0	 lea	 esi, DWORD PTR [eax+esi*4]
  0011f	56		 push	 esi
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ??$_Zero_range@PAH@std@@YAPAHQAH0@Z ; std::_Zero_range<int *>
  00126	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00129	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN3@Resize:

; 1610 :     }

  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx
  0012f	8b e5		 mov	 esp, ebp
  00131	5d		 pop	 ebp
  00132	c2 08 00	 ret	 8
$LN135@Resize:

; 1539 :             _Xlength();

  00135	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN136@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0013a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN74@Resize:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0013f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN131@Resize:
  00144	cc		 int	 3
??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
tv661 = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1574 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 1575 :         // trim or append elements, provide strong guarantee
; 1576 :         auto& _Al           = _Getal();
; 1577 :         auto& _My_data      = _Mypair._Myval2;
; 1578 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1579 :         pointer& _Mylast    = _My_data._Mylast;
; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1581 :         if (_Newsize < _Oldsize) { // trim

  00005	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0000e	8b c2		 mov	 eax, edx
  00010	8b 1f		 mov	 ebx, DWORD PTR [edi]
  00012	2b c3		 sub	 eax, ebx
  00014	c1 f8 03	 sar	 eax, 3
  00017	3b f0		 cmp	 esi, eax
  00019	73 0d		 jae	 SHORT $LN2@Resize

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  0001b	8d 04 f3	 lea	 eax, DWORD PTR [ebx+esi*8]

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1585 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1586 :             _Mylast = _Newlast;

  0001e	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00021	5f		 pop	 edi

; 1610 :     }

  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	5d		 pop	 ebp
  00025	c2 08 00	 ret	 8
$LN2@Resize:

; 1587 :             return;
; 1588 :         }
; 1589 : 
; 1590 :         if (_Newsize > _Oldsize) { // append

  00028	0f 86 de 00 00
	00		 jbe	 $LN3@Resize

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0002e	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00031	2b cb		 sub	 ecx, ebx
  00033	c1 f9 03	 sar	 ecx, 3

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  00036	3b f1		 cmp	 esi, ecx
  00038	0f 86 c4 00 00
	00		 jbe	 $LN4@Resize

; 1538 :         if (_Newsize > max_size()) {

  0003e	81 fe ff ff ff
	1f		 cmp	 esi, 536870911		; 1fffffffH
  00044	0f 87 c9 00 00
	00		 ja	 $LN141@Resize

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004a	8b d1		 mov	 edx, ecx
  0004c	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH
  00051	d1 ea		 shr	 edx, 1
  00053	2b c2		 sub	 eax, edx
  00055	3b c8		 cmp	 ecx, eax
  00057	76 14		 jbe	 SHORT $LN11@Resize

; 1997 :             return _Max; // geometric growth would overflow

  00059	b8 f8 ff ff ff	 mov	 eax, -8			; fffffff8H
  0005e	c7 45 08 f8 ff
	ff ff		 mov	 DWORD PTR tv661[ebp], -8 ; fffffff8H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006b	eb 39		 jmp	 SHORT $LN139@Resize
$LN11@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006d	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00070	3b c6		 cmp	 eax, esi
  00072	73 10		 jae	 SHORT $LN12@Resize

; 2003 :             return _Newsize; // geometric growth would be insufficient

  00074	8b c6		 mov	 eax, esi
$LN22@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  00076	c1 e0 03	 shl	 eax, 3
  00079	89 45 08	 mov	 DWORD PTR tv661[ebp], eax

; 227  :     if (_Bytes == 0) {

  0007c	85 c0		 test	 eax, eax
  0007e	75 11		 jne	 SHORT $LN26@Resize

; 228  :         return nullptr;

  00080	33 db		 xor	 ebx, ebx
  00082	eb 27		 jmp	 SHORT $LN36@Resize
$LN12@Resize:

; 117  :         if (_Count > _Max_possible) {

  00084	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00089	0f 87 89 00 00
	00		 ja	 $LN142@Resize
  0008f	eb e5		 jmp	 SHORT $LN22@Resize
$LN26@Resize:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00091	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00096	72 08		 jb	 SHORT $LN27@Resize

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009e	eb 06		 jmp	 SHORT $LN139@Resize
$LN27@Resize:

; 136  :         return ::operator new(_Bytes);

  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN139@Resize:

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000a6	8b d8		 mov	 ebx, eax
  000a8	83 c4 04	 add	 esp, 4
$LN36@Resize:
  000ab	53		 push	 ebx
  000ac	ff 77 04	 push	 DWORD PTR [edi+4]
  000af	ff 37		 push	 DWORD PTR [edi]
  000b1	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUD3DXVECTOR2@@PAU1@@std@@YAPAUD3DXVECTOR2@@PAU1@00@Z ; std::_Copy_memmove<D3DXVECTOR2 *,D3DXVECTOR2 *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000b6	8b 07		 mov	 eax, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000bb	85 c0		 test	 eax, eax
  000bd	74 2c		 je	 SHORT $LN66@Resize

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000bf	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000c2	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c4	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000c7	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000cd	72 12		 jb	 SHORT $LN77@Resize

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000cf	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000d2	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000d5	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000d7	83 c0 fc	 add	 eax, -4			; fffffffcH
  000da	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000dd	77 3e		 ja	 SHORT $LN74@Resize

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000df	8b c2		 mov	 eax, edx
$LN77@Resize:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000e1	51		 push	 ecx
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000e8	83 c4 08	 add	 esp, 8
$LN66@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  000eb	8d 04 f3	 lea	 eax, DWORD PTR [ebx+esi*8]
  000ee	89 1f		 mov	 DWORD PTR [edi], ebx
  000f0	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  000f3	8b 45 08	 mov	 eax, DWORD PTR tv661[ebp]
  000f6	03 c3		 add	 eax, ebx
  000f8	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000fb	5f		 pop	 edi

; 1610 :     }

  000fc	5e		 pop	 esi
  000fd	5b		 pop	 ebx
  000fe	5d		 pop	 ebp
  000ff	c2 08 00	 ret	 8
$LN4@Resize:

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00102	2b f0		 sub	 esi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  00104	74 03		 je	 SHORT $LN109@Resize
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00106	8d 14 f2	 lea	 edx, DWORD PTR [edx+esi*8]
$LN109@Resize:
  00109	89 57 04	 mov	 DWORD PTR [edi+4], edx
$LN3@Resize:
  0010c	5f		 pop	 edi

; 1610 :     }

  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx
  0010f	5d		 pop	 ebp
  00110	c2 08 00	 ret	 8
$LN141@Resize:

; 1539 :             _Xlength();

  00113	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlength
$LN142@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00118	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN74@Resize:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0011d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN138@Resize:
  00122	cc		 int	 3
??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CEffectMeshScript::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A ; CEffectMeshScript::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ ; CDynamicPool<CEffectMeshScript>::~CDynamicPool<CEffectMeshScript>
??__F?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CEffectMeshScript::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??__E?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CEffectMeshScript::ms_kPool'', COMDAT

; 434  : CDynamicPool<CEffectMeshScript> CEffectMeshScript::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CEffectMeshScript::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CEffectMeshScript::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z PROC	; CDynamicPool<CEffectMeshScript>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ ; CDynamicPool<CEffectMeshScript>::~CDynamicPool<CEffectMeshScript>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCEffectMeshScript@@@@UAEPAXI@Z ENDP	; CDynamicPool<CEffectMeshScript>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ PROC	; CDynamicPool<CEffectMeshScript>::~CDynamicPool<CEffectMeshScript>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCEffectMeshScript@@@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN37@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN56@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN56@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 2082 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN37@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN53@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN67@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@VCEffectMeshScript@@@@UAE@XZ ENDP	; CDynamicPool<CEffectMeshScript>::~CDynamicPool<CEffectMeshScript>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@CAXXZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@CAXXZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN5@vector

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00049	5e		 pop	 esi

; 820  :     }

  0004a	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00050	cc		 int	 3
??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN5@vector

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00049	5e		 pop	 esi

; 820  :     }

  0004a	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00050	cc		 int	 3
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	74 53		 je	 SHORT $LN5@vector

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0000d	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00012	2b ce		 sub	 ecx, esi
  00014	f7 e9		 imul	 ecx
  00016	d1 fa		 sar	 edx, 1
  00018	8b c2		 mov	 eax, edx
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001f	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00022	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00025	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002b	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002d	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00030	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00033	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00035	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00038	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0003b	77 23		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003d	8b f2		 mov	 esi, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0003f	51		 push	 ecx
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00046	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0004c	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0004f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 2082 :             _Myend   = nullptr;

  00056	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN5@vector:
  0005d	5f		 pop	 edi

; 820  :     }

  0005e	5e		 pop	 esi
  0005f	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00060	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00065	cc		 int	 3
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CEffectMesh::SEffectMeshData::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A ; CEffectMesh::SEffectMeshData::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ ; CDynamicPool<CEffectMesh::SEffectMeshData>::~CDynamicPool<CEffectMesh::SEffectMeshData>
??__F?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CEffectMesh::SEffectMeshData::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??__E?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CEffectMesh::SEffectMeshData::ms_kPool'', COMDAT

; 7    : CDynamicPool<CEffectMesh::SEffectMeshData> CEffectMesh::SEffectMeshData::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CEffectMesh::SEffectMeshData::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CEffectMesh::SEffectMeshData::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z PROC ; CDynamicPool<CEffectMesh::SEffectMeshData>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ ; CDynamicPool<CEffectMesh::SEffectMeshData>::~CDynamicPool<CEffectMesh::SEffectMeshData>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAEPAXI@Z ENDP ; CDynamicPool<CEffectMesh::SEffectMeshData>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ PROC ; CDynamicPool<CEffectMesh::SEffectMeshData>::~CDynamicPool<CEffectMesh::SEffectMeshData>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN37@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN56@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN56@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 2082 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN37@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN53@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN67@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@UAE@XZ ENDP ; CDynamicPool<CEffectMesh::SEffectMeshData>::~CDynamicPool<CEffectMesh::SEffectMeshData>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCEffectMeshScript@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEffectMeshScript@@UAEPAXI@Z PROC			; CEffectMeshScript::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CEffectMeshScript@@UAE@XZ ; CEffectMeshScript::~CEffectMeshScript
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 44		 push	 68			; 00000044H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCEffectMeshScript@@UAEPAXI@Z ENDP			; CEffectMeshScript::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?Delete@CEffectMeshScript@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
_pkData$ = 8						; size = 4
?Delete@CEffectMeshScript@@SAXPAV1@@Z PROC		; CEffectMeshScript::Delete, COMDAT

; 447  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 448  : 	pkData->Clear();

  00004	8b 75 08	 mov	 esi, DWORD PTR _pkData$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 ?Clear@CEffectElementBase@@QAEXXZ ; CEffectElementBase::Clear
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0000e	a1 14 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 449  : 	ms_kPool.Free(pkData);

  00013	89 75 08	 mov	 DWORD PTR _pkData$[ebp], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00016	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+24
  0001c	74 0c		 je	 SHORT $LN8@Delete

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  0001e	89 30		 mov	 DWORD PTR [eax], esi

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00020	83 05 14 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20, 4
  00027	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 450  : }

  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
$LN8@Delete:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002a	8d 4d 08	 lea	 ecx, DWORD PTR _pkData$[ebp]
  0002d	51		 push	 ecx
  0002e	50		 push	 eax
  0002f	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+16
  00034	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@AAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
  00039	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 450  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?Delete@CEffectMeshScript@@SAXPAV1@@Z ENDP		; CEffectMeshScript::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?New@CEffectMeshScript@@SAPAV1@XZ
_TEXT	SEGMENT
_pkNewData$2 = -16					; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?New@CEffectMeshScript@@SAPAV1@XZ PROC			; CEffectMeshScript::New, COMDAT

; 442  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@CEffectMeshScript@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00024	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20
  0002a	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+16, ecx
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 64   : 			if (m_kVct_pkFree.empty())

  00030	0f 85 84 00 00
	00		 jne	 $LN4@New

; 66   : 				T* pkNewData=new T;

  00036	6a 44		 push	 68			; 00000044H
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	83 c4 04	 add	 esp, 4
  00040	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	85 c0		 test	 eax, eax
  0004c	74 0b		 je	 SHORT $LN6@New
  0004e	8b c8		 mov	 ecx, eax
  00050	e8 00 00 00 00	 call	 ??0CEffectMeshScript@@QAE@XZ ; CEffectMeshScript::CEffectMeshScript
  00055	8b f0		 mov	 esi, eax
  00057	eb 02		 jmp	 SHORT $LN7@New
$LN6@New:
  00059	33 f6		 xor	 esi, esi
$LN7@New:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0005b	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+8
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 66   : 				T* pkNewData=new T;

  00060	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	89 75 f0	 mov	 DWORD PTR _pkNewData$2[ebp], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0006a	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+12
  00070	74 21		 je	 SHORT $LN15@New

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00072	89 30		 mov	 DWORD PTR [eax], esi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 443  : 	return ms_kPool.Alloc();

  00074	8b c6		 mov	 eax, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 854  :         ++_Mylast;

  00076	83 05 08 00 00
	00 04		 add	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+8, 4
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  0007d	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+32
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 444  : }

  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
$LN15@New:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00093	8d 4d f0	 lea	 ecx, DWORD PTR _pkNewData$2[ebp]
  00096	51		 push	 ecx
  00097	50		 push	 eax
  00098	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+4
  0009d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCEffectMeshScript@@@?$vector@PAVCEffectMeshScript@@V?$allocator@PAVCEffectMeshScript@@@std@@@std@@AAEPAPAVCEffectMeshScript@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectMeshScript *,std::allocator<CEffectMeshScript *> >::_Emplace_reallocate<CEffectMeshScript * const &>
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  000a2	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+32
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 443  : 	return ms_kPool.Alloc();

  000a8	8b c6		 mov	 eax, esi

; 444  : }

  000aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b4	59		 pop	 ecx
  000b5	5e		 pop	 esi
  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
$LN4@New:
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 72   : 			T* pkFreeData=m_kVct_pkFree.back();

  000ba	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1744 :         --_Mylast;

  000bd	83 c1 fc	 add	 ecx, -4			; fffffffcH
  000c0	89 0d 14 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20, ecx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 444  : }

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d0	59		 pop	 ecx
  000d1	5e		 pop	 esi
  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@CEffectMeshScript@@SAPAV1@XZ$0:
  00000	6a 44		 push	 68			; 00000044H
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
__ehhandler$?New@CEffectMeshScript@@SAPAV1@XZ:
  00014	90		 npad	 1
  00015	90		 npad	 1
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@CEffectMeshScript@@SAPAV1@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@CEffectMeshScript@@SAPAV1@XZ ENDP			; CEffectMeshScript::New
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?DestroySystem@CEffectMeshScript@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CEffectMeshScript@@SAXXZ PROC		; CEffectMeshScript::DestroySystem, COMDAT

; 437  : {

  00000	56		 push	 esi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  00001	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+4
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 437  : {

  00007	57		 push	 edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  00008	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+8
  0000e	3b f7		 cmp	 esi, edi
  00010	74 29		 je	 SHORT $LN12@DestroySys
$LL6@DestroySys:

; 111  : 			delete pkData;

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	85 c9		 test	 ecx, ecx
  00016	74 06		 je	 SHORT $LN4@DestroySys
  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	6a 01		 push	 1
  0001c	ff 10		 call	 DWORD PTR [eax]
$LN4@DestroySys:

; 50   : 			for (auto v : m_kVct_pkData)

  0001e	83 c6 04	 add	 esi, 4
  00021	3b f7		 cmp	 esi, edi
  00023	75 ed		 jne	 SHORT $LL6@DestroySys
  00025	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+8
  0002b	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	3b f7		 cmp	 esi, edi
  00033	74 06		 je	 SHORT $LN12@DestroySys

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00035	89 35 08 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+8, esi
$LN12@DestroySys:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0003b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+16
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20
  00048	74 05		 je	 SHORT $LN16@DestroySys

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0004a	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CEffectMeshScript@@2V?$CDynamicPool@VCEffectMeshScript@@@@A+20, eax
$LN16@DestroySys:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 439  : }

  0004f	c3		 ret	 0
?DestroySystem@CEffectMeshScript@@SAXXZ ENDP		; CEffectMeshScript::DestroySystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
$T1 = 11						; size = 1
?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z PROC ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::resize, COMDAT
; _this$ = ecx

; 1613 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
  00006	8b f9		 mov	 edi, ecx

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00008	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0000d	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00010	8b f1		 mov	 esi, ecx
  00012	2b 37		 sub	 esi, DWORD PTR [edi]
  00014	f7 ee		 imul	 esi
  00016	03 d6		 add	 edx, esi

; 1581 :         if (_Newsize < _Oldsize) { // trim

  00018	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  0001b	c1 fa 05	 sar	 edx, 5
  0001e	8b da		 mov	 ebx, edx
  00020	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00023	03 da		 add	 ebx, edx
  00025	3b f3		 cmp	 esi, ebx
  00027	73 21		 jae	 SHORT $LN4@resize

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  00029	8b 17		 mov	 edx, DWORD PTR [edi]
  0002b	8b c6		 mov	 eax, esi
  0002d	c1 e0 04	 shl	 eax, 4
  00030	2b c6		 sub	 eax, esi

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);

  00032	57		 push	 edi
  00033	51		 push	 ecx
  00034	8d 34 82	 lea	 esi, DWORD PTR [edx+eax*4]
  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 1614 :         // trim or append value-initialized elements, provide strong guarantee
; 1615 :         _Resize(_Newsize, _Value_init_tag{});
; 1616 :     }

  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1586 :             _Mylast = _Newlast;

  00040	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00043	5f		 pop	 edi

; 1614 :         // trim or append value-initialized elements, provide strong guarantee
; 1615 :         _Resize(_Newsize, _Value_init_tag{});
; 1616 :     }

  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
$LN4@resize:

; 1590 :         if (_Newsize > _Oldsize) { // append

  0004a	76 41		 jbe	 SHORT $LN5@resize

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0004c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0004f	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00054	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00056	f7 e9		 imul	 ecx
  00058	03 d1		 add	 edx, ecx
  0005a	c1 fa 05	 sar	 edx, 5
  0005d	8b c2		 mov	 eax, edx
  0005f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00062	03 c2		 add	 eax, edx

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  00064	3b f0		 cmp	 esi, eax
  00066	76 13		 jbe	 SHORT $LN6@resize

; 1593 :                 _Resize_reallocate(_Newsize, _Val);

  00068	8d 45 0b	 lea	 eax, DWORD PTR $T1[ebp]
  0006b	8b cf		 mov	 ecx, edi
  0006d	50		 push	 eax
  0006e	56		 push	 esi
  0006f	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::_Resize_reallocate<std::_Value_init_tag>
  00074	5f		 pop	 edi

; 1614 :         // trim or append value-initialized elements, provide strong guarantee
; 1615 :         _Resize(_Newsize, _Value_init_tag{});
; 1616 :     }

  00075	5e		 pop	 esi
  00076	5b		 pop	 ebx
  00077	5d		 pop	 ebp
  00078	c2 04 00	 ret	 4
$LN6@resize:

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  0007b	57		 push	 edi
  0007c	2b f3		 sub	 esi, ebx
  0007e	56		 push	 esi
  0007f	ff 77 04	 push	 DWORD PTR [edi+4]
  00082	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAPAUSMeshData@CEffectMeshScript@@PAU12@IAAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMeshScript::SMeshData> >
  00087	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1614 :         // trim or append value-initialized elements, provide strong guarantee
; 1615 :         _Resize(_Newsize, _Value_init_tag{});
; 1616 :     }

  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@resize:
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	5d		 pop	 ebp
  00091	c2 04 00	 ret	 4
?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAE@XZ PROC ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::~vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 6b		 je	 SHORT $LN5@vector
  00009	57		 push	 edi

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000a	56		 push	 esi
  0000b	ff 76 04	 push	 DWORD PTR [esi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0001c	8b 3e		 mov	 edi, DWORD PTR [esi]
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	2b cf		 sub	 ecx, edi
  00023	f7 e9		 imul	 ecx
  00025	03 d1		 add	 edx, ecx
  00027	c1 fa 05	 sar	 edx, 5
  0002a	8b c2		 mov	 eax, edx
  0002c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002f	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00031	8b c8		 mov	 ecx, eax
  00033	c1 e1 04	 shl	 ecx, 4
  00036	2b c8		 sub	 ecx, eax
  00038	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0003b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00041	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00043	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  00046	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00049	2b fa		 sub	 edi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  0004e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00051	77 23		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00053	8b fa		 mov	 edi, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00055	51		 push	 ecx
  00056	57		 push	 edi
  00057	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005c	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0005f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 2081 :             _Mylast  = nullptr;

  00065	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  0006c	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00073	5f		 pop	 edi
$LN5@vector:
  00074	5e		 pop	 esi

; 820  :     }

  00075	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00076	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  0007b	cc		 int	 3
??1?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAE@XZ ENDP ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::~vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z
_TEXT	SEGMENT
_dwMeshElementCount$ = -96				; size = 4
_GotoChild$2 = -92					; size = 4
__Left$1$ = -92						; size = 4
__Result$1$ = -88					; size = 4
__Right_size$1$ = -84					; size = 4
__My_data$2$ = -84					; size = 4
tv2040 = -80						; size = 4
_this$GSCopy$1$ = -80					; size = 4
_i$1$ = -76						; size = 4
__New_size$1$ = -76					; size = 4
_rTextFileLoader$GSCopy$1$ = -72			; size = 4
_rMeshData$1$ = -68					; size = 4
__Ptr$1$ = -68						; size = 4
$T3 = -64						; size = 24
$T4 = -40						; size = 24
$T5 = -40						; size = 24
$T6 = -40						; size = 24
$T7 = -40						; size = 24
$T8 = -40						; size = 24
$T9 = -40						; size = 24
$T10 = -40						; size = 24
$T11 = -40						; size = 24
$T12 = -40						; size = 24
$T13 = -40						; size = 24
$T14 = -40						; size = 24
$T15 = -40						; size = 24
$T16 = -40						; size = 24
$T17 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_rTextFileLoader$ = 8					; size = 4
?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z PROC ; CEffectMeshScript::OnLoadScript, COMDAT
; _this$ = ecx

; 610  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
  0002c	89 7d b0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  0002f	8b 75 08	 mov	 esi, DWORD PTR _rTextFileLoader$[ebp]

; 611  : 	if (rTextFileLoader.GetTokenString("meshfilename", &m_strMeshFileName))

  00032	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_0N@KFLKANCO@meshfilename@
  0003a	89 75 b8	 mov	 DWORD PTR _rTextFileLoader$GSCopy$1$[ebp], esi
  0003d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00042	83 c7 2c	 add	 edi, 44			; 0000002cH
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	57		 push	 edi
  0004d	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  00050	89 7d a8	 mov	 DWORD PTR __Result$1$[ebp], edi
  00053	50		 push	 eax
  00054	8b ce		 mov	 ecx, esi
  00056	e8 00 00 00 00	 call	 ?GetTokenString@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV23@@Z ; CTextFileLoader::GetTokenString
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0005b	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 611  : 	if (rTextFileLoader.GetTokenString("meshfilename", &m_strMeshFileName))

  0005e	8b f0		 mov	 esi, eax
  00060	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00067	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0006a	76 2c		 jbe	 SHORT $LN64@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0006c	8b 55 d8	 mov	 edx, DWORD PTR $T4[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0006f	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00070	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00072	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00078	72 14		 jb	 SHORT $LN75@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0007a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0007d	83 c1 23	 add	 ecx, 35			; 00000023H
  00080	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00082	83 c0 fc	 add	 eax, -4			; fffffffcH
  00085	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00088	0f 87 24 07 00
	00		 ja	 $LN162@OnLoadScri
$LN75@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0008e	51		 push	 ecx
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00095	83 c4 08	 add	 esp, 8
$LN64@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 611  : 	if (rTextFileLoader.GetTokenString("meshfilename", &m_strMeshFileName))

  00098	85 f6		 test	 esi, esi
  0009a	0f 84 f3 06 00
	00		 je	 $LN5@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000a0	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  000a4	8b c7		 mov	 eax, edi

; 426  :         if (_Large_mode_engaged()) {

  000a6	76 02		 jbe	 SHORT $LN654@OnLoadScri

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  000a8	8b 07		 mov	 eax, DWORD PTR [edi]
$LN654@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 613  : 		if (!IsGlobalFileName(m_strMeshFileName.c_str()))

  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ?IsGlobalFileName@@YA_NPBD@Z ; IsGlobalFileName
  000b0	83 c4 04	 add	 esp, 4
  000b3	84 c0		 test	 al, al
  000b5	0f 85 37 01 00
	00		 jne	 $LN660@OnLoadScri

; 615  : 			m_strMeshFileName = GetOnlyPathName(rTextFileLoader.GetFileName()) + m_strMeshFileName;

  000bb	8b 4d b8	 mov	 ecx, DWORD PTR _rTextFileLoader$GSCopy$1$[ebp]
  000be	e8 00 00 00 00	 call	 ?GetFileName@CTextFileLoader@@QAEPBDXZ ; CTextFileLoader::GetFileName
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 ?GetOnlyPathName@@YAPBDPBD@Z ; GetOnlyPathName
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000c9	8b f0		 mov	 esi, eax
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 615  : 			m_strMeshFileName = GetOnlyPathName(rTextFileLoader.GetFileName()) + m_strMeshFileName;

  000cb	89 45 a4	 mov	 DWORD PTR __Left$1$[ebp], eax
  000ce	83 c4 04	 add	 esp, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000d1	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
$LL659@OnLoadScri:
  000d4	8a 0e		 mov	 cl, BYTE PTR [esi]
  000d6	46		 inc	 esi
  000d7	84 c9		 test	 cl, cl
  000d9	75 f9		 jne	 SHORT $LL659@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3128 :     if (_Right.max_size() - _Right_size < _Left_size) {

  000db	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  000de	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000e3	2b f2		 sub	 esi, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3127 :     const auto _Right_size = _Right.size();

  000e5	89 4d ac	 mov	 DWORD PTR __Right_size$1$[ebp], ecx

; 3128 :     if (_Right.max_size() - _Right_size < _Left_size) {

  000e8	2b c1		 sub	 eax, ecx
  000ea	3b c6		 cmp	 eax, esi
  000ec	0f 82 c5 06 00
	00		 jb	 $LN666@OnLoadScri

; 434  :         return _Myres > _Small_string_capacity;

  000f2	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  000f6	76 05		 jbe	 SHORT $LN188@OnLoadScri

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  000f8	8b 3f		 mov	 edi, DWORD PTR [edi]
  000fa	89 7d a8	 mov	 DWORD PTR __Result$1$[ebp], edi
$LN188@OnLoadScri:

; 1032 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  000fd	03 ce		 add	 ecx, esi

; 1033 :         size_type _New_capacity = _Small_string_capacity;
; 1034 :         auto& _My_data          = _Mypair._Myval2;
; 1035 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  000ff	8d 45 c0	 lea	 eax, DWORD PTR $T3[ebp]
  00102	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH
  00107	89 4d b4	 mov	 DWORD PTR __New_size$1$[ebp], ecx
  0010a	89 45 bc	 mov	 DWORD PTR __Ptr$1$[ebp], eax
  0010d	0f 57 c0	 xorps	 xmm0, xmm0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00110	0f 11 45 c0	 movups	 XMMWORD PTR $T3[ebp], xmm0

; 1039 :         if (_New_capacity < _New_size) {

  00114	3b cf		 cmp	 ecx, edi
  00116	76 51		 jbe	 SHORT $LN195@OnLoadScri

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00118	8b f9		 mov	 edi, ecx
  0011a	83 cf 0f	 or	 edi, 15			; 0000000fH
  0011d	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00123	76 12		 jbe	 SHORT $LN211@OnLoadScri

; 2944 :             return _Max;

  00125	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0012a	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00135	eb 26		 jmp	 SHORT $LN664@OnLoadScri
$LN211@OnLoadScri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00137	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0013c	3b f8		 cmp	 edi, eax
  0013e	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  00141	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  00144	85 c0		 test	 eax, eax
  00146	74 1b		 je	 SHORT $LN663@OnLoadScri
$LN225@OnLoadScri:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00148	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0014d	72 08		 jb	 SHORT $LN226@OnLoadScri

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0014f	50		 push	 eax
  00150	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00155	eb 06		 jmp	 SHORT $LN664@OnLoadScri
$LN226@OnLoadScri:

; 136  :         return ::operator new(_Bytes);

  00157	50		 push	 eax
  00158	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN664@OnLoadScri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1043 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  0015d	8b 4d b4	 mov	 ecx, DWORD PTR __New_size$1$[ebp]
  00160	83 c4 04	 add	 esp, 4
$LN663@OnLoadScri:
  00163	89 45 bc	 mov	 DWORD PTR __Ptr$1$[ebp], eax
  00166	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
$LN195@OnLoadScri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00169	56		 push	 esi
  0016a	ff 75 a4	 push	 DWORD PTR __Left$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1046 :         _My_data._Mysize = _New_size;

  0016d	89 4d d0	 mov	 DWORD PTR $T3[ebp+16], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00170	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1047 :         _My_data._Myres  = _New_capacity;

  00171	89 7d d4	 mov	 DWORD PTR $T3[ebp+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00174	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1049 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  00179	8b 7d bc	 mov	 edi, DWORD PTR __Ptr$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0017c	ff 75 ac	 push	 DWORD PTR __Right_size$1$[ebp]
  0017f	ff 75 a8	 push	 DWORD PTR __Result$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1049 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  00182	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1050 :         _Traits::assign(_Ptr[_New_size], _Elem());

  0018b	8b 45 b4	 mov	 eax, DWORD PTR __New_size$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0018e	83 c4 18	 add	 esp, 24			; 00000018H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1050 :         _Traits::assign(_Ptr[_New_size], _Elem());

  00191	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0

; 1202 :         if (this == _STD addressof(_Right)) {

  00195	8d 45 c0	 lea	 eax, DWORD PTR $T3[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 615  : 			m_strMeshFileName = GetOnlyPathName(rTextFileLoader.GetFileName()) + m_strMeshFileName;

  00198	8b 7d b0	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  0019b	8d 77 2c	 lea	 esi, DWORD PTR [edi+44]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1202 :         if (this == _STD addressof(_Right)) {

  0019e	3b f0		 cmp	 esi, eax
  001a0	74 1a		 je	 SHORT $LN243@OnLoadScri

; 1203 :             return *this;
; 1204 :         }
; 1205 : 
; 1206 :         auto& _Al                 = _Getal();
; 1207 :         auto& _Right_al           = _Right._Getal();
; 1208 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
; 1209 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 1210 :             if (_Al != _Right_al) {
; 1211 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 1212 :                 _Mypair._Myval2._Orphan_all();
; 1213 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1214 :             }
; 1215 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 1216 :             if (_Al != _Right_al) {
; 1217 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 1218 :                 return *this;
; 1219 :             }
; 1220 :         }
; 1221 : 
; 1222 :         _Tidy_deallocate();

  001a2	8b ce		 mov	 ecx, esi
  001a4	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  001a9	0f 10 45 c0	 movups	 xmm0, XMMWORD PTR $T3[ebp]
  001ad	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  001b0	f3 0f 7e 45 d0	 movq	 xmm0, QWORD PTR $T3[ebp+16]
  001b5	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 434  :         return _Myres > _Small_string_capacity;

  001ba	eb 39		 jmp	 SHORT $LN274@OnLoadScri
$LN243@OnLoadScri:
  001bc	8b 4d d4	 mov	 ecx, DWORD PTR $T3[ebp+20]
  001bf	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  001c2	76 31		 jbe	 SHORT $LN274@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001c4	8b 55 c0	 mov	 edx, DWORD PTR $T3[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  001c7	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001c8	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001ca	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001d0	72 14		 jb	 SHORT $LN285@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001d2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001d5	83 c1 23	 add	 ecx, 35			; 00000023H
  001d8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001da	83 c0 fc	 add	 eax, -4			; fffffffcH
  001dd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001e0	0f 87 d6 05 00
	00		 ja	 $LN667@OnLoadScri
$LN285@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001e6	51		 push	 ecx
  001e7	52		 push	 edx
  001e8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001ed	83 c4 08	 add	 esp, 8
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 613  : 		if (!IsGlobalFileName(m_strMeshFileName.c_str()))

  001f0	eb 03		 jmp	 SHORT $LN274@OnLoadScri
$LN660@OnLoadScri:
  001f2	8b 7d b0	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN274@OnLoadScri:

; 623  : 	if (!rTextFileLoader.GetTokenInteger("meshanimationloopenable", &m_isMeshAnimationLoop))

  001f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@HOBONKKC@meshanimationloopenable@
  001fa	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  001fd	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00202	8b 4d b8	 mov	 ecx, DWORD PTR _rTextFileLoader$GSCopy$1$[ebp]
  00205	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  00208	50		 push	 eax
  00209	8d 45 d8	 lea	 eax, DWORD PTR $T5[ebp]
  0020c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00213	50		 push	 eax
  00214	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00219	8b 4d ec	 mov	 ecx, DWORD PTR $T5[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 623  : 	if (!rTextFileLoader.GetTokenInteger("meshanimationloopenable", &m_isMeshAnimationLoop))

  0021c	8b f0		 mov	 esi, eax
  0021e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00225	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00228	76 2c		 jbe	 SHORT $LN112@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0022a	8b 55 d8	 mov	 edx, DWORD PTR $T5[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0022d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0022e	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00230	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00236	72 14		 jb	 SHORT $LN123@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00238	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0023b	83 c1 23	 add	 ecx, 35			; 00000023H
  0023e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00240	83 c0 fc	 add	 eax, -4			; fffffffcH
  00243	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00246	0f 87 75 05 00
	00		 ja	 $LN668@OnLoadScri
$LN123@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0024c	51		 push	 ecx
  0024d	52		 push	 edx
  0024e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00253	83 c4 08	 add	 esp, 8
$LN112@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 623  : 	if (!rTextFileLoader.GetTokenInteger("meshanimationloopenable", &m_isMeshAnimationLoop))

  00256	85 f6		 test	 esi, esi
  00258	0f 84 35 05 00
	00		 je	 $LN5@OnLoadScri

; 624  : 		return FALSE;
; 625  : 	if (!rTextFileLoader.GetTokenInteger("meshanimationloopcount", &m_iMeshAnimationLoopCount))

  0025e	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CNDNOBIC@meshanimationloopcount@
  00263	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00266	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0026b	8b 4d b8	 mov	 ecx, DWORD PTR _rTextFileLoader$GSCopy$1$[ebp]
  0026e	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  00271	83 c7 18	 add	 edi, 24			; 00000018H
  00274	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0027b	57		 push	 edi
  0027c	50		 push	 eax
  0027d	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
  00282	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00285	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0028c	8b f0		 mov	 esi, eax
  0028e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00293	85 f6		 test	 esi, esi
  00295	75 02		 jne	 SHORT $LN9@OnLoadScri

; 626  : 	{
; 627  : 		m_iMeshAnimationLoopCount = 0;

  00297	89 37		 mov	 DWORD PTR [edi], esi
$LN9@OnLoadScri:

; 628  : 	}
; 629  : 	if (!rTextFileLoader.GetTokenFloat("meshanimationframedelay", &m_fMeshAnimationFrameDelay))

  00299	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@DLPGELIN@meshanimationframedelay@
  0029e	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  002a1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002a6	8b 7d b0	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  002a9	8b 4d b8	 mov	 ecx, DWORD PTR _rTextFileLoader$GSCopy$1$[ebp]
  002ac	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  002b3	8d 47 1c	 lea	 eax, DWORD PTR [edi+28]
  002b6	50		 push	 eax
  002b7	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  002ba	50		 push	 eax
  002bb	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
  002c0	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  002c3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002ca	8b f0		 mov	 esi, eax
  002cc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002d1	85 f6		 test	 esi, esi
  002d3	0f 84 ba 04 00
	00		 je	 $LN5@OnLoadScri

; 630  : 		return FALSE;
; 631  : 
; 632  : 	DWORD dwMeshElementCount;
; 633  : 	if (!rTextFileLoader.GetTokenDoubleWord("meshelementcount", &dwMeshElementCount))

  002d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@IMKDGDDP@meshelementcount@
  002de	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  002e1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002e6	8b 4d b8	 mov	 ecx, DWORD PTR _rTextFileLoader$GSCopy$1$[ebp]
  002e9	8d 45 a0	 lea	 eax, DWORD PTR _dwMeshElementCount$[ebp]
  002ec	50		 push	 eax
  002ed	8d 45 d8	 lea	 eax, DWORD PTR $T8[ebp]
  002f0	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  002f7	50		 push	 eax
  002f8	e8 00 00 00 00	 call	 ?GetTokenDoubleWord@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAK@Z ; CTextFileLoader::GetTokenDoubleWord
  002fd	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  00300	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00307	8b f0		 mov	 esi, eax
  00309	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0030e	85 f6		 test	 esi, esi
  00310	0f 84 7d 04 00
	00		 je	 $LN5@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00316	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 636  : 	m_MeshDataVector.clear();

  00319	8d 77 20	 lea	 esi, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0031c	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 636  : 	m_MeshDataVector.clear();

  0031e	89 75 ac	 mov	 DWORD PTR __My_data$2$[ebp], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00321	3b c8		 cmp	 ecx, eax
  00323	74 10		 je	 SHORT $LN368@OnLoadScri

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  00325	56		 push	 esi
  00326	50		 push	 eax
  00327	51		 push	 ecx
  00328	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0032d	8b 06		 mov	 eax, DWORD PTR [esi]
  0032f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00332	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN368@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 637  : 	m_MeshDataVector.resize(dwMeshElementCount);

  00335	ff 75 a0	 push	 DWORD PTR _dwMeshElementCount$[ebp]
  00338	8b ce		 mov	 ecx, esi
  0033a	e8 00 00 00 00	 call	 ?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::resize
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0033f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00342	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00347	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00349	f7 e9		 imul	 ecx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 638  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  0034b	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00352	03 d1		 add	 edx, ecx
  00354	c1 fa 05	 sar	 edx, 5
  00357	8b c2		 mov	 eax, edx
  00359	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0035c	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 638  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  0035e	0f 84 1a 04 00
	00		 je	 $LN3@OnLoadScri
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h

; 49   : 			CGotoChild(CTextFileLoader * pOwner, DWORD dwIndex) : m_pOwner(pOwner)

  00364	8b 7d b8	 mov	 edi, DWORD PTR _rTextFileLoader$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 637  : 	m_MeshDataVector.resize(dwMeshElementCount);

  00367	33 c9		 xor	 ecx, ecx
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h

; 49   : 			CGotoChild(CTextFileLoader * pOwner, DWORD dwIndex) : m_pOwner(pOwner)

  00369	89 7d a4	 mov	 DWORD PTR _GotoChild$2[ebp], edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 637  : 	m_MeshDataVector.resize(dwMeshElementCount);

  0036c	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR tv2040[ebp], 0
$LL4@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h

; 51   : 				m_pOwner->SetChildNode(dwIndex);

  00373	51		 push	 ecx
  00374	8b cf		 mov	 ecx, edi
  00376	e8 00 00 00 00	 call	 ?SetChildNode@CTextFileLoader@@QAEHK@Z ; CTextFileLoader::SetChildNode
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0037b	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 644  : 		if (!rTextFileLoader.GetTokenByte("billboardtype", &rMeshData.byBillboardType))

  0037d	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00380	03 75 b0	 add	 esi, DWORD PTR tv2040[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 644  : 		if (!rTextFileLoader.GetTokenByte("billboardtype", &rMeshData.byBillboardType))

  00383	68 00 00 00 00	 push	 OFFSET ??_C@_0O@EJACNAIE@billboardtype@
  00388	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0038f	89 75 bc	 mov	 DWORD PTR _rMeshData$1$[ebp], esi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 644  : 		if (!rTextFileLoader.GetTokenByte("billboardtype", &rMeshData.byBillboardType))

  00392	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00397	56		 push	 esi
  00398	8d 45 d8	 lea	 eax, DWORD PTR $T9[ebp]
  0039b	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0039f	50		 push	 eax
  003a0	8b cf		 mov	 ecx, edi
  003a2	e8 00 00 00 00	 call	 ?GetTokenByte@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; CTextFileLoader::GetTokenByte
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  003a7	8b 4d ec	 mov	 ecx, DWORD PTR $T9[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 644  : 		if (!rTextFileLoader.GetTokenByte("billboardtype", &rMeshData.byBillboardType))

  003aa	8b f0		 mov	 esi, eax
  003ac	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  003b0	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  003b3	76 2c		 jbe	 SHORT $LN154@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003b5	8b 55 d8	 mov	 edx, DWORD PTR $T9[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  003b8	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003b9	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  003bb	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  003c1	72 14		 jb	 SHORT $LN165@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003c3	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  003c6	83 c1 23	 add	 ecx, 35			; 00000023H
  003c9	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003cb	83 c0 fc	 add	 eax, -4			; fffffffcH
  003ce	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003d1	0f 87 db 03 00
	00		 ja	 $LN162@OnLoadScri
$LN165@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  003d7	51		 push	 ecx
  003d8	52		 push	 edx
  003d9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  003de	83 c4 08	 add	 esp, 8
$LN154@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 644  : 		if (!rTextFileLoader.GetTokenByte("billboardtype", &rMeshData.byBillboardType))

  003e1	85 f6		 test	 esi, esi
  003e3	0f 84 9c 03 00
	00		 je	 $LN636@OnLoadScri

; 646  : 		if (!rTextFileLoader.GetTokenBoolean("blendingenable", &rMeshData.bBlendingEnable))

  003e9	68 00 00 00 00	 push	 OFFSET ??_C@_0P@LCDJDIBK@blendingenable@
  003ee	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]
  003f1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003f6	8b 45 bc	 mov	 eax, DWORD PTR _rMeshData$1$[ebp]
  003f9	8b cf		 mov	 ecx, edi
  003fb	83 c0 04	 add	 eax, 4
  003fe	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00402	50		 push	 eax
  00403	8d 45 d8	 lea	 eax, DWORD PTR $T10[ebp]
  00406	50		 push	 eax
  00407	e8 00 00 00 00	 call	 ?GetTokenBoolean@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenBoolean
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0040c	8b 4d ec	 mov	 ecx, DWORD PTR $T10[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 646  : 		if (!rTextFileLoader.GetTokenBoolean("blendingenable", &rMeshData.bBlendingEnable))

  0040f	8b f0		 mov	 esi, eax
  00411	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00415	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00418	76 2c		 jbe	 SHORT $LN311@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0041a	8b 55 d8	 mov	 edx, DWORD PTR $T10[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0041d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0041e	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00420	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00426	72 14		 jb	 SHORT $LN322@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00428	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0042b	83 c1 23	 add	 ecx, 35			; 00000023H
  0042e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00430	83 c0 fc	 add	 eax, -4			; fffffffcH
  00433	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00436	0f 87 76 03 00
	00		 ja	 $LN162@OnLoadScri
$LN322@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0043c	51		 push	 ecx
  0043d	52		 push	 edx
  0043e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00443	83 c4 08	 add	 esp, 8
$LN311@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 646  : 		if (!rTextFileLoader.GetTokenBoolean("blendingenable", &rMeshData.bBlendingEnable))

  00446	85 f6		 test	 esi, esi
  00448	0f 84 37 03 00
	00		 je	 $LN636@OnLoadScri

; 648  : 		if (!rTextFileLoader.GetTokenByte("blendingsrctype", &rMeshData.byBlendingSrcType))

  0044e	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@CALCJEKJ@blendingsrctype@
  00453	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  00456	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0045b	8b 45 bc	 mov	 eax, DWORD PTR _rMeshData$1$[ebp]
  0045e	8b cf		 mov	 ecx, edi
  00460	83 c0 08	 add	 eax, 8
  00463	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00467	50		 push	 eax
  00468	8d 45 d8	 lea	 eax, DWORD PTR $T11[ebp]
  0046b	50		 push	 eax
  0046c	e8 00 00 00 00	 call	 ?GetTokenByte@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; CTextFileLoader::GetTokenByte
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00471	8b 4d ec	 mov	 ecx, DWORD PTR $T11[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 648  : 		if (!rTextFileLoader.GetTokenByte("blendingsrctype", &rMeshData.byBlendingSrcType))

  00474	8b f0		 mov	 esi, eax
  00476	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0047a	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0047d	76 2c		 jbe	 SHORT $LN348@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0047f	8b 55 d8	 mov	 edx, DWORD PTR $T11[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00482	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00483	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00485	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0048b	72 14		 jb	 SHORT $LN359@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0048d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00490	83 c1 23	 add	 ecx, 35			; 00000023H
  00493	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00495	83 c0 fc	 add	 eax, -4			; fffffffcH
  00498	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0049b	0f 87 11 03 00
	00		 ja	 $LN162@OnLoadScri
$LN359@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  004a1	51		 push	 ecx
  004a2	52		 push	 edx
  004a3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004a8	83 c4 08	 add	 esp, 8
$LN348@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 648  : 		if (!rTextFileLoader.GetTokenByte("blendingsrctype", &rMeshData.byBlendingSrcType))

  004ab	85 f6		 test	 esi, esi
  004ad	0f 84 d2 02 00
	00		 je	 $LN636@OnLoadScri

; 650  : 		if (!rTextFileLoader.GetTokenByte("blendingdesttype", &rMeshData.byBlendingDestType))

  004b3	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PBNEFHNO@blendingdesttype@
  004b8	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  004bb	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  004c0	8b 45 bc	 mov	 eax, DWORD PTR _rMeshData$1$[ebp]
  004c3	8b cf		 mov	 ecx, edi
  004c5	83 c0 09	 add	 eax, 9
  004c8	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  004cc	50		 push	 eax
  004cd	8d 45 d8	 lea	 eax, DWORD PTR $T12[ebp]
  004d0	50		 push	 eax
  004d1	e8 00 00 00 00	 call	 ?GetTokenByte@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; CTextFileLoader::GetTokenByte
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  004d6	8b 4d ec	 mov	 ecx, DWORD PTR $T12[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 650  : 		if (!rTextFileLoader.GetTokenByte("blendingdesttype", &rMeshData.byBlendingDestType))

  004d9	8b f0		 mov	 esi, eax
  004db	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  004df	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  004e2	76 2c		 jbe	 SHORT $LN392@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004e4	8b 55 d8	 mov	 edx, DWORD PTR $T12[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  004e7	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004e8	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  004ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  004f0	72 14		 jb	 SHORT $LN403@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  004f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  004f5	83 c1 23	 add	 ecx, 35			; 00000023H
  004f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  004fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00500	0f 87 ac 02 00
	00		 ja	 $LN162@OnLoadScri
$LN403@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00506	51		 push	 ecx
  00507	52		 push	 edx
  00508	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0050d	83 c4 08	 add	 esp, 8
$LN392@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 650  : 		if (!rTextFileLoader.GetTokenByte("blendingdesttype", &rMeshData.byBlendingDestType))

  00510	85 f6		 test	 esi, esi
  00512	0f 84 6d 02 00
	00		 je	 $LN636@OnLoadScri

; 653  : 		if (!rTextFileLoader.GetTokenBoolean("textureanimationloopenable", &rMeshData.bTextureAnimationLoopEnable))

  00518	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@INILLDMC@textureanimationloopenable@
  0051d	8d 4d d8	 lea	 ecx, DWORD PTR $T13[ebp]
  00520	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00525	8b 45 bc	 mov	 eax, DWORD PTR _rMeshData$1$[ebp]
  00528	8b cf		 mov	 ecx, edi
  0052a	83 c0 24	 add	 eax, 36			; 00000024H
  0052d	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  00531	50		 push	 eax
  00532	8d 45 d8	 lea	 eax, DWORD PTR $T13[ebp]
  00535	50		 push	 eax
  00536	e8 00 00 00 00	 call	 ?GetTokenBoolean@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenBoolean
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0053b	8b 4d ec	 mov	 ecx, DWORD PTR $T13[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 653  : 		if (!rTextFileLoader.GetTokenBoolean("textureanimationloopenable", &rMeshData.bTextureAnimationLoopEnable))

  0053e	8b f0		 mov	 esi, eax
  00540	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00544	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00547	76 2c		 jbe	 SHORT $LN429@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00549	8b 55 d8	 mov	 edx, DWORD PTR $T13[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0054c	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0054d	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0054f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00555	72 14		 jb	 SHORT $LN440@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00557	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0055a	83 c1 23	 add	 ecx, 35			; 00000023H
  0055d	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0055f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00562	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00565	0f 87 47 02 00
	00		 ja	 $LN162@OnLoadScri
$LN440@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0056b	51		 push	 ecx
  0056c	52		 push	 edx
  0056d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00572	83 c4 08	 add	 esp, 8
$LN429@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 653  : 		if (!rTextFileLoader.GetTokenBoolean("textureanimationloopenable", &rMeshData.bTextureAnimationLoopEnable))

  00575	85 f6		 test	 esi, esi
  00577	0f 84 08 02 00
	00		 je	 $LN636@OnLoadScri

; 655  : 		if (!rTextFileLoader.GetTokenFloat("textureanimationframedelay", &rMeshData.fTextureAnimationFrameDelay))

  0057d	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MIGDCCON@textureanimationframedelay@
  00582	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  00585	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0058a	8b 45 bc	 mov	 eax, DWORD PTR _rMeshData$1$[ebp]
  0058d	8b cf		 mov	 ecx, edi
  0058f	83 c0 28	 add	 eax, 40			; 00000028H
  00592	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  00596	50		 push	 eax
  00597	8d 45 d8	 lea	 eax, DWORD PTR $T14[ebp]
  0059a	50		 push	 eax
  0059b	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  005a0	8b 4d ec	 mov	 ecx, DWORD PTR $T14[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 655  : 		if (!rTextFileLoader.GetTokenFloat("textureanimationframedelay", &rMeshData.fTextureAnimationFrameDelay))

  005a3	8b f0		 mov	 esi, eax
  005a5	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  005a9	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  005ac	76 2c		 jbe	 SHORT $LN466@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005ae	8b 55 d8	 mov	 edx, DWORD PTR $T14[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  005b1	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005b2	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  005b4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  005ba	72 14		 jb	 SHORT $LN477@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  005bc	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  005bf	83 c1 23	 add	 ecx, 35			; 00000023H
  005c2	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  005c4	83 c0 fc	 add	 eax, -4			; fffffffcH
  005c7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  005ca	0f 87 e2 01 00
	00		 ja	 $LN162@OnLoadScri
$LN477@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  005d0	51		 push	 ecx
  005d1	52		 push	 edx
  005d2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  005d7	83 c4 08	 add	 esp, 8
$LN466@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 655  : 		if (!rTextFileLoader.GetTokenFloat("textureanimationframedelay", &rMeshData.fTextureAnimationFrameDelay))

  005da	85 f6		 test	 esi, esi
  005dc	0f 84 a3 01 00
	00		 je	 $LN636@OnLoadScri

; 657  : 		if (!rTextFileLoader.GetTokenDoubleWord("textureanimationstartframe", &rMeshData.dwTextureAnimationStartFrame))

  005e2	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@PMOBBIKD@textureanimationstartframe@
  005e7	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  005ea	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  005ef	8b 75 bc	 mov	 esi, DWORD PTR _rMeshData$1$[ebp]
  005f2	8d 45 d8	 lea	 eax, DWORD PTR $T15[ebp]
  005f5	83 c6 2c	 add	 esi, 44			; 0000002cH
  005f8	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  005fc	56		 push	 esi
  005fd	50		 push	 eax
  005fe	8b cf		 mov	 ecx, edi
  00600	e8 00 00 00 00	 call	 ?GetTokenDoubleWord@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAK@Z ; CTextFileLoader::GetTokenDoubleWord
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00605	8b 4d ec	 mov	 ecx, DWORD PTR $T15[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 657  : 		if (!rTextFileLoader.GetTokenDoubleWord("textureanimationstartframe", &rMeshData.dwTextureAnimationStartFrame))

  00608	8b f8		 mov	 edi, eax
  0060a	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0060e	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00611	76 2c		 jbe	 SHORT $LN503@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00613	8b 55 d8	 mov	 edx, DWORD PTR $T15[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00616	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00617	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00619	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0061f	72 14		 jb	 SHORT $LN514@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00621	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00624	83 c1 23	 add	 ecx, 35			; 00000023H
  00627	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00629	83 c0 fc	 add	 eax, -4			; fffffffcH
  0062c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0062f	0f 87 7d 01 00
	00		 ja	 $LN162@OnLoadScri
$LN514@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00635	51		 push	 ecx
  00636	52		 push	 edx
  00637	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0063c	83 c4 08	 add	 esp, 8
$LN503@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 657  : 		if (!rTextFileLoader.GetTokenDoubleWord("textureanimationstartframe", &rMeshData.dwTextureAnimationStartFrame))

  0063f	85 ff		 test	 edi, edi
  00641	75 02		 jne	 SHORT $LN18@OnLoadScri

; 658  : 		{
; 659  : 			rMeshData.dwTextureAnimationStartFrame = 0;

  00643	89 3e		 mov	 DWORD PTR [esi], edi
$LN18@OnLoadScri:

; 662  : 		if (!rTextFileLoader.GetTokenByte("coloroperationtype", &rMeshData.byColorOperationType))

  00645	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DAMHAFBJ@coloroperationtype@
  0064a	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  0064d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00652	8b 75 bc	 mov	 esi, DWORD PTR _rMeshData$1$[ebp]
  00655	8d 45 d8	 lea	 eax, DWORD PTR $T16[ebp]
  00658	8b 4d b8	 mov	 ecx, DWORD PTR _rTextFileLoader$GSCopy$1$[ebp]
  0065b	83 c6 10	 add	 esi, 16			; 00000010H
  0065e	56		 push	 esi
  0065f	50		 push	 eax
  00660	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  00664	e8 00 00 00 00	 call	 ?GetTokenByte@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAE@Z ; CTextFileLoader::GetTokenByte
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00669	8b 4d ec	 mov	 ecx, DWORD PTR $T16[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 662  : 		if (!rTextFileLoader.GetTokenByte("coloroperationtype", &rMeshData.byColorOperationType))

  0066c	8b f8		 mov	 edi, eax
  0066e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00672	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00675	76 2c		 jbe	 SHORT $LN540@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00677	8b 55 d8	 mov	 edx, DWORD PTR $T16[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0067a	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0067b	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0067d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00683	72 14		 jb	 SHORT $LN551@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00685	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00688	83 c1 23	 add	 ecx, 35			; 00000023H
  0068b	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0068d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00690	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00693	0f 87 19 01 00
	00		 ja	 $LN162@OnLoadScri
$LN551@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00699	51		 push	 ecx
  0069a	52		 push	 edx
  0069b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  006a0	83 c4 08	 add	 esp, 8
$LN540@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 662  : 		if (!rTextFileLoader.GetTokenByte("coloroperationtype", &rMeshData.byColorOperationType))

  006a3	85 ff		 test	 edi, edi
  006a5	75 03		 jne	 SHORT $LN19@OnLoadScri

; 663  : 		{
; 664  : 			rMeshData.byColorOperationType = D3DTOP_MODULATE;

  006a7	c6 06 04	 mov	 BYTE PTR [esi], 4
$LN19@OnLoadScri:

; 666  : 		if (!rTextFileLoader.GetTokenColor("colorfactor", &rMeshData.ColorFactor))

  006aa	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PBDNNBOP@colorfactor@
  006af	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  006b2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  006b7	8b 75 bc	 mov	 esi, DWORD PTR _rMeshData$1$[ebp]
  006ba	8d 45 d8	 lea	 eax, DWORD PTR $T17[ebp]
  006bd	8b 4d b8	 mov	 ecx, DWORD PTR _rTextFileLoader$GSCopy$1$[ebp]
  006c0	83 c6 14	 add	 esi, 20			; 00000014H
  006c3	56		 push	 esi
  006c4	50		 push	 eax
  006c5	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  006c9	e8 00 00 00 00	 call	 ?GetTokenColor@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXCOLOR@@@Z ; CTextFileLoader::GetTokenColor
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  006ce	8b 4d ec	 mov	 ecx, DWORD PTR $T17[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 666  : 		if (!rTextFileLoader.GetTokenColor("colorfactor", &rMeshData.ColorFactor))

  006d1	8b f8		 mov	 edi, eax
  006d3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  006d7	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  006da	76 2c		 jbe	 SHORT $LN577@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006dc	8b 55 d8	 mov	 edx, DWORD PTR $T17[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  006df	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006e0	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  006e2	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  006e8	72 14		 jb	 SHORT $LN588@OnLoadScri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  006ea	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  006ed	83 c1 23	 add	 ecx, 35			; 00000023H
  006f0	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  006f2	83 c0 fc	 add	 eax, -4			; fffffffcH
  006f5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  006f8	0f 87 b4 00 00
	00		 ja	 $LN162@OnLoadScri
$LN588@OnLoadScri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  006fe	51		 push	 ecx
  006ff	52		 push	 edx
  00700	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00705	83 c4 08	 add	 esp, 8
$LN577@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 666  : 		if (!rTextFileLoader.GetTokenColor("colorfactor", &rMeshData.ColorFactor))

  00708	85 ff		 test	 edi, edi
  0070a	75 0a		 jne	 SHORT $LN20@OnLoadScri

; 667  : 		{
; 668  : 			rMeshData.ColorFactor = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);

  0070c	0f 28 05 00 00
	00 00		 movaps	 xmm0, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
  00713	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
$LN20@OnLoadScri:

; 669  : 		}
; 670  : 
; 671  : 		if (!GetTokenTimeEventFloat(rTextFileLoader, "timeeventalpha", &rMeshData.TimeEventAlpha))

  00716	8b 75 bc	 mov	 esi, DWORD PTR _rMeshData$1$[ebp]
  00719	8b 7d b8	 mov	 edi, DWORD PTR _rTextFileLoader$GSCopy$1$[ebp]
  0071c	83 c6 30	 add	 esi, 48			; 00000030H
  0071f	56		 push	 esi
  00720	68 00 00 00 00	 push	 OFFSET ??_C@_0P@KALIPJCI@timeeventalpha@
  00725	57		 push	 edi
  00726	e8 00 00 00 00	 call	 ?GetTokenTimeEventFloat@@YAHAAVCTextFileLoader@@PBDPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z ; GetTokenTimeEventFloat
  0072b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0072e	85 c0		 test	 eax, eax
  00730	75 0a		 jne	 SHORT $LN601@OnLoadScri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00732	8b 06		 mov	 eax, DWORD PTR [esi]
  00734	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00737	74 03		 je	 SHORT $LN601@OnLoadScri

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00739	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN601@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h

; 55   : 				m_pOwner->SetParentNode();

  0073c	8b cf		 mov	 ecx, edi
  0073e	c7 45 fc 15 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 21 ; 00000015H
  00745	e8 00 00 00 00	 call	 ?SetParentNode@CTextFileLoader@@QAEHXZ ; CTextFileLoader::SetParentNode
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0074a	8b 75 ac	 mov	 esi, DWORD PTR __My_data$2$[ebp]
  0074d	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 638  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00752	ff 45 b4	 inc	 DWORD PTR _i$1$[ebp]
  00755	83 45 b0 3c	 add	 DWORD PTR tv2040[ebp], 60 ; 0000003cH
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h

; 56   : 			}

  00759	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00760	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00763	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00765	f7 e9		 imul	 ecx
  00767	03 d1		 add	 edx, ecx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 638  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00769	8b 4d b4	 mov	 ecx, DWORD PTR _i$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0076c	c1 fa 05	 sar	 edx, 5
  0076f	8b c2		 mov	 eax, edx
  00771	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00774	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 638  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00776	3b c8		 cmp	 ecx, eax
  00778	0f 82 f5 fb ff
	ff		 jb	 $LL4@OnLoadScri
$LN3@OnLoadScri:

; 672  : 		{
; 673  : 			rMeshData.TimeEventAlpha.clear();
; 674  : 		}
; 675  : 	}
; 676  : 
; 677  : 	return TRUE;

  0077e	b8 01 00 00 00	 mov	 eax, 1
  00783	eb 10		 jmp	 SHORT $LN1@OnLoadScri
$LN636@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h

; 55   : 				m_pOwner->SetParentNode();

  00785	8b cf		 mov	 ecx, edi
  00787	c7 45 fc 11 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 17 ; 00000011H
  0078e	e8 00 00 00 00	 call	 ?SetParentNode@CTextFileLoader@@QAEHXZ ; CTextFileLoader::SetParentNode
$LN5@OnLoadScri:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 678  : }

  00793	33 c0		 xor	 eax, eax
$LN1@OnLoadScri:
  00795	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00798	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0079f	59		 pop	 ecx
  007a0	5f		 pop	 edi
  007a1	5e		 pop	 esi
  007a2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007a5	33 cd		 xor	 ecx, ebp
  007a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007ac	8b e5		 mov	 esp, ebp
  007ae	5d		 pop	 ebp
  007af	c2 04 00	 ret	 4
$LN162@OnLoadScri:
  007b2	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN666@OnLoadScri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3129 :         _Xlen_string();

  007b7	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN667@OnLoadScri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  007bc	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN668@OnLoadScri:
  007c1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN662@OnLoadScri:
  007c6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$2:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$3:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$4:
  00018	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$5:
  00020	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$6:
  00028	8d 4d a4	 lea	 ecx, DWORD PTR _GotoChild$2[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1CGotoChild@CTextFileLoader@@QAE@XZ ; CTextFileLoader::CGotoChild::~CGotoChild
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$7:
  00030	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  00033	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$8:
  00038	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]
  0003b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$9:
  00040	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$10:
  00048	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  0004b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$11:
  00050	8d 4d d8	 lea	 ecx, DWORD PTR $T13[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$12:
  00058	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  0005b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$13:
  00060	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  00063	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$14:
  00068	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  0006b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z$15:
  00070	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  00073	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00078	cc		 int	 3
  00079	cc		 int	 3
  0007a	cc		 int	 3
  0007b	cc		 int	 3
  0007c	cc		 int	 3
__ehhandler$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z:
  0007d	90		 npad	 1
  0007e	90		 npad	 1
  0007f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00083	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00086	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00089	33 c8		 xor	 ecx, eax
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00093	33 c8		 xor	 ecx, eax
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z
  0009f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnLoadScript@CEffectMeshScript@@MAEHAAVCTextFileLoader@@@Z ENDP ; CEffectMeshScript::OnLoadScript
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnIsData@CEffectMeshScript@@MAE_NXZ
_TEXT	SEGMENT
?OnIsData@CEffectMeshScript@@MAE_NXZ PROC		; CEffectMeshScript::OnIsData, COMDAT
; _this$ = ecx

; 682  : 	if (0 == m_strMeshFileName.length())

  00000	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00004	0f 95 c0	 setne	 al

; 683  : 		return false;
; 684  : 
; 685  : 	return true;
; 686  : }

  00007	c3		 ret	 0
?OnIsData@CEffectMeshScript@@MAE_NXZ ENDP		; CEffectMeshScript::OnIsData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnClear@CEffectMeshScript@@MAEXXZ
_TEXT	SEGMENT
?OnClear@CEffectMeshScript@@MAEXXZ PROC			; CEffectMeshScript::OnClear, COMDAT
; _this$ = ecx

; 689  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 690  : 	m_isMeshAnimationLoop = false;
; 691  : 	m_iMeshAnimationLoopCount = 0;
; 692  : 	m_fMeshAnimationFrameDelay = 0.02f;
; 693  : 
; 694  : 	m_MeshDataVector.clear();

  00004	8d 77 20	 lea	 esi, DWORD PTR [edi+32]
  00007	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0
  0000e	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  00015	c7 47 1c 0a d7
	a3 3c		 mov	 DWORD PTR [edi+28], 1017370378 ; 3ca3d70aH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00021	3b c1		 cmp	 eax, ecx
  00023	74 10		 je	 SHORT $LN3@OnClear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  00025	56		 push	 esi
  00026	51		 push	 ecx
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0002d	8b 06		 mov	 eax, DWORD PTR [esi]
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN3@OnClear:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00035	6a 00		 push	 0
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 695  : 	m_strMeshFileName = "";

  0003c	8d 4f 2c	 lea	 ecx, DWORD PTR [edi+44]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0003f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 696  : }

  00046	c3		 ret	 0
?OnClear@CEffectMeshScript@@MAEXXZ ENDP			; CEffectMeshScript::OnClear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetTextureAnimationStartFrame@CEffectMeshScript@@QAEKK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetTextureAnimationStartFrame@CEffectMeshScript@@QAEKK@Z PROC ; CEffectMeshScript::GetTextureAnimationStartFrame, COMDAT
; _this$ = ecx

; 602  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 603  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetTexture

; 604  : 		return 0;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 607  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@GetTexture:

; 605  : 
; 606  : 	return m_MeshDataVector[dwMeshIndex].dwTextureAnimationStartFrame;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 607  : }

  00027	5e		 pop	 esi
  00028	8b 44 88 2c	 mov	 eax, DWORD PTR [eax+ecx*4+44]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetTextureAnimationStartFrame@CEffectMeshScript@@QAEKK@Z ENDP ; CEffectMeshScript::GetTextureAnimationStartFrame
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetTextureAnimationFrameDelay@CEffectMeshScript@@QAEMK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetTextureAnimationFrameDelay@CEffectMeshScript@@QAEMK@Z PROC ; CEffectMeshScript::GetTextureAnimationFrameDelay, COMDAT
; _this$ = ecx

; 594  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 595  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetTexture

; 596  : 		return 0.0f;

  00014	d9 ee		 fldz
  00016	5f		 pop	 edi

; 599  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@GetTexture:

; 597  : 
; 598  : 	return m_MeshDataVector[dwMeshIndex].fTextureAnimationFrameDelay;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 599  : }

  00027	5e		 pop	 esi
  00028	d9 44 88 28	 fld	 DWORD PTR [eax+ecx*4+40]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetTextureAnimationFrameDelay@CEffectMeshScript@@QAEMK@Z ENDP ; CEffectMeshScript::GetTextureAnimationFrameDelay
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?isTextureAnimationLoop@CEffectMeshScript@@QAEHK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?isTextureAnimationLoop@CEffectMeshScript@@QAEHK@Z PROC	; CEffectMeshScript::isTextureAnimationLoop, COMDAT
; _this$ = ecx

; 587  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 588  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@isTextureA

; 589  : 		return 0.0f;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 592  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@isTextureA:

; 590  : 
; 591  : 	return m_MeshDataVector[dwMeshIndex].bTextureAnimationLoopEnable;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 592  : }

  00027	5e		 pop	 esi
  00028	8b 44 88 24	 mov	 eax, DWORD PTR [eax+ecx*4+36]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?isTextureAnimationLoop@CEffectMeshScript@@QAEHK@Z ENDP	; CEffectMeshScript::isTextureAnimationLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ
_TEXT	SEGMENT
?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ PROC ; CEffectMeshScript::GetMeshAnimationFrameDelay, COMDAT
; _this$ = ecx

; 583  : 	return m_fMeshAnimationFrameDelay;

  00000	d9 41 1c	 fld	 DWORD PTR [ecx+28]

; 584  : }

  00003	c3		 ret	 0
?GetMeshAnimationFrameDelay@CEffectMeshScript@@QAEMXZ ENDP ; CEffectMeshScript::GetMeshAnimationFrameDelay
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ
_TEXT	SEGMENT
?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ PROC ; CEffectMeshScript::GetMeshAnimationLoopCount, COMDAT
; _this$ = ecx

; 579  : 	return m_iMeshAnimationLoopCount;

  00000	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]

; 580  : }

  00003	c3		 ret	 0
?GetMeshAnimationLoopCount@CEffectMeshScript@@QAEHXZ ENDP ; CEffectMeshScript::GetMeshAnimationLoopCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ
_TEXT	SEGMENT
?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ PROC	; CEffectMeshScript::isMeshAnimationLoop, COMDAT
; _this$ = ecx

; 575  : 	return m_isMeshAnimationLoop;

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]

; 576  : }

  00003	c3		 ret	 0
?isMeshAnimationLoop@CEffectMeshScript@@QAEHXZ ENDP	; CEffectMeshScript::isMeshAnimationLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
_pTimeEventAlpha$ = 12					; size = 4
?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z PROC ; CEffectMeshScript::GetTimeTableAlphaPointer, COMDAT
; _this$ = ecx

; 563  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 564  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetTimeTab

; 565  : 		return FALSE;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 568  : 
; 569  : 	return TRUE;
; 570  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN2@GetTimeTab:

; 567  : 	*pTimeEventAlpha = &m_MeshDataVector[dwMeshIndex].TimeEventAlpha;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 567  : 	*pTimeEventAlpha = &m_MeshDataVector[dwMeshIndex].TimeEventAlpha;

  00026	83 c0 30	 add	 eax, 48			; 00000030H
  00029	5f		 pop	 edi

; 568  : 
; 569  : 	return TRUE;
; 570  : }

  0002a	5e		 pop	 esi
  0002b	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  0002e	8b 45 0c	 mov	 eax, DWORD PTR _pTimeEventAlpha$[ebp]
  00031	89 08		 mov	 DWORD PTR [eax], ecx
  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetTimeTableAlphaPointer@CEffectMeshScript@@QAEHKPAPAV?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@@Z ENDP ; CEffectMeshScript::GetTimeTableAlphaPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
_pColor$ = 12						; size = 4
?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z PROC ; CEffectMeshScript::GetColorFactor, COMDAT
; _this$ = ecx

; 553  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 554  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetColorFa

; 555  : 		return FALSE;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 560  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN2@GetColorFa:

; 556  : 
; 557  : 	*pColor = m_MeshDataVector[dwMeshIndex].ColorFactor;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 560  : }

  00027	5e		 pop	 esi
  00028	0f 10 44 88 14	 movups	 xmm0, XMMWORD PTR [eax+ecx*4+20]
  0002d	8b 45 0c	 mov	 eax, DWORD PTR _pColor$[ebp]
  00030	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
?GetColorFactor@CEffectMeshScript@@QAEHKPAUD3DXCOLOR@@@Z ENDP ; CEffectMeshScript::GetColorFactor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
_pbyType$ = 12						; size = 4
?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z PROC ; CEffectMeshScript::GetColorOperationType, COMDAT
; _this$ = ecx

; 544  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 545  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetColorOp

; 546  : 		return FALSE;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 551  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN2@GetColorOp:

; 547  : 
; 548  : 	*pbyType = m_MeshDataVector[dwMeshIndex].byColorOperationType;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 551  : }

  00027	5e		 pop	 esi
  00028	8a 4c 88 10	 mov	 cl, BYTE PTR [eax+ecx*4+16]
  0002c	8b 45 0c	 mov	 eax, DWORD PTR _pbyType$[ebp]
  0002f	88 08		 mov	 BYTE PTR [eax], cl
  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	5d		 pop	 ebp
  00037	c2 08 00	 ret	 8
?GetColorOperationType@CEffectMeshScript@@QAEHKPAE@Z ENDP ; CEffectMeshScript::GetColorOperationType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?isTextureAlphaEnable@CEffectMeshScript@@QAEHK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?isTextureAlphaEnable@CEffectMeshScript@@QAEHK@Z PROC	; CEffectMeshScript::isTextureAlphaEnable, COMDAT
; _this$ = ecx

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 537  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@isTextureA

; 538  : 		return false;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 541  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@isTextureA:

; 539  : 
; 540  : 	return m_MeshDataVector[dwMeshIndex].bTextureAlphaEnable;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 541  : }

  00027	5e		 pop	 esi
  00028	8b 44 88 0c	 mov	 eax, DWORD PTR [eax+ecx*4+12]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?isTextureAlphaEnable@CEffectMeshScript@@QAEHK@Z ENDP	; CEffectMeshScript::isTextureAlphaEnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z PROC	; CEffectMeshScript::GetBlendingDestType, COMDAT
; _this$ = ecx

; 529  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 530  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 06		 jne	 SHORT $LN2@GetBlendin

; 534  : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@GetBlendin:

; 531  : 		return false;
; 532  : 
; 533  : 	return m_MeshDataVector[dwMeshIndex].byBlendingDestType;

  0001a	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001d	8b ce		 mov	 ecx, esi
  0001f	c1 e1 04	 shl	 ecx, 4
  00022	2b ce		 sub	 ecx, esi
  00024	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 534  : }

  00025	5e		 pop	 esi
  00026	8a 44 88 09	 mov	 al, BYTE PTR [eax+ecx*4+9]
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?GetBlendingDestType@CEffectMeshScript@@QAEEK@Z ENDP	; CEffectMeshScript::GetBlendingDestType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z PROC	; CEffectMeshScript::GetBlendingSrcType, COMDAT
; _this$ = ecx

; 522  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 523  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 06		 jne	 SHORT $LN2@GetBlendin

; 527  : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@GetBlendin:

; 524  : 		return false;
; 525  : 
; 526  : 	return m_MeshDataVector[dwMeshIndex].byBlendingSrcType;

  0001a	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001d	8b ce		 mov	 ecx, esi
  0001f	c1 e1 04	 shl	 ecx, 4
  00022	2b ce		 sub	 ecx, esi
  00024	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 527  : }

  00025	5e		 pop	 esi
  00026	8a 44 88 08	 mov	 al, BYTE PTR [eax+ecx*4+8]
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
?GetBlendingSrcType@CEffectMeshScript@@QAEEK@Z ENDP	; CEffectMeshScript::GetBlendingSrcType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?isBlendingEnable@CEffectMeshScript@@QAEHK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?isBlendingEnable@CEffectMeshScript@@QAEHK@Z PROC	; CEffectMeshScript::isBlendingEnable, COMDAT
; _this$ = ecx

; 515  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 516  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@isBlending

; 517  : 		return FALSE;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 520  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@isBlending:

; 518  : 
; 519  : 	return m_MeshDataVector[dwMeshIndex].bBlendingEnable;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 520  : }

  00027	5e		 pop	 esi
  00028	8b 44 88 04	 mov	 eax, DWORD PTR [eax+ecx*4+4]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?isBlendingEnable@CEffectMeshScript@@QAEHK@Z ENDP	; CEffectMeshScript::isBlendingEnable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetBillboardType@CEffectMeshScript@@QAEHK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetBillboardType@CEffectMeshScript@@QAEHK@Z PROC	; CEffectMeshScript::GetBillboardType, COMDAT
; _this$ = ecx

; 508  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 509  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 08		 jne	 SHORT $LN2@GetBillboa

; 510  : 		return 0;

  00014	5f		 pop	 edi
  00015	33 c0		 xor	 eax, eax

; 513  : }

  00017	5e		 pop	 esi
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@GetBillboa:

; 511  : 
; 512  : 	return m_MeshDataVector[dwMeshIndex].byBillboardType;

  0001c	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001f	8b ce		 mov	 ecx, esi
  00021	c1 e1 04	 shl	 ecx, 4
  00024	2b ce		 sub	 ecx, esi
  00026	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 513  : }

  00027	5e		 pop	 esi
  00028	0f b6 04 88	 movzx	 eax, BYTE PTR [eax+ecx*4]
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?GetBillboardType@CEffectMeshScript@@QAEHK@Z ENDP	; CEffectMeshScript::GetBillboardType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshDataCount@CEffectMeshScript@@QAEHXZ
_TEXT	SEGMENT
?GetMeshDataCount@CEffectMeshScript@@QAEHXZ PROC	; CEffectMeshScript::GetMeshDataCount, COMDAT
; _this$ = ecx

; 503  : {

  00000	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00001	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00004	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00009	2b 71 20	 sub	 esi, DWORD PTR [ecx+32]
  0000c	f7 ee		 imul	 esi
  0000e	03 d6		 add	 edx, esi
  00010	c1 fa 05	 sar	 edx, 5
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 504  : 	return m_MeshDataVector.size();

  0001a	5e		 pop	 esi

; 505  : }

  0001b	c3		 ret	 0
?GetMeshDataCount@CEffectMeshScript@@QAEHXZ ENDP	; CEffectMeshScript::GetMeshDataCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
_ppMeshData$ = 12					; size = 4
?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z PROC ; CEffectMeshScript::GetMeshDataPointer, COMDAT
; _this$ = ecx

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 494  : 	if (!CheckMeshIndex(dwMeshIndex))

  00004	8b 75 08	 mov	 esi, DWORD PTR _dwMeshIndex$[ebp]
  00007	57		 push	 edi
  00008	56		 push	 esi
  00009	8b f9		 mov	 edi, ecx
  0000b	e8 00 00 00 00	 call	 ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ; CEffectMeshScript::CheckMeshIndex
  00010	84 c0		 test	 al, al
  00012	75 06		 jne	 SHORT $LN2@GetMeshDat

; 500  : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
$LN2@GetMeshDat:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001a	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0001d	8b ce		 mov	 ecx, esi
  0001f	c1 e1 04	 shl	 ecx, 4
  00022	2b ce		 sub	 ecx, esi
  00024	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 500  : }

  00025	5e		 pop	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00026	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 497  : 	*ppMeshData = &m_MeshDataVector[dwMeshIndex];

  00029	8b 45 0c	 mov	 eax, DWORD PTR _ppMeshData$[ebp]
  0002c	89 08		 mov	 DWORD PTR [eax], ecx

; 498  : 
; 499  : 	return true;

  0002e	b0 01		 mov	 al, 1

; 500  : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
?GetMeshDataPointer@CEffectMeshScript@@QAE_NKPAPAUSMeshData@1@@Z ENDP ; CEffectMeshScript::GetMeshDataPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z PROC	; CEffectMeshScript::CheckMeshIndex, COMDAT
; _this$ = ecx

; 485  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00004	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00007	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0000c	2b 71 20	 sub	 esi, DWORD PTR [ecx+32]
  0000f	f7 ee		 imul	 esi
  00011	03 d6		 add	 edx, esi
  00013	c1 fa 05	 sar	 edx, 5
  00016	8b c2		 mov	 eax, edx
  00018	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001b	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 486  : 	if (dwMeshIndex >= m_MeshDataVector.size())

  0001d	39 45 08	 cmp	 DWORD PTR _dwMeshIndex$[ebp], eax

; 487  : 		return false;

  00020	5e		 pop	 esi
  00021	0f 92 c0	 setb	 al

; 488  : 
; 489  : 	return true;
; 490  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?CheckMeshIndex@CEffectMeshScript@@QAE_NK@Z ENDP	; CEffectMeshScript::CheckMeshIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?ReserveMeshData@CEffectMeshScript@@QAEXK@Z
_TEXT	SEGMENT
_dwMeshCount$ = 8					; size = 4
_i$1$ = 8						; size = 4
?ReserveMeshData@CEffectMeshScript@@QAEXK@Z PROC	; CEffectMeshScript::ReserveMeshData, COMDAT
; _this$ = ecx

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1899 :         auto& _My_data = _Mypair._Myval2;

  00004	8d 59 20	 lea	 ebx, DWORD PTR [ecx+32]

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00007	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 453  : {

  0000c	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000d	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  00010	8b ce		 mov	 ecx, esi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 453  : {

  00012	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00013	8b 3b		 mov	 edi, DWORD PTR [ebx]
  00015	2b cf		 sub	 ecx, edi
  00017	f7 e9		 imul	 ecx
  00019	03 d1		 add	 edx, ecx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 454  : 	if (m_MeshDataVector.size() == dwMeshCount)

  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _dwMeshCount$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0001e	c1 fa 05	 sar	 edx, 5
  00021	8b c2		 mov	 eax, edx
  00023	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00026	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 454  : 	if (m_MeshDataVector.size() == dwMeshCount)

  00028	3b c1		 cmp	 eax, ecx
  0002a	0f 84 b3 00 00
	00		 je	 $LN3@ReserveMes
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00030	3b fe		 cmp	 edi, esi
  00032	74 13		 je	 SHORT $LN10@ReserveMes

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  00034	53		 push	 ebx
  00035	56		 push	 esi
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@YAXPAUSMeshData@CEffectMeshScript@@QAU12@AAV?$allocator@USMeshData@CEffectMeshScript@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectMeshScript::SMeshData> >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0003c	8b 03		 mov	 eax, DWORD PTR [ebx]
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _dwMeshCount$[ebp]
  00044	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN10@ReserveMes:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 458  : 	m_MeshDataVector.resize(dwMeshCount);

  00047	51		 push	 ecx
  00048	8b cb		 mov	 ecx, ebx
  0004a	e8 00 00 00 00	 call	 ?resize@?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::resize
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0004f	8b 3b		 mov	 edi, DWORD PTR [ebx]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 460  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00051	33 c9		 xor	 ecx, ecx
  00053	89 4d 08	 mov	 DWORD PTR _i$1$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00056	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0005b	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0005e	2b cf		 sub	 ecx, edi
  00060	f7 e9		 imul	 ecx
  00062	03 d1		 add	 edx, ecx
  00064	c1 fa 05	 sar	 edx, 5
  00067	8b c2		 mov	 eax, edx
  00069	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0006c	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 460  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  0006e	74 73		 je	 SHORT $LN3@ReserveMes
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 920  :     r = fr;

  00070	0f 28 0d 00 00
	00 00		 movaps	 xmm1, XMMWORD PTR __xmm@3f8000003f8000003f8000003f800000
  00077	33 f6		 xor	 esi, esi
  00079	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@ReserveMes:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 460  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  00080	ff 45 08	 inc	 DWORD PTR _i$1$[ebp]
  00083	8d 76 3c	 lea	 esi, DWORD PTR [esi+60]

; 461  : 	{
; 462  : 		TMeshData & rMeshData = m_MeshDataVector[i];
; 463  : 
; 464  : 		rMeshData.byBillboardType = MESH_BILLBOARD_TYPE_NONE;

  00086	c6 44 3e c4 00	 mov	 BYTE PTR [esi+edi-60], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0008b	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 465  : 		rMeshData.bBlendingEnable = TRUE;

  00090	c7 44 3e c8 01
	00 00 00	 mov	 DWORD PTR [esi+edi-56], 1

; 466  : 		rMeshData.byBlendingSrcType = D3DBLEND_SRCCOLOR;

  00098	66 c7 44 3e cc
	03 02		 mov	 WORD PTR [esi+edi-52], 515 ; 00000203H

; 467  : 		rMeshData.byBlendingDestType = D3DBLEND_ONE;
; 468  : 		rMeshData.bTextureAlphaEnable = FALSE;

  0009f	c7 44 3e d0 00
	00 00 00	 mov	 DWORD PTR [esi+edi-48], 0

; 469  : 
; 470  : 		rMeshData.byColorOperationType = D3DTOP_MODULATE;

  000a7	c6 44 3e d4 04	 mov	 BYTE PTR [esi+edi-44], 4

; 471  : 		rMeshData.ColorFactor = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);

  000ac	0f 11 4c 3e d8	 movups	 XMMWORD PTR [esi+edi-40], xmm1

; 472  : 
; 473  : 		rMeshData.bTextureAnimationLoopEnable = true;

  000b1	c7 44 3e e8 01
	00 00 00	 mov	 DWORD PTR [esi+edi-24], 1

; 474  : 		rMeshData.fTextureAnimationFrameDelay = 0.02f;

  000b9	c7 44 3e ec 0a
	d7 a3 3c	 mov	 DWORD PTR [esi+edi-20], 1017370378 ; 3ca3d70aH

; 475  : 		rMeshData.dwTextureAnimationStartFrame = 0;

  000c1	c7 44 3e f0 00
	00 00 00	 mov	 DWORD PTR [esi+edi-16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000c9	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000cc	8b 3b		 mov	 edi, DWORD PTR [ebx]
  000ce	2b cf		 sub	 ecx, edi
  000d0	f7 e9		 imul	 ecx
  000d2	03 d1		 add	 edx, ecx
  000d4	c1 fa 05	 sar	 edx, 5
  000d7	8b c2		 mov	 eax, edx
  000d9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000dc	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 460  : 	for (DWORD i = 0; i < m_MeshDataVector.size(); ++i)

  000de	39 45 08	 cmp	 DWORD PTR _i$1$[ebp], eax
  000e1	72 9d		 jb	 SHORT $LL4@ReserveMes
$LN3@ReserveMes:
  000e3	5f		 pop	 edi

; 476  : 	}
; 477  : }

  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx
  000e6	5d		 pop	 ebp
  000e7	c2 04 00	 ret	 4
?ReserveMeshData@CEffectMeshScript@@QAEXK@Z ENDP	; CEffectMeshScript::ReserveMeshData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ
_TEXT	SEGMENT
?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ PROC	; CEffectMeshScript::GetMeshFileName, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00000	83 79 40 0f	 cmp	 DWORD PTR [ecx+64], 15	; 0000000fH

; 2328 :         return _Mypair._Myval2._Myptr();

  00004	8d 41 2c	 lea	 eax, DWORD PTR [ecx+44]

; 426  :         if (_Large_mode_engaged()) {

  00007	76 02		 jbe	 SHORT $LN7@GetMeshFil
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 481  : 	return m_strMeshFileName.c_str();

  00009	8b 00		 mov	 eax, DWORD PTR [eax]
$LN7@GetMeshFil:

; 482  : }

  0000b	c3		 ret	 0
?GetMeshFileName@CEffectMeshScript@@QAEPBDXZ ENDP	; CEffectMeshScript::GetMeshFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??1CEffectMeshScript@@UAE@XZ
_TEXT	SEGMENT
??1CEffectMeshScript@@UAE@XZ PROC			; CEffectMeshScript::~CEffectMeshScript, COMDAT
; _this$ = ecx

; 702  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectMeshScript@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00009	8b 4e 40	 mov	 ecx, DWORD PTR [esi+64]
  0000c	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0000f	76 28		 jbe	 SHORT $LN24@CEffectMes
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00014	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00015	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001b	72 12		 jb	 SHORT $LN35@CEffectMes

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00020	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00023	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00025	83 c0 fc	 add	 eax, -4			; fffffffcH
  00028	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002b	77 2e		 ja	 SHORT $LN32@CEffectMes

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	8b c2		 mov	 eax, edx
$LN35@CEffectMes:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	83 c4 08	 add	 esp, 8
$LN24@CEffectMes:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 703  : }

  00039	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  0003c	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00043	c7 46 40 0f 00
	00 00		 mov	 DWORD PTR [esi+64], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004a	c6 46 2c 00	 mov	 BYTE PTR [esi+44], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 703  : }

  0004e	e8 00 00 00 00	 call	 ??1?$vector@USMeshData@CEffectMeshScript@@V?$allocator@USMeshData@CEffectMeshScript@@@std@@@std@@QAE@XZ ; std::vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >::~vector<CEffectMeshScript::SMeshData,std::allocator<CEffectMeshScript::SMeshData> >
  00053	8b ce		 mov	 ecx, esi
  00055	5e		 pop	 esi
  00056	e9 00 00 00 00	 jmp	 ??1CEffectElementBase@@UAE@XZ ; CEffectElementBase::~CEffectElementBase
$LN32@CEffectMes:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN45@CEffectMes:
  00060	cc		 int	 3
??1CEffectMeshScript@@UAE@XZ ENDP			; CEffectMeshScript::~CEffectMeshScript
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??0CEffectMeshScript@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CEffectMeshScript@@QAE@XZ PROC			; CEffectMeshScript::CEffectMeshScript, COMDAT
; _this$ = ecx

; 699  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	e8 00 00 00 00	 call	 ??0CEffectElementBase@@QAE@XZ ; CEffectElementBase::CEffectElementBase
  0000f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectMeshScript@@6B@
  00015	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00018	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 700  : }

  0001f	8b c6		 mov	 eax, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00021	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  00028	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0002f	0f 11 46 2c	 movups	 XMMWORD PTR [esi+44], xmm0

; 836  :         _My_data._Mysize = 0;

  00033	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0003a	c7 46 40 0f 00
	00 00		 mov	 DWORD PTR [esi+64], 15	; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00041	c6 46 2c 00	 mov	 BYTE PTR [esi+44], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 700  : }

  00045	5e		 pop	 esi
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??0CEffectMeshScript@@QAE@XZ ENDP			; CEffectMeshScript::CEffectMeshScript
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCEffectMesh@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCEffectMesh@@UAEPAXI@Z PROC				; CEffectMesh::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CEffectMesh@@UAE@XZ	; CEffectMesh::~CEffectMesh
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 44		 push	 68			; 00000044H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCEffectMesh@@UAEPAXI@Z ENDP				; CEffectMesh::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z PROC ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Change_array, COMDAT
; _this$ = ecx

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();
; 2047 :         auto& _My_data    = _Mypair._Myval2;
; 2048 :         pointer& _Myfirst = _My_data._Myfirst;
; 2049 :         pointer& _Mylast  = _My_data._Mylast;
; 2050 :         pointer& _Myend   = _My_data._Myend;
; 2051 : 
; 2052 :         _My_data._Orphan_all();
; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN10@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000f	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN21@Change_arr

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN18@Change_arr

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN21@Change_arr:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN10@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2060 :         _Myfirst = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 2064 :     }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN18@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z ENDP ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Newsize$ = 8						; size = 4
$T1 = 8							; size = 4
?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z PROC ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::resize, COMDAT
; _this$ = ecx

; 1613 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1581 :         if (_Newsize < _Oldsize) { // trim

  00006	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]

; 1613 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	89 7d fc	 mov	 DWORD PTR _this$1$[ebp], edi

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0000f	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00012	8b da		 mov	 ebx, edx
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	2b d8		 sub	 ebx, eax
  00018	c1 fb 02	 sar	 ebx, 2

; 1581 :         if (_Newsize < _Oldsize) { // trim

  0001b	3b f3		 cmp	 esi, ebx
  0001d	73 0f		 jae	 SHORT $LN4@resize

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  0001f	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1585 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1586 :             _Mylast = _Newlast;

  00022	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00025	5f		 pop	 edi

; 1616 :     }

  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
$LN4@resize:

; 1590 :         if (_Newsize > _Oldsize) { // append

  0002e	0f 86 c3 00 00
	00		 jbe	 $LN5@resize

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00034	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00037	2b c8		 sub	 ecx, eax
  00039	c1 f9 02	 sar	 ecx, 2

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  0003c	3b f1		 cmp	 esi, ecx
  0003e	0f 86 a1 00 00
	00		 jbe	 $LN6@resize

; 1538 :         if (_Newsize > max_size()) {

  00044	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  0004a	0f 87 b0 00 00
	00		 ja	 $LN111@resize

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00050	8b d1		 mov	 edx, ecx
  00052	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00057	d1 ea		 shr	 edx, 1
  00059	2b c2		 sub	 eax, edx
  0005b	3b c8		 cmp	 ecx, eax
  0005d	76 12		 jbe	 SHORT $LN13@resize

; 1997 :             return _Max; // geometric growth would overflow

  0005f	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00064	bf ff ff ff 3f	 mov	 edi, 1073741823		; 3fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006f	eb 35		 jmp	 SHORT $LN109@resize
$LN13@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00071	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00074	3b fe		 cmp	 edi, esi
  00076	73 0f		 jae	 SHORT $LN14@resize

; 2003 :             return _Newsize; // geometric growth would be insufficient

  00078	8b fe		 mov	 edi, esi
$LN24@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  0007a	8d 04 bd 00 00
	00 00		 lea	 eax, DWORD PTR [edi*4]

; 227  :     if (_Bytes == 0) {

  00081	85 c0		 test	 eax, eax
  00083	75 0c		 jne	 SHORT $LN28@resize

; 228  :         return nullptr;

  00085	eb 22		 jmp	 SHORT $LN108@resize
$LN14@resize:

; 117  :         if (_Count > _Max_possible) {

  00087	81 ff ff ff ff
	3f		 cmp	 edi, 1073741823		; 3fffffffH
  0008d	77 76		 ja	 SHORT $LN112@resize
  0008f	eb e9		 jmp	 SHORT $LN24@resize
$LN28@resize:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00091	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00096	72 08		 jb	 SHORT $LN29@resize

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009e	eb 06		 jmp	 SHORT $LN109@resize
$LN29@resize:

; 136  :         return ::operator new(_Bytes);

  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN109@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000a6	83 c4 04	 add	 esp, 4
$LN108@resize:
  000a9	8d 0c 98	 lea	 ecx, DWORD PTR [eax+ebx*4]
  000ac	89 45 08	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  000af	8b c6		 mov	 eax, esi
  000b1	2b c3		 sub	 eax, ebx
  000b3	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b6	50		 push	 eax
  000b7	51		 push	 ecx
  000b8	e8 00 00 00 00	 call	 ??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z ; std::_Zero_range<CEffectMesh::SEffectMeshData * *>

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bd	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  000c0	ff 75 08	 push	 DWORD PTR $T1[ebp]
  000c3	ff 73 04	 push	 DWORD PTR [ebx+4]
  000c6	ff 33		 push	 DWORD PTR [ebx]
  000c8	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>
  000cd	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1570 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000d0	8b cb		 mov	 ecx, ebx
  000d2	57		 push	 edi
  000d3	56		 push	 esi
  000d4	ff 75 08	 push	 DWORD PTR $T1[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Change_array
  000dc	5f		 pop	 edi

; 1616 :     }

  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx
  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c2 04 00	 ret	 4
$LN6@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  000e5	2b f3		 sub	 esi, ebx
  000e7	8d 34 b2	 lea	 esi, DWORD PTR [edx+esi*4]
  000ea	56		 push	 esi
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ??$_Zero_range@PAPAUSEffectMeshData@CEffectMesh@@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@QAPAU12@0@Z ; std::_Zero_range<CEffectMesh::SEffectMeshData * *>
  000f1	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  000f4	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN5@resize:
  000f7	5f		 pop	 edi

; 1616 :     }

  000f8	5e		 pop	 esi
  000f9	5b		 pop	 ebx
  000fa	8b e5		 mov	 esp, ebp
  000fc	5d		 pop	 ebp
  000fd	c2 04 00	 ret	 4
$LN111@resize:

; 1539 :             _Xlength();

  00100	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Xlength
$LN112@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00105	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN107@resize:
  0010a	cc		 int	 3
?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXABQAUSEffectMeshData@CEffectMesh@@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -12					; size = 4
tv583 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
__Whereptr$1$ = -4					; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXABQAUSEffectMeshData@CEffectMesh@@@Z PROC ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::push_back, COMDAT
; _this$ = ecx

; 917  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 829  :         if (_Mylast != _My_data._Myend) {

  0000b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00011	89 4d fc	 mov	 DWORD PTR __Whereptr$1$[ebp], ecx
  00014	3b ca		 cmp	 ecx, edx
  00016	74 14		 je	 SHORT $LN4@push_back

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00018	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  0001f	83 46 04 04	 add	 DWORD PTR [esi+4], 4

; 919  :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN4@push_back:

; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0002c	8b 3e		 mov	 edi, DWORD PTR [esi]
  0002e	8b c1		 mov	 eax, ecx
  00030	2b c7		 sub	 eax, edi
  00032	c1 f8 02	 sar	 eax, 2
  00035	89 45 f4	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);
; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  00038	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0003d	0f 84 c0 00 00
	00		 je	 $LN106@push_back

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00043	2b d7		 sub	 edx, edi

; 876  :         const size_type _Newsize = _Oldsize + 1;

  00045	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00048	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004b	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00050	8b fa		 mov	 edi, edx

; 876  :         const size_type _Newsize = _Oldsize + 1;

  00052	89 5d f8	 mov	 DWORD PTR __Newsize$1$[ebp], ebx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00055	d1 ef		 shr	 edi, 1
  00057	2b c7		 sub	 eax, edi
  00059	3b d0		 cmp	 edx, eax
  0005b	76 12		 jbe	 SHORT $LN15@push_back

; 1997 :             return _Max; // geometric growth would overflow

  0005d	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00062	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006d	eb 38		 jmp	 SHORT $LN104@push_back
$LN15@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006f	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00072	3b c3		 cmp	 eax, ebx
  00074	0f 43 d8	 cmovae	 ebx, eax
  00077	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  0007d	0f 87 85 00 00
	00		 ja	 $LN107@push_back

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00083	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]

; 227  :     if (_Bytes == 0) {

  0008a	85 c0		 test	 eax, eax
  0008c	75 04		 jne	 SHORT $LN30@push_back

; 228  :         return nullptr;

  0008e	33 ff		 xor	 edi, edi
  00090	eb 1d		 jmp	 SHORT $LN29@push_back
$LN30@push_back:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00092	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00097	72 08		 jb	 SHORT $LN31@push_back

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009f	eb 06		 jmp	 SHORT $LN104@push_back
$LN31@push_back:

; 136  :         return ::operator new(_Bytes);

  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN104@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR __Whereptr$1$[ebp]
  000aa	8b f8		 mov	 edi, eax
  000ac	83 c4 04	 add	 esp, 4
$LN29@push_back:
  000af	8b 45 f4	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  000b2	8d 14 87	 lea	 edx, DWORD PTR [edi+eax*4]
  000b5	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000b8	89 55 f4	 mov	 DWORD PTR tv583[ebp], edx
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	89 02		 mov	 DWORD PTR [edx], eax

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000bf	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c2	8b 16		 mov	 edx, DWORD PTR [esi]
  000c4	3b c8		 cmp	 ecx, eax
  000c6	75 04		 jne	 SHORT $LN10@push_back
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000c8	8b cf		 mov	 ecx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000ca	eb 17		 jmp	 SHORT $LN59@push_back
$LN10@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cc	57		 push	 edi
  000cd	51		 push	 ecx
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000d4	8b 4d f4	 mov	 ecx, DWORD PTR tv583[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000da	8b 55 fc	 mov	 edx, DWORD PTR __Whereptr$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000dd	83 c1 04	 add	 ecx, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000e0	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
$LN59@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 900  :         _Guard._New_begin = nullptr;

  000e3	51		 push	 ecx
  000e4	50		 push	 eax
  000e5	52		 push	 edx
  000e6	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSEffectMeshData@CEffectMesh@@PAPAU12@@std@@YAPAPAUSEffectMeshData@CEffectMesh@@PAPAU12@00@Z ; std::_Copy_memmove<CEffectMesh::SEffectMeshData * *,CEffectMesh::SEffectMeshData * *>
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000ee	8b ce		 mov	 ecx, esi
  000f0	53		 push	 ebx
  000f1	ff 75 f8	 push	 DWORD PTR __Newsize$1$[ebp]
  000f4	57		 push	 edi
  000f5	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@AAEXQAPAUSEffectMeshData@CEffectMesh@@II@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Change_array

; 919  :     }

  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 04 00	 ret	 4
$LN106@push_back:

; 873  :             _Xlength();

  00103	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@CAXXZ ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::_Xlength
$LN107@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00108	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN103@push_back:
  0010d	cc		 int	 3
?push_back@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXABQAUSEffectMeshData@CEffectMesh@@@Z ENDP ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z
_TEXT	SEGMENT
_stTokenVector$4 = -540					; size = 12
_textFileLoader$5 = -528				; size = 16
__My_data$1$ = -512					; size = 4
_pMotionData$6 = -508					; size = 4
_n$1$ = -504						; size = 4
_iIndexVector$ = -500					; size = 12
_v3TextureVertexVector$ = -488				; size = 12
_iTextureIndexVector$ = -476				; size = 12
_v3VertexVector$ = -464					; size = 12
__Result$1$ = -452					; size = 4
_i$1$ = -452						; size = 4
_this$GSCopy$1$ = -448					; size = 4
_pMeshData$1$ = -444					; size = 4
tv2820 = -440						; size = 4
__Old_capacity$1$ = -440				; size = 4
__Newlast$1$ = -440					; size = 4
__Result$2$ = -436					; size = 4
__Oldsize$1$ = -436					; size = 4
_pImage$7 = -436					; size = 4
_pImage$8 = -436					; size = 4
_c_pbBuf$GSCopy$4$ = -432				; size = 4
__Oldsize$1$ = -428					; size = 4
tv2904 = -428						; size = 4
_j$1$ = -428						; size = 4
tv2848 = -428						; size = 4
__My_data$1$ = -424					; size = 4
_i$1$ = -424						; size = 4
$T9 = -420						; size = 4
tv2822 = -420						; size = 4
__Backout$2$sroa$1180$1$ = -420				; size = 4
__Backout$1$sroa$1181$1$ = -420				; size = 4
__Last$1$ = -420					; size = 4
$T10 = -413						; size = 1
$T11 = -413						; size = 1
$T12 = -413						; size = 1
$T13 = -413						; size = 1
$T14 = -413						; size = 1
$T15 = -413						; size = 1
_File$16 = -412						; size = 324
_strExtension$17 = -88					; size = 24
_strPathName$18 = -64					; size = 24
_strTextureFileName$19 = -40				; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iSize$ = 8						; size = 4
_c_pbBuf$ = 12						; size = 4
?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z PROC		; CEffectMesh::__LoadData_Ver002, COMDAT
; _this$ = ecx

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 10 02 00
	00		 sub	 esp, 528		; 00000210H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx
  0002f	89 bd 40 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  00035	8b 75 0c	 mov	 esi, DWORD PTR _c_pbBuf$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00038	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3VertexVector$[ebp], 0
  00042	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3VertexVector$[ebp+4], 0
  0004c	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3VertexVector$[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 103  : 	std::vector<D3DXVECTOR3> v3VertexVector;

  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0005d	c7 85 0c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp], 0
  00067	c7 85 10 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp+4], 0
  00071	c7 85 14 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp+8], 0
  0007b	c7 85 18 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp], 0
  00085	c7 85 1c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], 0
  0008f	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp+8], 0
  00099	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp], 0
  000a3	c7 85 28 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], 0
  000ad	c7 85 2c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 108  : 	m_iGeomCount = *(int *)c_pbBuf;

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  000b9	8d 4f 34	 lea	 ecx, DWORD PTR [edi+52]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 108  : 	m_iGeomCount = *(int *)c_pbBuf;

  000bc	89 47 2c	 mov	 DWORD PTR [edi+44], eax

; 109  : 	c_pbBuf += 4;
; 110  : 	m_iFrameCount = *(int *)c_pbBuf;

  000bf	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 111  : 	c_pbBuf += 4;

  000c2	83 c6 08	 add	 esi, 8
  000c5	89 47 30	 mov	 DWORD PTR [edi+48], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000c8	8b 01		 mov	 eax, DWORD PTR [ecx]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 106  : 	std::vector<int> iTextureIndexVector;

  000ca	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  000ce	89 8d 00 fe ff
	ff		 mov	 DWORD PTR __My_data$1$[ebp], ecx

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000d4	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000d7	74 03		 je	 SHORT $LN676@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  000d9	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN676@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 114  : 	m_pEffectMeshDataVector.resize(m_iGeomCount);

  000dc	ff 77 2c	 push	 DWORD PTR [edi+44]
  000df	e8 00 00 00 00	 call	 ?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::resize

; 116  : 	for (short n = 0; n < m_iGeomCount; ++n)

  000e4	83 7f 2c 00	 cmp	 DWORD PTR [edi+44], 0
  000e8	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  000f2	0f 8e a0 09 00
	00		 jle	 $LN726@LoadData_V
$LL4@LoadData_V:

; 118  : 		SEffectMeshData * pMeshData = SEffectMeshData::New();

  000f8	e8 00 00 00 00	 call	 ?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ ; CEffectMesh::SEffectMeshData::New

; 120  : 		memcpy(pMeshData->szObjectName, c_pbBuf, 32);

  000fd	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00100	8b d0		 mov	 edx, eax

; 121  : 		c_pbBuf += 32;
; 122  : 		memcpy(pMeshData->szDiffuseMapFileName, c_pbBuf, 128);

  00102	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  00107	8d 82 a0 00 00
	00		 lea	 eax, DWORD PTR [edx+160]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 118  : 		SEffectMeshData * pMeshData = SEffectMeshData::New();

  0010d	89 95 44 fe ff
	ff		 mov	 DWORD PTR _pMeshData$1$[ebp], edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  00113	89 85 58 fe ff
	ff		 mov	 DWORD PTR __My_data$1$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 120  : 		memcpy(pMeshData->szObjectName, c_pbBuf, 32);

  00119	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0

; 121  : 		c_pbBuf += 32;
; 122  : 		memcpy(pMeshData->szDiffuseMapFileName, c_pbBuf, 128);

  0011c	8d 7a 20	 lea	 edi, DWORD PTR [edx+32]
  0011f	0f 10 46 10	 movups	 xmm0, XMMWORD PTR [esi+16]
  00123	83 c6 20	 add	 esi, 32			; 00000020H
  00126	89 b5 50 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], esi

; 123  : 		c_pbBuf += 128;

  0012c	83 ad 50 fe ff
	ff 80		 sub	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], -128 ; ffffff80H
  00133	0f 11 42 10	 movups	 XMMWORD PTR [edx+16], xmm0
  00137	f3 a5		 rep movsd
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00139	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0013c	8b 30		 mov	 esi, DWORD PTR [eax]
  0013e	89 8d 5c fe ff
	ff		 mov	 DWORD PTR __Last$1$[ebp], ecx
  00144	3b f1		 cmp	 esi, ecx
  00146	74 28		 je	 SHORT $LN562@LoadData_V
  00148	8b f9		 mov	 edi, ecx
  0014a	66 0f 1f 44 00
	00		 npad	 6
$LL569@LoadData_V:
  00150	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00153	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00158	83 c6 20	 add	 esi, 32			; 00000020H
  0015b	3b f7		 cmp	 esi, edi
  0015d	75 f1		 jne	 SHORT $LL569@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1807 :         _Mylast = _Myfirst;

  0015f	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
  00165	8b 08		 mov	 ecx, DWORD PTR [eax]
  00167	89 8d 5c fe ff
	ff		 mov	 DWORD PTR __Last$1$[ebp], ecx
  0016d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN562@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 126  : 		pMeshData->EffectFrameDataVector.resize(m_iFrameCount);

  00170	8b bd 40 fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00176	8b d1		 mov	 edx, ecx
  00178	8b 30		 mov	 esi, DWORD PTR [eax]
  0017a	2b d6		 sub	 edx, esi
  0017c	c1 fa 05	 sar	 edx, 5
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 126  : 		pMeshData->EffectFrameDataVector.resize(m_iFrameCount);

  0017f	8b 7f 30	 mov	 edi, DWORD PTR [edi+48]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1581 :         if (_Newsize < _Oldsize) { // trim

  00182	3b fa		 cmp	 edi, edx
  00184	0f 83 ec 00 00
	00		 jae	 $LN541@LoadData_V

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  0018a	c1 e7 05	 shl	 edi, 5
  0018d	03 fe		 add	 edi, esi
  0018f	89 bd 48 fe ff
	ff		 mov	 DWORD PTR __Newlast$1$[ebp], edi

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);

  00195	8b f7		 mov	 esi, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00197	3b f9		 cmp	 edi, ecx
  00199	74 21		 je	 SHORT $LN547@LoadData_V
  0019b	8b bd 5c fe ff
	ff		 mov	 edi, DWORD PTR __Last$1$[ebp]
$LL548@LoadData_V:
  001a1	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  001a4	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  001a9	83 c6 20	 add	 esi, 32			; 00000020H
  001ac	3b f7		 cmp	 esi, edi
  001ae	75 f1		 jne	 SHORT $LL548@LoadData_V
  001b0	8b bd 48 fe ff
	ff		 mov	 edi, DWORD PTR __Newlast$1$[ebp]
  001b6	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
$LN547@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1586 :             _Mylast = _Newlast;

  001bc	89 78 04	 mov	 DWORD PTR [eax+4], edi
$LN755@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 128  : 		for(int i = 0; i < m_iFrameCount; ++i)

  001bf	8b b5 58 fe ff
	ff		 mov	 esi, DWORD PTR __My_data$1$[ebp]
$LN542@LoadData_V:
  001c5	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  001cb	c7 85 3c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1$[ebp], 0
  001d5	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  001d9	0f 8e 4c 03 00
	00		 jle	 $LN6@LoadData_V
  001df	33 c0		 xor	 eax, eax
  001e1	89 85 48 fe ff
	ff		 mov	 DWORD PTR tv2820[ebp], eax
  001e7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@LoadData_V:

; 132  : 			memcpy(&rFrameData.byChangedFrame, c_pbBuf, sizeof(BYTE));

  001f0	8b 8d 50 fe ff
	ff		 mov	 ecx, DWORD PTR _c_pbBuf$GSCopy$4$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  001f6	8b 3e		 mov	 edi, DWORD PTR [esi]
  001f8	03 f8		 add	 edi, eax
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 132  : 			memcpy(&rFrameData.byChangedFrame, c_pbBuf, sizeof(BYTE));

  001fa	8a 01		 mov	 al, BYTE PTR [ecx]
  001fc	88 07		 mov	 BYTE PTR [edi], al

; 133  : 			c_pbBuf += sizeof(BYTE);
; 134  : 
; 135  : 			memcpy(&rFrameData.fVisibility, c_pbBuf, sizeof(float));

  001fe	8b 41 01	 mov	 eax, DWORD PTR [ecx+1]
  00201	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 136  : 			c_pbBuf += sizeof(float);
; 137  : 
; 138  : 			memcpy(&rFrameData.dwVertexCount, c_pbBuf, sizeof(DWORD));

  00204	8b 41 05	 mov	 eax, DWORD PTR [ecx+5]
  00207	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 139  : 			c_pbBuf += sizeof(DWORD);
; 140  : 
; 141  : 			memcpy(&rFrameData.dwIndexCount, c_pbBuf, sizeof(DWORD));

  0020a	8b 41 09	 mov	 eax, DWORD PTR [ecx+9]
  0020d	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 142  : 			c_pbBuf += sizeof(DWORD);
; 143  : 
; 144  : 			memcpy(&rFrameData.dwTextureVertexCount, c_pbBuf, sizeof(DWORD));

  00210	8b 41 0d	 mov	 eax, DWORD PTR [ecx+13]

; 145  : 			c_pbBuf += sizeof(DWORD);

  00213	83 c1 11	 add	 ecx, 17			; 00000011H
  00216	89 47 0c	 mov	 DWORD PTR [edi+12], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00219	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR _v3VertexVector$[ebp+4]
  0021f	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR _v3VertexVector$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 145  : 			c_pbBuf += sizeof(DWORD);

  00225	89 8d 50 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0022b	3b c2		 cmp	 eax, edx
  0022d	74 06		 je	 SHORT $LN298@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  0022f	89 85 34 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], eax
$LN298@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 148  : 			v3VertexVector.resize(rFrameData.dwVertexCount);

  00235	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00238	8b c8		 mov	 ecx, eax
  0023a	0f 44 ca	 cmove	 ecx, edx
  0023d	89 8d 5c fe ff
	ff		 mov	 DWORD PTR __Backout$1$sroa$1181$1$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00243	2b c8		 sub	 ecx, eax
  00245	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0024a	f7 e9		 imul	 ecx
  0024c	d1 fa		 sar	 edx, 1
  0024e	8b c2		 mov	 eax, edx
  00250	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00253	03 c2		 add	 eax, edx
  00255	89 85 54 fe ff
	ff		 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1581 :         if (_Newsize < _Oldsize) { // trim

  0025b	3b f0		 cmp	 esi, eax
  0025d	73 58		 jae	 SHORT $LN305@LoadData_V

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  0025f	8b 95 30 fe ff
	ff		 mov	 edx, DWORD PTR _v3VertexVector$[ebp]
  00265	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00268	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 1586 :             _Mylast = _Newlast;

  0026b	89 85 34 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], eax

; 1587 :             return;

  00271	e9 92 00 00 00	 jmp	 $LN306@LoadData_V
$LN541@LoadData_V:

; 1590 :         if (_Newsize > _Oldsize) { // append

  00276	0f 86 43 ff ff
	ff		 jbe	 $LN755@LoadData_V

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0027c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0027f	2b c6		 sub	 eax, esi

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  00281	8b b5 58 fe ff
	ff		 mov	 esi, DWORD PTR __My_data$1$[ebp]
  00287	c1 f8 05	 sar	 eax, 5
  0028a	3b f8		 cmp	 edi, eax
  0028c	76 14		 jbe	 SHORT $LN543@LoadData_V

; 1593 :                 _Resize_reallocate(_Newsize, _Val);

  0028e	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00294	8b ce		 mov	 ecx, esi
  00296	50		 push	 eax
  00297	57		 push	 edi
  00298	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Resize_reallocate<std::_Value_init_tag>

; 1594 :                 return;

  0029d	e9 23 ff ff ff	 jmp	 $LN542@LoadData_V
$LN543@LoadData_V:

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  002a2	56		 push	 esi
  002a3	2b fa		 sub	 edi, edx
  002a5	57		 push	 edi
  002a6	51		 push	 ecx
  002a7	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@YAPAUSEffectFrameData@CEffectMesh@@PAU12@IAAV?$allocator@USEffectFrameData@CEffectMesh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMesh::SEffectFrameData> >
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  002af	89 46 04	 mov	 DWORD PTR [esi+4], eax
  002b2	e9 0e ff ff ff	 jmp	 $LN542@LoadData_V
$LN305@LoadData_V:

; 1590 :         if (_Newsize > _Oldsize) { // append

  002b7	76 4f		 jbe	 SHORT $LN306@LoadData_V

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  002b9	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR _v3VertexVector$[ebp+8]
  002bf	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  002c4	2b 8d 30 fe ff
	ff		 sub	 ecx, DWORD PTR _v3VertexVector$[ebp]
  002ca	f7 e9		 imul	 ecx
  002cc	d1 fa		 sar	 edx, 1
  002ce	8b c2		 mov	 eax, edx
  002d0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002d3	03 c2		 add	 eax, edx

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  002d5	3b f0		 cmp	 esi, eax
  002d7	76 15		 jbe	 SHORT $LN307@LoadData_V

; 1593 :                 _Resize_reallocate(_Newsize, _Val);

  002d9	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  002df	50		 push	 eax
  002e0	56		 push	 esi
  002e1	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR _v3VertexVector$[ebp]
  002e7	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>

; 1594 :                 return;

  002ec	eb 1a		 jmp	 SHORT $LN306@LoadData_V
$LN307@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  002ee	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR __Backout$1$sroa$1181$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  002f4	2b b5 54 fe ff
	ff		 sub	 esi, DWORD PTR __Oldsize$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  002fa	74 06		 je	 SHORT $LN312@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1598 :             const pointer _Oldlast = _Mylast;

  002fc	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  002ff	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
$LN312@LoadData_V:

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00302	89 8d 34 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], ecx
$LN306@LoadData_V:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00308	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _iIndexVector$[ebp]
  0030e	3b 85 10 fe ff
	ff		 cmp	 eax, DWORD PTR _iIndexVector$[ebp+4]
  00314	74 06		 je	 SHORT $LN320@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  00316	89 85 10 fe ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp+4], eax
$LN320@LoadData_V:

; 1615 :         _Resize(_Newsize, _Value_init_tag{});

  0031c	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  00322	50		 push	 eax
  00323	ff 77 10	 push	 DWORD PTR [edi+16]
  00326	8d 8d 0c fe ff
	ff		 lea	 ecx, DWORD PTR _iIndexVector$[ebp]
  0032c	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize<std::_Value_init_tag>

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00331	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR _v3TextureVertexVector$[ebp]
  00337	3b 85 1c fe ff
	ff		 cmp	 eax, DWORD PTR _v3TextureVertexVector$[ebp+4]
  0033d	74 06		 je	 SHORT $LN324@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  0033f	89 85 1c fe ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], eax
$LN324@LoadData_V:

; 1615 :         _Resize(_Newsize, _Value_init_tag{});

  00345	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  0034b	50		 push	 eax
  0034c	ff 77 0c	 push	 DWORD PTR [edi+12]
  0034f	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _v3TextureVertexVector$[ebp]
  00355	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Resize<std::_Value_init_tag>

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0035a	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR _iTextureIndexVector$[ebp]
  00360	3b 85 28 fe ff
	ff		 cmp	 eax, DWORD PTR _iTextureIndexVector$[ebp+4]
  00366	74 06		 je	 SHORT $LN330@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  00368	89 85 28 fe ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], eax
$LN330@LoadData_V:

; 1615 :         _Resize(_Newsize, _Value_init_tag{});

  0036e	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00374	50		 push	 eax
  00375	ff 77 10	 push	 DWORD PTR [edi+16]
  00378	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR _iTextureIndexVector$[ebp]
  0037e	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize<std::_Value_init_tag>
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 156  : 			memcpy(&v3VertexVector[0], c_pbBuf, rFrameData.dwVertexCount*sizeof(D3DXVECTOR3));

  00383	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00386	8b b5 50 fe ff
	ff		 mov	 esi, DWORD PTR _c_pbBuf$GSCopy$4$[ebp]
  0038c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0038f	c1 e0 02	 shl	 eax, 2
  00392	50		 push	 eax
  00393	56		 push	 esi
  00394	ff b5 30 fe ff
	ff		 push	 DWORD PTR _v3VertexVector$[ebp]
  0039a	e8 00 00 00 00	 call	 _memcpy

; 157  : 			c_pbBuf += rFrameData.dwVertexCount*sizeof(D3DXVECTOR3);

  0039f	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003a2	83 c4 0c	 add	 esp, 12			; 0000000cH
  003a5	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  003a8	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]

; 158  : 			if (rFrameData.dwIndexCount) // @fixme027

  003ab	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  003ae	85 c0		 test	 eax, eax
  003b0	74 13		 je	 SHORT $LN14@LoadData_V

; 159  : 				memcpy(&iIndexVector[0], c_pbBuf, rFrameData.dwIndexCount*sizeof(int));

  003b2	c1 e0 02	 shl	 eax, 2
  003b5	50		 push	 eax
  003b6	56		 push	 esi
  003b7	ff b5 0c fe ff
	ff		 push	 DWORD PTR _iIndexVector$[ebp]
  003bd	e8 00 00 00 00	 call	 _memcpy
  003c2	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@LoadData_V:

; 160  : 			c_pbBuf += rFrameData.dwIndexCount*sizeof(int);

  003c5	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  003c8	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]

; 161  : 			memcpy(&v3TextureVertexVector[0], c_pbBuf, rFrameData.dwTextureVertexCount*sizeof(D3DXVECTOR2));

  003cb	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  003ce	c1 e0 03	 shl	 eax, 3
  003d1	50		 push	 eax
  003d2	56		 push	 esi
  003d3	ff b5 18 fe ff
	ff		 push	 DWORD PTR _v3TextureVertexVector$[ebp]
  003d9	e8 00 00 00 00	 call	 _memcpy

; 162  : 			c_pbBuf += rFrameData.dwTextureVertexCount*sizeof(D3DXVECTOR2);

  003de	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  003e1	83 c4 0c	 add	 esp, 12			; 0000000cH
  003e4	8d 34 c6	 lea	 esi, DWORD PTR [esi+eax*8]

; 163  : 			if (rFrameData.dwIndexCount) // @fixme027

  003e7	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  003ea	85 c0		 test	 eax, eax
  003ec	74 13		 je	 SHORT $LN15@LoadData_V

; 164  : 				memcpy(&iTextureIndexVector[0], c_pbBuf, rFrameData.dwIndexCount*sizeof(int));

  003ee	c1 e0 02	 shl	 eax, 2
  003f1	50		 push	 eax
  003f2	56		 push	 esi
  003f3	ff b5 24 fe ff
	ff		 push	 DWORD PTR _iTextureIndexVector$[ebp]
  003f9	e8 00 00 00 00	 call	 _memcpy
  003fe	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@LoadData_V:

; 165  : 			c_pbBuf += rFrameData.dwIndexCount*sizeof(int);

  00401	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00404	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00407	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  0040a	89 8d 5c fe ff
	ff		 mov	 DWORD PTR __Backout$2$sroa$1180$1$[ebp], ecx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 165  : 			c_pbBuf += rFrameData.dwIndexCount*sizeof(int);

  00410	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]
  00413	89 b5 50 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00419	3b d1		 cmp	 edx, ecx
  0041b	74 0b		 je	 SHORT $LN342@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  0041d	89 57 18	 mov	 DWORD PTR [edi+24], edx
  00420	8b ca		 mov	 ecx, edx
  00422	89 95 5c fe ff
	ff		 mov	 DWORD PTR __Backout$2$sroa$1180$1$[ebp], edx
$LN342@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 170  : 			rFrameData.PDTVertexVector.resize(rFrameData.dwIndexCount);

  00428	8b f0		 mov	 esi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0042a	8b c2		 mov	 eax, edx
  0042c	2b c8		 sub	 ecx, eax
  0042e	89 85 54 fe ff
	ff		 mov	 DWORD PTR tv2848[ebp], eax
  00434	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00439	f7 e9		 imul	 ecx
  0043b	c1 fa 03	 sar	 edx, 3
  0043e	8b c2		 mov	 eax, edx
  00440	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00443	03 c2		 add	 eax, edx
  00445	89 85 4c fe ff
	ff		 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1581 :         if (_Newsize < _Oldsize) { // trim

  0044b	3b f0		 cmp	 esi, eax
  0044d	0f 83 b6 01 00
	00		 jae	 $LN349@LoadData_V

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  00453	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR tv2848[ebp]
  00459	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  0045c	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 1586 :             _Mylast = _Newlast;

  0045f	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN753@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 171  : 			for (DWORD j = 0; j < rFrameData.dwIndexCount; ++j)

  00462	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
$LN350@LoadData_V:
  00465	33 d2		 xor	 edx, edx
  00467	89 95 54 fe ff
	ff		 mov	 DWORD PTR _j$1$[ebp], edx
  0046d	39 57 10	 cmp	 DWORD PTR [edi+16], edx
  00470	0f 86 84 00 00
	00		 jbe	 $LN5@LoadData_V
  00476	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  0047e	33 c9		 xor	 ecx, ecx
  00480	89 8d 5c fe ff
	ff		 mov	 DWORD PTR tv2822[ebp], ecx
$LL10@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00486	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 175  : 				DWORD dwIndex = iIndexVector[j];

  00488	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _iIndexVector$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0048e	03 f1		 add	 esi, ecx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 175  : 				DWORD dwIndex = iIndexVector[j];

  00490	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]

; 176  : 				DWORD dwTextureIndex = iTextureIndexVector[j];

  00493	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR _iTextureIndexVector$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00499	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 176  : 				DWORD dwTextureIndex = iTextureIndexVector[j];

  0049c	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0049f	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR _v3VertexVector$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 181  : 				rVertex.position = v3VertexVector[dwIndex];

  004a5	f3 0f 7e 04 88	 movq	 xmm0, QWORD PTR [eax+ecx*4]
  004aa	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  004ae	8b 44 88 08	 mov	 eax, DWORD PTR [eax+ecx*4+8]
  004b2	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 182  : 				rVertex.texCoord = v3TextureVertexVector[dwTextureIndex];

  004b5	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR _v3TextureVertexVector$[ebp]
  004bb	8b 0c d0	 mov	 ecx, DWORD PTR [eax+edx*8]
  004be	8b 44 d0 04	 mov	 eax, DWORD PTR [eax+edx*8+4]
  004c2	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _j$1$[ebp]
  004c8	89 46 10	 mov	 DWORD PTR [esi+16], eax
  004cb	42		 inc	 edx

; 183  : 				rVertex.texCoord.y *= -1;

  004cc	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  004d1	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  004d4	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  004d7	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR tv2822[ebp]
  004dd	f3 0f 59 c1	 mulss	 xmm0, xmm1
  004e1	83 c1 14	 add	 ecx, 20			; 00000014H
  004e4	89 95 54 fe ff
	ff		 mov	 DWORD PTR _j$1$[ebp], edx
  004ea	89 8d 5c fe ff
	ff		 mov	 DWORD PTR tv2822[ebp], ecx
  004f0	f3 0f 11 46 10	 movss	 DWORD PTR [esi+16], xmm0
  004f5	3b 57 10	 cmp	 edx, DWORD PTR [edi+16]
  004f8	72 8c		 jb	 SHORT $LL10@LoadData_V
$LN5@LoadData_V:

; 128  : 		for(int i = 0; i < m_iFrameCount; ++i)

  004fa	8b b5 3c fe ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
  00500	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00506	46		 inc	 esi
  00507	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR tv2820[ebp]
  0050d	83 c0 20	 add	 eax, 32			; 00000020H
  00510	89 b5 3c fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00516	89 85 48 fe ff
	ff		 mov	 DWORD PTR tv2820[ebp], eax
  0051c	3b 71 30	 cmp	 esi, DWORD PTR [ecx+48]
  0051f	8b b5 58 fe ff
	ff		 mov	 esi, DWORD PTR __My_data$1$[ebp]
  00525	0f 8c c5 fc ff
	ff		 jl	 $LL7@LoadData_V
$LN6@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  0052b	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR _pMeshData$1$[ebp]

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00531	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00537	8d b1 ac 00 00
	00		 lea	 esi, DWORD PTR [ecx+172]
  0053d	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  00540	74 03		 je	 SHORT $LN291@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  00542	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN291@LoadData_V:
  00545	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00548	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _strExtension$17[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0054f	0f 11 45 a8	 movups	 XMMWORD PTR _strExtension$17[ebp], xmm0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00553	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _strExtension$17[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0055a	c6 45 a8 00	 mov	 BYTE PTR _strExtension$17[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 192  : 		GetFileExtension(pMeshData->szDiffuseMapFileName, strlen(pMeshData->szDiffuseMapFileName), &strExtension);

  0055e	8d 79 20	 lea	 edi, DWORD PTR [ecx+32]
  00561	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00565	8b cf		 mov	 ecx, edi
  00567	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  0056a	66 0f 1f 44 00
	00		 npad	 6
$LL746@LoadData_V:
  00570	8a 01		 mov	 al, BYTE PTR [ecx]
  00572	41		 inc	 ecx
  00573	84 c0		 test	 al, al
  00575	75 f9		 jne	 SHORT $LL746@LoadData_V
  00577	8d 45 a8	 lea	 eax, DWORD PTR _strExtension$17[ebp]
  0057a	2b ca		 sub	 ecx, edx
  0057c	50		 push	 eax
  0057d	51		 push	 ecx
  0057e	57		 push	 edi
  0057f	e8 00 00 00 00	 call	 ?GetFileExtension@@YAXPBDHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetFileExtension

; 193  : 		stl_lowers(strExtension);

  00584	8d 45 a8	 lea	 eax, DWORD PTR _strExtension$17[ebp]
  00587	50		 push	 eax
  00588	e8 00 00 00 00	 call	 ?stl_lowers@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stl_lowers
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2876 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  0058d	8b 7d b8	 mov	 edi, DWORD PTR _strExtension$17[ebp+16]

; 425  :         const value_type* _Result = _Bx._Buf;

  00590	8d 4d a8	 lea	 ecx, DWORD PTR _strExtension$17[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 193  : 		stl_lowers(strExtension);

  00593	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2876 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00596	b8 03 00 00 00	 mov	 eax, 3

; 434  :         return _Myres > _Small_string_capacity;

  0059b	83 7d bc 0f	 cmp	 DWORD PTR _strExtension$17[ebp+20], 15 ; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 413  :         return _CSTD memcmp(_First1, _First2, _Count);

  0059f	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_03BNIHALFD@ifl@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  005a4	0f 47 4d a8	 cmova	 ecx, DWORD PTR _strExtension$17[ebp]

; 2876 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  005a8	83 ff 03	 cmp	 edi, 3
  005ab	0f 47 f8	 cmova	 edi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 413  :         return _CSTD memcmp(_First1, _First2, _Count);

  005ae	83 ef 04	 sub	 edi, 4
  005b1	72 11		 jb	 SHORT $LN749@LoadData_V
$LL750@LoadData_V:
  005b3	8b 01		 mov	 eax, DWORD PTR [ecx]
  005b5	3b 02		 cmp	 eax, DWORD PTR [edx]
  005b7	75 14		 jne	 SHORT $LN748@LoadData_V
  005b9	83 c1 04	 add	 ecx, 4
  005bc	83 c2 04	 add	 edx, 4
  005bf	83 ef 04	 sub	 edi, 4
  005c2	73 ef		 jae	 SHORT $LL750@LoadData_V
$LN749@LoadData_V:
  005c4	83 ff fc	 cmp	 edi, -4			; fffffffcH
  005c7	0f 84 ac 00 00
	00		 je	 $LN747@LoadData_V
$LN748@LoadData_V:
  005cd	8a 01		 mov	 al, BYTE PTR [ecx]
  005cf	3a 02		 cmp	 al, BYTE PTR [edx]
  005d1	75 2f		 jne	 SHORT $LN751@LoadData_V
  005d3	83 ff fd	 cmp	 edi, -3			; fffffffdH
  005d6	0f 84 9d 00 00
	00		 je	 $LN747@LoadData_V
  005dc	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  005df	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  005e2	75 1e		 jne	 SHORT $LN751@LoadData_V
  005e4	83 ff fe	 cmp	 edi, -2			; fffffffeH
  005e7	0f 84 8c 00 00
	00		 je	 $LN747@LoadData_V
  005ed	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  005f0	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  005f3	75 0d		 jne	 SHORT $LN751@LoadData_V
  005f5	83 ff ff	 cmp	 edi, -1
  005f8	74 7f		 je	 SHORT $LN747@LoadData_V
  005fa	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  005fd	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00600	74 77		 je	 SHORT $LN747@LoadData_V
$LN751@LoadData_V:
  00602	1b c0		 sbb	 eax, eax
  00604	83 c8 01	 or	 eax, 1
  00607	eb 72		 jmp	 SHORT $LN752@LoadData_V
$LN349@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1590 :         if (_Newsize > _Oldsize) { // append

  00609	0f 86 53 fe ff
	ff		 jbe	 $LN753@LoadData_V

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0060f	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00612	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00617	2b 8d 54 fe ff
	ff		 sub	 ecx, DWORD PTR tv2848[ebp]
  0061d	f7 e9		 imul	 ecx
  0061f	c1 fa 03	 sar	 edx, 3
  00622	8b c2		 mov	 eax, edx
  00624	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00627	03 c2		 add	 eax, edx

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  00629	3b f0		 cmp	 esi, eax
  0062b	76 15		 jbe	 SHORT $LN351@LoadData_V

; 1593 :                 _Resize_reallocate(_Newsize, _Val);

  0062d	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00633	50		 push	 eax
  00634	56		 push	 esi
  00635	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  00638	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Resize_reallocate<std::_Value_init_tag>

; 1594 :                 return;

  0063d	e9 20 fe ff ff	 jmp	 $LN753@LoadData_V
$LN351@LoadData_V:

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00642	2b b5 4c fe ff
	ff		 sub	 esi, DWORD PTR __Oldsize$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  00648	74 1e		 je	 SHORT $LN356@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  0064a	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR __Backout$2$sroa$1180$1$[ebp]
  00650	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]
  00653	c1 e6 02	 shl	 esi, 2
  00656	56		 push	 esi
  00657	6a 00		 push	 0
  00659	51		 push	 ecx
  0065a	e8 00 00 00 00	 call	 _memset
  0065f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00662	01 b5 5c fe ff
	ff		 add	 DWORD PTR __Backout$2$sroa$1180$1$[ebp], esi
$LN356@LoadData_V:
  00668	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR __Backout$2$sroa$1180$1$[ebp]
  0066e	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  00671	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00674	e9 ec fd ff ff	 jmp	 $LN350@LoadData_V
$LN747@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 413  :         return _CSTD memcmp(_First1, _First2, _Count);

  00679	33 c0		 xor	 eax, eax
$LN752@LoadData_V:

; 595  :     if (_Ans != 0) {

  0067b	85 c0		 test	 eax, eax
  0067d	0f 85 6f 03 00
	00		 jne	 $LN16@LoadData_V

; 596  :         return _Ans;
; 597  :     }
; 598  : 
; 599  :     if (_Left_size < _Right_size) {

  00683	83 7d b8 03	 cmp	 DWORD PTR _strExtension$17[ebp+16], 3
  00687	0f 82 65 03 00
	00		 jb	 $LN16@LoadData_V

; 600  :         return -1;
; 601  :     }
; 602  : 
; 603  :     if (_Left_size > _Right_size) {

  0068d	0f 87 5f 03 00
	00		 ja	 $LN16@LoadData_V
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 195  : 		if (0 == strExtension.compare("ifl"))

  00693	85 c0		 test	 eax, eax
  00695	0f 85 57 03 00
	00		 jne	 $LN16@LoadData_V

; 196  : 		{
; 197  : 			LPCVOID pMotionData;
; 198  : 			CMappedFile File;

  0069b	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$16[ebp]
  006a1	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 199  : 
; 200  : 			if (CEterPackManager::Instance().Get(File, pMeshData->szDiffuseMapFileName, &pMotionData))

  006a6	8b bd 44 fe ff
	ff		 mov	 edi, DWORD PTR _pMeshData$1$[ebp]
  006ac	8d 85 04 fe ff
	ff		 lea	 eax, DWORD PTR _pMotionData$6[ebp]
  006b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  006b8	50		 push	 eax
  006b9	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _File$16[ebp]
  006bf	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  006c3	8d 77 20	 lea	 esi, DWORD PTR [edi+32]
  006c6	56		 push	 esi
  006c7	50		 push	 eax
  006c8	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  006cd	84 c0		 test	 al, al
  006cf	0f 84 10 03 00
	00		 je	 $LN18@LoadData_V

; 201  : 			{
; 202  : 				CMemoryTextFileLoader textFileLoader;

  006d5	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  006db	e8 00 00 00 00	 call	 ??0CMemoryTextFileLoader@@QAE@XZ ; CMemoryTextFileLoader::CMemoryTextFileLoader
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  006e0	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$4[ebp], 0
  006ea	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$4[ebp+4], 0
  006f4	c7 85 ec fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$4[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 205  : 				textFileLoader.Bind(File.Size(), pMotionData);

  006fe	ff b5 04 fe ff
	ff		 push	 DWORD PTR _pMotionData$6[ebp]
  00704	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$16[ebp]
  0070a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0070e	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  00713	50		 push	 eax
  00714	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  0071a	e8 00 00 00 00	 call	 ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ; CMemoryTextFileLoader::Bind
  0071f	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00722	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPathName$18[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00729	0f 11 45 c0	 movups	 XMMWORD PTR _strPathName$18[ebp], xmm0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0072d	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPathName$18[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00734	c6 45 c0 00	 mov	 BYTE PTR _strPathName$18[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 208  : 				GetOnlyPathName(pMeshData->szDiffuseMapFileName, strPathName);

  00738	8d 45 c0	 lea	 eax, DWORD PTR _strPathName$18[ebp]
  0073b	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0073f	50		 push	 eax
  00740	56		 push	 esi
  00741	e8 00 00 00 00	 call	 ?GetOnlyPathName@@YAXPBDAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetOnlyPathName
  00746	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00749	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strTextureFileName$19[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00750	0f 11 45 d8	 movups	 XMMWORD PTR _strTextureFileName$19[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 208  : 				GetOnlyPathName(pMeshData->szDiffuseMapFileName, strPathName);

  00754	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00757	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strTextureFileName$19[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0075e	c6 45 d8 00	 mov	 BYTE PTR _strTextureFileName$19[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 211  : 				for (DWORD i = 0; i < textFileLoader.GetLineCount(); ++i)

  00762	33 f6		 xor	 esi, esi
  00764	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00768	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  0076e	89 b5 58 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00774	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  00779	85 c0		 test	 eax, eax
  0077b	0f 84 c5 01 00
	00		 je	 $LN12@LoadData_V
$LL13@LoadData_V:

; 212  : 				{
; 213  : 					const std::string & c_rstrFileName = textFileLoader.GetLineString(i);

  00781	56		 push	 esi
  00782	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  00788	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  0078d	89 85 3c fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2458 :         return _Mypair._Myval2._Mysize == 0;

  00793	83 c0 10	 add	 eax, 16			; 00000010H
  00796	89 85 54 fe ff
	ff		 mov	 DWORD PTR tv2904[ebp], eax
  0079c	83 38 00	 cmp	 DWORD PTR [eax], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 215  : 					if (c_rstrFileName.empty())

  0079f	0f 84 87 01 00
	00		 je	 $LN11@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  007a5	83 7d d4 0f	 cmp	 DWORD PTR _strPathName$18[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  007a9	8d 45 c0	 lea	 eax, DWORD PTR _strPathName$18[ebp]

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007ac	8b 4d ec	 mov	 ecx, DWORD PTR _strTextureFileName$19[ebp+20]

; 426  :         if (_Large_mode_engaged()) {

  007af	0f 47 45 c0	 cmova	 eax, DWORD PTR _strPathName$18[ebp]

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007b3	8b 7d d0	 mov	 edi, DWORD PTR _strPathName$18[ebp+16]

; 426  :         if (_Large_mode_engaged()) {

  007b6	89 85 4c fe ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007bc	89 8d 48 fe ff
	ff		 mov	 DWORD PTR __Old_capacity$1$[ebp], ecx
  007c2	3b f9		 cmp	 edi, ecx

; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  007c4	77 21		 ja	 SHORT $LN388@LoadData_V

; 434  :         return _Myres > _Small_string_capacity;

  007c6	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 1597 :             _Mypair._Myval2._Mysize = _Count;

  007c9	89 7d e8	 mov	 DWORD PTR _strTextureFileName$19[ebp+16], edi
  007cc	57		 push	 edi

; 416  :         value_type* _Result = _Bx._Buf;

  007cd	8d 75 d8	 lea	 esi, DWORD PTR _strTextureFileName$19[ebp]

; 417  :         if (_Large_mode_engaged()) {

  007d0	0f 47 75 d8	 cmova	 esi, DWORD PTR _strTextureFileName$19[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  007d4	50		 push	 eax
  007d5	56		 push	 esi
  007d6	e8 00 00 00 00	 call	 _memmove
  007db	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  007de	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 1600 :             _ASAN_STRING_CREATE(*this);
; 1601 :             return *this;

  007e2	e9 d1 00 00 00	 jmp	 $LN403@LoadData_V
$LN388@LoadData_V:

; 2962 :         if (_New_size > max_size()) {

  007e7	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  007ed	0f 87 df 03 00
	00		 ja	 $LN716@LoadData_V

; 2964 :         }
; 2965 : 
; 2966 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  007f3	8b f7		 mov	 esi, edi
  007f5	83 ce 0f	 or	 esi, 15			; 0000000fH

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  007f8	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  007fe	76 12		 jbe	 SHORT $LN409@LoadData_V

; 2944 :             return _Max;

  00800	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00805	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0080a	50		 push	 eax
  0080b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00810	eb 45		 jmp	 SHORT $LN760@LoadData_V
$LN409@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00812	8b d1		 mov	 edx, ecx
  00814	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00819	d1 ea		 shr	 edx, 1
  0081b	2b c2		 sub	 eax, edx
  0081d	3b c8		 cmp	 ecx, eax
  0081f	76 12		 jbe	 SHORT $LN410@LoadData_V

; 2948 :             return _Max;

  00821	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00826	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0082b	50		 push	 eax
  0082c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00831	eb 24		 jmp	 SHORT $LN760@LoadData_V
$LN410@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00833	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00836	3b f0		 cmp	 esi, eax
  00838	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0083b	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  0083e	85 c0		 test	 eax, eax
  00840	74 18		 je	 SHORT $LN759@LoadData_V
$LN423@LoadData_V:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00842	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00847	72 08		 jb	 SHORT $LN424@LoadData_V

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00849	50		 push	 eax
  0084a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0084f	eb 06		 jmp	 SHORT $LN760@LoadData_V
$LN424@LoadData_V:

; 136  :         return ::operator new(_Bytes);

  00851	50		 push	 eax
  00852	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN760@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  00857	83 c4 04	 add	 esp, 4
$LN759@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0085a	57		 push	 edi
  0085b	ff b5 4c fe ff
	ff		 push	 DWORD PTR __Result$2$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  00861	89 75 ec	 mov	 DWORD PTR _strTextureFileName$19[ebp+20], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00864	8b f0		 mov	 esi, eax
  00866	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  00867	89 85 5c fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  0086d	89 7d e8	 mov	 DWORD PTR _strTextureFileName$19[ebp+16], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00870	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  00875	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0087b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0087e	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  00882	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00885	76 2e		 jbe	 SHORT $LN402@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00887	8b 55 d8	 mov	 edx, DWORD PTR _strTextureFileName$19[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0088a	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0088d	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0088f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00895	72 14		 jb	 SHORT $LN452@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00897	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0089a	83 c1 23	 add	 ecx, 35			; 00000023H
  0089d	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0089f	83 c0 fc	 add	 eax, -4			; fffffffcH
  008a2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008a5	0f 87 2c 03 00
	00		 ja	 $LN659@LoadData_V
$LN452@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  008ab	51		 push	 ecx
  008ac	52		 push	 edx
  008ad	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008b2	83 c4 08	 add	 esp, 8
$LN402@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  008b5	89 75 d8	 mov	 DWORD PTR _strTextureFileName$19[ebp], esi
$LN403@LoadData_V:
  008b8	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]
  008be	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  008c2	76 02		 jbe	 SHORT $LN371@LoadData_V

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  008c4	8b 00		 mov	 eax, DWORD PTR [eax]
$LN371@LoadData_V:

; 1459 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  008c6	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR tv2904[ebp]
  008cc	ff 31		 push	 DWORD PTR [ecx]
  008ce	8d 4d d8	 lea	 ecx, DWORD PTR _strTextureFileName$19[ebp]
  008d1	50		 push	 eax
  008d2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 434  :         return _Myres > _Small_string_capacity;

  008d7	83 7d ec 0f	 cmp	 DWORD PTR _strTextureFileName$19[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  008db	8d 45 d8	 lea	 eax, DWORD PTR _strTextureFileName$19[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 221  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  008de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  008e4	0f 47 45 d8	 cmova	 eax, DWORD PTR _strTextureFileName$19[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 221  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  008e8	50		 push	 eax
  008e9	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  008ee	8b bd 44 fe ff
	ff		 mov	 edi, DWORD PTR _pMeshData$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 221  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  008f4	89 85 4c fe ff
	ff		 mov	 DWORD PTR _pImage$7[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  008fa	8b 8f b0 00 00
	00		 mov	 ecx, DWORD PTR [edi+176]
  00900	3b 8f b4 00 00
	00		 cmp	 ecx, DWORD PTR [edi+180]
  00906	74 0b		 je	 SHORT $LN472@LoadData_V

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00908	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  0090a	83 87 b0 00 00
	00 04		 add	 DWORD PTR [edi+176], 4

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00911	eb 13		 jmp	 SHORT $LN761@LoadData_V
$LN472@LoadData_V:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00913	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR _pImage$7[ebp]
  00919	50		 push	 eax
  0091a	51		 push	 ecx
  0091b	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00921	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
$LN761@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 211  : 				for (DWORD i = 0; i < textFileLoader.GetLineCount(); ++i)

  00926	8b b5 58 fe ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
$LN11@LoadData_V:
  0092c	46		 inc	 esi
  0092d	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  00933	89 b5 58 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00939	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  0093e	3b f0		 cmp	 esi, eax
  00940	0f 82 3b fe ff
	ff		 jb	 $LL13@LoadData_V
$LN12@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00946	8b 4d ec	 mov	 ecx, DWORD PTR _strTextureFileName$19[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 225  : 			}

  00949	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0094d	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00950	76 2c		 jbe	 SHORT $LN110@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00952	8b 55 d8	 mov	 edx, DWORD PTR _strTextureFileName$19[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00955	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00956	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00958	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0095e	72 14		 jb	 SHORT $LN121@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00960	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00963	83 c1 23	 add	 ecx, 35			; 00000023H
  00966	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00968	83 c0 fc	 add	 eax, -4			; fffffffcH
  0096b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0096e	0f 87 63 02 00
	00		 ja	 $LN659@LoadData_V
$LN121@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00974	51		 push	 ecx
  00975	52		 push	 edx
  00976	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0097b	83 c4 08	 add	 esp, 8
$LN110@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0097e	8b 4d d4	 mov	 ecx, DWORD PTR _strPathName$18[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  00981	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strTextureFileName$19[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00988	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strTextureFileName$19[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0098f	c6 45 d8 00	 mov	 BYTE PTR _strTextureFileName$19[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 225  : 			}

  00993	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00997	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0099a	76 2c		 jbe	 SHORT $LN147@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0099c	8b 55 c0	 mov	 edx, DWORD PTR _strPathName$18[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0099f	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009a0	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  009a2	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  009a8	72 14		 jb	 SHORT $LN158@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009aa	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  009ad	83 c1 23	 add	 ecx, 35			; 00000023H
  009b0	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009b2	83 c0 fc	 add	 eax, -4			; fffffffcH
  009b5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009b8	0f 87 19 02 00
	00		 ja	 $LN659@LoadData_V
$LN158@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  009be	51		 push	 ecx
  009bf	52		 push	 edx
  009c0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009c5	83 c4 08	 add	 esp, 8
$LN147@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 225  : 			}

  009c8	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  009ce	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPathName$18[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  009d5	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPathName$18[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  009dc	c6 45 c0 00	 mov	 BYTE PTR _strPathName$18[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 225  : 			}

  009e0	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
$LN18@LoadData_V:

; 226  : 		}

  009e5	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$16[ebp]
  009eb	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  009f0	eb 3a		 jmp	 SHORT $LN484@LoadData_V
$LN16@LoadData_V:

; 229  : 			CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(pMeshData->szDiffuseMapFileName);

  009f2	8b bd 44 fe ff
	ff		 mov	 edi, DWORD PTR _pMeshData$1$[ebp]
  009f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  009fe	8d 47 20	 lea	 eax, DWORD PTR [edi+32]
  00a01	50		 push	 eax
  00a02	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00a07	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 229  : 			CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(pMeshData->szDiffuseMapFileName);

  00a0a	89 85 4c fe ff
	ff		 mov	 DWORD PTR _pImage$8[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00a10	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00a13	74 08		 je	 SHORT $LN485@LoadData_V

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00a15	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00a17	83 46 04 04	 add	 DWORD PTR [esi+4], 4

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00a1b	eb 0f		 jmp	 SHORT $LN484@LoadData_V
$LN485@LoadData_V:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00a1d	8d 85 4c fe ff
	ff		 lea	 eax, DWORD PTR _pImage$8[ebp]
  00a23	50		 push	 eax
  00a24	51		 push	 ecx
  00a25	8b ce		 mov	 ecx, esi
  00a27	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
$LN484@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 236  : 		m_pEffectMeshDataVector[n] = pMeshData;

  00a2c	8b 85 00 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
  00a32	8b b5 08 fe ff
	ff		 mov	 esi, DWORD PTR _n$1$[ebp]
  00a38	0f bf ce	 movsx	 ecx, si

; 237  : 	}

  00a3b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00a3f	8b 00		 mov	 eax, DWORD PTR [eax]
  00a41	89 3c 88	 mov	 DWORD PTR [eax+ecx*4], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00a44	8b 4d bc	 mov	 ecx, DWORD PTR _strExtension$17[ebp+20]
  00a47	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00a4a	76 2c		 jbe	 SHORT $LN69@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a4c	8b 55 a8	 mov	 edx, DWORD PTR _strExtension$17[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00a4f	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a50	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00a52	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00a58	72 14		 jb	 SHORT $LN80@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a5a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00a5d	83 c1 23	 add	 ecx, 35			; 00000023H
  00a60	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a62	83 c0 fc	 add	 eax, -4			; fffffffcH
  00a65	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a68	0f 87 69 01 00
	00		 ja	 $LN659@LoadData_V
$LN80@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00a6e	51		 push	 ecx
  00a6f	52		 push	 edx
  00a70	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a75	83 c4 08	 add	 esp, 8
$LN69@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 116  : 	for (short n = 0; n < m_iGeomCount; ++n)

  00a78	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00a7e	46		 inc	 esi
  00a7f	0f bf c6	 movsx	 eax, si
  00a82	89 b5 08 fe ff
	ff		 mov	 DWORD PTR _n$1$[ebp], esi
  00a88	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  00a8b	7d 0b		 jge	 SHORT $LN726@LoadData_V
  00a8d	8b b5 50 fe ff
	ff		 mov	 esi, DWORD PTR _c_pbBuf$GSCopy$4$[ebp]
  00a93	e9 60 f6 ff ff	 jmp	 $LL4@LoadData_V
$LN726@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00a98	8b 95 24 fe ff
	ff		 mov	 edx, DWORD PTR _iTextureIndexVector$[ebp]
  00a9e	85 d2		 test	 edx, edx
  00aa0	74 51		 je	 SHORT $LN587@LoadData_V

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00aa2	8b 8d 2c fe ff
	ff		 mov	 ecx, DWORD PTR _iTextureIndexVector$[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00aa8	8b c2		 mov	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00aaa	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00aac	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00aaf	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00ab5	72 14		 jb	 SHORT $LN606@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00ab7	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00aba	83 c1 23	 add	 ecx, 35			; 00000023H
  00abd	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00abf	83 c0 fc	 add	 eax, -4			; fffffffcH
  00ac2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00ac5	0f 87 0c 01 00
	00		 ja	 $LN659@LoadData_V
$LN606@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00acb	51		 push	 ecx
  00acc	52		 push	 edx
  00acd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ad2	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00ad5	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp], 0

; 2081 :             _Mylast  = nullptr;

  00adf	c7 85 28 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], 0

; 2082 :             _Myend   = nullptr;

  00ae9	c7 85 2c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp+8], 0
$LN587@LoadData_V:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00af3	8b 95 18 fe ff
	ff		 mov	 edx, DWORD PTR _v3TextureVertexVector$[ebp]
  00af9	85 d2		 test	 edx, edx
  00afb	74 51		 je	 SHORT $LN615@LoadData_V

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00afd	8b 8d 20 fe ff
	ff		 mov	 ecx, DWORD PTR _v3TextureVertexVector$[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b03	8b c2		 mov	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b05	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b07	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00b0a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00b10	72 14		 jb	 SHORT $LN634@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b12	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00b15	83 c1 23	 add	 ecx, 35			; 00000023H
  00b18	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b1a	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b1d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b20	0f 87 b1 00 00
	00		 ja	 $LN659@LoadData_V
$LN634@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00b26	51		 push	 ecx
  00b27	52		 push	 edx
  00b28	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b2d	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00b30	c7 85 18 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp], 0

; 2081 :             _Mylast  = nullptr;

  00b3a	c7 85 1c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], 0

; 2082 :             _Myend   = nullptr;

  00b44	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp+8], 0
$LN615@LoadData_V:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00b4e	8b 95 0c fe ff
	ff		 mov	 edx, DWORD PTR _iIndexVector$[ebp]
  00b54	85 d2		 test	 edx, edx
  00b56	74 4d		 je	 SHORT $LN643@LoadData_V

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b58	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR _iIndexVector$[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b5e	8b c2		 mov	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b60	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b62	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00b65	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00b6b	72 10		 jb	 SHORT $LN662@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b6d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00b70	83 c1 23	 add	 ecx, 35			; 00000023H
  00b73	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b75	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b78	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b7b	77 5a		 ja	 SHORT $LN659@LoadData_V
$LN662@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00b7d	51		 push	 ecx
  00b7e	52		 push	 edx
  00b7f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b84	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00b87	c7 85 0c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp], 0

; 2081 :             _Mylast  = nullptr;

  00b91	c7 85 10 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp+4], 0

; 2082 :             _Myend   = nullptr;

  00b9b	c7 85 14 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp+8], 0
$LN643@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 239  : 	return TRUE;

  00ba5	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR _v3VertexVector$[ebp]
  00bab	e8 00 00 00 00	 call	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
  00bb0	b8 01 00 00 00	 mov	 eax, 1

; 240  : }

  00bb5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00bb8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00bbf	59		 pop	 ecx
  00bc0	5f		 pop	 edi
  00bc1	5e		 pop	 esi
  00bc2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bc5	33 cd		 xor	 ecx, ebp
  00bc7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bcc	8b e5		 mov	 esp, ebp
  00bce	5d		 pop	 ebp
  00bcf	c2 08 00	 ret	 8
$LN716@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2963 :             _Xlen_string(); // result too long

  00bd2	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN659@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 240  : }

  00bd7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN757@LoadData_V:
  00bdc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$0:
  00000	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR _v3VertexVector$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$1:
  0000b	8d 8d 0c fe ff
	ff		 lea	 ecx, DWORD PTR _iIndexVector$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$2:
  00016	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _v3TextureVertexVector$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$3:
  00021	8d 8d 24 fe ff
	ff		 lea	 ecx, DWORD PTR _iTextureIndexVector$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$4:
  0002c	8d 4d a8	 lea	 ecx, DWORD PTR _strExtension$17[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$5:
  00034	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$16[ebp]
  0003a	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$6:
  0003f	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$7:
  0004a	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _stTokenVector$4[ebp]
  00050	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$8:
  00055	8d 4d c0	 lea	 ecx, DWORD PTR _strPathName$18[ebp]
  00058	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z$9:
  0005d	8d 4d d8	 lea	 ecx, DWORD PTR _strTextureFileName$19[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00065	cc		 int	 3
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
__ehhandler$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z:
  0006a	90		 npad	 1
  0006b	90		 npad	 1
  0006c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00070	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00073	8b 8a e4 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-540]
  00079	33 c8		 xor	 ecx, eax
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00083	33 c8		 xor	 ecx, eax
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z
  0008f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z ENDP		; CEffectMesh::__LoadData_Ver002
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z
_TEXT	SEGMENT
_stTokenVector$4 = -552					; size = 12
_textFileLoader$5 = -540				; size = 16
__My_data$1$ = -524					; size = 4
_pMotionData$6 = -520					; size = 4
_n$1$ = -516						; size = 4
_i$1$ = -512						; size = 4
__Old_capacity$1$ = -508				; size = 4
_dwTextureVertexCount$1$ = -508				; size = 4
__Result$1$ = -504					; size = 4
_dwIndexCount$1$ = -504					; size = 4
_dwVertexCount$1$ = -500				; size = 4
tv2895 = -500						; size = 4
_iIndexVector$ = -496					; size = 12
_v3TextureVertexVector$ = -484				; size = 12
_iTextureIndexVector$ = -472				; size = 12
_v3VertexVector$ = -460					; size = 12
__Newlast$1$ = -448					; size = 4
tv2821 = -448						; size = 4
_this$GSCopy$1$ = -444					; size = 4
_c_pbBuf$GSCopy$4$ = -440				; size = 4
_pMeshData$1$ = -436					; size = 4
__Result$2$ = -432					; size = 4
__Oldsize$1$ = -432					; size = 4
_pImage$7 = -432					; size = 4
_pImage$8 = -432					; size = 4
tv2849 = -428						; size = 4
_j$1$ = -428						; size = 4
__Oldsize$1$ = -428					; size = 4
_i$1$ = -424						; size = 4
__My_data$1$ = -424					; size = 4
tv2823 = -420						; size = 4
__Backout$2$sroa$1179$1$ = -420				; size = 4
$T9 = -420						; size = 4
__Last$1$ = -420					; size = 4
__Backout$1$sroa$1181$1$ = -420				; size = 4
$T10 = -413						; size = 1
$T11 = -413						; size = 1
$T12 = -413						; size = 1
$T13 = -413						; size = 1
$T14 = -413						; size = 1
$T15 = -413						; size = 1
_File$16 = -412						; size = 324
_strExtension$17 = -88					; size = 24
_strPathName$18 = -64					; size = 24
_strTextureFileName$19 = -40				; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iSize$ = 8						; size = 4
_c_pbBuf$ = 12						; size = 4
?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z PROC		; CEffectMesh::__LoadData_Ver001, COMDAT
; _this$ = ecx

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 1c 02 00
	00		 sub	 esp, 540		; 0000021cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx
  0002f	89 b5 44 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi
  00035	8b 55 0c	 mov	 edx, DWORD PTR _c_pbBuf$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00038	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3VertexVector$[ebp], 0
  00042	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3VertexVector$[ebp+4], 0
  0004c	c7 85 3c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3VertexVector$[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 244  : 	std::vector<D3DXVECTOR3> v3VertexVector;

  00056	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0005d	c7 85 10 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp], 0
  00067	c7 85 14 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp+4], 0
  00071	c7 85 18 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp+8], 0
  0007b	c7 85 1c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp], 0
  00085	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], 0
  0008f	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp+8], 0
  00099	c7 85 28 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp], 0
  000a3	c7 85 2c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], 0
  000ad	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 249  : 	m_iGeomCount = *(int *)c_pbBuf;

  000b7	8b 02		 mov	 eax, DWORD PTR [edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  000b9	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 249  : 	m_iGeomCount = *(int *)c_pbBuf;

  000bc	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 250  : 	c_pbBuf += 4;
; 251  : 	m_iFrameCount = *(int *)c_pbBuf;

  000bf	8b 42 04	 mov	 eax, DWORD PTR [edx+4]

; 252  : 	c_pbBuf += 4;

  000c2	83 c2 08	 add	 edx, 8
  000c5	89 46 30	 mov	 DWORD PTR [esi+48], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000c8	8b 01		 mov	 eax, DWORD PTR [ecx]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 247  : 	std::vector<int> iTextureIndexVector;

  000ca	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 252  : 	c_pbBuf += 4;

  000ce	89 95 48 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  000d4	89 8d f4 fd ff
	ff		 mov	 DWORD PTR __My_data$1$[ebp], ecx

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000da	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000dd	74 03		 je	 SHORT $LN676@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  000df	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN676@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 255  : 	m_pEffectMeshDataVector.resize(m_iGeomCount);

  000e2	ff 76 2c	 push	 DWORD PTR [esi+44]
  000e5	e8 00 00 00 00	 call	 ?resize@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXI@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::resize

; 257  : 	for (short n = 0; n < m_iGeomCount; ++n)

  000ea	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  000ee	c7 85 fc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _n$1$[ebp], 0
  000f8	0f 8e c2 09 00
	00		 jle	 $LN726@LoadData_V
  000fe	66 90		 npad	 2
$LL4@LoadData_V:

; 258  : 	{
; 259  : 		SEffectMeshData * pMeshData = SEffectMeshData::New();

  00100	e8 00 00 00 00	 call	 ?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ ; CEffectMesh::SEffectMeshData::New
  00105	8b c8		 mov	 ecx, eax

; 260  : 
; 261  : 		memcpy(pMeshData->szObjectName, c_pbBuf, 32);

  00107	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR _c_pbBuf$GSCopy$4$[ebp]
  0010d	89 8d 4c fe ff
	ff		 mov	 DWORD PTR _pMeshData$1$[ebp], ecx
  00113	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]

; 262  : 		c_pbBuf += 32;
; 263  : 		memcpy(pMeshData->szDiffuseMapFileName, c_pbBuf, 128);

  00116	8d 79 20	 lea	 edi, DWORD PTR [ecx+32]
  00119	8d 70 20	 lea	 esi, DWORD PTR [eax+32]
  0011c	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  0011f	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00123	0f 11 41 10	 movups	 XMMWORD PTR [ecx+16], xmm0
  00127	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0012c	f3 a5		 rep movsd

; 264  : 		c_pbBuf += 128;
; 265  : 
; 266  : 		//
; 267  : 
; 268  : 		DWORD dwVertexCount;
; 269  : 		DWORD dwIndexCount;
; 270  : 		DWORD dwTextureVertexCount;
; 271  : 
; 272  : 		memcpy(&dwVertexCount, c_pbBuf, sizeof(DWORD));

  0012e	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  00134	89 8d 0c fe ff
	ff		 mov	 DWORD PTR _dwVertexCount$1$[ebp], ecx

; 273  : 		c_pbBuf += sizeof(DWORD);
; 274  : 
; 275  : 		memcpy(&dwIndexCount, c_pbBuf, sizeof(DWORD));

  0013a	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00140	89 8d 08 fe ff
	ff		 mov	 DWORD PTR _dwIndexCount$1$[ebp], ecx

; 278  : 		memcpy(&dwTextureVertexCount, c_pbBuf, sizeof(DWORD));

  00146	8b 88 a8 00 00
	00		 mov	 ecx, DWORD PTR [eax+168]

; 279  : 		c_pbBuf += sizeof(DWORD);

  0014c	05 ac 00 00 00	 add	 eax, 172		; 000000acH
  00151	89 85 48 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  00157	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR _pMeshData$1$[ebp]
  0015d	05 a0 00 00 00	 add	 eax, 160		; 000000a0H
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 278  : 		memcpy(&dwTextureVertexCount, c_pbBuf, sizeof(DWORD));

  00162	89 8d 04 fe ff
	ff		 mov	 DWORD PTR _dwTextureVertexCount$1$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  00168	89 85 58 fe ff
	ff		 mov	 DWORD PTR __My_data$1$[ebp], eax

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0016e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00171	8b 30		 mov	 esi, DWORD PTR [eax]
  00173	89 8d 5c fe ff
	ff		 mov	 DWORD PTR __Last$1$[ebp], ecx
  00179	3b f1		 cmp	 esi, ecx
  0017b	74 23		 je	 SHORT $LN562@LoadData_V
  0017d	8b f9		 mov	 edi, ecx
  0017f	90		 npad	 1
$LL569@LoadData_V:
  00180	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00183	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00188	83 c6 20	 add	 esi, 32			; 00000020H
  0018b	3b f7		 cmp	 esi, edi
  0018d	75 f1		 jne	 SHORT $LL569@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1807 :         _Mylast = _Myfirst;

  0018f	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
  00195	8b 08		 mov	 ecx, DWORD PTR [eax]
  00197	89 8d 5c fe ff
	ff		 mov	 DWORD PTR __Last$1$[ebp], ecx
  0019d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN562@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 282  : 		pMeshData->EffectFrameDataVector.resize(m_iFrameCount);

  001a0	8b bd 44 fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  001a6	8b d1		 mov	 edx, ecx
  001a8	8b 30		 mov	 esi, DWORD PTR [eax]
  001aa	2b d6		 sub	 edx, esi
  001ac	c1 fa 05	 sar	 edx, 5
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 282  : 		pMeshData->EffectFrameDataVector.resize(m_iFrameCount);

  001af	8b 7f 30	 mov	 edi, DWORD PTR [edi+48]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1581 :         if (_Newsize < _Oldsize) { // trim

  001b2	3b fa		 cmp	 edi, edx
  001b4	0f 83 dc 00 00
	00		 jae	 $LN541@LoadData_V

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  001ba	c1 e7 05	 shl	 edi, 5
  001bd	03 fe		 add	 edi, esi
  001bf	89 bd 40 fe ff
	ff		 mov	 DWORD PTR __Newlast$1$[ebp], edi

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);

  001c5	8b f7		 mov	 esi, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  001c7	3b f9		 cmp	 edi, ecx
  001c9	74 21		 je	 SHORT $LN547@LoadData_V
  001cb	8b bd 5c fe ff
	ff		 mov	 edi, DWORD PTR __Last$1$[ebp]
$LL548@LoadData_V:
  001d1	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  001d4	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  001d9	83 c6 20	 add	 esi, 32			; 00000020H
  001dc	3b f7		 cmp	 esi, edi
  001de	75 f1		 jne	 SHORT $LL548@LoadData_V
  001e0	8b bd 40 fe ff
	ff		 mov	 edi, DWORD PTR __Newlast$1$[ebp]
  001e6	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
$LN547@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1586 :             _Mylast = _Newlast;

  001ec	89 78 04	 mov	 DWORD PTR [eax+4], edi
$LN755@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 284  : 		for(int i = 0; i < m_iFrameCount; ++i)

  001ef	8b b5 58 fe ff
	ff		 mov	 esi, DWORD PTR __My_data$1$[ebp]
$LN542@LoadData_V:
  001f5	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  001fb	c7 85 00 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$1$[ebp], 0
  00205	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0
  00209	0f 8e 46 03 00
	00		 jle	 $LN6@LoadData_V
  0020f	33 c0		 xor	 eax, eax
  00211	89 85 40 fe ff
	ff		 mov	 DWORD PTR tv2821[ebp], eax
  00217	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00220	8b 3e		 mov	 edi, DWORD PTR [esi]
  00222	03 f8		 add	 edi, eax
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 288  : 			rFrameData.dwVertexCount = dwVertexCount;

  00224	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR _dwVertexCount$1$[ebp]
  0022a	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 289  : 			rFrameData.dwIndexCount = dwIndexCount;

  0022d	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR _dwIndexCount$1$[ebp]
  00233	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 290  : 			rFrameData.dwTextureVertexCount = dwTextureVertexCount;

  00236	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR _dwTextureVertexCount$1$[ebp]
  0023c	89 47 0c	 mov	 DWORD PTR [edi+12], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0023f	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR _v3VertexVector$[ebp+4]
  00245	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR _v3VertexVector$[ebp]
  0024b	3b c2		 cmp	 eax, edx
  0024d	74 06		 je	 SHORT $LN298@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  0024f	89 85 38 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], eax
$LN298@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 293  : 			v3VertexVector.resize(rFrameData.dwVertexCount);

  00255	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00258	8b c8		 mov	 ecx, eax
  0025a	0f 44 ca	 cmove	 ecx, edx
  0025d	89 8d 5c fe ff
	ff		 mov	 DWORD PTR __Backout$1$sroa$1181$1$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00263	2b c8		 sub	 ecx, eax
  00265	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0026a	f7 e9		 imul	 ecx
  0026c	d1 fa		 sar	 edx, 1
  0026e	8b c2		 mov	 eax, edx
  00270	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00273	03 c2		 add	 eax, edx
  00275	89 85 54 fe ff
	ff		 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1581 :         if (_Newsize < _Oldsize) { // trim

  0027b	3b f0		 cmp	 esi, eax
  0027d	73 58		 jae	 SHORT $LN305@LoadData_V

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  0027f	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR _v3VertexVector$[ebp]
  00285	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00288	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 1586 :             _Mylast = _Newlast;

  0028b	89 85 38 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], eax

; 1587 :             return;

  00291	e9 92 00 00 00	 jmp	 $LN306@LoadData_V
$LN541@LoadData_V:

; 1590 :         if (_Newsize > _Oldsize) { // append

  00296	0f 86 53 ff ff
	ff		 jbe	 $LN755@LoadData_V

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0029c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0029f	2b c6		 sub	 eax, esi

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  002a1	8b b5 58 fe ff
	ff		 mov	 esi, DWORD PTR __My_data$1$[ebp]
  002a7	c1 f8 05	 sar	 eax, 5
  002aa	3b f8		 cmp	 edi, eax
  002ac	76 14		 jbe	 SHORT $LN543@LoadData_V

; 1593 :                 _Resize_reallocate(_Newsize, _Val);

  002ae	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  002b4	8b ce		 mov	 ecx, esi
  002b6	50		 push	 eax
  002b7	57		 push	 edi
  002b8	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Resize_reallocate<std::_Value_init_tag>

; 1594 :                 return;

  002bd	e9 33 ff ff ff	 jmp	 $LN542@LoadData_V
$LN543@LoadData_V:

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  002c2	56		 push	 esi
  002c3	2b fa		 sub	 edi, edx
  002c5	57		 push	 edi
  002c6	51		 push	 ecx
  002c7	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@YAPAUSEffectFrameData@CEffectMesh@@PAU12@IAAV?$allocator@USEffectFrameData@CEffectMesh@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CEffectMesh::SEffectFrameData> >
  002cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  002cf	89 46 04	 mov	 DWORD PTR [esi+4], eax
  002d2	e9 1e ff ff ff	 jmp	 $LN542@LoadData_V
$LN305@LoadData_V:

; 1590 :         if (_Newsize > _Oldsize) { // append

  002d7	76 4f		 jbe	 SHORT $LN306@LoadData_V

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  002d9	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR _v3VertexVector$[ebp+8]
  002df	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  002e4	2b 8d 34 fe ff
	ff		 sub	 ecx, DWORD PTR _v3VertexVector$[ebp]
  002ea	f7 e9		 imul	 ecx
  002ec	d1 fa		 sar	 edx, 1
  002ee	8b c2		 mov	 eax, edx
  002f0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002f3	03 c2		 add	 eax, edx

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  002f5	3b f0		 cmp	 esi, eax
  002f7	76 15		 jbe	 SHORT $LN307@LoadData_V

; 1593 :                 _Resize_reallocate(_Newsize, _Val);

  002f9	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  002ff	50		 push	 eax
  00300	56		 push	 esi
  00301	8d 8d 34 fe ff
	ff		 lea	 ecx, DWORD PTR _v3VertexVector$[ebp]
  00307	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>

; 1594 :                 return;

  0030c	eb 1a		 jmp	 SHORT $LN306@LoadData_V
$LN307@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  0030e	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR __Backout$1$sroa$1181$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00314	2b b5 54 fe ff
	ff		 sub	 esi, DWORD PTR __Oldsize$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  0031a	74 06		 je	 SHORT $LN312@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1598 :             const pointer _Oldlast = _Mylast;

  0031c	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  0031f	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
$LN312@LoadData_V:

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00322	89 8d 38 fe ff
	ff		 mov	 DWORD PTR _v3VertexVector$[ebp+4], ecx
$LN306@LoadData_V:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00328	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR _iIndexVector$[ebp]
  0032e	3b 85 14 fe ff
	ff		 cmp	 eax, DWORD PTR _iIndexVector$[ebp+4]
  00334	74 06		 je	 SHORT $LN320@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  00336	89 85 14 fe ff
	ff		 mov	 DWORD PTR _iIndexVector$[ebp+4], eax
$LN320@LoadData_V:

; 1615 :         _Resize(_Newsize, _Value_init_tag{});

  0033c	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00342	50		 push	 eax
  00343	ff 77 10	 push	 DWORD PTR [edi+16]
  00346	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR _iIndexVector$[ebp]
  0034c	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize<std::_Value_init_tag>

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00351	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR _v3TextureVertexVector$[ebp]
  00357	3b 85 20 fe ff
	ff		 cmp	 eax, DWORD PTR _v3TextureVertexVector$[ebp+4]
  0035d	74 06		 je	 SHORT $LN324@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  0035f	89 85 20 fe ff
	ff		 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], eax
$LN324@LoadData_V:

; 1615 :         _Resize(_Newsize, _Value_init_tag{});

  00365	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  0036b	50		 push	 eax
  0036c	ff 77 0c	 push	 DWORD PTR [edi+12]
  0036f	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR _v3TextureVertexVector$[ebp]
  00375	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::_Resize<std::_Value_init_tag>

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0037a	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR _iTextureIndexVector$[ebp]
  00380	3b 85 2c fe ff
	ff		 cmp	 eax, DWORD PTR _iTextureIndexVector$[ebp+4]
  00386	74 06		 je	 SHORT $LN330@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  00388	89 85 2c fe ff
	ff		 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], eax
$LN330@LoadData_V:

; 1615 :         _Resize(_Newsize, _Value_init_tag{});

  0038e	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00394	50		 push	 eax
  00395	ff 77 10	 push	 DWORD PTR [edi+16]
  00398	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR _iTextureIndexVector$[ebp]
  0039e	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Resize<std::_Value_init_tag>
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 301  : 			memcpy(&rFrameData.fVisibility, c_pbBuf, sizeof(float));

  003a3	8b b5 48 fe ff
	ff		 mov	 esi, DWORD PTR _c_pbBuf$GSCopy$4$[ebp]
  003a9	8b 06		 mov	 eax, DWORD PTR [esi]

; 302  : 			c_pbBuf += sizeof(float);

  003ab	83 c6 04	 add	 esi, 4
  003ae	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 303  : 			memcpy(&v3VertexVector[0], c_pbBuf, rFrameData.dwVertexCount*sizeof(D3DXVECTOR3));

  003b1	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003b4	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  003b7	c1 e0 02	 shl	 eax, 2
  003ba	50		 push	 eax
  003bb	56		 push	 esi
  003bc	ff b5 34 fe ff
	ff		 push	 DWORD PTR _v3VertexVector$[ebp]
  003c2	e8 00 00 00 00	 call	 _memcpy

; 304  : 			c_pbBuf += rFrameData.dwVertexCount*sizeof(D3DXVECTOR3);

  003c7	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  003ca	83 c4 0c	 add	 esp, 12			; 0000000cH
  003cd	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  003d0	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]

; 305  : 			if (rFrameData.dwIndexCount) // @fixme027

  003d3	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  003d6	85 c0		 test	 eax, eax
  003d8	74 13		 je	 SHORT $LN14@LoadData_V

; 306  : 				memcpy(&iIndexVector[0], c_pbBuf, rFrameData.dwIndexCount*sizeof(int));

  003da	c1 e0 02	 shl	 eax, 2
  003dd	50		 push	 eax
  003de	56		 push	 esi
  003df	ff b5 10 fe ff
	ff		 push	 DWORD PTR _iIndexVector$[ebp]
  003e5	e8 00 00 00 00	 call	 _memcpy
  003ea	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN14@LoadData_V:

; 307  : 			c_pbBuf += rFrameData.dwIndexCount*sizeof(int);

  003ed	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  003f0	8d 34 86	 lea	 esi, DWORD PTR [esi+eax*4]

; 308  : 			memcpy(&v3TextureVertexVector[0], c_pbBuf, rFrameData.dwTextureVertexCount*sizeof(D3DXVECTOR2));

  003f3	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  003f6	c1 e0 03	 shl	 eax, 3
  003f9	50		 push	 eax
  003fa	56		 push	 esi
  003fb	ff b5 1c fe ff
	ff		 push	 DWORD PTR _v3TextureVertexVector$[ebp]
  00401	e8 00 00 00 00	 call	 _memcpy

; 309  : 			c_pbBuf += rFrameData.dwTextureVertexCount*sizeof(D3DXVECTOR2);

  00406	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  00409	83 c4 0c	 add	 esp, 12			; 0000000cH
  0040c	8d 34 c6	 lea	 esi, DWORD PTR [esi+eax*8]

; 310  : 			if (rFrameData.dwIndexCount) // @fixme027

  0040f	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00412	85 c0		 test	 eax, eax
  00414	74 13		 je	 SHORT $LN15@LoadData_V

; 311  : 				memcpy(&iTextureIndexVector[0], c_pbBuf, rFrameData.dwIndexCount*sizeof(int));

  00416	c1 e0 02	 shl	 eax, 2
  00419	50		 push	 eax
  0041a	56		 push	 esi
  0041b	ff b5 28 fe ff
	ff		 push	 DWORD PTR _iTextureIndexVector$[ebp]
  00421	e8 00 00 00 00	 call	 _memcpy
  00426	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN15@LoadData_V:

; 312  : 			c_pbBuf += rFrameData.dwIndexCount*sizeof(int);

  00429	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0042c	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  0042f	89 8d 5c fe ff
	ff		 mov	 DWORD PTR __Backout$2$sroa$1179$1$[ebp], ecx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 312  : 			c_pbBuf += rFrameData.dwIndexCount*sizeof(int);

  00435	8d 14 86	 lea	 edx, DWORD PTR [esi+eax*4]
  00438	89 95 48 fe ff
	ff		 mov	 DWORD PTR _c_pbBuf$GSCopy$4$[ebp], edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0043e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00441	3b d1		 cmp	 edx, ecx
  00443	74 0b		 je	 SHORT $LN342@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  00445	89 57 18	 mov	 DWORD PTR [edi+24], edx
  00448	8b ca		 mov	 ecx, edx
  0044a	89 95 5c fe ff
	ff		 mov	 DWORD PTR __Backout$2$sroa$1179$1$[ebp], edx
$LN342@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 317  : 			rFrameData.PDTVertexVector.resize(rFrameData.dwIndexCount);

  00450	8b f0		 mov	 esi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00452	8b c2		 mov	 eax, edx
  00454	2b c8		 sub	 ecx, eax
  00456	89 85 54 fe ff
	ff		 mov	 DWORD PTR tv2849[ebp], eax
  0045c	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00461	f7 e9		 imul	 ecx
  00463	c1 fa 03	 sar	 edx, 3
  00466	8b c2		 mov	 eax, edx
  00468	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0046b	03 c2		 add	 eax, edx
  0046d	89 85 50 fe ff
	ff		 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1581 :         if (_Newsize < _Oldsize) { // trim

  00473	3b f0		 cmp	 esi, eax
  00475	0f 83 b2 01 00
	00		 jae	 $LN349@LoadData_V

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  0047b	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR tv2849[ebp]
  00481	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00484	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 1586 :             _Mylast = _Newlast;

  00487	89 47 18	 mov	 DWORD PTR [edi+24], eax
$LN753@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 318  : 			for (DWORD j = 0; j < rFrameData.dwIndexCount; ++j)

  0048a	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
$LN350@LoadData_V:
  0048d	33 d2		 xor	 edx, edx
  0048f	89 95 54 fe ff
	ff		 mov	 DWORD PTR _j$1$[ebp], edx
  00495	39 57 10	 cmp	 DWORD PTR [edi+16], edx
  00498	0f 86 86 00 00
	00		 jbe	 $LN5@LoadData_V
  0049e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  004a6	33 c9		 xor	 ecx, ecx
  004a8	89 8d 5c fe ff
	ff		 mov	 DWORD PTR tv2823[ebp], ecx
  004ae	66 90		 npad	 2
$LL10@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  004b0	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 322  : 				DWORD dwIndex = iIndexVector[j];

  004b2	8b 85 10 fe ff
	ff		 mov	 eax, DWORD PTR _iIndexVector$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  004b8	03 f1		 add	 esi, ecx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 322  : 				DWORD dwIndex = iIndexVector[j];

  004ba	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]

; 323  : 				DWORD dwTextureIndex = iTextureIndexVector[j];

  004bd	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR _iTextureIndexVector$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  004c3	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 323  : 				DWORD dwTextureIndex = iTextureIndexVector[j];

  004c6	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  004c9	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR _v3VertexVector$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 328  : 				rVertex.position = v3VertexVector[dwIndex];

  004cf	f3 0f 7e 04 88	 movq	 xmm0, QWORD PTR [eax+ecx*4]
  004d4	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  004d8	8b 44 88 08	 mov	 eax, DWORD PTR [eax+ecx*4+8]
  004dc	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 329  : 				rVertex.texCoord = v3TextureVertexVector[dwTextureIndex];

  004df	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR _v3TextureVertexVector$[ebp]
  004e5	8b 0c d0	 mov	 ecx, DWORD PTR [eax+edx*8]
  004e8	8b 44 d0 04	 mov	 eax, DWORD PTR [eax+edx*8+4]
  004ec	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _j$1$[ebp]
  004f2	89 46 10	 mov	 DWORD PTR [esi+16], eax
  004f5	42		 inc	 edx

; 330  : 				rVertex.texCoord.y *= -1;

  004f6	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  004fb	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  004fe	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00501	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR tv2823[ebp]
  00507	f3 0f 59 c1	 mulss	 xmm0, xmm1
  0050b	83 c1 14	 add	 ecx, 20			; 00000014H
  0050e	89 95 54 fe ff
	ff		 mov	 DWORD PTR _j$1$[ebp], edx
  00514	89 8d 5c fe ff
	ff		 mov	 DWORD PTR tv2823[ebp], ecx
  0051a	f3 0f 11 46 10	 movss	 DWORD PTR [esi+16], xmm0
  0051f	3b 57 10	 cmp	 edx, DWORD PTR [edi+16]
  00522	72 8c		 jb	 SHORT $LL10@LoadData_V
$LN5@LoadData_V:

; 284  : 		for(int i = 0; i < m_iFrameCount; ++i)

  00524	8b 8d 00 fe ff
	ff		 mov	 ecx, DWORD PTR _i$1$[ebp]
  0052a	8b 95 44 fe ff
	ff		 mov	 edx, DWORD PTR _this$GSCopy$1$[ebp]
  00530	41		 inc	 ecx
  00531	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR tv2821[ebp]
  00537	8b b5 58 fe ff
	ff		 mov	 esi, DWORD PTR __My_data$1$[ebp]
  0053d	83 c0 20	 add	 eax, 32			; 00000020H
  00540	89 8d 00 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ecx
  00546	89 85 40 fe ff
	ff		 mov	 DWORD PTR tv2821[ebp], eax
  0054c	3b 4a 30	 cmp	 ecx, DWORD PTR [edx+48]
  0054f	0f 8c cb fc ff
	ff		 jl	 $LL7@LoadData_V
$LN6@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  00555	8b 8d 4c fe ff
	ff		 mov	 ecx, DWORD PTR _pMeshData$1$[ebp]

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0055b	8b 81 ac 00 00
	00		 mov	 eax, DWORD PTR [ecx+172]
  00561	8d b1 ac 00 00
	00		 lea	 esi, DWORD PTR [ecx+172]
  00567	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0056a	74 03		 je	 SHORT $LN291@LoadData_V

; 1807 :         _Mylast = _Myfirst;

  0056c	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN291@LoadData_V:
  0056f	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00572	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _strExtension$17[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00579	0f 11 45 a8	 movups	 XMMWORD PTR _strExtension$17[ebp], xmm0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0057d	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR _strExtension$17[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00584	c6 45 a8 00	 mov	 BYTE PTR _strExtension$17[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 339  : 		GetFileExtension(pMeshData->szDiffuseMapFileName, strlen(pMeshData->szDiffuseMapFileName), &strExtension);

  00588	8d 79 20	 lea	 edi, DWORD PTR [ecx+32]
  0058b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0058f	8b cf		 mov	 ecx, edi
  00591	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL746@LoadData_V:
  00594	8a 01		 mov	 al, BYTE PTR [ecx]
  00596	41		 inc	 ecx
  00597	84 c0		 test	 al, al
  00599	75 f9		 jne	 SHORT $LL746@LoadData_V
  0059b	8d 45 a8	 lea	 eax, DWORD PTR _strExtension$17[ebp]
  0059e	2b ca		 sub	 ecx, edx
  005a0	50		 push	 eax
  005a1	51		 push	 ecx
  005a2	57		 push	 edi
  005a3	e8 00 00 00 00	 call	 ?GetFileExtension@@YAXPBDHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetFileExtension

; 340  : 		stl_lowers(strExtension);

  005a8	8d 45 a8	 lea	 eax, DWORD PTR _strExtension$17[ebp]
  005ab	50		 push	 eax
  005ac	e8 00 00 00 00	 call	 ?stl_lowers@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stl_lowers
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2876 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  005b1	8b 7d b8	 mov	 edi, DWORD PTR _strExtension$17[ebp+16]

; 425  :         const value_type* _Result = _Bx._Buf;

  005b4	8d 4d a8	 lea	 ecx, DWORD PTR _strExtension$17[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 340  : 		stl_lowers(strExtension);

  005b7	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2876 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  005ba	b8 03 00 00 00	 mov	 eax, 3

; 434  :         return _Myres > _Small_string_capacity;

  005bf	83 7d bc 0f	 cmp	 DWORD PTR _strExtension$17[ebp+20], 15 ; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 413  :         return _CSTD memcmp(_First1, _First2, _Count);

  005c3	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_03BNIHALFD@ifl@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  005c8	0f 47 4d a8	 cmova	 ecx, DWORD PTR _strExtension$17[ebp]

; 2876 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  005cc	83 ff 03	 cmp	 edi, 3
  005cf	0f 47 f8	 cmova	 edi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 413  :         return _CSTD memcmp(_First1, _First2, _Count);

  005d2	83 ef 04	 sub	 edi, 4
  005d5	72 11		 jb	 SHORT $LN749@LoadData_V
$LL750@LoadData_V:
  005d7	8b 01		 mov	 eax, DWORD PTR [ecx]
  005d9	3b 02		 cmp	 eax, DWORD PTR [edx]
  005db	75 14		 jne	 SHORT $LN748@LoadData_V
  005dd	83 c1 04	 add	 ecx, 4
  005e0	83 c2 04	 add	 edx, 4
  005e3	83 ef 04	 sub	 edi, 4
  005e6	73 ef		 jae	 SHORT $LL750@LoadData_V
$LN749@LoadData_V:
  005e8	83 ff fc	 cmp	 edi, -4			; fffffffcH
  005eb	0f 84 ac 00 00
	00		 je	 $LN747@LoadData_V
$LN748@LoadData_V:
  005f1	8a 01		 mov	 al, BYTE PTR [ecx]
  005f3	3a 02		 cmp	 al, BYTE PTR [edx]
  005f5	75 2f		 jne	 SHORT $LN751@LoadData_V
  005f7	83 ff fd	 cmp	 edi, -3			; fffffffdH
  005fa	0f 84 9d 00 00
	00		 je	 $LN747@LoadData_V
  00600	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00603	3a 42 01	 cmp	 al, BYTE PTR [edx+1]
  00606	75 1e		 jne	 SHORT $LN751@LoadData_V
  00608	83 ff fe	 cmp	 edi, -2			; fffffffeH
  0060b	0f 84 8c 00 00
	00		 je	 $LN747@LoadData_V
  00611	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00614	3a 42 02	 cmp	 al, BYTE PTR [edx+2]
  00617	75 0d		 jne	 SHORT $LN751@LoadData_V
  00619	83 ff ff	 cmp	 edi, -1
  0061c	74 7f		 je	 SHORT $LN747@LoadData_V
  0061e	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00621	3a 42 03	 cmp	 al, BYTE PTR [edx+3]
  00624	74 77		 je	 SHORT $LN747@LoadData_V
$LN751@LoadData_V:
  00626	1b c0		 sbb	 eax, eax
  00628	83 c8 01	 or	 eax, 1
  0062b	eb 72		 jmp	 SHORT $LN752@LoadData_V
$LN349@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1590 :         if (_Newsize > _Oldsize) { // append

  0062d	0f 86 57 fe ff
	ff		 jbe	 $LN753@LoadData_V

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00633	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00636	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0063b	2b 8d 54 fe ff
	ff		 sub	 ecx, DWORD PTR tv2849[ebp]
  00641	f7 e9		 imul	 ecx
  00643	c1 fa 03	 sar	 edx, 3
  00646	8b c2		 mov	 eax, edx
  00648	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0064b	03 c2		 add	 eax, edx

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  0064d	3b f0		 cmp	 esi, eax
  0064f	76 15		 jbe	 SHORT $LN351@LoadData_V

; 1593 :                 _Resize_reallocate(_Newsize, _Val);

  00651	8d 85 63 fe ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00657	50		 push	 eax
  00658	56		 push	 esi
  00659	8d 4f 14	 lea	 ecx, DWORD PTR [edi+20]
  0065c	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Resize_reallocate<std::_Value_init_tag>

; 1594 :                 return;

  00661	e9 24 fe ff ff	 jmp	 $LN753@LoadData_V
$LN351@LoadData_V:

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00666	2b b5 50 fe ff
	ff		 sub	 esi, DWORD PTR __Oldsize$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  0066c	74 1e		 je	 SHORT $LN356@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  0066e	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR __Backout$2$sroa$1179$1$[ebp]
  00674	8d 34 b6	 lea	 esi, DWORD PTR [esi+esi*4]
  00677	c1 e6 02	 shl	 esi, 2
  0067a	56		 push	 esi
  0067b	6a 00		 push	 0
  0067d	51		 push	 ecx
  0067e	e8 00 00 00 00	 call	 _memset
  00683	83 c4 0c	 add	 esp, 12			; 0000000cH
  00686	01 b5 5c fe ff
	ff		 add	 DWORD PTR __Backout$2$sroa$1179$1$[ebp], esi
$LN356@LoadData_V:
  0068c	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR __Backout$2$sroa$1179$1$[ebp]
  00692	8d 47 14	 lea	 eax, DWORD PTR [edi+20]
  00695	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00698	e9 f0 fd ff ff	 jmp	 $LN350@LoadData_V
$LN747@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 413  :         return _CSTD memcmp(_First1, _First2, _Count);

  0069d	33 c0		 xor	 eax, eax
$LN752@LoadData_V:

; 595  :     if (_Ans != 0) {

  0069f	85 c0		 test	 eax, eax
  006a1	0f 85 7a 03 00
	00		 jne	 $LN16@LoadData_V

; 596  :         return _Ans;
; 597  :     }
; 598  : 
; 599  :     if (_Left_size < _Right_size) {

  006a7	83 7d b8 03	 cmp	 DWORD PTR _strExtension$17[ebp+16], 3
  006ab	0f 82 70 03 00
	00		 jb	 $LN16@LoadData_V

; 600  :         return -1;
; 601  :     }
; 602  : 
; 603  :     if (_Left_size > _Right_size) {

  006b1	0f 87 6a 03 00
	00		 ja	 $LN16@LoadData_V
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 342  : 		if (0 == strExtension.compare("ifl"))

  006b7	85 c0		 test	 eax, eax
  006b9	0f 85 62 03 00
	00		 jne	 $LN16@LoadData_V

; 343  : 		{
; 344  : 			LPCVOID pMotionData;
; 345  : 			CMappedFile File;

  006bf	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$16[ebp]
  006c5	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 346  : 
; 347  : 			if (CEterPackManager::Instance().Get(File, pMeshData->szDiffuseMapFileName, &pMotionData))

  006ca	8b bd 4c fe ff
	ff		 mov	 edi, DWORD PTR _pMeshData$1$[ebp]
  006d0	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR _pMotionData$6[ebp]
  006d6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  006dc	50		 push	 eax
  006dd	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR _File$16[ebp]
  006e3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  006e7	8d 77 20	 lea	 esi, DWORD PTR [edi+32]
  006ea	56		 push	 esi
  006eb	50		 push	 eax
  006ec	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  006f1	84 c0		 test	 al, al
  006f3	0f 84 1b 03 00
	00		 je	 $LN18@LoadData_V

; 348  : 			{
; 349  : 				CMemoryTextFileLoader textFileLoader;

  006f9	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  006ff	e8 00 00 00 00	 call	 ??0CMemoryTextFileLoader@@QAE@XZ ; CMemoryTextFileLoader::CMemoryTextFileLoader
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00704	c7 85 d8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$4[ebp], 0
  0070e	c7 85 dc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$4[ebp+4], 0
  00718	c7 85 e0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$4[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 352  : 				textFileLoader.Bind(File.Size(), pMotionData);

  00722	ff b5 f8 fd ff
	ff		 push	 DWORD PTR _pMotionData$6[ebp]
  00728	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$16[ebp]
  0072e	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00732	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  00737	50		 push	 eax
  00738	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  0073e	e8 00 00 00 00	 call	 ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ; CMemoryTextFileLoader::Bind
  00743	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00746	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPathName$18[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0074d	0f 11 45 c0	 movups	 XMMWORD PTR _strPathName$18[ebp], xmm0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00751	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPathName$18[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00758	c6 45 c0 00	 mov	 BYTE PTR _strPathName$18[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 355  : 				GetOnlyPathName(pMeshData->szDiffuseMapFileName, strPathName);

  0075c	8d 45 c0	 lea	 eax, DWORD PTR _strPathName$18[ebp]
  0075f	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00763	50		 push	 eax
  00764	56		 push	 esi
  00765	e8 00 00 00 00	 call	 ?GetOnlyPathName@@YAXPBDAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetOnlyPathName
  0076a	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  0076d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strTextureFileName$19[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00774	0f 11 45 d8	 movups	 XMMWORD PTR _strTextureFileName$19[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 355  : 				GetOnlyPathName(pMeshData->szDiffuseMapFileName, strPathName);

  00778	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0077b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strTextureFileName$19[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00782	c6 45 d8 00	 mov	 BYTE PTR _strTextureFileName$19[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 358  : 				for (DWORD i = 0; i < textFileLoader.GetLineCount(); ++i)

  00786	33 f6		 xor	 esi, esi
  00788	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  0078c	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  00792	89 b5 58 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00798	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  0079d	85 c0		 test	 eax, eax
  0079f	0f 84 d0 01 00
	00		 je	 $LN12@LoadData_V
  007a5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL13@LoadData_V:

; 359  : 				{
; 360  : 					const std::string & c_rstrFileName = textFileLoader.GetLineString(i);

  007b0	56		 push	 esi
  007b1	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  007b7	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  007bc	89 85 08 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2458 :         return _Mypair._Myval2._Mysize == 0;

  007c2	83 c0 10	 add	 eax, 16			; 00000010H
  007c5	89 85 0c fe ff
	ff		 mov	 DWORD PTR tv2895[ebp], eax
  007cb	83 38 00	 cmp	 DWORD PTR [eax], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 362  : 					if (c_rstrFileName.empty())

  007ce	0f 84 87 01 00
	00		 je	 $LN11@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  007d4	83 7d d4 0f	 cmp	 DWORD PTR _strPathName$18[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  007d8	8d 45 c0	 lea	 eax, DWORD PTR _strPathName$18[ebp]

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007db	8b 4d ec	 mov	 ecx, DWORD PTR _strTextureFileName$19[ebp+20]

; 426  :         if (_Large_mode_engaged()) {

  007de	0f 47 45 c0	 cmova	 eax, DWORD PTR _strPathName$18[ebp]

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007e2	8b 7d d0	 mov	 edi, DWORD PTR _strPathName$18[ebp+16]

; 426  :         if (_Large_mode_engaged()) {

  007e5	89 85 50 fe ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  007eb	89 8d 04 fe ff
	ff		 mov	 DWORD PTR __Old_capacity$1$[ebp], ecx
  007f1	3b f9		 cmp	 edi, ecx

; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  007f3	77 21		 ja	 SHORT $LN388@LoadData_V

; 434  :         return _Myres > _Small_string_capacity;

  007f5	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 1597 :             _Mypair._Myval2._Mysize = _Count;

  007f8	89 7d e8	 mov	 DWORD PTR _strTextureFileName$19[ebp+16], edi
  007fb	57		 push	 edi

; 416  :         value_type* _Result = _Bx._Buf;

  007fc	8d 75 d8	 lea	 esi, DWORD PTR _strTextureFileName$19[ebp]

; 417  :         if (_Large_mode_engaged()) {

  007ff	0f 47 75 d8	 cmova	 esi, DWORD PTR _strTextureFileName$19[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00803	50		 push	 eax
  00804	56		 push	 esi
  00805	e8 00 00 00 00	 call	 _memmove
  0080a	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0080d	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 1600 :             _ASAN_STRING_CREATE(*this);
; 1601 :             return *this;

  00811	e9 d1 00 00 00	 jmp	 $LN403@LoadData_V
$LN388@LoadData_V:

; 2962 :         if (_New_size > max_size()) {

  00816	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  0081c	0f 87 dd 03 00
	00		 ja	 $LN716@LoadData_V

; 2964 :         }
; 2965 : 
; 2966 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  00822	8b f7		 mov	 esi, edi
  00824	83 ce 0f	 or	 esi, 15			; 0000000fH

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00827	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0082d	76 12		 jbe	 SHORT $LN409@LoadData_V

; 2944 :             return _Max;

  0082f	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00834	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00839	50		 push	 eax
  0083a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0083f	eb 45		 jmp	 SHORT $LN760@LoadData_V
$LN409@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00841	8b d1		 mov	 edx, ecx
  00843	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00848	d1 ea		 shr	 edx, 1
  0084a	2b c2		 sub	 eax, edx
  0084c	3b c8		 cmp	 ecx, eax
  0084e	76 12		 jbe	 SHORT $LN410@LoadData_V

; 2948 :             return _Max;

  00850	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00855	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0085a	50		 push	 eax
  0085b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00860	eb 24		 jmp	 SHORT $LN760@LoadData_V
$LN410@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00862	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00865	3b f0		 cmp	 esi, eax
  00867	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0086a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  0086d	85 c0		 test	 eax, eax
  0086f	74 18		 je	 SHORT $LN759@LoadData_V
$LN423@LoadData_V:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00871	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00876	72 08		 jb	 SHORT $LN424@LoadData_V

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00878	50		 push	 eax
  00879	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0087e	eb 06		 jmp	 SHORT $LN760@LoadData_V
$LN424@LoadData_V:

; 136  :         return ::operator new(_Bytes);

  00880	50		 push	 eax
  00881	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN760@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  00886	83 c4 04	 add	 esp, 4
$LN759@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00889	57		 push	 edi
  0088a	ff b5 50 fe ff
	ff		 push	 DWORD PTR __Result$2$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  00890	89 75 ec	 mov	 DWORD PTR _strTextureFileName$19[ebp+20], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00893	8b f0		 mov	 esi, eax
  00895	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  00896	89 85 5c fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  0089c	89 7d e8	 mov	 DWORD PTR _strTextureFileName$19[ebp+16], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0089f	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  008a4	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  008aa	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  008ad	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  008b1	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  008b4	76 2e		 jbe	 SHORT $LN402@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008b6	8b 55 d8	 mov	 edx, DWORD PTR _strTextureFileName$19[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  008b9	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008bc	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  008be	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  008c4	72 14		 jb	 SHORT $LN452@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  008c6	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  008c9	83 c1 23	 add	 ecx, 35			; 00000023H
  008cc	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  008ce	83 c0 fc	 add	 eax, -4			; fffffffcH
  008d1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008d4	0f 87 20 03 00
	00		 ja	 $LN659@LoadData_V
$LN452@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  008da	51		 push	 ecx
  008db	52		 push	 edx
  008dc	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008e1	83 c4 08	 add	 esp, 8
$LN402@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  008e4	89 75 d8	 mov	 DWORD PTR _strTextureFileName$19[ebp], esi
$LN403@LoadData_V:
  008e7	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]
  008ed	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  008f1	76 02		 jbe	 SHORT $LN371@LoadData_V

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  008f3	8b 00		 mov	 eax, DWORD PTR [eax]
$LN371@LoadData_V:

; 1459 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  008f5	8b 8d 0c fe ff
	ff		 mov	 ecx, DWORD PTR tv2895[ebp]
  008fb	ff 31		 push	 DWORD PTR [ecx]
  008fd	8d 4d d8	 lea	 ecx, DWORD PTR _strTextureFileName$19[ebp]
  00900	50		 push	 eax
  00901	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 434  :         return _Myres > _Small_string_capacity;

  00906	83 7d ec 0f	 cmp	 DWORD PTR _strTextureFileName$19[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  0090a	8d 45 d8	 lea	 eax, DWORD PTR _strTextureFileName$19[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 368  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  0090d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  00913	0f 47 45 d8	 cmova	 eax, DWORD PTR _strTextureFileName$19[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 368  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  00917	50		 push	 eax
  00918	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0091d	8b bd 4c fe ff
	ff		 mov	 edi, DWORD PTR _pMeshData$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 368  : 					CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(strTextureFileName.c_str());

  00923	89 85 50 fe ff
	ff		 mov	 DWORD PTR _pImage$7[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00929	8b 8f b0 00 00
	00		 mov	 ecx, DWORD PTR [edi+176]
  0092f	3b 8f b4 00 00
	00		 cmp	 ecx, DWORD PTR [edi+180]
  00935	74 0b		 je	 SHORT $LN472@LoadData_V

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00937	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00939	83 87 b0 00 00
	00 04		 add	 DWORD PTR [edi+176], 4

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00940	eb 13		 jmp	 SHORT $LN761@LoadData_V
$LN472@LoadData_V:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00942	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _pImage$7[ebp]
  00948	50		 push	 eax
  00949	51		 push	 ecx
  0094a	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
  00950	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
$LN761@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 358  : 				for (DWORD i = 0; i < textFileLoader.GetLineCount(); ++i)

  00955	8b b5 58 fe ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
$LN11@LoadData_V:
  0095b	46		 inc	 esi
  0095c	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  00962	89 b5 58 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00968	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  0096d	3b f0		 cmp	 esi, eax
  0096f	0f 82 3b fe ff
	ff		 jb	 $LL13@LoadData_V
$LN12@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00975	8b 4d ec	 mov	 ecx, DWORD PTR _strTextureFileName$19[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 372  : 			}

  00978	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0097c	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0097f	76 2c		 jbe	 SHORT $LN110@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00981	8b 55 d8	 mov	 edx, DWORD PTR _strTextureFileName$19[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00984	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00985	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00987	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0098d	72 14		 jb	 SHORT $LN121@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0098f	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00992	83 c1 23	 add	 ecx, 35			; 00000023H
  00995	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00997	83 c0 fc	 add	 eax, -4			; fffffffcH
  0099a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0099d	0f 87 57 02 00
	00		 ja	 $LN659@LoadData_V
$LN121@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  009a3	51		 push	 ecx
  009a4	52		 push	 edx
  009a5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009aa	83 c4 08	 add	 esp, 8
$LN110@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  009ad	8b 4d d4	 mov	 ecx, DWORD PTR _strPathName$18[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  009b0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strTextureFileName$19[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  009b7	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strTextureFileName$19[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  009be	c6 45 d8 00	 mov	 BYTE PTR _strTextureFileName$19[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 372  : 			}

  009c2	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  009c6	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  009c9	76 2c		 jbe	 SHORT $LN147@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009cb	8b 55 c0	 mov	 edx, DWORD PTR _strPathName$18[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  009ce	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009cf	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  009d1	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  009d7	72 14		 jb	 SHORT $LN158@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009d9	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  009dc	83 c1 23	 add	 ecx, 35			; 00000023H
  009df	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009e1	83 c0 fc	 add	 eax, -4			; fffffffcH
  009e4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009e7	0f 87 0d 02 00
	00		 ja	 $LN659@LoadData_V
$LN158@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  009ed	51		 push	 ecx
  009ee	52		 push	 edx
  009ef	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009f4	83 c4 08	 add	 esp, 8
$LN147@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 372  : 			}

  009f7	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  009fd	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strPathName$18[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00a04	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strPathName$18[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00a0b	c6 45 c0 00	 mov	 BYTE PTR _strPathName$18[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 372  : 			}

  00a0f	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
$LN18@LoadData_V:

; 373  : 		}

  00a14	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$16[ebp]
  00a1a	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00a1f	eb 3a		 jmp	 SHORT $LN484@LoadData_V
$LN16@LoadData_V:

; 376  : 			CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(pMeshData->szDiffuseMapFileName);

  00a21	8b bd 4c fe ff
	ff		 mov	 edi, DWORD PTR _pMeshData$1$[ebp]
  00a27	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00a2d	8d 47 20	 lea	 eax, DWORD PTR [edi+32]
  00a30	50		 push	 eax
  00a31	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00a36	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 376  : 			CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(pMeshData->szDiffuseMapFileName);

  00a39	89 85 50 fe ff
	ff		 mov	 DWORD PTR _pImage$8[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00a3f	3b 4e 08	 cmp	 ecx, DWORD PTR [esi+8]
  00a42	74 08		 je	 SHORT $LN485@LoadData_V

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00a44	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00a46	83 46 04 04	 add	 DWORD PTR [esi+4], 4

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00a4a	eb 0f		 jmp	 SHORT $LN484@LoadData_V
$LN485@LoadData_V:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00a4c	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR _pImage$8[ebp]
  00a52	50		 push	 eax
  00a53	51		 push	 ecx
  00a54	8b ce		 mov	 ecx, esi
  00a56	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
$LN484@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 383  : 		m_pEffectMeshDataVector[n] = pMeshData;

  00a5b	8b 85 f4 fd ff
	ff		 mov	 eax, DWORD PTR __My_data$1$[ebp]
  00a61	8b b5 fc fd ff
	ff		 mov	 esi, DWORD PTR _n$1$[ebp]
  00a67	0f bf ce	 movsx	 ecx, si

; 384  : 	}

  00a6a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00a6e	8b 00		 mov	 eax, DWORD PTR [eax]
  00a70	89 3c 88	 mov	 DWORD PTR [eax+ecx*4], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00a73	8b 4d bc	 mov	 ecx, DWORD PTR _strExtension$17[ebp+20]
  00a76	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00a79	76 2c		 jbe	 SHORT $LN69@LoadData_V
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a7b	8b 55 a8	 mov	 edx, DWORD PTR _strExtension$17[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00a7e	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a7f	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00a81	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00a87	72 14		 jb	 SHORT $LN80@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a89	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00a8c	83 c1 23	 add	 ecx, 35			; 00000023H
  00a8f	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a91	83 c0 fc	 add	 eax, -4			; fffffffcH
  00a94	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a97	0f 87 5d 01 00
	00		 ja	 $LN659@LoadData_V
$LN80@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00a9d	51		 push	 ecx
  00a9e	52		 push	 edx
  00a9f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00aa4	83 c4 08	 add	 esp, 8
$LN69@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 257  : 	for (short n = 0; n < m_iGeomCount; ++n)

  00aa7	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00aad	46		 inc	 esi
  00aae	0f bf c6	 movsx	 eax, si
  00ab1	89 b5 fc fd ff
	ff		 mov	 DWORD PTR _n$1$[ebp], esi
  00ab7	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  00aba	0f 8c 40 f6 ff
	ff		 jl	 $LL4@LoadData_V
$LN726@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00ac0	8b 95 28 fe ff
	ff		 mov	 edx, DWORD PTR _iTextureIndexVector$[ebp]
  00ac6	85 d2		 test	 edx, edx
  00ac8	74 51		 je	 SHORT $LN587@LoadData_V

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00aca	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR _iTextureIndexVector$[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00ad0	8b c2		 mov	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00ad2	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00ad4	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00ad7	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00add	72 14		 jb	 SHORT $LN606@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00adf	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00ae2	83 c1 23	 add	 ecx, 35			; 00000023H
  00ae5	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00ae7	83 c0 fc	 add	 eax, -4			; fffffffcH
  00aea	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00aed	0f 87 07 01 00
	00		 ja	 $LN659@LoadData_V
$LN606@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00af3	51		 push	 ecx
  00af4	52		 push	 edx
  00af5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00afa	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00afd	c7 85 28 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp], 0

; 2081 :             _Mylast  = nullptr;

  00b07	c7 85 2c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp+4], 0

; 2082 :             _Myend   = nullptr;

  00b11	c7 85 30 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iTextureIndexVector$[ebp+8], 0
$LN587@LoadData_V:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00b1b	8b 95 1c fe ff
	ff		 mov	 edx, DWORD PTR _v3TextureVertexVector$[ebp]
  00b21	85 d2		 test	 edx, edx
  00b23	74 51		 je	 SHORT $LN615@LoadData_V

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b25	8b 8d 24 fe ff
	ff		 mov	 ecx, DWORD PTR _v3TextureVertexVector$[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b2b	8b c2		 mov	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b2d	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b2f	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00b32	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00b38	72 14		 jb	 SHORT $LN634@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b3a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00b3d	83 c1 23	 add	 ecx, 35			; 00000023H
  00b40	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b42	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b45	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b48	0f 87 ac 00 00
	00		 ja	 $LN659@LoadData_V
$LN634@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00b4e	51		 push	 ecx
  00b4f	52		 push	 edx
  00b50	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b55	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00b58	c7 85 1c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp], 0

; 2081 :             _Mylast  = nullptr;

  00b62	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp+4], 0

; 2082 :             _Myend   = nullptr;

  00b6c	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _v3TextureVertexVector$[ebp+8], 0
$LN615@LoadData_V:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00b76	8b 95 10 fe ff
	ff		 mov	 edx, DWORD PTR _iIndexVector$[ebp]
  00b7c	85 d2		 test	 edx, edx
  00b7e	74 4d		 je	 SHORT $LN643@LoadData_V

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b80	8b 8d 18 fe ff
	ff		 mov	 ecx, DWORD PTR _iIndexVector$[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b86	8b c2		 mov	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00b88	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b8a	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00b8d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00b93	72 10		 jb	 SHORT $LN662@LoadData_V

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b95	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00b98	83 c1 23	 add	 ecx, 35			; 00000023H
  00b9b	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b9d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00ba0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00ba3	77 55		 ja	 SHORT $LN659@LoadData_V
$LN662@LoadData_V:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00ba5	51		 push	 ecx
  00ba6	52		 push	 edx
  00ba7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00bac	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00baf	c7 85 10 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp], 0

; 2081 :             _Mylast  = nullptr;

  00bb9	c7 85 14 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp+4], 0

; 2082 :             _Myend   = nullptr;

  00bc3	c7 85 18 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _iIndexVector$[ebp+8], 0
$LN643@LoadData_V:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 386  : 	return TRUE;

  00bcd	8d 8d 34 fe ff
	ff		 lea	 ecx, DWORD PTR _v3VertexVector$[ebp]
  00bd3	e8 00 00 00 00	 call	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
  00bd8	b8 01 00 00 00	 mov	 eax, 1

; 387  : }

  00bdd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00be0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00be7	59		 pop	 ecx
  00be8	5f		 pop	 edi
  00be9	5e		 pop	 esi
  00bea	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bed	33 cd		 xor	 ecx, ebp
  00bef	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bf4	8b e5		 mov	 esp, ebp
  00bf6	5d		 pop	 ebp
  00bf7	c2 08 00	 ret	 8
$LN659@LoadData_V:
  00bfa	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN716@LoadData_V:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2963 :             _Xlen_string(); // result too long

  00bff	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN757@LoadData_V:
  00c04	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$0:
  00000	8d 8d 34 fe ff
	ff		 lea	 ecx, DWORD PTR _v3VertexVector$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$1:
  0000b	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR _iIndexVector$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$2:
  00016	8d 8d 1c fe ff
	ff		 lea	 ecx, DWORD PTR _v3TextureVertexVector$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR2@@V?$allocator@UD3DXVECTOR2@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >::~vector<D3DXVECTOR2,std::allocator<D3DXVECTOR2> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$3:
  00021	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR _iTextureIndexVector$[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$4:
  0002c	8d 4d a8	 lea	 ecx, DWORD PTR _strExtension$17[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$5:
  00034	8d 8d 64 fe ff
	ff		 lea	 ecx, DWORD PTR _File$16[ebp]
  0003a	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$6:
  0003f	8d 8d e4 fd ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$5[ebp]
  00045	e9 00 00 00 00	 jmp	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$7:
  0004a	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR _stTokenVector$4[ebp]
  00050	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$8:
  00055	8d 4d c0	 lea	 ecx, DWORD PTR _strPathName$18[ebp]
  00058	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z$9:
  0005d	8d 4d d8	 lea	 ecx, DWORD PTR _strTextureFileName$19[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00065	cc		 int	 3
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
__ehhandler$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z:
  0006a	90		 npad	 1
  0006b	90		 npad	 1
  0006c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00070	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00073	8b 8a d8 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-552]
  00079	33 c8		 xor	 ecx, eax
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00083	33 c8		 xor	 ecx, eax
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z
  0008f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z ENDP		; CEffectMesh::__LoadData_Ver001
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnIsType@CEffectMesh@@MAE_NK@Z
_TEXT	SEGMENT
_type$ = 8						; size = 4
?OnIsType@CEffectMesh@@MAE_NK@Z PROC			; CEffectMesh::OnIsType, COMDAT
; _this$ = ecx

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 65   : 	if (CEffectMesh::Type() == type)

  00006	e8 00 00 00 00	 call	 ?Type@CEffectMesh@@SAKXZ ; CEffectMesh::Type
  0000b	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0000e	3b c2		 cmp	 eax, edx
  00010	75 07		 jne	 SHORT $LN2@OnIsType

; 66   : 		return true;

  00012	b0 01		 mov	 al, 1
  00014	5e		 pop	 esi

; 69   : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN2@OnIsType:

; 67   : 
; 68   : 	return CResource::OnIsType(type);

  00019	52		 push	 edx
  0001a	8b ce		 mov	 ecx, esi
  0001c	e8 00 00 00 00	 call	 ?OnIsType@CResource@@MAE_NK@Z ; CResource::OnIsType
  00021	5e		 pop	 esi

; 69   : }

  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?OnIsType@CEffectMesh@@MAE_NK@Z ENDP			; CEffectMesh::OnIsType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnIsEmpty@CEffectMesh@@MBE_NXZ
_TEXT	SEGMENT
?OnIsEmpty@CEffectMesh@@MBE_NXZ PROC			; CEffectMesh::OnIsEmpty, COMDAT
; _this$ = ecx

; 418  : 	return !m_isData;

  00000	80 79 40 00	 cmp	 BYTE PTR [ecx+64], 0
  00004	0f 94 c0	 sete	 al

; 419  : }

  00007	c3		 ret	 0
?OnIsEmpty@CEffectMesh@@MBE_NXZ ENDP			; CEffectMesh::OnIsEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnClear@CEffectMesh@@MAEXXZ
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
tv411 = -8						; size = 4
_i$1$ = -4						; size = 4
?OnClear@CEffectMesh@@MAEXXZ PROC			; CEffectMesh::OnClear, COMDAT
; _this$ = ecx

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	89 5d f4	 mov	 DWORD PTR _this$1$[ebp], ebx

; 401  : 	if (!m_isData)

  0000c	80 7b 40 00	 cmp	 BYTE PTR [ebx+64], 0
  00010	0f 84 b2 00 00
	00		 je	 $LN1@OnClear
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00016	8b 53 38	 mov	 edx, DWORD PTR [ebx+56]
  00019	8b c2		 mov	 eax, edx
  0001b	8b 4b 34	 mov	 ecx, DWORD PTR [ebx+52]
  0001e	2b c1		 sub	 eax, ecx
  00020	56		 push	 esi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 404  : 	for (DWORD i = 0; i < m_pEffectMeshDataVector.size(); ++i)

  00021	33 f6		 xor	 esi, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00023	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 404  : 	for (DWORD i = 0; i < m_pEffectMeshDataVector.size(); ++i)

  00026	89 75 fc	 mov	 DWORD PTR _i$1$[ebp], esi
  00029	85 c0		 test	 eax, eax
  0002b	0f 84 8b 00 00
	00		 je	 $LN3@OnClear
  00031	57		 push	 edi
$LL4@OnClear:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00032	8d 14 b5 00 00
	00 00		 lea	 edx, DWORD PTR [esi*4]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 406  : 		m_pEffectMeshDataVector[i]->pImageVector.clear();

  00039	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0003c	89 55 f8	 mov	 DWORD PTR tv411[ebp], edx

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0003f	8b 88 ac 00 00
	00		 mov	 ecx, DWORD PTR [eax+172]
  00045	3b 88 b0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+176]
  0004b	74 06		 je	 SHORT $LN13@OnClear

; 1807 :         _Mylast = _Myfirst;

  0004d	89 88 b0 00 00
	00		 mov	 DWORD PTR [eax+176], ecx
$LN13@OnClear:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 407  : 		m_pEffectMeshDataVector[i]->EffectFrameDataVector.clear();

  00053	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00056	8b 3c 02	 mov	 edi, DWORD PTR [edx+eax]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00059	8b b7 a0 00 00
	00		 mov	 esi, DWORD PTR [edi+160]
  0005f	8b 9f a4 00 00
	00		 mov	 ebx, DWORD PTR [edi+164]
  00065	3b f3		 cmp	 esi, ebx
  00067	74 25		 je	 SHORT $LN20@OnClear
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL27@OnClear:
  00070	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00073	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00078	83 c6 20	 add	 esi, 32			; 00000020H
  0007b	3b f3		 cmp	 esi, ebx
  0007d	75 f1		 jne	 SHORT $LL27@OnClear
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1807 :         _Mylast = _Myfirst;

  0007f	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  00085	8b 55 f8	 mov	 edx, DWORD PTR tv411[ebp]
  00088	89 87 a4 00 00
	00		 mov	 DWORD PTR [edi+164], eax
$LN20@OnClear:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 409  : 		SEffectMeshData::Delete(m_pEffectMeshDataVector[i]);

  0008e	8b 5d f4	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00091	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  00094	ff 34 02	 push	 DWORD PTR [edx+eax]
  00097	e8 00 00 00 00	 call	 ?Delete@SEffectMeshData@CEffectMesh@@SAXPAU12@@Z ; CEffectMesh::SEffectMeshData::Delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0009c	8b 53 38	 mov	 edx, DWORD PTR [ebx+56]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 409  : 		SEffectMeshData::Delete(m_pEffectMeshDataVector[i]);

  0009f	83 c4 04	 add	 esp, 4
  000a2	8b 75 fc	 mov	 esi, DWORD PTR _i$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000a5	8b c2		 mov	 eax, edx
  000a7	8b 4b 34	 mov	 ecx, DWORD PTR [ebx+52]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 404  : 	for (DWORD i = 0; i < m_pEffectMeshDataVector.size(); ++i)

  000aa	46		 inc	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000ab	2b c1		 sub	 eax, ecx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 404  : 	for (DWORD i = 0; i < m_pEffectMeshDataVector.size(); ++i)

  000ad	89 75 fc	 mov	 DWORD PTR _i$1$[ebp], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000b0	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 404  : 	for (DWORD i = 0; i < m_pEffectMeshDataVector.size(); ++i)

  000b3	3b f0		 cmp	 esi, eax
  000b5	0f 82 77 ff ff
	ff		 jb	 $LL4@OnClear
  000bb	5f		 pop	 edi
$LN3@OnClear:
  000bc	5e		 pop	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000bd	3b ca		 cmp	 ecx, edx
  000bf	74 03		 je	 SHORT $LN44@OnClear

; 1807 :         _Mylast = _Myfirst;

  000c1	89 4b 38	 mov	 DWORD PTR [ebx+56], ecx
$LN44@OnClear:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 413  : 	m_isData = false;

  000c4	c6 43 40 00	 mov	 BYTE PTR [ebx+64], 0
$LN1@OnClear:
  000c8	5b		 pop	 ebx

; 414  : }

  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c3		 ret	 0
?OnClear@CEffectMesh@@MAEXXZ ENDP			; CEffectMesh::OnClear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?OnLoad@CEffectMesh@@MAE_NHPBX@Z
_TEXT	SEGMENT
_szHeader$ = -12					; size = 11
_iSize$ = 8						; size = 4
_c_pvBuf$ = 12						; size = 4
?OnLoad@CEffectMesh@@MAE_NHPBX@Z PROC			; CEffectMesh::OnLoad, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   : 	if (!c_pvBuf)

  00003	8b 55 0c	 mov	 edx, DWORD PTR _c_pvBuf$[ebp]
  00006	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx
  0000c	57		 push	 edi
  0000d	85 d2		 test	 edx, edx
  0000f	0f 84 a6 00 00
	00		 je	 $LN6@OnLoad

; 74   : 		return false;
; 75   : 
; 76   : 	const BYTE * c_pbBuf = static_cast<const BYTE *> (c_pvBuf);
; 77   : 
; 78   : 	char szHeader[10+1];
; 79   : 	memcpy(szHeader, c_pbBuf, 10+1);

  00015	66 8b 42 08	 mov	 ax, WORD PTR [edx+8]

; 80   : 	c_pbBuf += 10+1;

  00019	8d 7a 0b	 lea	 edi, DWORD PTR [edx+11]
  0001c	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]

; 81   : 
; 82   : 	if (0 == strcmp("EffectData", szHeader))

  00020	8d 4d f4	 lea	 ecx, DWORD PTR _szHeader$[ebp]
  00023	66 89 45 fc	 mov	 WORD PTR _szHeader$[ebp+8], ax
  00027	8a 42 0a	 mov	 al, BYTE PTR [edx+10]
  0002a	88 45 fe	 mov	 BYTE PTR _szHeader$[ebp+10], al
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@HDPGDEFC@EffectData@
  00032	66 0f d6 45 f4	 movq	 QWORD PTR _szHeader$[ebp], xmm0
$LL13@OnLoad:
  00037	8a 10		 mov	 dl, BYTE PTR [eax]
  00039	3a 11		 cmp	 dl, BYTE PTR [ecx]
  0003b	75 1a		 jne	 SHORT $LN14@OnLoad
  0003d	84 d2		 test	 dl, dl
  0003f	74 12		 je	 SHORT $LN15@OnLoad
  00041	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00044	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00047	75 0e		 jne	 SHORT $LN14@OnLoad
  00049	83 c0 02	 add	 eax, 2
  0004c	83 c1 02	 add	 ecx, 2
  0004f	84 d2		 test	 dl, dl
  00051	75 e4		 jne	 SHORT $LL13@OnLoad
$LN15@OnLoad:
  00053	33 c0		 xor	 eax, eax
  00055	eb 05		 jmp	 SHORT $LN16@OnLoad
$LN14@OnLoad:
  00057	1b c0		 sbb	 eax, eax
  00059	83 c8 01	 or	 eax, 1
$LN16@OnLoad:
  0005c	85 c0		 test	 eax, eax
  0005e	75 0d		 jne	 SHORT $LN3@OnLoad

; 83   : 	{
; 84   : 		if (!__LoadData_Ver001(iSize, c_pbBuf))

  00060	57		 push	 edi
  00061	ff 75 08	 push	 DWORD PTR _iSize$[ebp]
  00064	8b ce		 mov	 ecx, esi
  00066	e8 00 00 00 00	 call	 ?__LoadData_Ver001@CEffectMesh@@IAEHHPBE@Z ; CEffectMesh::__LoadData_Ver001
  0006b	eb 3c		 jmp	 SHORT $LN31@OnLoad
$LN3@OnLoad:

; 85   : 			return false;
; 86   : 	}
; 87   : 	else if (0 == strcmp("MDEData002", szHeader))

  0006d	8d 4d f4	 lea	 ecx, DWORD PTR _szHeader$[ebp]
  00070	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0L@HDHCIEF@MDEData002@
$LL17@OnLoad:
  00075	8a 10		 mov	 dl, BYTE PTR [eax]
  00077	3a 11		 cmp	 dl, BYTE PTR [ecx]
  00079	75 1a		 jne	 SHORT $LN18@OnLoad
  0007b	84 d2		 test	 dl, dl
  0007d	74 12		 je	 SHORT $LN19@OnLoad
  0007f	8a 50 01	 mov	 dl, BYTE PTR [eax+1]
  00082	3a 51 01	 cmp	 dl, BYTE PTR [ecx+1]
  00085	75 0e		 jne	 SHORT $LN18@OnLoad
  00087	83 c0 02	 add	 eax, 2
  0008a	83 c1 02	 add	 ecx, 2
  0008d	84 d2		 test	 dl, dl
  0008f	75 e4		 jne	 SHORT $LL17@OnLoad
$LN19@OnLoad:
  00091	33 c0		 xor	 eax, eax
  00093	eb 05		 jmp	 SHORT $LN20@OnLoad
$LN18@OnLoad:
  00095	1b c0		 sbb	 eax, eax
  00097	83 c8 01	 or	 eax, 1
$LN20@OnLoad:
  0009a	85 c0		 test	 eax, eax
  0009c	75 1d		 jne	 SHORT $LN6@OnLoad

; 88   : 	{
; 89   : 		if (!__LoadData_Ver002(iSize, c_pbBuf))

  0009e	57		 push	 edi
  0009f	ff 75 08	 push	 DWORD PTR _iSize$[ebp]
  000a2	8b ce		 mov	 ecx, esi
  000a4	e8 00 00 00 00	 call	 ?__LoadData_Ver002@CEffectMesh@@IAEHHPBE@Z ; CEffectMesh::__LoadData_Ver002
$LN31@OnLoad:

; 95   : 	}
; 96   : 
; 97   : 	m_isData = true;

  000a9	85 c0		 test	 eax, eax
  000ab	74 0e		 je	 SHORT $LN6@OnLoad
  000ad	5f		 pop	 edi
  000ae	c6 46 40 01	 mov	 BYTE PTR [esi+64], 1

; 98   : 	return true;

  000b2	b0 01		 mov	 al, 1

; 99   : }

  000b4	5e		 pop	 esi
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 08 00	 ret	 8
$LN6@OnLoad:
  000bb	5f		 pop	 edi

; 90   : 			return false;
; 91   : 	}
; 92   : 	else
; 93   : 	{
; 94   : 		return false;

  000bc	32 c0		 xor	 al, al

; 99   : }

  000be	5e		 pop	 esi
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8
?OnLoad@CEffectMesh@@MAE_NHPBX@Z ENDP			; CEffectMesh::OnLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshElementPointer@CEffectMesh@@QAEHKPAPAUSEffectMeshData@1@@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
_ppMeshData$ = 12					; size = 4
?GetMeshElementPointer@CEffectMesh@@QAEHKPAPAUSEffectMeshData@1@@Z PROC ; CEffectMesh::GetMeshElementPointer, COMDAT
; _this$ = ecx

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00006	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00009	2b c2		 sub	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 391  : 	if (dwMeshIndex >= m_pEffectMeshDataVector.size())

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _dwMeshIndex$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000e	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 391  : 	if (dwMeshIndex >= m_pEffectMeshDataVector.size())

  00011	3b c8		 cmp	 ecx, eax
  00013	72 06		 jb	 SHORT $LN2@GetMeshEle

; 392  : 		return FALSE;

  00015	33 c0		 xor	 eax, eax

; 397  : }

  00017	5d		 pop	 ebp
  00018	c2 08 00	 ret	 8
$LN2@GetMeshEle:

; 393  : 
; 394  : 	*ppMeshData = m_pEffectMeshDataVector[dwMeshIndex];

  0001b	8b 45 0c	 mov	 eax, DWORD PTR _ppMeshData$[ebp]
  0001e	8b 0c 8a	 mov	 ecx, DWORD PTR [edx+ecx*4]
  00021	89 08		 mov	 DWORD PTR [eax], ecx

; 395  : 
; 396  : 	return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1

; 397  : }

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?GetMeshElementPointer@CEffectMesh@@QAEHKPAPAUSEffectMeshData@1@@Z ENDP ; CEffectMesh::GetMeshElementPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetTextureVectorReference@CEffectMesh@@QAEAAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetTextureVectorReference@CEffectMesh@@QAEAAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z PROC ; CEffectMesh::GetTextureVectorReference, COMDAT
; _this$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 54   : 	return m_pEffectMeshDataVector[dwMeshIndex]->pImageVector;

  00003	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  00006	8b 45 08	 mov	 eax, DWORD PTR _dwMeshIndex$[ebp]
  00009	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0000c	05 ac 00 00 00	 add	 eax, 172		; 000000acH

; 55   : }

  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?GetTextureVectorReference@CEffectMesh@@QAEAAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z ENDP ; CEffectMesh::GetTextureVectorReference
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z PROC ; CEffectMesh::GetTextureVectorPointer, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00006	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00009	2b c2		 sub	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 46   : 	if (dwMeshIndex>=m_pEffectMeshDataVector.size())

  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _dwMeshIndex$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000e	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 46   : 	if (dwMeshIndex>=m_pEffectMeshDataVector.size())

  00011	3b c8		 cmp	 ecx, eax
  00013	72 06		 jb	 SHORT $LN2@GetTexture

; 47   : 		return NULL;

  00015	33 c0		 xor	 eax, eax

; 50   : }

  00017	5d		 pop	 ebp
  00018	c2 04 00	 ret	 4
$LN2@GetTexture:

; 48   : 
; 49   : 	return &m_pEffectMeshDataVector[dwMeshIndex]->pImageVector;

  0001b	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0001e	05 ac 00 00 00	 add	 eax, 172		; 000000acH

; 50   : }

  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?GetTextureVectorPointer@CEffectMesh@@QAEPAV?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@K@Z ENDP ; CEffectMesh::GetTextureVectorPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z
_TEXT	SEGMENT
_dwMeshIndex$ = 8					; size = 4
?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z PROC ; CEffectMesh::GetMeshDataPointer, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 40   : 	assert(dwMeshIndex < m_pEffectMeshDataVector.size());
; 41   : 	return m_pEffectMeshDataVector[dwMeshIndex];

  00003	8b 49 34	 mov	 ecx, DWORD PTR [ecx+52]
  00006	8b 45 08	 mov	 eax, DWORD PTR _dwMeshIndex$[ebp]
  00009	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 42   : }

  0000c	5d		 pop	 ebp
  0000d	c2 04 00	 ret	 4
?GetMeshDataPointer@CEffectMesh@@QAEPAUSEffectMeshData@1@K@Z ENDP ; CEffectMesh::GetMeshDataPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetMeshCount@CEffectMesh@@QAEKXZ
_TEXT	SEGMENT
?GetMeshCount@CEffectMesh@@QAEKXZ PROC			; CEffectMesh::GetMeshCount, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00000	8b 41 38	 mov	 eax, DWORD PTR [ecx+56]
  00003	2b 41 34	 sub	 eax, DWORD PTR [ecx+52]
  00006	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 36   : }

  00009	c3		 ret	 0
?GetMeshCount@CEffectMesh@@QAEKXZ ENDP			; CEffectMesh::GetMeshCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?GetFrameCount@CEffectMesh@@QAEKXZ
_TEXT	SEGMENT
?GetFrameCount@CEffectMesh@@QAEKXZ PROC			; CEffectMesh::GetFrameCount, COMDAT
; _this$ = ecx

; 30   : 	return m_iFrameCount;

  00000	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]

; 31   : }

  00003	c3		 ret	 0
?GetFrameCount@CEffectMesh@@QAEKXZ ENDP			; CEffectMesh::GetFrameCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??1CEffectMesh@@UAE@XZ
_TEXT	SEGMENT
??1CEffectMesh@@UAE@XZ PROC				; CEffectMesh::~CEffectMesh, COMDAT
; _this$ = ecx

; 429  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectMesh@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CEffectMes

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CEffectMes

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 29		 ja	 SHORT $LN24@CEffectMes

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CEffectMes:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
$LN8@CEffectMes:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 430  : }

  00051	8b ce		 mov	 ecx, esi
  00053	5e		 pop	 esi
  00054	e9 00 00 00 00	 jmp	 ??1CResource@@UAE@XZ	; CResource::~CResource
$LN24@CEffectMes:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00059	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN36@CEffectMes:
  0005e	cc		 int	 3
??1CEffectMesh@@UAE@XZ ENDP				; CEffectMesh::~CEffectMesh
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ??0CEffectMesh@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_szFileName$ = 8					; size = 4
??0CEffectMesh@@QAE@PBD@Z PROC				; CEffectMesh::CEffectMesh, COMDAT
; _this$ = ecx

; 422  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000d	e8 00 00 00 00	 call	 ??0CResource@@QAE@PBD@Z	; CResource::CResource
  00012	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CEffectMesh@@6B@

; 426  : }

  00018	8b c6		 mov	 eax, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0001a	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  00021	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00028	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 423  : 	m_iGeomCount = 0;

  0002f	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 424  : 	m_iFrameCount = 0;

  00036	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 425  : 	m_isData = false;

  0003d	c6 46 40 00	 mov	 BYTE PTR [esi+64], 0

; 426  : }

  00041	5e		 pop	 esi
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??0CEffectMesh@@QAE@PBD@Z ENDP				; CEffectMesh::CEffectMesh
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?Type@CEffectMesh@@SAKXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?Type@CEffectMesh@@SAKXZ PROC				; CEffectMesh::Type, COMDAT

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Type@CEffectMesh@@SAKXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 59   : 	static TType s_type = StringToType("CEffectMesh");

  00022	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  0002e	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA
  00036	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  0003c	7f 14		 jg	 SHORT $LN9@Type
$LN5@Type:

; 60   : 	return s_type;
; 61   : }

  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_type@?1??Type@CEffectMesh@@SAKXZ@4KA
  00043	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00046	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004d	59		 pop	 ecx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN9@Type:

; 59   : 	static TType s_type = StringToType("CEffectMesh");

  00052	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA
  00057	e8 00 00 00 00	 call	 __Init_thread_header
  0005c	83 c4 04	 add	 esp, 4
  0005f	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA, -1
  00066	75 d6		 jne	 SHORT $LN5@Type
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0M@HCKGHODL@CEffectMesh@
  0006d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00074	e8 00 00 00 00	 call	 ?StringToType@CResource@@SAKPBD@Z ; CResource::StringToType
  00079	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA
  0007e	a3 00 00 00 00	 mov	 DWORD PTR ?s_type@?1??Type@CEffectMesh@@SAKXZ@4KA, eax
  00083	e8 00 00 00 00	 call	 __Init_thread_footer
  00088	83 c4 08	 add	 esp, 8
  0008b	eb b1		 jmp	 SHORT $LN5@Type
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Type@CEffectMesh@@SAKXZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CEffectMesh@@SAKXZ@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Type@CEffectMesh@@SAKXZ:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Type@CEffectMesh@@SAKXZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Type@CEffectMesh@@SAKXZ ENDP				; CEffectMesh::Type
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?DestroySystem@SEffectMeshData@CEffectMesh@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@SEffectMeshData@CEffectMesh@@SAXXZ PROC	; CEffectMesh::SEffectMeshData::DestroySystem, COMDAT

; 23   : {

  00000	53		 push	 ebx
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  00001	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+8
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 23   : {

  00007	57		 push	 edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  00008	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+4
  0000e	3b fb		 cmp	 edi, ebx
  00010	0f 84 95 00 00
	00		 je	 $LN53@DestroySys
  00016	56		 push	 esi
$LL6@DestroySys:

; 111  : 			delete pkData;

  00017	8b 37		 mov	 esi, DWORD PTR [edi]
  00019	85 f6		 test	 esi, esi
  0001b	74 70		 je	 SHORT $LN4@DestroySys
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0001d	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  00023	85 c0		 test	 eax, eax
  00025	74 4d		 je	 SHORT $LN25@DestroySys

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00027	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]
  0002d	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00032	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00038	72 12		 jb	 SHORT $LN44@DestroySys

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0003d	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00040	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00042	83 c0 fc	 add	 eax, -4			; fffffffcH
  00045	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00048	77 76		 ja	 SHORT $LN41@DestroySys

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004a	8b c2		 mov	 eax, edx
$LN44@DestroySys:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0004c	51		 push	 ecx
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00053	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0005d	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00060	c7 86 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+176], 0

; 2082 :             _Myend   = nullptr;

  0006a	c7 86 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+180], 0
$LN25@DestroySys:
  00074	8d 8e a0 00 00
	00		 lea	 ecx, DWORD PTR [esi+160]
  0007a	e8 00 00 00 00	 call	 ??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::~vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >
  0007f	68 b8 00 00 00	 push	 184			; 000000b8H
  00084	56		 push	 esi
  00085	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0008a	83 c4 08	 add	 esp, 8
$LN4@DestroySys:
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  0008d	83 c7 04	 add	 edi, 4
  00090	3b fb		 cmp	 edi, ebx
  00092	75 83		 jne	 SHORT $LL6@DestroySys
  00094	8b 1d 08 00 00
	00		 mov	 ebx, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+8
  0009a	8b 3d 04 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+4
  000a0	5e		 pop	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000a1	3b fb		 cmp	 edi, ebx
  000a3	74 06		 je	 SHORT $LN53@DestroySys

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  000a5	89 3d 08 00 00
	00		 mov	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+8, edi
$LN53@DestroySys:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000ab	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+16
  000b0	5f		 pop	 edi
  000b1	5b		 pop	 ebx
  000b2	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+20
  000b8	74 05		 je	 SHORT $LN57@DestroySys

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  000ba	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+20, eax
$LN57@DestroySys:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 25   : }

  000bf	c3		 ret	 0
$LN41@DestroySys:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c0	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN75@DestroySys:
  000c5	cc		 int	 3
?DestroySystem@SEffectMeshData@CEffectMesh@@SAXXZ ENDP	; CEffectMesh::SEffectMeshData::DestroySystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?Delete@SEffectMeshData@CEffectMesh@@SAXPAU12@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
_pkData$ = 8						; size = 4
?Delete@SEffectMeshData@CEffectMesh@@SAXPAU12@@Z PROC	; CEffectMesh::SEffectMeshData::Delete, COMDAT

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1793 :         auto& _My_data    = _Mypair._Myval2;

  00006	8b 7d 08	 mov	 edi, DWORD PTR _pkData$[ebp]

; 1794 :         pointer& _Myfirst = _My_data._Myfirst;
; 1795 :         pointer& _Mylast  = _My_data._Mylast;
; 1796 : 
; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00009	8b b7 a0 00 00
	00		 mov	 esi, DWORD PTR [edi+160]
  0000f	8b 9f a4 00 00
	00		 mov	 ebx, DWORD PTR [edi+164]
  00015	3b f3		 cmp	 esi, ebx
  00017	74 22		 je	 SHORT $LN3@Delete
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL10@Delete:
  00020	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00023	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00028	83 c6 20	 add	 esi, 32			; 00000020H
  0002b	3b f3		 cmp	 esi, ebx
  0002d	75 f1		 jne	 SHORT $LL10@Delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1807 :         _Mylast = _Myfirst;

  0002f	8b 87 a0 00 00
	00		 mov	 eax, DWORD PTR [edi+160]
  00035	89 87 a4 00 00
	00		 mov	 DWORD PTR [edi+164], eax
$LN3@Delete:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0003b	8b 87 ac 00 00
	00		 mov	 eax, DWORD PTR [edi+172]
  00041	3b 87 b0 00 00
	00		 cmp	 eax, DWORD PTR [edi+176]
  00047	74 06		 je	 SHORT $LN24@Delete

; 1807 :         _Mylast = _Myfirst;

  00049	89 87 b0 00 00
	00		 mov	 DWORD PTR [edi+176], eax
$LN24@Delete:
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 82   : 			m_kVct_pkFree.push_back(pkData);

  0004f	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 19   : 	ms_kPool.Free(pkData);

  00052	89 7d 08	 mov	 DWORD PTR _pkData$[ebp], edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 82   : 			m_kVct_pkFree.push_back(pkData);

  00055	50		 push	 eax
  00056	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+16
  0005b	e8 00 00 00 00	 call	 ?push_back@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXABQAUSEffectMeshData@CEffectMesh@@@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::push_back
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5b		 pop	 ebx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 20   : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?Delete@SEffectMeshData@CEffectMesh@@SAXPAU12@@Z ENDP	; CEffectMesh::SEffectMeshData::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp
;	COMDAT ?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ
_TEXT	SEGMENT
_pkNewData$1 = -4					; size = 4
?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ PROC	; CEffectMesh::SEffectMeshData::New, COMDAT

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00004	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+20
  0000a	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+16, ecx
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 64   : 			if (m_kVct_pkFree.empty())

  00010	75 72		 jne	 SHORT $LN4@New
  00012	56		 push	 esi

; 66   : 				T* pkNewData=new T;

  00013	68 b8 00 00 00	 push	 184			; 000000b8H
  00018	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001d	8b f0		 mov	 esi, eax
  0001f	83 c4 04	 add	 esp, 4
  00022	85 f6		 test	 esi, esi
  00024	74 3e		 je	 SHORT $LN6@New
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00026	c7 86 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+160], 0
  00030	c7 86 a4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+164], 0
  0003a	c7 86 a8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+168], 0
  00044	c7 86 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+172], 0
  0004e	c7 86 b0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+176], 0
  00058	c7 86 b4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+180], 0
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 66   : 				T* pkNewData=new T;

  00062	eb 02		 jmp	 SHORT $LN7@New
$LN6@New:
  00064	33 f6		 xor	 esi, esi
$LN7@New:

; 67   : 				m_kVct_pkData.push_back(pkNewData);

  00066	8d 45 fc	 lea	 eax, DWORD PTR _pkNewData$1[ebp]
  00069	89 75 fc	 mov	 DWORD PTR _pkNewData$1[ebp], esi
  0006c	50		 push	 eax
  0006d	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+4
  00072	e8 00 00 00 00	 call	 ?push_back@?$vector@PAUSEffectMeshData@CEffectMesh@@V?$allocator@PAUSEffectMeshData@CEffectMesh@@@std@@@std@@QAEXABQAUSEffectMeshData@CEffectMesh@@@Z ; std::vector<CEffectMesh::SEffectMeshData *,std::allocator<CEffectMesh::SEffectMeshData *> >::push_back

; 68   : 				++m_uUsedCapacity;

  00077	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+32
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 11   : 	return ms_kPool.Alloc();

  0007d	8b c6		 mov	 eax, esi
  0007f	5e		 pop	 esi

; 12   : }

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
$LN4@New:
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 72   : 			T* pkFreeData=m_kVct_pkFree.back();

  00084	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1744 :         --_Mylast;

  00087	83 c1 fc	 add	 ecx, -4			; fffffffcH
  0008a	89 0d 14 00 00
	00		 mov	 DWORD PTR ?ms_kPool@SEffectMeshData@CEffectMesh@@2V?$CDynamicPool@USEffectMeshData@CEffectMesh@@@@A+20, ecx
; File C:\Marty 5.5\Src-Client\Client\EffectLib\EffectMesh.cpp

; 12   : }

  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
?New@SEffectMeshData@CEffectMesh@@SAPAU12@XZ ENDP	; CEffectMesh::SEffectMeshData::New
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ PROC ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::~vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	74 5a		 je	 SHORT $LN5@vector
  0000a	53		 push	 ebx

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  0000e	3b f3		 cmp	 esi, ebx
  00010	74 0f		 je	 SHORT $LN10@vector
$LL11@vector:
  00012	8d 4e 14	 lea	 ecx, DWORD PTR [esi+20]
  00015	e8 00 00 00 00	 call	 ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
  0001a	83 c6 20	 add	 esi, 32			; 00000020H
  0001d	3b f3		 cmp	 esi, ebx
  0001f	75 f1		 jne	 SHORT $LL11@vector
$LN10@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00021	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00024	8b 07		 mov	 eax, DWORD PTR [edi]
  00026	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00028	83 e1 e0	 and	 ecx, -32		; ffffffe0H
  0002b	5b		 pop	 ebx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0002c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00032	72 12		 jb	 SHORT $LN41@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00034	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00037	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0003a	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0003f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00042	77 23		 ja	 SHORT $LN38@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00044	8b c2		 mov	 eax, edx
$LN41@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00046	51		 push	 ecx
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0004d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00053	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00056	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 2082 :             _Myend   = nullptr;

  0005d	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN5@vector:
  00064	5f		 pop	 edi

; 820  :     }

  00065	5e		 pop	 esi
  00066	c3		 ret	 0
$LN38@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00067	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN54@vector:
  0006c	cc		 int	 3
??1?$vector@USEffectFrameData@CEffectMesh@@V?$allocator@USEffectFrameData@CEffectMesh@@@std@@@std@@QAE@XZ ENDP ; std::vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >::~vector<CEffectMesh::SEffectFrameData,std::allocator<CEffectMesh::SEffectFrameData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@CAXXZ PROC ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@CAXXZ ENDP ; std::vector<SPTVertex,std::allocator<SPTVertex> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ PROC ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	74 54		 je	 SHORT $LN5@vector

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000a	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0000d	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  00012	2b ce		 sub	 ecx, esi
  00014	f7 e9		 imul	 ecx
  00016	c1 fa 03	 sar	 edx, 3
  00019	8b c2		 mov	 eax, edx
  0001b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001e	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00020	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00023	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00026	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002c	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002e	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00031	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00034	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00036	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00039	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0003c	77 23		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003e	8b f2		 mov	 esi, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	51		 push	 ecx
  00041	56		 push	 esi
  00042	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00047	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0004d	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00050	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 2082 :             _Myend   = nullptr;

  00057	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN5@vector:
  0005e	5f		 pop	 edi

; 820  :     }

  0005f	5e		 pop	 esi
  00060	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00061	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00066	cc		 int	 3
??1?$vector@USPTVertex@@V?$allocator@USPTVertex@@@std@@@std@@QAE@XZ ENDP ; std::vector<SPTVertex,std::allocator<SPTVertex> >::~vector<SPTVertex,std::allocator<SPTVertex> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
;	COMDAT ??1CGotoChild@CTextFileLoader@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CGotoChild@CTextFileLoader@@QAE@XZ PROC		; CTextFileLoader::CGotoChild::~CGotoChild, COMDAT
; _this$ = ecx

; 54   : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGotoChild@CTextFileLoader@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 55   : 				m_pOwner->SetParentNode();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	e8 00 00 00 00	 call	 ?SetParentNode@CTextFileLoader@@QAEHXZ ; CTextFileLoader::SetParentNode

; 56   : 			}

  00029	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0002c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00033	59		 pop	 ecx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
  00038	cc		 int	 3
  00039	cc		 int	 3
  0003a	cc		 int	 3
  0003b	cc		 int	 3
  0003c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CGotoChild@CTextFileLoader@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGotoChild@CTextFileLoader@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGotoChild@CTextFileLoader@@QAE@XZ ENDP		; CTextFileLoader::CGotoChild::~CGotoChild
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	0f 84 a6 00 00
	00		 je	 $LN5@vector
  0000e	53		 push	 ebx

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000f	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00012	3b f3		 cmp	 esi, ebx
  00014	74 47		 je	 SHORT $LN87@vector
$LL11@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00016	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00019	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0001c	76 27		 jbe	 SHORT $LN40@vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00020	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00021	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00027	72 12		 jb	 SHORT $LN51@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00029	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00031	83 c0 fc	 add	 eax, -4			; fffffffcH
  00034	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00037	77 7e		 ja	 SHORT $LN74@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00039	8b c2		 mov	 eax, edx
$LN51@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00042	83 c4 08	 add	 esp, 8
$LN40@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00045	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  0004c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00053	c6 06 00	 mov	 BYTE PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00056	83 c6 18	 add	 esi, 24			; 00000018H
  00059	3b f3		 cmp	 esi, ebx
  0005b	75 b9		 jne	 SHORT $LL11@vector
$LN87@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0005d	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00060	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00065	8b 37		 mov	 esi, DWORD PTR [edi]
  00067	2b ce		 sub	 ecx, esi
  00069	f7 e9		 imul	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0006b	5b		 pop	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006c	c1 fa 02	 sar	 edx, 2
  0006f	8b c2		 mov	 eax, edx
  00071	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00074	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00076	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00079	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0007c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00082	72 12		 jb	 SHORT $LN77@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00084	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00087	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0008a	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0008c	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0008f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00092	77 23		 ja	 SHORT $LN74@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00094	8b f2		 mov	 esi, edx
$LN77@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00096	51		 push	 ecx
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0009d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000a3	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000a6	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 2082 :             _Myend   = nullptr;

  000ad	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN5@vector:
  000b4	5f		 pop	 edi

; 820  :     }

  000b5	5e		 pop	 esi
  000b6	c3		 ret	 0
$LN74@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN95@vector:
  000bc	cc		 int	 3
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3045 :         auto& _My_data = _Mypair._Myval2;
; 3046 :         _My_data._Orphan_all();
; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 27		 jbe	 SHORT $LN16@Tidy_deall
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN27@Tidy_deall

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN24@Tidy_deall

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN27@Tidy_deall:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN16@Tidy_deall:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3058 :     }

  00044	c3		 ret	 0
$LN24@Tidy_deall:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN35@Tidy_deall:
  0004a	cc		 int	 3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
$T1 = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1592 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1593 :         // assign [_Ptr, _Ptr + _Count)
; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 416  :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 434  :         return _Myres > _Small_string_capacity;

  00018	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 417  :         if (_Large_mode_engaged()) {

  0001b	76 02		 jbe	 SHORT $LN5@assign

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1597 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 1609 :             },
; 1610 :             _Ptr);
; 1611 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 2962 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 c7 00 00
	00		 ja	 $LN87@assign

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 12		 jbe	 SHORT $LN23@assign

; 2944 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	eb 45		 jmp	 SHORT $LN85@assign
$LN23@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00069	8b d1		 mov	 edx, ecx
  0006b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00070	d1 ea		 shr	 edx, 1
  00072	2b c2		 sub	 eax, edx
  00074	3b c8		 cmp	 ecx, eax
  00076	76 12		 jbe	 SHORT $LN24@assign

; 2948 :             return _Max;

  00078	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0007d	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00088	eb 24		 jmp	 SHORT $LN85@assign
$LN24@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0008a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0008d	3b f8		 cmp	 edi, eax
  0008f	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  00092	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  00095	85 c0		 test	 eax, eax
  00097	74 18		 je	 SHORT $LN84@assign
$LN37@assign:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00099	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0009e	72 08		 jb	 SHORT $LN38@assign

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a6	eb 06		 jmp	 SHORT $LN85@assign
$LN38@assign:

; 136  :         return ::operator new(_Bytes);

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN85@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000ae	83 c4 04	 add	 esp, 4
$LN84@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b1	53		 push	 ebx
  000b2	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000b5	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b8	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000b9	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  000bc	89 7e 14	 mov	 DWORD PTR [esi+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bf	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000c4	8b 7d 0c	 mov	 edi, DWORD PTR $T1[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  000ca	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000cd	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  000d1	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000d4	76 29		 jbe	 SHORT $LN16@assign

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000d6	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000db	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000e1	72 12		 jb	 SHORT $LN66@assign

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000e3	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000e6	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000e9	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000eb	83 c0 fc	 add	 eax, -4			; fffffffcH
  000ee	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f1	77 19		 ja	 SHORT $LN63@assign

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000f3	8b c2		 mov	 eax, edx
$LN66@assign:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000f5	51		 push	 ecx
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000fc	83 c4 08	 add	 esp, 8
$LN16@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1604 :         return _Reallocate_for(

  000ff	89 3e		 mov	 DWORD PTR [esi], edi

; 1609 :             },
; 1610 :             _Ptr);
; 1611 :     }

  00101	8b c6		 mov	 eax, esi
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 08 00	 ret	 8
$LN63@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN87@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2963 :             _Xlen_string(); // result too long

  00111	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN82@assign:
  00116	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__New_size$1$ = -16					; size = 4
tv518 = -16						; size = 4
__Old_size$1$ = -12					; size = 4
__Old$1$ = -8						; size = 4
$T1 = -4						; size = 4
tv508 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
tv503 = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1486 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 1487 :         // append [_Ptr, _Ptr + _Count)
; 1488 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 1489 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d f4	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 f8	 mov	 DWORD PTR __Old$1$[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 2e		 ja	 SHORT $LN2@append

; 1490 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1491 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 416  :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 434  :         return _Myres > _Small_string_capacity;

  0002a	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 417  :         if (_Large_mode_engaged()) {

  0002d	76 02		 jbe	 SHORT $LN5@append

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	53		 push	 ebx
  00032	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1493 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00035	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _memmove
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1494 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00041	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 1507 :     }

  00045	8b c7		 mov	 eax, edi
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN2@append:

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

  00050	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00055	2b c1		 sub	 eax, ecx
  00057	3b c3		 cmp	 eax, ebx
  00059	0f 82 1d 01 00
	00		 jb	 $LN98@append

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00062	8b f0		 mov	 esi, eax

; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

  00064	89 45 f0	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00067	83 ce 0f	 or	 esi, 15			; 0000000fH
  0006a	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00070	76 12		 jbe	 SHORT $LN23@append

; 2944 :             return _Max;

  00072	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00077	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00082	eb 4b		 jmp	 SHORT $LN96@append
$LN23@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00084	8b c2		 mov	 eax, edx
  00086	d1 e8		 shr	 eax, 1
  00088	89 45 fc	 mov	 DWORD PTR tv508[ebp], eax
  0008b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00090	2b 45 fc	 sub	 eax, DWORD PTR tv508[ebp]
  00093	3b d0		 cmp	 edx, eax
  00095	76 12		 jbe	 SHORT $LN24@append

; 2948 :             return _Max;

  00097	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009c	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a7	eb 26		 jmp	 SHORT $LN96@append
$LN24@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000a9	8b 45 fc	 mov	 eax, DWORD PTR tv508[ebp]
  000ac	03 c2		 add	 eax, edx
  000ae	3b f0		 cmp	 esi, eax
  000b0	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  000b3	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  000b6	85 c0		 test	 eax, eax
  000b8	74 1e		 je	 SHORT $LN95@append
$LN37@append:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000ba	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000bf	72 08		 jb	 SHORT $LN38@append

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000c7	eb 06		 jmp	 SHORT $LN96@append
$LN38@append:

; 136  :         return ::operator new(_Bytes);

  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN96@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3005 :         _My_data._Mysize      = _New_size;

  000cf	8b 55 f8	 mov	 edx, DWORD PTR __Old$1$[ebp]
  000d2	83 c4 04	 add	 esp, 4
  000d5	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
$LN95@append:
  000d8	8b 5d f0	 mov	 ebx, DWORD PTR __New_size$1$[ebp]
  000db	89 5f 10	 mov	 DWORD PTR [edi+16], ebx

; 3006 :         _My_data._Myres       = _New_capacity;
; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000de	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  000e1	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000e4	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  000e7	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  000ea	89 75 f0	 mov	 DWORD PTR tv518[ebp], esi
  000ed	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  000f0	89 45 0c	 mov	 DWORD PTR tv503[ebp], eax

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

  000f3	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  000f6	51		 push	 ecx
  000f7	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  000fa	76 56		 jbe	 SHORT $LN16@append

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000fc	8b 37		 mov	 esi, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000fe	56		 push	 esi
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _memcpy
  00105	53		 push	 ebx
  00106	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00109	ff 75 f0	 push	 DWORD PTR tv518[ebp]
  0010c	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00111	8b 45 0c	 mov	 eax, DWORD PTR tv503[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00114	83 c4 18	 add	 esp, 24			; 00000018H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00117	8b 4d f8	 mov	 ecx, DWORD PTR __Old$1$[ebp]
  0011a	41		 inc	 ecx

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0011b	c6 00 00	 mov	 BYTE PTR [eax], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0011e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00124	72 12		 jb	 SHORT $LN69@append

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00126	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00129	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0012c	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012e	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00131	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00134	77 4b		 ja	 SHORT $LN66@append

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00136	8b f2		 mov	 esi, edx
$LN69@append:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00138	51		 push	 ecx
  00139	56		 push	 esi
  0013a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1498 :         return _Reallocate_grow_by(

  0013f	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00142	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1498 :         return _Reallocate_grow_by(

  00145	89 07		 mov	 DWORD PTR [edi], eax

; 1507 :     }

  00147	8b c7		 mov	 eax, edi
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx
  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 08 00	 ret	 8
$LN16@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00152	57		 push	 edi
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	53		 push	 ebx
  0015a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0015d	56		 push	 esi
  0015e	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00163	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00166	83 c4 18	 add	 esp, 24			; 00000018H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00169	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1498 :         return _Reallocate_grow_by(

  0016c	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0016f	89 07		 mov	 DWORD PTR [edi], eax

; 1507 :     }

  00171	8b c7		 mov	 eax, edi
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5b		 pop	 ebx
  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	c2 08 00	 ret	 8
$LN98@append:

; 2994 :             _Xlen_string(); // result too long

  0017c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN66@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00181	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN93@append:
  00186	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 27		 jbe	 SHORT $LN19@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN30@basic_stri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN27@basic_stri

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN30@basic_stri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN19@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 1366 :     }

  00044	c3		 ret	 0
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 744  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b d9		 mov	 ebx, ecx
  00008	0f 57 c0	 xorps	 xmm0, xmm0
  0000b	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000c	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  0000f	8b f7		 mov	 esi, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00011	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00014	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001b	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00022	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL51@basic_stri:
  00025	8a 06		 mov	 al, BYTE PTR [esi]
  00027	46		 inc	 esi
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL51@basic_stri
  0002c	2b f1		 sub	 esi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 857  :         if (_Count > max_size()) {

  0002e	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00034	0f 87 9b 00 00
	00		 ja	 $LN62@basic_stri

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();
; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

  0003a	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0003d	77 24		 ja	 SHORT $LN21@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0003f	56		 push	 esi
  00040	57		 push	 edi
  00041	53		 push	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 866  :             _My_data._Mysize = _Count;

  00042	89 73 10	 mov	 DWORD PTR [ebx+16], esi

; 867  :             _My_data._Myres  = _Small_string_capacity;

  00045	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0004c	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00051	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 746  :     }

  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	8b c3		 mov	 eax, ebx
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN21@basic_stri:

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00063	8b fe		 mov	 edi, esi
  00065	83 cf 0f	 or	 edi, 15			; 0000000fH
  00068	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006e	76 12		 jbe	 SHORT $LN27@basic_stri

; 2944 :             return _Max;

  00070	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00075	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00080	eb 26		 jmp	 SHORT $LN60@basic_stri
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00082	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00087	3b f8		 cmp	 edi, eax
  00089	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0008c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  0008f	85 c0		 test	 eax, eax
  00091	74 18		 je	 SHORT $LN59@basic_stri
$LN41@basic_stri:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00093	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00098	72 08		 jb	 SHORT $LN42@basic_stri

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a0	eb 06		 jmp	 SHORT $LN60@basic_stri
$LN42@basic_stri:

; 136  :         return ::operator new(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN60@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000a8	83 c4 04	 add	 esp, 4
$LN59@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ab	56		 push	 esi
  000ac	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000af	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b2	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000b3	89 03		 mov	 DWORD PTR [ebx], eax

; 890  : 
; 891  :         _My_data._Mysize = _Count;

  000b5	89 73 10	 mov	 DWORD PTR [ebx+16], esi

; 892  :         _My_data._Myres  = _New_capacity;

  000b8	89 7b 14	 mov	 DWORD PTR [ebx+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bb	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000c0	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 746  :     }

  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	5f		 pop	 edi

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000c7	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 746  :     }

  000cb	8b c3		 mov	 eax, ebx
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 04 00	 ret	 4
$LN62@basic_stri:

; 858  :             _Xlen_string(); // result too long

  000d5	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN57@basic_stri:
  000da	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 512  :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
