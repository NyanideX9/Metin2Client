; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\EffectLib\Distribute\ParticleProperty.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CParticleProperty@@QAE@XZ			; CParticleProperty::CParticleProperty
PUBLIC	??1CParticleProperty@@UAE@XZ			; CParticleProperty::~CParticleProperty
PUBLIC	?Clear@CParticleProperty@@QAEXXZ		; CParticleProperty::Clear
PUBLIC	?InsertTexture@CParticleProperty@@QAEXPBD@Z	; CParticleProperty::InsertTexture
PUBLIC	?SetTexture@CParticleProperty@@QAE_NPBD@Z	; CParticleProperty::SetTexture
PUBLIC	?_Xlength@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@CAXXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Xlength
PUBLIC	?_Xlength@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@CAXXZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Xlength
PUBLIC	?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength
PUBLIC	??4CParticleProperty@@QAEAAV0@ABV0@@Z		; CParticleProperty::operator=
PUBLIC	??_GCParticleProperty@@UAEPAXI@Z		; CParticleProperty::`scalar deleting destructor'
PUBLIC	??$_Assign_counted_range@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEXPAPAVCGraphicImage@@I@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Assign_counted_range<CGraphicImage * *>
PUBLIC	??$_Assign_counted_range@PAV?$CTimeEvent@UDWORDCOLOR@@@@@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@AAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Assign_counted_range<CTimeEvent<DWORDCOLOR> *>
PUBLIC	??$_Assign_counted_range@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@AAEXPAV?$CTimeEvent@M@@I@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Assign_counted_range<CTimeEvent<float> *>
PUBLIC	??$_Copy_memmove_n@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@I0@Z ; std::_Copy_memmove_n<CGraphicImage * *,CGraphicImage * *>
PUBLIC	??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
PUBLIC	??$_Copy_memmove_n@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@I0@Z ; std::_Copy_memmove_n<CTimeEvent<float> *,CTimeEvent<float> *>
PUBLIC	??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CGraphicImage * *>
PUBLIC	??$_Copy_memmove_tail@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@QBDQAV1@II@Z ; std::_Copy_memmove_tail<CTimeEvent<float> *>
PUBLIC	??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_7CParticleProperty@@6B@			; CParticleProperty::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CParticleProperty@@6B@			; CParticleProperty::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCParticleProperty@@@8			; CParticleProperty `RTTI Type Descriptor'
PUBLIC	??_R3CParticleProperty@@8			; CParticleProperty::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CParticleProperty@@8			; CParticleProperty::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CParticleProperty@@8		; CParticleProperty::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_ECParticleProperty@@UAEPAXI@Z:PROC		; CParticleProperty::`vector deleting destructor'
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	__CxxThrowException@8:PROC
EXTRN	_memmove:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@CParticleProperty@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CParticleProperty@@8 DD FLAT:??_R0?AVCParticleProperty@@@8 ; CParticleProperty::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CParticleProperty@@8
rdata$r	ENDS
;	COMDAT ??_R2CParticleProperty@@8
rdata$r	SEGMENT
??_R2CParticleProperty@@8 DD FLAT:??_R1A@?0A@EA@CParticleProperty@@8 ; CParticleProperty::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CParticleProperty@@8
rdata$r	SEGMENT
??_R3CParticleProperty@@8 DD 00H			; CParticleProperty::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CParticleProperty@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCParticleProperty@@@8
data$rs	SEGMENT
??_R0?AVCParticleProperty@@@8 DD FLAT:??_7type_info@@6B@ ; CParticleProperty `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCParticleProperty@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CParticleProperty@@6B@
rdata$r	SEGMENT
??_R4CParticleProperty@@6B@ DD 00H			; CParticleProperty::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCParticleProperty@@@8
	DD	FLAT:??_R3CParticleProperty@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CParticleProperty@@6B@
CONST	SEGMENT
??_7CParticleProperty@@6B@ DD FLAT:??_R4CParticleProperty@@6B@ ; CParticleProperty::`vftable'
	DD	FLAT:??_ECParticleProperty@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CGraphicImage * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@QBDQAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@QBDQAV1@II@Z PROC ; std::_Copy_memmove_tail<CTimeEvent<float> *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@QBDQAV1@II@Z ENDP ; std::_Copy_memmove_tail<CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z PROC ; std::_Copy_memmove_tail<CGraphicImage * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z ENDP ; std::_Copy_memmove_tail<CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_n@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@I0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Object_count$ = 12					; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove_n@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@I0@Z PROC ; std::_Copy_memmove_n<CTimeEvent<float> *,CTimeEvent<float> *>, COMDAT

; 4790 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Object_count, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4791 :     const auto _First_ptr  = _STD _To_address(_First);
; 4792 :     const auto _First_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4793 :     const auto _Byte_count = _Object_count * sizeof(*_First_ptr);
; 4794 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Object_count$[ebp]
  00006	50		 push	 eax
  00007	c1 e0 03	 shl	 eax, 3
  0000a	50		 push	 eax
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAV?$CTimeEvent@M@@@std@@YAPAV?$CTimeEvent@M@@QBDQAV1@II@Z ; std::_Copy_memmove_tail<CTimeEvent<float> *>
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 4795 : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Copy_memmove_n@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@I0@Z ENDP ; std::_Copy_memmove_n<CTimeEvent<float> *,CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv652 = -8						; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 09 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004a	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv652[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00069	0f 87 c7 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00076	89 45 f8	 mov	 DWORD PTR tv652[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a1	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv650[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	3b d8		 cmp	 ebx, eax
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>
  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicImage * *,CGraphicImage * *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00116	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00118	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR tv652[ebp]
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_n@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@I0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Object_count$ = 12					; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove_n@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@I0@Z PROC ; std::_Copy_memmove_n<CGraphicImage * *,CGraphicImage * *>, COMDAT

; 4790 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Object_count, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4791 :     const auto _First_ptr  = _STD _To_address(_First);
; 4792 :     const auto _First_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4793 :     const auto _Byte_count = _Object_count * sizeof(*_First_ptr);
; 4794 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Object_count$[ebp]
  00006	50		 push	 eax
  00007	c1 e0 02	 shl	 eax, 2
  0000a	50		 push	 eax
  0000b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCGraphicImage@@@std@@YAPAPAVCGraphicImage@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CGraphicImage * *>
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 4795 : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Copy_memmove_n@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@I0@Z ENDP ; std::_Copy_memmove_n<CGraphicImage * *,CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Assign_counted_range@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@AAEXPAV?$CTimeEvent@M@@I@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Oldsize$1$ = 12					; size = 4
$T3 = 12						; size = 4
??$_Assign_counted_range@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@AAEXPAV?$CTimeEvent@M@@I@Z PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Assign_counted_range<CTimeEvent<float> *>, COMDAT
; _this$ = ecx

; 1405 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1406 :         // assign elements from counted range _First + [0, _Newsize)
; 1407 :         auto& _Al         = _Getal();
; 1408 :         auto& _My_data    = _Mypair._Myval2;
; 1409 :         pointer& _Myfirst = _My_data._Myfirst;
; 1410 :         pointer& _Mylast  = _My_data._Mylast;
; 1411 :         pointer& _Myend   = _My_data._Myend;
; 1412 : 
; 1413 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1414 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1415 : 
; 1416 :         _My_data._Orphan_all();
; 1417 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1418 :         if (_Newsize > _Oldcapacity) {

  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0000e	8b 33		 mov	 esi, DWORD PTR [ebx]
  00010	2b ce		 sub	 ecx, esi
  00012	c1 f9 03	 sar	 ecx, 3
  00015	3b f9		 cmp	 edi, ecx
  00017	0f 86 da 00 00
	00		 jbe	 $LN5@Assign_cou

; 1688 :         if (_Newsize > max_size()) {

  0001d	81 ff ff ff ff
	1f		 cmp	 edi, 536870911		; 1fffffffH
  00023	0f 87 30 01 00
	00		 ja	 $LN114@Assign_cou

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00029	8b d1		 mov	 edx, ecx
  0002b	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH
  00030	d1 ea		 shr	 edx, 1
  00032	2b c2		 sub	 eax, edx
  00034	3b c8		 cmp	 ecx, eax
  00036	76 09		 jbe	 SHORT $LN15@Assign_cou

; 1997 :             return _Max; // geometric growth would overflow

  00038	c7 45 0c ff ff
	ff 1f		 mov	 DWORD PTR $T3[ebp], 536870911 ; 1fffffffH
  0003f	eb 0b		 jmp	 SHORT $LN16@Assign_cou
$LN15@Assign_cou:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00041	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00044	3b c7		 cmp	 eax, edi
  00046	0f 42 c7	 cmovb	 eax, edi
  00049	89 45 0c	 mov	 DWORD PTR $T3[ebp], eax
$LN16@Assign_cou:

; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  0004c	85 f6		 test	 esi, esi
  0004e	74 3f		 je	 SHORT $LN12@Assign_cou
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00050	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00053	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00059	72 16		 jb	 SHORT $LN37@Assign_cou

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0005b	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  0005e	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00061	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00063	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00066	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00069	0f 87 f4 00 00
	00		 ja	 $LN34@Assign_cou

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0006f	8b f2		 mov	 esi, edx
$LN37@Assign_cou:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00071	51		 push	 ecx
  00072	56		 push	 esi
  00073	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1699 :             _Myfirst = nullptr;

  00078	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007e	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1700 :             _Mylast  = nullptr;

  00081	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1701 :             _Myend   = nullptr;

  00088	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
$LN12@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0008f	8b 45 0c	 mov	 eax, DWORD PTR $T3[ebp]
  00092	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00097	0f 87 c1 00 00
	00		 ja	 $LN115@Assign_cou

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0009d	8d 34 c5 00 00
	00 00		 lea	 esi, DWORD PTR [eax*8]

; 227  :     if (_Bytes == 0) {

  000a4	85 f6		 test	 esi, esi
  000a6	75 04		 jne	 SHORT $LN52@Assign_cou

; 228  :         return nullptr;

  000a8	33 d2		 xor	 edx, edx
  000aa	eb 1a		 jmp	 SHORT $LN51@Assign_cou
$LN52@Assign_cou:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000ac	56		 push	 esi
  000ad	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  000b3	72 07		 jb	 SHORT $LN53@Assign_cou

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000b5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ba	eb 05		 jmp	 SHORT $LN112@Assign_cou
$LN53@Assign_cou:

; 136  :         return ::operator new(_Bytes);

  000bc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN112@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2020 :         _Myfirst              = _Newvec;

  000c1	8b d0		 mov	 edx, eax
  000c3	83 c4 04	 add	 esp, 4
$LN51@Assign_cou:
  000c6	89 13		 mov	 DWORD PTR [ebx], edx

; 2022 :         _Myend                = _Newvec + _Newcapacity;

  000c8	8d 04 16	 lea	 eax, DWORD PTR [esi+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1881 :     auto _UFirst = _STD _Get_unwrapped(_STD move(_First));

  000cb	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2021 :         _Mylast               = _Newvec;

  000ce	89 53 04	 mov	 DWORD PTR [ebx+4], edx

; 2022 :         _Myend                = _Newvec + _Newcapacity;

  000d1	89 43 08	 mov	 DWORD PTR [ebx+8], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

  000d4	85 ff		 test	 edi, edi
  000d6	74 5e		 je	 SHORT $LN73@Assign_cou
$LL63@Assign_cou:

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  000d8	8b 06		 mov	 eax, DWORD PTR [esi]

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

  000da	8d 76 08	 lea	 esi, DWORD PTR [esi+8]

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  000dd	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  000e0	89 02		 mov	 DWORD PTR [edx], eax
  000e2	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1808 :         ++_Last;

  000e5	83 c2 08	 add	 edx, 8

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

  000e8	83 ef 01	 sub	 edi, 1
  000eb	75 eb		 jne	 SHORT $LL63@Assign_cou
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1465 :     }

  000ed	5f		 pop	 edi
  000ee	5e		 pop	 esi
  000ef	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  000f2	5b		 pop	 ebx
  000f3	5d		 pop	 ebp
  000f4	c2 08 00	 ret	 8
$LN5@Assign_cou:

; 1419 :             _Clear_and_reserve_geometric(_Newsize);
; 1420 :             if constexpr (_Nothrow_construct) {
; 1421 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1422 :                 _ASAN_VECTOR_CREATE;
; 1423 :             } else {
; 1424 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1425 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1426 :             }
; 1427 :             return;
; 1428 :         }
; 1429 : 
; 1430 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  000f7	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  000fa	2b c6		 sub	 eax, esi
  000fc	c1 f8 03	 sar	 eax, 3
  000ff	89 45 0c	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1431 :         if (_Newsize > _Oldsize) {

  00102	56		 push	 esi
  00103	3b f8		 cmp	 edi, eax
  00105	76 39		 jbe	 SHORT $LN6@Assign_cou

; 1432 :             bool _Copied = false;
; 1433 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1434 : #if _HAS_CXX20
; 1435 :                 if (!_STD is_constant_evaluated())
; 1436 : #endif // _HAS_CXX20
; 1437 :                 {
; 1438 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);

  00107	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0010a	50		 push	 eax
  0010b	56		 push	 esi
  0010c	e8 00 00 00 00	 call	 ??$_Copy_memmove_n@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@I0@Z ; std::_Copy_memmove_n<CTimeEvent<float> *,CTimeEvent<float> *>

; 1439 :                     _First += _Oldsize;

  00111	8b 45 0c	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00117	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1439 :                     _First += _Oldsize;

  0011a	8d 34 c6	 lea	 esi, DWORD PTR [esi+eax*8]

; 1440 :                     _Copied = true;
; 1441 :                 }
; 1442 :             }
; 1443 : 
; 1444 :             if (!_Copied) {
; 1445 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {
; 1446 :                     *_Mid = *_First;
; 1447 :                 }
; 1448 :             }
; 1449 : 
; 1450 :             if constexpr (_Nothrow_construct) {
; 1451 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1452 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

  0011d	2b f8		 sub	 edi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

  0011f	74 15		 je	 SHORT $LN73@Assign_cou
$LL74@Assign_cou:

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00121	8b 06		 mov	 eax, DWORD PTR [esi]

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

  00123	8d 76 08	 lea	 esi, DWORD PTR [esi+8]

; 1807 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00126	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  00129	89 02		 mov	 DWORD PTR [edx], eax
  0012b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1808 :         ++_Last;

  0012e	83 c2 08	 add	 edx, 8

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

  00131	83 ef 01	 sub	 edi, 1
  00134	75 eb		 jne	 SHORT $LL74@Assign_cou
$LN73@Assign_cou:
  00136	5f		 pop	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1465 :     }

  00137	5e		 pop	 esi
  00138	89 53 04	 mov	 DWORD PTR [ebx+4], edx
  0013b	5b		 pop	 ebx
  0013c	5d		 pop	 ebp
  0013d	c2 08 00	 ret	 8
$LN6@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 4824 :             return _Copy_memmove_n(_First, static_cast<size_t>(_Count), _Dest);

  00140	57		 push	 edi
  00141	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00144	e8 00 00 00 00	 call	 ??$_Copy_memmove_n@PAV?$CTimeEvent@M@@PAV1@@std@@YAPAV?$CTimeEvent@M@@PAV1@I0@Z ; std::_Copy_memmove_n<CTimeEvent<float> *,CTimeEvent<float> *>
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1459 :             const pointer _Newlast = _Myfirst + _Newsize;

  0014c	8d 04 fe	 lea	 eax, DWORD PTR [esi+edi*8]

; 1460 :             _STD _Copy_n_unchecked4(_STD move(_First), _Newsize, _Myfirst);
; 1461 :             _STD _Destroy_range(_Newlast, _Mylast, _Al);
; 1462 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1463 :             _Mylast = _Newlast;

  0014f	89 43 04	 mov	 DWORD PTR [ebx+4], eax
  00152	5f		 pop	 edi

; 1465 :     }

  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	5d		 pop	 ebp
  00156	c2 08 00	 ret	 8
$LN114@Assign_cou:

; 1689 :             _Xlength();

  00159	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@CAXXZ ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Xlength
$LN115@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0015e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN34@Assign_cou:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00163	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN111@Assign_cou:
  00168	cc		 int	 3
??$_Assign_counted_range@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@AAEXPAV?$CTimeEvent@M@@I@Z ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Assign_counted_range<CTimeEvent<float> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\Type.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\Type.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\Type.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\Type.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File C:\Marty 5.5\Src-Client\Client\EffectLib\Type.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Assign_counted_range@PAV?$CTimeEvent@UDWORDCOLOR@@@@@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@AAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Oldsize$1$ = 12					; size = 4
__Ptr_container$1$ = 12					; size = 4
??$_Assign_counted_range@PAV?$CTimeEvent@UDWORDCOLOR@@@@@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@AAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Assign_counted_range<CTimeEvent<DWORDCOLOR> *>, COMDAT
; _this$ = ecx

; 1405 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx
  00006	56		 push	 esi

; 1406 :         // assign elements from counted range _First + [0, _Newsize)
; 1407 :         auto& _Al         = _Getal();
; 1408 :         auto& _My_data    = _Mypair._Myval2;
; 1409 :         pointer& _Myfirst = _My_data._Myfirst;
; 1410 :         pointer& _Mylast  = _My_data._Mylast;
; 1411 :         pointer& _Myend   = _My_data._Myend;
; 1412 : 
; 1413 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1414 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1415 : 
; 1416 :         _My_data._Orphan_all();
; 1417 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1418 :         if (_Newsize > _Oldcapacity) {

  00007	8b 75 0c	 mov	 esi, DWORD PTR __Newsize$[ebp]
  0000a	57		 push	 edi
  0000b	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0000e	8b 13		 mov	 edx, DWORD PTR [ebx]
  00010	2b ca		 sub	 ecx, edx
  00012	c1 f9 03	 sar	 ecx, 3
  00015	3b f1		 cmp	 esi, ecx
  00017	0f 86 d2 00 00
	00		 jbe	 $LN5@Assign_cou

; 1688 :         if (_Newsize > max_size()) {

  0001d	81 fe ff ff ff
	1f		 cmp	 esi, 536870911		; 1fffffffH
  00023	0f 87 47 01 00
	00		 ja	 $LN144@Assign_cou

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00029	8b f9		 mov	 edi, ecx
  0002b	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH
  00030	d1 ef		 shr	 edi, 1
  00032	2b c7		 sub	 eax, edi
  00034	3b c8		 cmp	 ecx, eax
  00036	76 07		 jbe	 SHORT $LN15@Assign_cou

; 1997 :             return _Max; // geometric growth would overflow

  00038	bf ff ff ff 1f	 mov	 edi, 536870911		; 1fffffffH
  0003d	eb 07		 jmp	 SHORT $LN16@Assign_cou
$LN15@Assign_cou:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0003f	03 f9		 add	 edi, ecx

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00041	3b fe		 cmp	 edi, esi
  00043	0f 42 fe	 cmovb	 edi, esi
$LN16@Assign_cou:

; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00046	85 d2		 test	 edx, edx
  00048	74 43		 je	 SHORT $LN12@Assign_cou
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0004a	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0004d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00053	72 1a		 jb	 SHORT $LN37@Assign_cou

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00055	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  00058	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0005b	2b d0		 sub	 edx, eax
  0005d	89 45 0c	 mov	 DWORD PTR __Ptr_container$1$[ebp], eax

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00060	8d 42 fc	 lea	 eax, DWORD PTR [edx-4]
  00063	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00066	0f 87 0e 01 00
	00		 ja	 $LN34@Assign_cou

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0006c	8b 55 0c	 mov	 edx, DWORD PTR __Ptr_container$1$[ebp]
$LN37@Assign_cou:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0006f	51		 push	 ecx
  00070	52		 push	 edx
  00071	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1699 :             _Myfirst = nullptr;

  00076	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007c	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1700 :             _Mylast  = nullptr;

  0007f	c7 43 04 00 00
	00 00		 mov	 DWORD PTR [ebx+4], 0

; 1701 :             _Myend   = nullptr;

  00086	c7 43 08 00 00
	00 00		 mov	 DWORD PTR [ebx+8], 0
$LN12@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0008d	81 ff ff ff ff
	1f		 cmp	 edi, 536870911		; 1fffffffH
  00093	0f 87 dc 00 00
	00		 ja	 $LN145@Assign_cou

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00099	c1 e7 03	 shl	 edi, 3

; 227  :     if (_Bytes == 0) {

  0009c	85 ff		 test	 edi, edi
  0009e	75 04		 jne	 SHORT $LN52@Assign_cou

; 228  :         return nullptr;

  000a0	33 c9		 xor	 ecx, ecx
  000a2	eb 1a		 jmp	 SHORT $LN51@Assign_cou
$LN52@Assign_cou:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000a4	57		 push	 edi
  000a5	81 ff 00 10 00
	00		 cmp	 edi, 4096		; 00001000H
  000ab	72 07		 jb	 SHORT $LN53@Assign_cou

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000ad	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000b2	eb 05		 jmp	 SHORT $LN142@Assign_cou
$LN53@Assign_cou:

; 136  :         return ::operator new(_Bytes);

  000b4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN142@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2020 :         _Myfirst              = _Newvec;

  000b9	8b c8		 mov	 ecx, eax
  000bb	83 c4 04	 add	 esp, 4
$LN51@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1881 :     auto _UFirst = _STD _Get_unwrapped(_STD move(_First));

  000be	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2022 :         _Myend                = _Newvec + _Newcapacity;

  000c1	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  000c4	89 0b		 mov	 DWORD PTR [ebx], ecx
  000c6	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  000c9	89 43 08	 mov	 DWORD PTR [ebx+8], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

  000cc	85 f6		 test	 esi, esi
  000ce	74 6b		 je	 SHORT $LN83@Assign_cou
$LL63@Assign_cou:
  000d0	8b 02		 mov	 eax, DWORD PTR [edx]
  000d2	8d 52 08	 lea	 edx, DWORD PTR [edx+8]
  000d5	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Marty 5.5\Src-Client\Client\EffectLib\Type.h

; 136  : 		: m_dwColor(r.m_dwColor)

  000d7	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  000da	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  000dd	83 c1 08	 add	 ecx, 8

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

  000e0	83 ee 01	 sub	 esi, 1
  000e3	75 eb		 jne	 SHORT $LL63@Assign_cou
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1465 :     }

  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  000ea	5b		 pop	 ebx
  000eb	5d		 pop	 ebp
  000ec	c2 08 00	 ret	 8
$LN5@Assign_cou:

; 1419 :             _Clear_and_reserve_geometric(_Newsize);
; 1420 :             if constexpr (_Nothrow_construct) {
; 1421 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1422 :                 _ASAN_VECTOR_CREATE;
; 1423 :             } else {
; 1424 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1425 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1426 :             }
; 1427 :             return;
; 1428 :         }
; 1429 : 
; 1430 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  000ef	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000f2	8b c1		 mov	 eax, ecx
  000f4	2b c2		 sub	 eax, edx
  000f6	c1 f8 03	 sar	 eax, 3
  000f9	89 45 0c	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1431 :         if (_Newsize > _Oldsize) {

  000fc	3b f0		 cmp	 esi, eax
  000fe	76 45		 jbe	 SHORT $LN6@Assign_cou

; 1445 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

  00100	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  00103	3b d1		 cmp	 edx, ecx
  00105	74 1a		 je	 SHORT $LN3@Assign_cou
$LL4@Assign_cou:
  00107	8b 07		 mov	 eax, DWORD PTR [edi]
  00109	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Marty 5.5\Src-Client\Client\EffectLib\Type.h

; 141  : 		m_dwColor = r.m_dwColor;

  0010b	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1445 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

  0010e	83 c7 08	 add	 edi, 8
; File C:\Marty 5.5\Src-Client\Client\EffectLib\Type.h

; 141  : 		m_dwColor = r.m_dwColor;

  00111	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1445 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {

  00114	83 c2 08	 add	 edx, 8
  00117	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0011a	3b d1		 cmp	 edx, ecx
  0011c	75 e9		 jne	 SHORT $LL4@Assign_cou
  0011e	8b 45 0c	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
$LN3@Assign_cou:

; 1446 :                     *_Mid = *_First;
; 1447 :                 }
; 1448 :             }
; 1449 : 
; 1450 :             if constexpr (_Nothrow_construct) {
; 1451 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1452 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);
; 1453 :             } else {
; 1454 :                 _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1455 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

  00121	2b f0		 sub	 esi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

  00123	74 16		 je	 SHORT $LN83@Assign_cou
  00125	2b f9		 sub	 edi, ecx
$LL84@Assign_cou:
  00127	8b 04 39	 mov	 eax, DWORD PTR [ecx+edi]
  0012a	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Marty 5.5\Src-Client\Client\EffectLib\Type.h

; 136  : 		: m_dwColor(r.m_dwColor)

  0012c	8b 44 39 04	 mov	 eax, DWORD PTR [ecx+edi+4]
  00130	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  00133	83 c1 08	 add	 ecx, 8

; 1900 :     for (; _Count != 0; ++_UFirst, (void) --_Count) {

  00136	83 ee 01	 sub	 esi, 1
  00139	75 ec		 jne	 SHORT $LL84@Assign_cou
$LN83@Assign_cou:
  0013b	5f		 pop	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1465 :     }

  0013c	5e		 pop	 esi
  0013d	89 4b 04	 mov	 DWORD PTR [ebx+4], ecx
  00140	5b		 pop	 ebx
  00141	5d		 pop	 ebp
  00142	c2 08 00	 ret	 8
$LN6@Assign_cou:

; 1456 :                 _ASAN_VECTOR_RELEASE_GUARD;
; 1457 :             }
; 1458 :         } else {
; 1459 :             const pointer _Newlast = _Myfirst + _Newsize;
; 1460 :             _STD _Copy_n_unchecked4(_STD move(_First), _Newsize, _Myfirst);

  00145	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00148	8d 3c f2	 lea	 edi, DWORD PTR [edx+esi*8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 4828 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

  0014b	85 f6		 test	 esi, esi
  0014d	74 17		 je	 SHORT $LN100@Assign_cou
  0014f	90		 npad	 1
$LL101@Assign_cou:
  00150	8b 01		 mov	 eax, DWORD PTR [ecx]
  00152	8d 52 08	 lea	 edx, DWORD PTR [edx+8]
  00155	89 42 f8	 mov	 DWORD PTR [edx-8], eax
  00158	8d 49 08	 lea	 ecx, DWORD PTR [ecx+8]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\Type.h

; 141  : 		m_dwColor = r.m_dwColor;

  0015b	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  0015e	89 42 fc	 mov	 DWORD PTR [edx-4], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 4828 :     for (; _Count != 0; ++_Dest, (void) ++_First, --_Count) {

  00161	83 ee 01	 sub	 esi, 1
  00164	75 ea		 jne	 SHORT $LL101@Assign_cou
$LN100@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1463 :             _Mylast = _Newlast;

  00166	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00169	5f		 pop	 edi

; 1465 :     }

  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	5d		 pop	 ebp
  0016d	c2 08 00	 ret	 8
$LN144@Assign_cou:

; 1689 :             _Xlength();

  00170	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@CAXXZ ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Xlength
$LN145@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00175	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN34@Assign_cou:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0017a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN141@Assign_cou:
  0017f	cc		 int	 3
??$_Assign_counted_range@PAV?$CTimeEvent@UDWORDCOLOR@@@@@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@AAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Assign_counted_range<CTimeEvent<DWORDCOLOR> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Assign_counted_range@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEXPAPAVCGraphicImage@@I@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Oldsize$1$ = 12					; size = 4
$T1 = 12						; size = 4
??$_Assign_counted_range@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEXPAPAVCGraphicImage@@I@Z PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Assign_counted_range<CGraphicImage * *>, COMDAT
; _this$ = ecx

; 1405 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1406 :         // assign elements from counted range _First + [0, _Newsize)
; 1407 :         auto& _Al         = _Getal();
; 1408 :         auto& _My_data    = _Mypair._Myval2;
; 1409 :         pointer& _Myfirst = _My_data._Myfirst;
; 1410 :         pointer& _Mylast  = _My_data._Mylast;
; 1411 :         pointer& _Myend   = _My_data._Myend;
; 1412 : 
; 1413 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1414 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1415 : 
; 1416 :         _My_data._Orphan_all();
; 1417 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1418 :         if (_Newsize > _Oldcapacity) {

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0000e	8b 37		 mov	 esi, DWORD PTR [edi]
  00010	2b ce		 sub	 ecx, esi
  00012	c1 f9 02	 sar	 ecx, 2
  00015	3b d9		 cmp	 ebx, ecx
  00017	0f 86 ca 00 00
	00		 jbe	 $LN5@Assign_cou

; 1688 :         if (_Newsize > max_size()) {

  0001d	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  00023	0f 87 fb 00 00
	00		 ja	 $LN105@Assign_cou

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00029	8b d1		 mov	 edx, ecx
  0002b	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00030	d1 ea		 shr	 edx, 1
  00032	2b c2		 sub	 eax, edx
  00034	3b c8		 cmp	 ecx, eax
  00036	76 09		 jbe	 SHORT $LN15@Assign_cou

; 1997 :             return _Max; // geometric growth would overflow

  00038	c7 45 0c ff ff
	ff 3f		 mov	 DWORD PTR $T1[ebp], 1073741823 ; 3fffffffH
  0003f	eb 0b		 jmp	 SHORT $LN16@Assign_cou
$LN15@Assign_cou:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00041	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00044	3b c3		 cmp	 eax, ebx
  00046	0f 42 c3	 cmovb	 eax, ebx
  00049	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
$LN16@Assign_cou:

; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  0004c	85 f6		 test	 esi, esi
  0004e	74 3f		 je	 SHORT $LN12@Assign_cou
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00050	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00053	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00059	72 16		 jb	 SHORT $LN37@Assign_cou

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0005b	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  0005e	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00061	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00063	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00066	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00069	0f 87 bf 00 00
	00		 ja	 $LN34@Assign_cou

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0006f	8b f2		 mov	 esi, edx
$LN37@Assign_cou:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00071	51		 push	 ecx
  00072	56		 push	 esi
  00073	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1699 :             _Myfirst = nullptr;

  00078	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007e	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1700 :             _Mylast  = nullptr;

  00081	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1701 :             _Myend   = nullptr;

  00088	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN12@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0008f	8b 75 0c	 mov	 esi, DWORD PTR $T1[ebp]
  00092	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  00098	0f 87 8b 00 00
	00		 ja	 $LN106@Assign_cou

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0009e	c1 e6 02	 shl	 esi, 2

; 227  :     if (_Bytes == 0) {

  000a1	85 f6		 test	 esi, esi
  000a3	74 1a		 je	 SHORT $LN51@Assign_cou
$LN52@Assign_cou:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000a5	56		 push	 esi
  000a6	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  000ac	72 07		 jb	 SHORT $LN53@Assign_cou

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000ae	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000b3	eb 05		 jmp	 SHORT $LN102@Assign_cou
$LN53@Assign_cou:

; 136  :         return ::operator new(_Bytes);

  000b5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN102@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2020 :         _Myfirst              = _Newvec;

  000ba	8b f0		 mov	 esi, eax
  000bc	83 c4 04	 add	 esp, 4
$LN51@Assign_cou:

; 2021 :         _Mylast               = _Newvec;
; 2022 :         _Myend                = _Newvec + _Newcapacity;

  000bf	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
  000c2	89 37		 mov	 DWORD PTR [edi], esi
  000c4	89 77 04	 mov	 DWORD PTR [edi+4], esi
  000c7	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000ca	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN6@Assign_cou:

; 1465 :     }

  000cd	56		 push	 esi
  000ce	53		 push	 ebx
  000cf	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000d2	e8 00 00 00 00	 call	 ??$_Copy_memmove_n@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@I0@Z ; std::_Copy_memmove_n<CGraphicImage * *,CGraphicImage * *>
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000da	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]
  000dd	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	5d		 pop	 ebp
  000e4	c2 08 00	 ret	 8
$LN5@Assign_cou:

; 1419 :             _Clear_and_reserve_geometric(_Newsize);
; 1420 :             if constexpr (_Nothrow_construct) {
; 1421 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1422 :                 _ASAN_VECTOR_CREATE;
; 1423 :             } else {
; 1424 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1425 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1426 :             }
; 1427 :             return;
; 1428 :         }
; 1429 : 
; 1430 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  000e7	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000ea	2b c6		 sub	 eax, esi
  000ec	c1 f8 02	 sar	 eax, 2
  000ef	89 45 0c	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1431 :         if (_Newsize > _Oldsize) {

  000f2	3b d8		 cmp	 ebx, eax
  000f4	76 d7		 jbe	 SHORT $LN6@Assign_cou

; 1432 :             bool _Copied = false;
; 1433 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1434 : #if _HAS_CXX20
; 1435 :                 if (!_STD is_constant_evaluated())
; 1436 : #endif // _HAS_CXX20
; 1437 :                 {
; 1438 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);

  000f6	56		 push	 esi
  000f7	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  000fa	50		 push	 eax
  000fb	56		 push	 esi
  000fc	e8 00 00 00 00	 call	 ??$_Copy_memmove_n@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@I0@Z ; std::_Copy_memmove_n<CGraphicImage * *,CGraphicImage * *>

; 1439 :                     _First += _Oldsize;

  00101	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]

; 1440 :                     _Copied = true;
; 1441 :                 }
; 1442 :             }
; 1443 : 
; 1444 :             if (!_Copied) {
; 1445 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {
; 1446 :                     *_Mid = *_First;
; 1447 :                 }
; 1448 :             }
; 1449 : 
; 1450 :             if constexpr (_Nothrow_construct) {
; 1451 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1452 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

  00104	2b d9		 sub	 ebx, ecx
  00106	8d 04 8e	 lea	 eax, DWORD PTR [esi+ecx*4]
  00109	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1893 :             _STD _Copy_memmove_n(_UFirst, _Count, _STD _Unfancy(_Dest));

  0010c	56		 push	 esi
  0010d	53		 push	 ebx
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ??$_Copy_memmove_n@PAPAVCGraphicImage@@PAPAV1@@std@@YAPAPAVCGraphicImage@@PAPAV1@I0@Z ; std::_Copy_memmove_n<CGraphicImage * *,CGraphicImage * *>
  00114	83 c4 18	 add	 esp, 24			; 00000018H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1465 :     }

  00117	8d 04 9e	 lea	 eax, DWORD PTR [esi+ebx*4]
  0011a	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	5d		 pop	 ebp
  00121	c2 08 00	 ret	 8
$LN105@Assign_cou:

; 1689 :             _Xlength();

  00124	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength
$LN106@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00129	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN34@Assign_cou:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN101@Assign_cou:
  00133	cc		 int	 3
??$_Assign_counted_range@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEXPAPAVCGraphicImage@@I@Z ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Assign_counted_range<CGraphicImage * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCParticleProperty@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCParticleProperty@@UAEPAXI@Z PROC			; CParticleProperty::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CParticleProperty@@UAE@XZ ; CParticleProperty::~CParticleProperty
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN5@scalar
  00011	68 88 00 00 00	 push	 136			; 00000088H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCParticleProperty@@UAEPAXI@Z ENDP			; CParticleProperty::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
;	COMDAT ??4CParticleProperty@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
_c_ParticleProperty$ = 8				; size = 4
??4CParticleProperty@@QAEAAV0@ABV0@@Z PROC		; CParticleProperty::operator=, COMDAT
; _this$ = ecx

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	57		 push	 edi

; 82   : 	m_byTexAniType = c_ParticleProperty.m_byTexAniType;

  00007	8b 7d 08	 mov	 edi, DWORD PTR _c_ParticleProperty$[ebp]

; 83   : 	m_fTexAniDelay = c_ParticleProperty.m_fTexAniDelay;
; 84   : 	m_bTexAniRandomStartFrameFlag = c_ParticleProperty.m_bTexAniRandomStartFrameFlag;
; 85   : 
; 86   : 	m_bySrcBlendType = c_ParticleProperty.m_bySrcBlendType;
; 87   : 	m_byDestBlendType = c_ParticleProperty.m_byDestBlendType;
; 88   : 	m_byColorOperationType = c_ParticleProperty.m_byColorOperationType;
; 89   : 
; 90   : 	m_byBillboardType = c_ParticleProperty.m_byBillboardType;
; 91   : 
; 92   : 	m_byRotationType = c_ParticleProperty.m_byRotationType;
; 93   : 	m_fRotationSpeed = c_ParticleProperty.m_fRotationSpeed;
; 94   : 	m_wRotationRandomStartingBegin = c_ParticleProperty.m_wRotationRandomStartingBegin;
; 95   : 	m_wRotationRandomStartingEnd = c_ParticleProperty.m_wRotationRandomStartingEnd;
; 96   : 
; 97   : 	m_bAttachFlag = c_ParticleProperty.m_bAttachFlag;
; 98   : 	m_bStretchFlag = c_ParticleProperty.m_bStretchFlag;
; 99   : 
; 100  : 	m_TimeEventGravity = c_ParticleProperty.m_TimeEventGravity;

  0000a	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  0000d	0f b6 47 04	 movzx	 eax, BYTE PTR [edi+4]
  00011	88 46 04	 mov	 BYTE PTR [esi+4], al
  00014	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00017	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0001a	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0001d	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00020	0f b6 47 10	 movzx	 eax, BYTE PTR [edi+16]
  00024	88 46 10	 mov	 BYTE PTR [esi+16], al
  00027	0f b6 47 11	 movzx	 eax, BYTE PTR [edi+17]
  0002b	88 46 11	 mov	 BYTE PTR [esi+17], al
  0002e	0f b6 47 12	 movzx	 eax, BYTE PTR [edi+18]
  00032	88 46 12	 mov	 BYTE PTR [esi+18], al
  00035	0f b6 47 13	 movzx	 eax, BYTE PTR [edi+19]
  00039	88 46 13	 mov	 BYTE PTR [esi+19], al
  0003c	0f b6 47 14	 movzx	 eax, BYTE PTR [edi+20]
  00040	88 46 14	 mov	 BYTE PTR [esi+20], al
  00043	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00046	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00049	0f b7 47 1c	 movzx	 eax, WORD PTR [edi+28]
  0004d	66 89 46 1c	 mov	 WORD PTR [esi+28], ax
  00051	0f b7 47 1e	 movzx	 eax, WORD PTR [edi+30]
  00055	66 89 46 1e	 mov	 WORD PTR [esi+30], ax
  00059	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0005c	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0005f	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  00062	89 46 24	 mov	 DWORD PTR [esi+36], eax
  00065	8d 47 28	 lea	 eax, DWORD PTR [edi+40]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1509 :         if (this == _STD addressof(_Right)) {

  00068	3b c8		 cmp	 ecx, eax
  0006a	74 11		 je	 SHORT $LN3@operator

; 1510 :             return *this;
; 1511 :         }
; 1512 : 
; 1513 :         auto& _Al       = _Getal();
; 1514 :         auto& _Right_al = _Right._Getal();
; 1515 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1516 :             if (_Al != _Right_al) {
; 1517 :                 _Tidy();
; 1518 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1519 :             }
; 1520 :         }
; 1521 : 
; 1522 :         _Pocca(_Al, _Right_al);
; 1523 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1524 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

  0006c	8b 10		 mov	 edx, DWORD PTR [eax]
  0006e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00071	2b c2		 sub	 eax, edx
  00073	c1 f8 03	 sar	 eax, 3
  00076	50		 push	 eax
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@AAEXPAV?$CTimeEvent@M@@I@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Assign_counted_range<CTimeEvent<float> *>
$LN3@operator:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 101  : 	m_TimeEventAirResistance = c_ParticleProperty.m_TimeEventAirResistance;

  0007d	8d 47 34	 lea	 eax, DWORD PTR [edi+52]
  00080	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1509 :         if (this == _STD addressof(_Right)) {

  00083	3b c8		 cmp	 ecx, eax
  00085	74 11		 je	 SHORT $LN6@operator

; 1510 :             return *this;
; 1511 :         }
; 1512 : 
; 1513 :         auto& _Al       = _Getal();
; 1514 :         auto& _Right_al = _Right._Getal();
; 1515 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1516 :             if (_Al != _Right_al) {
; 1517 :                 _Tidy();
; 1518 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1519 :             }
; 1520 :         }
; 1521 : 
; 1522 :         _Pocca(_Al, _Right_al);
; 1523 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1524 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

  00087	8b 10		 mov	 edx, DWORD PTR [eax]
  00089	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008c	2b c2		 sub	 eax, edx
  0008e	c1 f8 03	 sar	 eax, 3
  00091	50		 push	 eax
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@AAEXPAV?$CTimeEvent@M@@I@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Assign_counted_range<CTimeEvent<float> *>
$LN6@operator:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 103  : 	m_TimeEventScaleX = c_ParticleProperty.m_TimeEventScaleX;

  00098	8d 47 40	 lea	 eax, DWORD PTR [edi+64]
  0009b	8d 4e 40	 lea	 ecx, DWORD PTR [esi+64]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1509 :         if (this == _STD addressof(_Right)) {

  0009e	3b c8		 cmp	 ecx, eax
  000a0	74 11		 je	 SHORT $LN9@operator

; 1510 :             return *this;
; 1511 :         }
; 1512 : 
; 1513 :         auto& _Al       = _Getal();
; 1514 :         auto& _Right_al = _Right._Getal();
; 1515 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1516 :             if (_Al != _Right_al) {
; 1517 :                 _Tidy();
; 1518 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1519 :             }
; 1520 :         }
; 1521 : 
; 1522 :         _Pocca(_Al, _Right_al);
; 1523 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1524 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

  000a2	8b 10		 mov	 edx, DWORD PTR [eax]
  000a4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a7	2b c2		 sub	 eax, edx
  000a9	c1 f8 03	 sar	 eax, 3
  000ac	50		 push	 eax
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@AAEXPAV?$CTimeEvent@M@@I@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Assign_counted_range<CTimeEvent<float> *>
$LN9@operator:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 104  : 	m_TimeEventScaleY = c_ParticleProperty.m_TimeEventScaleY;

  000b3	8d 47 4c	 lea	 eax, DWORD PTR [edi+76]
  000b6	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1509 :         if (this == _STD addressof(_Right)) {

  000b9	3b c8		 cmp	 ecx, eax
  000bb	74 11		 je	 SHORT $LN12@operator

; 1510 :             return *this;
; 1511 :         }
; 1512 : 
; 1513 :         auto& _Al       = _Getal();
; 1514 :         auto& _Right_al = _Right._Getal();
; 1515 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1516 :             if (_Al != _Right_al) {
; 1517 :                 _Tidy();
; 1518 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1519 :             }
; 1520 :         }
; 1521 : 
; 1522 :         _Pocca(_Al, _Right_al);
; 1523 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1524 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

  000bd	8b 10		 mov	 edx, DWORD PTR [eax]
  000bf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c2	2b c2		 sub	 eax, edx
  000c4	c1 f8 03	 sar	 eax, 3
  000c7	50		 push	 eax
  000c8	52		 push	 edx
  000c9	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@AAEXPAV?$CTimeEvent@M@@I@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Assign_counted_range<CTimeEvent<float> *>
$LN12@operator:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 114  : 	m_TimeEventColor = c_ParticleProperty.m_TimeEventColor;

  000ce	8d 47 58	 lea	 eax, DWORD PTR [edi+88]
  000d1	8d 4e 58	 lea	 ecx, DWORD PTR [esi+88]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1509 :         if (this == _STD addressof(_Right)) {

  000d4	3b c8		 cmp	 ecx, eax
  000d6	74 11		 je	 SHORT $LN15@operator

; 1510 :             return *this;
; 1511 :         }
; 1512 : 
; 1513 :         auto& _Al       = _Getal();
; 1514 :         auto& _Right_al = _Right._Getal();
; 1515 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1516 :             if (_Al != _Right_al) {
; 1517 :                 _Tidy();
; 1518 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1519 :             }
; 1520 :         }
; 1521 : 
; 1522 :         _Pocca(_Al, _Right_al);
; 1523 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1524 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

  000d8	8b 10		 mov	 edx, DWORD PTR [eax]
  000da	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dd	2b c2		 sub	 eax, edx
  000df	c1 f8 03	 sar	 eax, 3
  000e2	50		 push	 eax
  000e3	52		 push	 edx
  000e4	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PAV?$CTimeEvent@UDWORDCOLOR@@@@@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@AAEXPAV?$CTimeEvent@UDWORDCOLOR@@@@I@Z ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Assign_counted_range<CTimeEvent<DWORDCOLOR> *>
$LN15@operator:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 116  : 	m_TimeEventRotation = c_ParticleProperty.m_TimeEventRotation;

  000e9	8d 47 64	 lea	 eax, DWORD PTR [edi+100]
  000ec	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1509 :         if (this == _STD addressof(_Right)) {

  000ef	3b c8		 cmp	 ecx, eax
  000f1	74 11		 je	 SHORT $LN18@operator

; 1510 :             return *this;
; 1511 :         }
; 1512 : 
; 1513 :         auto& _Al       = _Getal();
; 1514 :         auto& _Right_al = _Right._Getal();
; 1515 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1516 :             if (_Al != _Right_al) {
; 1517 :                 _Tidy();
; 1518 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1519 :             }
; 1520 :         }
; 1521 : 
; 1522 :         _Pocca(_Al, _Right_al);
; 1523 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1524 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

  000f3	8b 10		 mov	 edx, DWORD PTR [eax]
  000f5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f8	2b c2		 sub	 eax, edx
  000fa	c1 f8 03	 sar	 eax, 3
  000fd	50		 push	 eax
  000fe	52		 push	 edx
  000ff	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PAV?$CTimeEvent@M@@@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@AAEXPAV?$CTimeEvent@M@@I@Z ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Assign_counted_range<CTimeEvent<float> *>
$LN18@operator:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 118  : 	m_ImageVector = c_ParticleProperty.m_ImageVector;

  00104	8d 47 70	 lea	 eax, DWORD PTR [edi+112]
  00107	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1509 :         if (this == _STD addressof(_Right)) {

  0010a	3b c8		 cmp	 ecx, eax
  0010c	74 11		 je	 SHORT $LN24@operator

; 1510 :             return *this;
; 1511 :         }
; 1512 : 
; 1513 :         auto& _Al       = _Getal();
; 1514 :         auto& _Right_al = _Right._Getal();
; 1515 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 1516 :             if (_Al != _Right_al) {
; 1517 :                 _Tidy();
; 1518 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1519 :             }
; 1520 :         }
; 1521 : 
; 1522 :         _Pocca(_Al, _Right_al);
; 1523 :         auto& _Right_data = _Right._Mypair._Myval2;
; 1524 :         _Assign_counted_range(_Right_data._Myfirst, static_cast<size_type>(_Right_data._Mylast - _Right_data._Myfirst));

  0010e	8b 10		 mov	 edx, DWORD PTR [eax]
  00110	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00113	2b c2		 sub	 eax, edx
  00115	c1 f8 02	 sar	 eax, 2
  00118	50		 push	 eax
  00119	52		 push	 edx
  0011a	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PAPAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEXPAPAVCGraphicImage@@I@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Assign_counted_range<CGraphicImage * *>
$LN24@operator:
  0011f	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 121  : }

  00120	8b c6		 mov	 eax, esi
  00122	5e		 pop	 esi
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
??4CParticleProperty@@QAEAAV0@ABV0@@Z ENDP		; CParticleProperty::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@CAXXZ PROC ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@V?$CTimeEvent@UDWORDCOLOR@@@@V?$allocator@V?$CTimeEvent@UDWORDCOLOR@@@@@std@@@std@@CAXXZ ENDP ; std::vector<CTimeEvent<DWORDCOLOR>,std::allocator<CTimeEvent<DWORDCOLOR> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@CAXXZ PROC ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@V?$CTimeEvent@M@@V?$allocator@V?$CTimeEvent@M@@@std@@@std@@CAXXZ ENDP ; std::vector<CTimeEvent<float>,std::allocator<CTimeEvent<float> > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
;	COMDAT ?SetTexture@CParticleProperty@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?SetTexture@CParticleProperty@@QAE_NPBD@Z PROC		; CParticleProperty::SetTexture, COMDAT
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 41 74	 mov	 eax, DWORD PTR [ecx+116]
  00006	8b 51 70	 mov	 edx, DWORD PTR [ecx+112]
  00009	2b c2		 sub	 eax, edx
  0000b	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 17   : 	if (m_ImageVector.size() > 1)

  0000e	83 f8 01	 cmp	 eax, 1
  00011	76 06		 jbe	 SHORT $LN2@SetTexture

; 18   : 	{
; 19   : 		assert(false);
; 20   : 		return false;

  00013	32 c0		 xor	 al, al

; 28   : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
$LN2@SetTexture:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00019	3b 51 74	 cmp	 edx, DWORD PTR [ecx+116]
  0001c	74 03		 je	 SHORT $LN7@SetTexture

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0001e	89 51 74	 mov	 DWORD PTR [ecx+116], edx
$LN7@SetTexture:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 26   : 	InsertTexture(c_szFileName);

  00021	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00024	e8 00 00 00 00	 call	 ?InsertTexture@CParticleProperty@@QAEXPBD@Z ; CParticleProperty::InsertTexture

; 27   : 	return true;

  00029	b0 01		 mov	 al, 1

; 28   : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?SetTexture@CParticleProperty@@QAE_NPBD@Z ENDP		; CParticleProperty::SetTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
;	COMDAT ?InsertTexture@CParticleProperty@@QAEXPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
_pImage$ = 8						; size = 4
?InsertTexture@CParticleProperty@@QAEXPBD@Z PROC	; CParticleProperty::InsertTexture, COMDAT
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 7    : 	CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(c_szFileName);

  00004	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  0000f	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00014	8b 56 74	 mov	 edx, DWORD PTR [esi+116]
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 9    : 	m_ImageVector.push_back(pImage);

  00017	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  0001a	89 45 08	 mov	 DWORD PTR _pImage$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0001d	5e		 pop	 esi
  0001e	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00021	74 0a		 je	 SHORT $LN6@InsertText

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00023	89 02		 mov	 DWORD PTR [edx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00025	83 41 04 04	 add	 DWORD PTR [ecx+4], 4
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 13   : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN6@InsertText:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0002d	8d 45 08	 lea	 eax, DWORD PTR _pImage$[ebp]
  00030	50		 push	 eax
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicImage@@@?$vector@PAVCGraphicImage@@V?$allocator@PAVCGraphicImage@@@std@@@std@@AAEPAPAVCGraphicImage@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicImage *,std::allocator<CGraphicImage *> >::_Emplace_reallocate<CGraphicImage * const &>
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 13   : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?InsertTexture@CParticleProperty@@QAEXPBD@Z ENDP	; CParticleProperty::InsertTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
;	COMDAT ?Clear@CParticleProperty@@QAEXXZ
_TEXT	SEGMENT
?Clear@CParticleProperty@@QAEXXZ PROC			; CParticleProperty::Clear, COMDAT
; _this$ = ecx

; 32   : 	m_byRotationType = 0;
; 33   : 	m_fRotationSpeed = 0.0f;
; 34   : 	m_wRotationRandomStartingBegin = 0;

  00000	33 c0		 xor	 eax, eax

; 35   : 	m_wRotationRandomStartingEnd = 0;
; 36   : 
; 37   : 	m_bAttachFlag = FALSE;
; 38   : 	m_bStretchFlag = FALSE;
; 39   : 
; 40   : 	m_bySrcBlendType = D3DBLEND_SRCALPHA;
; 41   : 	m_byDestBlendType = D3DBLEND_ONE;
; 42   : 	m_byColorOperationType = D3DTOP_MODULATE;
; 43   : 
; 44   : 	m_byBillboardType = BILLBOARD_TYPE_NONE;

  00002	66 c7 41 13 00
	00		 mov	 WORD PTR [ecx+19], 0
  00008	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0
  0000f	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00012	89 41 20	 mov	 DWORD PTR [ecx+32], eax
  00015	89 41 24	 mov	 DWORD PTR [ecx+36], eax
  00018	66 c7 41 10 05
	02		 mov	 WORD PTR [ecx+16], 517	; 00000205H
  0001e	c6 41 12 04	 mov	 BYTE PTR [ecx+18], 4

; 45   : 
; 46   : 	m_byTexAniType = TEXTURE_ANIMATION_TYPE_NONE;

  00022	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 47   : 	m_fTexAniDelay = 0.05f;

  00025	c7 41 08 cd cc
	4c 3d		 mov	 DWORD PTR [ecx+8], 1028443341 ; 3d4ccccdH

; 48   : 	m_bTexAniRandomStartFrameFlag = FALSE;

  0002c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0002f	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  00032	3b 41 2c	 cmp	 eax, DWORD PTR [ecx+44]
  00035	74 03		 je	 SHORT $LN3@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00037	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
$LN3@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0003a	8b 41 34	 mov	 eax, DWORD PTR [ecx+52]
  0003d	3b 41 38	 cmp	 eax, DWORD PTR [ecx+56]
  00040	74 03		 je	 SHORT $LN7@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00042	89 41 38	 mov	 DWORD PTR [ecx+56], eax
$LN7@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00045	8b 41 40	 mov	 eax, DWORD PTR [ecx+64]
  00048	3b 41 44	 cmp	 eax, DWORD PTR [ecx+68]
  0004b	74 03		 je	 SHORT $LN11@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0004d	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN11@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00050	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00053	3b 41 50	 cmp	 eax, DWORD PTR [ecx+80]
  00056	74 03		 je	 SHORT $LN15@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00058	89 41 50	 mov	 DWORD PTR [ecx+80], eax
$LN15@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0005b	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  0005e	3b 41 5c	 cmp	 eax, DWORD PTR [ecx+92]
  00061	74 03		 je	 SHORT $LN19@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00063	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
$LN19@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00066	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00069	3b 41 68	 cmp	 eax, DWORD PTR [ecx+104]
  0006c	74 03		 je	 SHORT $LN23@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0006e	89 41 68	 mov	 DWORD PTR [ecx+104], eax
$LN23@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00071	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  00074	3b 41 74	 cmp	 eax, DWORD PTR [ecx+116]
  00077	74 03		 je	 SHORT $LN27@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00079	89 41 74	 mov	 DWORD PTR [ecx+116], eax
$LN27@Clear:
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 71   : }

  0007c	c3		 ret	 0
?Clear@CParticleProperty@@QAEXXZ ENDP			; CParticleProperty::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
;	COMDAT ??1CParticleProperty@@UAE@XZ
_TEXT	SEGMENT
??1CParticleProperty@@UAE@XZ PROC			; CParticleProperty::~CParticleProperty, COMDAT
; _this$ = ecx

; 77   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CParticleProperty@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 70	 mov	 eax, DWORD PTR [esi+112]
  0000c	85 c0		 test	 eax, eax
  0000e	74 45		 je	 SHORT $LN8@CParticleP

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 78	 mov	 ecx, DWORD PTR [esi+120]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 16		 jb	 SHORT $LN27@CParticleP

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	0f 87 e3 01 00
	00		 ja	 $LN193@CParticleP

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00034	8b c2		 mov	 eax, edx
$LN27@CParticleP:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00036	51		 push	 ecx
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0003d	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00044	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00047	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0

; 2082 :             _Myend   = nullptr;

  0004e	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0
$LN8@CParticleP:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00055	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  00058	85 c0		 test	 eax, eax
  0005a	74 45		 je	 SHORT $LN37@CParticleP

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0005c	8b 4e 6c	 mov	 ecx, DWORD PTR [esi+108]
  0005f	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00061	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00064	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0006a	72 16		 jb	 SHORT $LN56@CParticleP

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0006c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00072	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00074	83 c0 fc	 add	 eax, -4			; fffffffcH
  00077	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0007a	0f 87 97 01 00
	00		 ja	 $LN193@CParticleP

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00080	8b c2		 mov	 eax, edx
$LN56@CParticleP:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00082	51		 push	 ecx
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00089	c7 46 64 00 00
	00 00		 mov	 DWORD PTR [esi+100], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00090	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00093	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0

; 2082 :             _Myend   = nullptr;

  0009a	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0
$LN37@CParticleP:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  000a1	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  000a4	85 c0		 test	 eax, eax
  000a6	74 45		 je	 SHORT $LN65@CParticleP

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000a8	8b 4e 60	 mov	 ecx, DWORD PTR [esi+96]
  000ab	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ad	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000b0	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000b6	72 16		 jb	 SHORT $LN84@CParticleP

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000b8	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000bb	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000be	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000c3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000c6	0f 87 4b 01 00
	00		 ja	 $LN193@CParticleP

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000cc	8b c2		 mov	 eax, edx
$LN84@CParticleP:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000ce	51		 push	 ecx
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  000d5	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000dc	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000df	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0

; 2082 :             _Myend   = nullptr;

  000e6	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
$LN65@CParticleP:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  000ed	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  000f0	85 c0		 test	 eax, eax
  000f2	74 45		 je	 SHORT $LN93@CParticleP

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000f4	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  000f7	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f9	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000fc	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00102	72 16		 jb	 SHORT $LN112@CParticleP

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00104	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00107	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0010a	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0010f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00112	0f 87 ff 00 00
	00		 ja	 $LN193@CParticleP

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00118	8b c2		 mov	 eax, edx
$LN112@CParticleP:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0011a	51		 push	 ecx
  0011b	50		 push	 eax
  0011c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00121	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00128	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0012b	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 2082 :             _Myend   = nullptr;

  00132	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0
$LN93@CParticleP:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00139	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0013c	85 c0		 test	 eax, eax
  0013e	74 45		 je	 SHORT $LN121@CParticleP

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00140	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00143	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00145	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00148	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0014e	72 16		 jb	 SHORT $LN140@CParticleP

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00150	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00153	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00156	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00158	83 c0 fc	 add	 eax, -4			; fffffffcH
  0015b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0015e	0f 87 b3 00 00
	00		 ja	 $LN193@CParticleP

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00164	8b c2		 mov	 eax, edx
$LN140@CParticleP:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00166	51		 push	 ecx
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0016d	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00174	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00177	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0

; 2082 :             _Myend   = nullptr;

  0017e	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
$LN121@CParticleP:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00185	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  00188	85 c0		 test	 eax, eax
  0018a	74 41		 je	 SHORT $LN149@CParticleP

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0018c	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  0018f	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00191	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00194	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0019a	72 12		 jb	 SHORT $LN168@CParticleP

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0019c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0019f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001a2	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001a4	83 c0 fc	 add	 eax, -4			; fffffffcH
  001a7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001aa	77 6b		 ja	 SHORT $LN193@CParticleP

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001ac	8b c2		 mov	 eax, edx
$LN168@CParticleP:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001ae	51		 push	 ecx
  001af	50		 push	 eax
  001b0	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  001b5	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  001bc	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  001bf	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0

; 2082 :             _Myend   = nullptr;

  001c6	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
$LN149@CParticleP:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  001cd	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  001d0	85 c0		 test	 eax, eax
  001d2	74 41		 je	 SHORT $LN177@CParticleP

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  001d4	8b 4e 30	 mov	 ecx, DWORD PTR [esi+48]
  001d7	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001d9	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001dc	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001e2	72 12		 jb	 SHORT $LN196@CParticleP

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001e4	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001e7	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001ea	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001ec	83 c0 fc	 add	 eax, -4			; fffffffcH
  001ef	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001f2	77 23		 ja	 SHORT $LN193@CParticleP

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001f4	8b c2		 mov	 eax, edx
$LN196@CParticleP:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001f6	51		 push	 ecx
  001f7	50		 push	 eax
  001f8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  001fd	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00204	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00207	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0

; 2082 :             _Myend   = nullptr;

  0020e	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN177@CParticleP:
  00215	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 78   : }

  00216	c3		 ret	 0
$LN193@CParticleP:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00217	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN222@CParticleP:
  0021c	cc		 int	 3
??1CParticleProperty@@UAE@XZ ENDP			; CParticleProperty::~CParticleProperty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp
;	COMDAT ??0CParticleProperty@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CParticleProperty@@QAE@XZ PROC			; CParticleProperty::CParticleProperty, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CParticleProperty@@6B@

; 75   : }

  0000a	8b c1		 mov	 eax, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000c	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0
  00013	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  0001a	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
  00021	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0
  00028	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  0002f	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00036	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  0003d	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0
  00044	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0
  0004b	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0
  00052	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0
  00059	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0
  00060	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0
  00067	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [ecx+92], 0
  0006e	c7 41 60 00 00
	00 00		 mov	 DWORD PTR [ecx+96], 0
  00075	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0
  0007c	c7 41 68 00 00
	00 00		 mov	 DWORD PTR [ecx+104], 0
  00083	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 74   : {

  0008a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0008d	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], 0
  00094	c7 41 74 00 00
	00 00		 mov	 DWORD PTR [ecx+116], 0
  0009b	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], 0
; File C:\Marty 5.5\Src-Client\Client\EffectLib\ParticleProperty.cpp

; 75   : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	c3		 ret	 0
??0CParticleProperty@@QAE@XZ ENDP			; CParticleProperty::CParticleProperty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
