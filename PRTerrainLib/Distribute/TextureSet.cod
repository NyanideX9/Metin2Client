; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\PRTerrainLib\Distribute\TextureSet.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??_GCGraphicImageInstance@@UAEPAXI@Z		; CGraphicImageInstance::`scalar deleting destructor'
PUBLIC	??0STerrainTexture@@QAE@XZ			; STerrainTexture::STerrainTexture
PUBLIC	??1STerrainTexture@@QAE@XZ			; STerrainTexture::~STerrainTexture
PUBLIC	??0STerrainTexture@@QAE@ABU0@@Z			; STerrainTexture::STerrainTexture
PUBLIC	??0CTextureSet@@QAE@XZ				; CTextureSet::CTextureSet
PUBLIC	??1CTextureSet@@UAE@XZ				; CTextureSet::~CTextureSet
PUBLIC	?Initialize@CTextureSet@@QAEXXZ			; CTextureSet::Initialize
PUBLIC	?Clear@CTextureSet@@QAEXXZ			; CTextureSet::Clear
PUBLIC	?Create@CTextureSet@@QAEXXZ			; CTextureSet::Create
PUBLIC	?Load@CTextureSet@@QAE_NPBDM@Z			; CTextureSet::Load
PUBLIC	?Save@CTextureSet@@QAE_NPBD@Z			; CTextureSet::Save
PUBLIC	?GetTextureCount@CTextureSet@@QAEKXZ		; CTextureSet::GetTextureCount
PUBLIC	?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z ; CTextureSet::GetTexture
PUBLIC	?RemoveTexture@CTextureSet@@QAE_NK@Z		; CTextureSet::RemoveTexture
PUBLIC	?SetTexture@CTextureSet@@QAE_NKPBDMMMM_NGGM@Z	; CTextureSet::SetTexture
PUBLIC	?Reload@CTextureSet@@QAEXM@Z			; CTextureSet::Reload
PUBLIC	?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z	; CTextureSet::AddTexture
PUBLIC	?AddEmptyTexture@CTextureSet@@IAEXXZ		; CTextureSet::AddEmptyTexture
PUBLIC	??1?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::~vector<STerrainTexture,std::allocator<STerrainTexture> >
PUBLIC	?_Change_array@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXQAUSTerrainTexture@@II@Z ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Change_array
PUBLIC	?_Xlength@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@CAXXZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Xlength
PUBLIC	??_GCTextureSet@@UAEPAXI@Z			; CTextureSet::`scalar deleting destructor'
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Destroy_range<std::allocator<STerrainTexture> >
PUBLIC	??$destroy@USTerrainTexture@@@?$_Default_allocator_traits@V?$allocator@USTerrainTexture@@@std@@@std@@SAXAAV?$allocator@USTerrainTexture@@@1@QAUSTerrainTexture@@@Z ; std::_Default_allocator_traits<std::allocator<STerrainTexture> >::destroy<STerrainTexture>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??1_Simple_reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Simple_reallocation_guard::~_Simple_reallocation_guard
PUBLIC	??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Uninitialized_copy<STerrainTexture *,STerrainTexture *,std::allocator<STerrainTexture> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<STerrainTexture> >
PUBLIC	??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Emplace_reallocate<STerrainTexture const &>
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<STerrainTexture> >::~_Uninitialized_backout_al<std::allocator<STerrainTexture> >
PUBLIC	??1_Reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Uninitialized_move<STerrainTexture *,std::allocator<STerrainTexture> >
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_7CGraphicImageInstance@@6B@			; CGraphicImageInstance::`vftable'
PUBLIC	??_7CTextureSet@@6B@				; CTextureSet::`vftable'
PUBLIC	??_C@_0BP@PGALBFBK@d?3?1ymir?5work?1special?1error?4tga@ ; `string'
PUBLIC	??_C@_0CC@NFEEIIKK@TextureSet?3?3Load?5?3?5cannot?5load?5@ ; `string'
PUBLIC	??_C@_0L@FLIBEPMB@textureset@			; `string'
PUBLIC	??_C@_0DL@HIELGKBC@TextureSet?3?3Load?5?3?5syntax?5error@ ; `string'
PUBLIC	??_C@_0N@MMECMGAI@texturecount@			; `string'
PUBLIC	??_C@_0DN@FCLAEMJC@TextureSet?3?3Load?5?3?5syntax?5error@ ; `string'
PUBLIC	??_C@_0M@NDPMIDHE@texture?$CF03d@		; `string'
PUBLIC	??_C@_0DF@CFOIFDDM@CTextureSet?3?3Load?5?3?5SetTexture?5@ ; `string'
PUBLIC	??_C@_06CEEECGLN@B?E?$IC?D?$IFd@		; `string'
PUBLIC	??_C@_0HJ@ILLJBGPC@CTextureSet?3?3SetTexture?3?5B?E?$IC?D?$IFd@ ; `string'
PUBLIC	??_C@_0FD@HGCGEJHO@CTextureSet?3?3SetTexture?3?5Nie?5mo@ ; `string'
PUBLIC	??_C@_0HJ@COHDILEG@CTextureSet?3?3AddTexture?3?5B?E?$IC?D?$IFd@ ; `string'
PUBLIC	??_C@_0CG@GCCGCFA@You?5cannot?5add?5more?5than?5255?5te@ ; `string'
PUBLIC	??_C@_09OINHJNMP@Duplicate@			; `string'
PUBLIC	??_C@_0CJ@ELAAMMOC@Texture?5of?5the?5same?5name?5alread@ ; `string'
PUBLIC	??_C@_0FC@LGIGBEJD@CTextureSet?3?3AddTexture?3?5Nie?5mo@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0M@MPCHGPBP@TextureSet?6@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BC@GGJBGKJP@TextureCount?5?$CFld?6@	; `string'
PUBLIC	??_C@_0BD@BJELLKNB@Start?5Texture?$CF03d?6@	; `string'
PUBLIC	??_C@_09BMPLDMAP@?5?5?5?5?$CC?$CFs?$CC?6@	; `string'
PUBLIC	??_C@_07ELCCFBHK@?5?5?5?5?$CFf?6@		; `string'
PUBLIC	??_C@_07EIKGIFBE@?5?5?5?5?$CFd?6@		; `string'
PUBLIC	??_C@_08PFAGAKKH@?5?5?5?5?$CFhu?6@		; `string'
PUBLIC	??_C@_0BB@GNLMPHOK@End?5Texture?$CF03d?6@	; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CGraphicImageInstance@@6B@			; CGraphicImageInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGraphicImageInstance@@@8		; CGraphicImageInstance `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicImageInstance@@8			; CGraphicImageInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicImageInstance@@8			; CGraphicImageInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicImageInstance@@8		; CGraphicImageInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CTextureSet@@6B@				; CTextureSet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTextureSet@@@8				; CTextureSet `RTTI Type Descriptor'
PUBLIC	??_R3CTextureSet@@8				; CTextureSet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTextureSet@@8				; CTextureSet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTextureSet@@8			; CTextureSet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_atof:PROC
EXTRN	_atol:PROC
EXTRN	__atoi64:PROC
EXTRN	_D3DXMatrixScaling@16:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	?LogBox@@YAXPBD0PAUHWND__@@@Z:PROC		; LogBox
EXTRN	?LoadMultipleTextData@@YA_NPBDAAV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@@Z:PROC ; LoadMultipleTextData
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?IsType@CResource@@QAE_NK@Z:PROC		; CResource::IsType
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	?Type@CGraphicImage@@SAKXZ:PROC			; CGraphicImage::Type
EXTRN	??0CGraphicImageInstance@@QAE@XZ:PROC		; CGraphicImageInstance::CGraphicImageInstance
EXTRN	??1CGraphicImageInstance@@UAE@XZ:PROC		; CGraphicImageInstance::~CGraphicImageInstance
EXTRN	?Destroy@CGraphicImageInstance@@QAEXXZ:PROC	; CGraphicImageInstance::Destroy
EXTRN	?SetScale@CGraphicImageInstance@@UAEXMM@Z:PROC	; CGraphicImageInstance::SetScale
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?ReloadImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::ReloadImagePointer
EXTRN	?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ:PROC ; CGraphicImageInstance::GetTexturePointer
EXTRN	?OnRender@CGraphicImageInstance@@MAEXXZ:PROC	; CGraphicImageInstance::OnRender
EXTRN	?OnSetImagePointer@CGraphicImageInstance@@MAEXXZ:PROC ; CGraphicImageInstance::OnSetImagePointer
EXTRN	?OnIsType@CGraphicImageInstance@@MAEHK@Z:PROC	; CGraphicImageInstance::OnIsType
EXTRN	??_ECGraphicImageInstance@@UAEPAXI@Z:PROC	; CGraphicImageInstance::`vector deleting destructor'
EXTRN	??_ECTextureSet@@UAEPAXI@Z:PROC			; CTextureSet::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CTextureSet@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTextureSet@@8 DD FLAT:??_R0?AVCTextureSet@@@8 ; CTextureSet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTextureSet@@8
rdata$r	ENDS
;	COMDAT ??_R2CTextureSet@@8
rdata$r	SEGMENT
??_R2CTextureSet@@8 DD FLAT:??_R1A@?0A@EA@CTextureSet@@8 ; CTextureSet::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CTextureSet@@8
rdata$r	SEGMENT
??_R3CTextureSet@@8 DD 00H				; CTextureSet::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CTextureSet@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTextureSet@@@8
data$rs	SEGMENT
??_R0?AVCTextureSet@@@8 DD FLAT:??_7type_info@@6B@	; CTextureSet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTextureSet@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CTextureSet@@6B@
rdata$r	SEGMENT
??_R4CTextureSet@@6B@ DD 00H				; CTextureSet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTextureSet@@@8
	DD	FLAT:??_R3CTextureSet@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicImageInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicImageInstance@@8 DD FLAT:??_R0?AVCGraphicImageInstance@@@8 ; CGraphicImageInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicImageInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicImageInstance@@8
rdata$r	SEGMENT
??_R2CGraphicImageInstance@@8 DD FLAT:??_R1A@?0A@EA@CGraphicImageInstance@@8 ; CGraphicImageInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicImageInstance@@8
rdata$r	SEGMENT
??_R3CGraphicImageInstance@@8 DD 00H			; CGraphicImageInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicImageInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicImageInstance@@@8
data$rs	SEGMENT
??_R0?AVCGraphicImageInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicImageInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicImageInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CGraphicImageInstance@@6B@
rdata$r	SEGMENT
??_R4CGraphicImageInstance@@6B@ DD 00H			; CGraphicImageInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGraphicImageInstance@@@8
	DD	FLAT:??_R3CGraphicImageInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GNLMPHOK@End?5Texture?$CF03d?6@
CONST	SEGMENT
??_C@_0BB@GNLMPHOK@End?5Texture?$CF03d?6@ DB 'End Texture%03d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08PFAGAKKH@?5?5?5?5?$CFhu?6@
CONST	SEGMENT
??_C@_08PFAGAKKH@?5?5?5?5?$CFhu?6@ DB '    %hu', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EIKGIFBE@?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_07EIKGIFBE@?5?5?5?5?$CFd?6@ DB '    %d', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07ELCCFBHK@?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_07ELCCFBHK@?5?5?5?5?$CFf?6@ DB '    %f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09BMPLDMAP@?5?5?5?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_09BMPLDMAP@?5?5?5?5?$CC?$CFs?$CC?6@ DB '    "%s"', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BJELLKNB@Start?5Texture?$CF03d?6@
CONST	SEGMENT
??_C@_0BD@BJELLKNB@Start?5Texture?$CF03d?6@ DB 'Start Texture%03d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GGJBGKJP@TextureCount?5?$CFld?6@
CONST	SEGMENT
??_C@_0BC@GGJBGKJP@TextureCount?5?$CFld?6@ DB 'TextureCount %ld', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MPCHGPBP@TextureSet?6@
CONST	SEGMENT
??_C@_0M@MPCHGPBP@TextureSet?6@ DB 'TextureSet', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@LGIGBEJD@CTextureSet?3?3AddTexture?3?5Nie?5mo@
CONST	SEGMENT
??_C@_0FC@LGIGBEJD@CTextureSet?3?3AddTexture?3?5Nie?5mo@ DB 'CTextureSet:'
	DB	':AddTexture: Nie mo', 0c5H, 0bcH, 'na ustawi', 0c4H, 087H, ' '
	DB	'tekstury. Tekstura ''%s'' nie istnieje', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ELAAMMOC@Texture?5of?5the?5same?5name?5alread@
CONST	SEGMENT
??_C@_0CJ@ELAAMMOC@Texture?5of?5the?5same?5name?5alread@ DB 'Texture of t'
	DB	'he same name already exists.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09OINHJNMP@Duplicate@
CONST	SEGMENT
??_C@_09OINHJNMP@Duplicate@ DB 'Duplicate', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@GCCGCFA@You?5cannot?5add?5more?5than?5255?5te@
CONST	SEGMENT
??_C@_0CG@GCCGCFA@You?5cannot?5add?5more?5than?5255?5te@ DB 'You cannot a'
	DB	'dd more than 255 texture.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0HJ@COHDILEG@CTextureSet?3?3AddTexture?3?5B?E?$IC?D?$IFd@
CONST	SEGMENT
??_C@_0HJ@COHDILEG@CTextureSet?3?3AddTexture?3?5B?E?$IC?D?$IFd@ DB 'CText'
	DB	'ureSet::AddTexture: B', 0c5H, 082H, 0c4H, 085H, 'd - Brak naz'
	DB	'wy pliku. Przekazany wska', 0c5H, 0baH, 'nik na nazw', 0c4H, 099H
	DB	' pliku jest niezdefiniowany (nullptr).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@HGCGEJHO@CTextureSet?3?3SetTexture?3?5Nie?5mo@
CONST	SEGMENT
??_C@_0FD@HGCGEJHO@CTextureSet?3?3SetTexture?3?5Nie?5mo@ DB 'CTextureSet:'
	DB	':SetTexture: Nie mo', 0c5H, 0bcH, 'na ustawi', 0c4H, 087H, ' '
	DB	'tekstury. Tekstura ''%s'' nie istnieje.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HJ@ILLJBGPC@CTextureSet?3?3SetTexture?3?5B?E?$IC?D?$IFd@
CONST	SEGMENT
??_C@_0HJ@ILLJBGPC@CTextureSet?3?3SetTexture?3?5B?E?$IC?D?$IFd@ DB 'CText'
	DB	'ureSet::SetTexture: B', 0c5H, 082H, 0c4H, 085H, 'd - Brak naz'
	DB	'wy pliku. Przekazany wska', 0c5H, 0baH, 'nik na nazw', 0c4H, 099H
	DB	' pliku jest niezdefiniowany (nullptr).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06CEEECGLN@B?E?$IC?D?$IFd@
CONST	SEGMENT
??_C@_06CEEECGLN@B?E?$IC?D?$IFd@ DB 'B', 0c5H, 082H, 0c4H, 085H, 'd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@CFOIFDDM@CTextureSet?3?3Load?5?3?5SetTexture?5@
CONST	SEGMENT
??_C@_0DF@CFOIFDDM@CTextureSet?3?3Load?5?3?5SetTexture?5@ DB 'CTextureSet'
	DB	'::Load : SetTexture failed : Filename: %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NDPMIDHE@texture?$CF03d@
CONST	SEGMENT
??_C@_0M@NDPMIDHE@texture?$CF03d@ DB 'texture%03d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@FCLAEMJC@TextureSet?3?3Load?5?3?5syntax?5error@
CONST	SEGMENT
??_C@_0DN@FCLAEMJC@TextureSet?3?3Load?5?3?5syntax?5error@ DB 'TextureSet:'
	DB	':Load : syntax error, TextureCount (filename: %s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MMECMGAI@texturecount@
CONST	SEGMENT
??_C@_0N@MMECMGAI@texturecount@ DB 'texturecount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@HIELGKBC@TextureSet?3?3Load?5?3?5syntax?5error@
CONST	SEGMENT
??_C@_0DL@HIELGKBC@TextureSet?3?3Load?5?3?5syntax?5error@ DB 'TextureSet:'
	DB	':Load : syntax error, TextureSet (filename: %s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FLIBEPMB@textureset@
CONST	SEGMENT
??_C@_0L@FLIBEPMB@textureset@ DB 'textureset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@NFEEIIKK@TextureSet?3?3Load?5?3?5cannot?5load?5@
CONST	SEGMENT
??_C@_0CC@NFEEIIKK@TextureSet?3?3Load?5?3?5cannot?5load?5@ DB 'TextureSet'
	DB	'::Load : cannot load %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PGALBFBK@d?3?1ymir?5work?1special?1error?4tga@
CONST	SEGMENT
??_C@_0BP@PGALBFBK@d?3?1ymir?5work?1special?1error?4tga@ DB 'd:/ymir work'
	DB	'/special/error.tga', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CTextureSet@@6B@
CONST	SEGMENT
??_7CTextureSet@@6B@ DD FLAT:??_R4CTextureSet@@6B@	; CTextureSet::`vftable'
	DD	FLAT:??_ECTextureSet@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CGraphicImageInstance@@6B@
CONST	SEGMENT
??_7CGraphicImageInstance@@6B@ DD FLAT:??_R4CGraphicImageInstance@@6B@ ; CGraphicImageInstance::`vftable'
	DD	FLAT:??_ECGraphicImageInstance@@UAEPAXI@Z
	DD	FLAT:?SetScale@CGraphicImageInstance@@UAEXMM@Z
	DD	FLAT:?OnRender@CGraphicImageInstance@@MAEXXZ
	DD	FLAT:?OnSetImagePointer@CGraphicImageInstance@@MAEXXZ
	DD	FLAT:?OnIsType@CGraphicImageInstance@@MAEHK@Z
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z$0
__ehfuncinfo$??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z$1
__ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__ehfuncinfo$??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Reallocate@$0A@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Reallocate@$0A@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXAAI@Z$0
__ehfuncinfo$??$_Reallocate@$0A@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXAAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Reallocate@$0A@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2
__ehfuncinfo$??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2
__ehfuncinfo$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?reserve@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?reserve@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAEXI@Z$0
__ehfuncinfo$?reserve@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?reserve@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddEmptyTexture@CTextureSet@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddEmptyTexture@CTextureSet@@IAEXXZ$0
__ehfuncinfo$?AddEmptyTexture@CTextureSet@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddEmptyTexture@CTextureSet@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z$0
__ehfuncinfo$?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Load@CTextureSet@@QAE_NPBDM@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?Load@CTextureSet@@QAE_NPBDM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Load@CTextureSet@@QAE_NPBDM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$37
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$5
	DD	03H
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$28
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$6
	DD	05H
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$9
	DD	08H
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$10
	DD	09H
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$11
	DD	0aH
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$12
	DD	0bH
	DD	FLAT:__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$13
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CTextureSet@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CTextureSet@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTextureSet@@QAE@XZ$0
__ehfuncinfo$??0CTextureSet@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CTextureSet@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0STerrainTexture@@QAE@ABU0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0STerrainTexture@@QAE@ABU0@@Z$0
__ehfuncinfo$??0STerrainTexture@@QAE@ABU0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0STerrainTexture@@QAE@ABU0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0STerrainTexture@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0STerrainTexture@@QAE@XZ$0
__ehfuncinfo$??0STerrainTexture@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0STerrainTexture@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CRef@VCGraphicImage@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z
_TEXT	SEGMENT
__Backout$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z PROC ; std::_Uninitialized_move<STerrainTexture *,std::allocator<STerrainTexture> >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00028	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0002b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);

  0002e	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	89 7d e8	 mov	 DWORD PTR __Backout$[ebp], edi
  00034	89 7d ec	 mov	 DWORD PTR __Backout$[ebp+4], edi
  00037	89 45 f0	 mov	 DWORD PTR __Backout$[ebp+8], eax

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1956 :             return _Dest + (_ULast - _UFirst);
; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  0003a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	3b f3		 cmp	 esi, ebx
  00046	74 1e		 je	 SHORT $LN3@Uninitiali
$LL4@Uninitiali:

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00048	56		 push	 esi
  00049	8b cf		 mov	 ecx, edi
  0004b	e8 00 00 00 00	 call	 ??0STerrainTexture@@QAE@ABU0@@Z

; 1808 :         ++_Last;

  00050	81 c7 9c 00 00
	00		 add	 edi, 156		; 0000009cH

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1956 :             return _Dest + (_ULast - _UFirst);
; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  00056	81 c6 9c 00 00
	00		 add	 esi, 156		; 0000009cH

; 1808 :         ++_Last;

  0005c	89 7d ec	 mov	 DWORD PTR __Backout$[ebp+4], edi

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1956 :             return _Dest + (_ULast - _UFirst);
; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  0005f	3b f3		 cmp	 esi, ebx
  00061	75 e5		 jne	 SHORT $LL4@Uninitiali
  00063	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
$LN3@Uninitiali:

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  00066	50		 push	 eax
  00067	57		 push	 edi
  00068	57		 push	 edi
  00069	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Destroy_range<std::allocator<STerrainTexture> >
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1963 :     }
; 1964 : 
; 1965 :     return _Backout._Release();

  00071	8b c7		 mov	 eax, edi

; 1966 : }

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<STerrainTexture> >::~_Uninitialized_backout_al<std::allocator<STerrainTexture> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ENDP ; std::_Uninitialized_move<STerrainTexture *,std::allocator<STerrainTexture> >
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ PROC ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Reallocation_guard::~_Reallocation_guard, COMDAT
; _this$ = ecx

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 606  :             if (_New_begin != nullptr) {

  00003	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00007	74 3e		 je	 SHORT $LN10@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	ff 76 10	 push	 DWORD PTR [esi+16]
  0000e	ff 76 0c	 push	 DWORD PTR [esi+12]
  00011	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Destroy_range<std::allocator<STerrainTexture> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00016	69 4e 08 9c 00
	00 00		 imul	 ecx, DWORD PTR [esi+8], 156
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00020	8b 46 04	 mov	 eax, DWORD PTR [esi+4]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00023	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00029	72 12		 jb	 SHORT $LN21@Reallocati

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002e	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00033	83 c0 fc	 add	 eax, -4			; fffffffcH
  00036	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00039	77 0e		 ja	 SHORT $LN18@Reallocati

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003b	8b c2		 mov	 eax, edx
$LN21@Reallocati:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0003d	51		 push	 ecx
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00044	83 c4 08	 add	 esp, 8
$LN10@Reallocati:
  00047	5e		 pop	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 610  :         }

  00048	c3		 ret	 0
$LN18@Reallocati:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00049	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@Reallocati:
  0004e	cc		 int	 3
??1_Reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ENDP ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Uninitialized_backout_al@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<STerrainTexture> >::~_Uninitialized_backout_al<std::allocator<STerrainTexture> >, COMDAT
; _this$ = ecx

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  00000	ff 71 08	 push	 DWORD PTR [ecx+8]
  00003	ff 71 04	 push	 DWORD PTR [ecx+4]
  00006	ff 31		 push	 DWORD PTR [ecx]
  00008	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Destroy_range<std::allocator<STerrainTexture> >
  0000d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1803 :     }

  00010	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<STerrainTexture> >::~_Uninitialized_backout_al<std::allocator<STerrainTexture> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3271 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 425  :         const value_type* _Result = _Bx._Buf;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b d0		 mov	 edx, eax

; 434  :         return _Myres > _Small_string_capacity;

  00008	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0000c	76 02		 jbe	 SHORT $LN8@operator

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0000e	8b 10		 mov	 edx, DWORD PTR [eax]
$LN8@operator:

; 425  :         const value_type* _Result = _Bx._Buf;

  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00016	83 79 14 0f	 cmp	 DWORD PTR [ecx+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0001a	76 02		 jbe	 SHORT $LN15@operator

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0001c	8b 31		 mov	 esi, DWORD PTR [ecx]
$LN15@operator:

; 2854 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0001e	ff 70 10	 push	 DWORD PTR [eax+16]
  00021	52		 push	 edx
  00022	ff 71 10	 push	 DWORD PTR [ecx+16]
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 3272 :     return _Left.compare(_Right) < 0;

  0002e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00031	5e		 pop	 esi

; 3273 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0000a	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0000f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00012	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00015	76 27		 jbe	 SHORT $LN32@destroy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00019	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 12		 jb	 SHORT $LN43@destroy

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00022	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00025	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00028	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00030	77 20		 ja	 SHORT $LN40@destroy

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00032	8b c2		 mov	 eax, edx
$LN43@destroy:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00034	51		 push	 ecx
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN32@destroy:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  0003e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00045	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004f	5e		 pop	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 743  :     }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN40@destroy:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00052	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN55@destroy:
  00057	cc		 int	 3
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Guard$ = -44						; size = 20
__Oldsize$1$ = -24					; size = 4
__Constructed_last$1$ = -20				; size = 4
__Whereoff$1$ = -16					; size = 4
tv318 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z PROC ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Emplace_reallocate<STerrainTexture const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0002a	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0002c	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
  00031	8b 75 08	 mov	 esi, DWORD PTR __Whereptr$[ebp]

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00034	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00037	2b f7		 sub	 esi, edi
  00039	f7 ee		 imul	 esi
  0003b	2b cf		 sub	 ecx, edi
  0003d	03 d6		 add	 edx, esi
  0003f	c1 fa 07	 sar	 edx, 7
  00042	8b c2		 mov	 eax, edx
  00044	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00047	03 c2		 add	 eax, edx
  00049	89 45 f0	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  0004c	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
  00051	f7 e9		 imul	 ecx
  00053	03 d1		 add	 edx, ecx
  00055	c1 fa 07	 sar	 edx, 7
  00058	8b c2		 mov	 eax, edx
  0005a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005d	03 c2		 add	 eax, edx
  0005f	89 45 e8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  00062	3d 41 1a a4 01	 cmp	 eax, 27531841		; 01a41a41H
  00067	0f 84 1f 01 00
	00		 je	 $LN37@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006d	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00070	8d 70 01	 lea	 esi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00073	2b cf		 sub	 ecx, edi
  00075	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
  0007a	f7 e9		 imul	 ecx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0007c	b8 41 1a a4 01	 mov	 eax, 27531841		; 01a41a41H

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00081	03 d1		 add	 edx, ecx
  00083	c1 fa 07	 sar	 edx, 7
  00086	8b ca		 mov	 ecx, edx
  00088	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0008b	03 ca		 add	 ecx, edx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0008d	8b d1		 mov	 edx, ecx
  0008f	d1 ea		 shr	 edx, 1
  00091	2b c2		 sub	 eax, edx
  00093	3b c8		 cmp	 ecx, eax
  00095	76 12		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00097	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  0009c	bf 41 1a a4 01	 mov	 edi, 27531841		; 01a41a41H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a7	eb 39		 jmp	 SHORT $LN35@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000a9	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  000ac	8b fe		 mov	 edi, esi
  000ae	3b c6		 cmp	 eax, esi
  000b0	0f 43 f8	 cmovae	 edi, eax
  000b3	81 ff 41 1a a4
	01		 cmp	 edi, 27531841		; 01a41a41H
  000b9	0f 87 d2 00 00
	00		 ja	 $LN38@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  000bf	69 c7 9c 00 00
	00		 imul	 eax, edi, 156

; 227  :     if (_Bytes == 0) {

  000c5	85 c0		 test	 eax, eax
  000c7	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  000c9	33 f6		 xor	 esi, esi
  000cb	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000cd	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000d2	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000da	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN35@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000e2	8b f0		 mov	 esi, eax
  000e4	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  000e7	69 45 f0 9c 00
	00 00		 imul	 eax, DWORD PTR __Whereoff$1$[ebp], 156

; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  000ee	89 5d d4	 mov	 DWORD PTR __Guard$[ebp], ebx
  000f1	89 75 d8	 mov	 DWORD PTR __Guard$[ebp+4], esi
  000f4	89 7d dc	 mov	 DWORD PTR __Guard$[ebp+8], edi
  000f7	03 c6		 add	 eax, esi
  000f9	89 45 f0	 mov	 DWORD PTR tv318[ebp], eax
  000fc	8d 88 9c 00 00
	00		 lea	 ecx, DWORD PTR [eax+156]
  00102	89 4d ec	 mov	 DWORD PTR __Constructed_last$1$[ebp], ecx
  00105	89 4d e0	 mov	 DWORD PTR __Guard$[ebp+12], ecx
  00108	89 4d e4	 mov	 DWORD PTR __Guard$[ebp+16], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0010b	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  0010e	8b c8		 mov	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  00110	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00117	e8 00 00 00 00	 call	 ??0STerrainTexture@@QAE@ABU0@@Z
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 886  :         _Constructed_first = _Newvec + _Whereoff;

  0011c	8b 45 f0	 mov	 eax, DWORD PTR tv318[ebp]

; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0011f	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00122	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00125	89 45 e0	 mov	 DWORD PTR __Guard$[ebp+12], eax
  00128	8b 03		 mov	 eax, DWORD PTR [ebx]
  0012a	53		 push	 ebx
  0012b	56		 push	 esi
  0012c	3b d1		 cmp	 edx, ecx
  0012e	75 0c		 jne	 SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);

  00130	51		 push	 ecx
  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Uninitialized_copy<STerrainTexture *,STerrainTexture *,std::allocator<STerrainTexture> >
  00137	83 c4 10	 add	 esp, 16			; 00000010H

; 893  :             }
; 894  :         } else { // provide basic guarantee

  0013a	eb 1c		 jmp	 SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

  0013c	52		 push	 edx
  0013d	50		 push	 eax
  0013e	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Uninitialized_move<STerrainTexture *,std::allocator<STerrainTexture> >

; 896  :             _Constructed_first = _Newvec;
; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  00143	53		 push	 ebx
  00144	ff 75 ec	 push	 DWORD PTR __Constructed_last$1$[ebp]
  00147	89 75 e0	 mov	 DWORD PTR __Guard$[ebp+12], esi
  0014a	ff 73 04	 push	 DWORD PTR [ebx+4]
  0014d	ff 75 08	 push	 DWORD PTR __Whereptr$[ebp]
  00150	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@QAU1@0PAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Uninitialized_move<STerrainTexture *,std::allocator<STerrainTexture> >
  00155	83 c4 20	 add	 esp, 32			; 00000020H
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;
; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00158	8b 45 e8	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  0015b	8b cb		 mov	 ecx, ebx
  0015d	57		 push	 edi
  0015e	40		 inc	 eax
  0015f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Guard$[ebp+4], 0
  00166	50		 push	 eax
  00167	56		 push	 esi
  00168	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXQAUSTerrainTexture@@II@Z ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Change_array

; 902  :         return _Newvec + _Whereoff;

  0016d	8d 4d d4	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00170	e8 00 00 00 00	 call	 ??1_Reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Reallocation_guard::~_Reallocation_guard
  00175	8b 45 f0	 mov	 eax, DWORD PTR tv318[ebp]

; 903  :     }

  00178	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00182	59		 pop	 ecx
  00183	5f		 pop	 edi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx
  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c2 08 00	 ret	 8
$LN37@Emplace_re:

; 873  :             _Xlength();

  0018c	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@CAXXZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Xlength
$LN38@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00191	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN34@Emplace_re:
  00196	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Reallocation_guard::~_Reallocation_guard
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z ENDP ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Emplace_reallocate<STerrainTexture const &>
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z
_TEXT	SEGMENT
__Backout$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<STerrainTexture> >, COMDAT

; 2041 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00028	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  0002b	8b 5d 10	 mov	 ebx, DWORD PTR __Al$[ebp]
  0002e	89 7d e8	 mov	 DWORD PTR __Backout$[ebp], edi
  00031	89 7d ec	 mov	 DWORD PTR __Backout$[ebp+4], edi
  00034	89 5d f0	 mov	 DWORD PTR __Backout$[ebp+8], ebx

; 2042 :     // value-initialize _Count objects to raw _First, using _Al
; 2043 :     using _Ptrty = typename _Alloc::value_type*;
; 2044 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2045 : #if _HAS_CXX20
; 2046 :         if (!_STD is_constant_evaluated())
; 2047 : #endif // _HAS_CXX20
; 2048 :         {
; 2049 :             auto _PFirst = _Unfancy(_First);
; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2051 :             return _First + _Count;
; 2052 :         }
; 2053 :     }
; 2054 : 
; 2055 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2056 :     for (; 0 < _Count; --_Count) {

  00037	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00041	85 f6		 test	 esi, esi
  00043	74 15		 je	 SHORT $LN3@Uninitiali
$LL4@Uninitiali:

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00045	8b cf		 mov	 ecx, edi
  00047	e8 00 00 00 00	 call	 ??0STerrainTexture@@QAE@XZ ; STerrainTexture::STerrainTexture

; 1808 :         ++_Last;

  0004c	81 c7 9c 00 00
	00		 add	 edi, 156		; 0000009cH
  00052	89 7d ec	 mov	 DWORD PTR __Backout$[ebp+4], edi

; 2042 :     // value-initialize _Count objects to raw _First, using _Al
; 2043 :     using _Ptrty = typename _Alloc::value_type*;
; 2044 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2045 : #if _HAS_CXX20
; 2046 :         if (!_STD is_constant_evaluated())
; 2047 : #endif // _HAS_CXX20
; 2048 :         {
; 2049 :             auto _PFirst = _Unfancy(_First);
; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2051 :             return _First + _Count;
; 2052 :         }
; 2053 :     }
; 2054 : 
; 2055 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2056 :     for (; 0 < _Count; --_Count) {

  00055	83 ee 01	 sub	 esi, 1
  00058	75 eb		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  0005a	53		 push	 ebx
  0005b	57		 push	 edi
  0005c	57		 push	 edi
  0005d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Destroy_range<std::allocator<STerrainTexture> >
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2057 :         _Backout._Emplace_back();
; 2058 :     }
; 2059 : 
; 2060 :     return _Backout._Release();

  00065	8b c7		 mov	 eax, edi

; 2061 : }

  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5b		 pop	 ebx
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<STerrainTexture> >::~_Uninitialized_backout_al<std::allocator<STerrainTexture> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<STerrainTexture> >
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z
_TEXT	SEGMENT
__Backout$ = -24					; size = 12
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z PROC ; std::_Uninitialized_copy<STerrainTexture *,STerrainTexture *,std::allocator<STerrainTexture> >, COMDAT

; 1824 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00028	8b 7d 10	 mov	 edi, DWORD PTR __Dest$[ebp]
  0002b	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]

; 1825 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1826 :     // note: only called internally from elsewhere in the STL
; 1827 :     using _Ptrval = typename _Alloc::value_type*;
; 1828 : 
; 1829 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1830 :     _STD _Adl_verify_range(_First, _Last);
; 1831 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1832 : 
; 1833 : #if _HAS_CXX20
; 1834 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1835 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1836 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1837 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1838 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1839 :     auto _UFirst = _STD _Get_unwrapped(_STD move(_First));

  0002e	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	89 7d e8	 mov	 DWORD PTR __Backout$[ebp], edi
  00034	89 7d ec	 mov	 DWORD PTR __Backout$[ebp+4], edi
  00037	89 45 f0	 mov	 DWORD PTR __Backout$[ebp+8], eax

; 1840 :     auto _ULast  = _STD _Get_unwrapped(_STD move(_Last));
; 1841 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1842 : 
; 1843 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1844 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1845 : 
; 1846 :     if constexpr (_Can_memmove) {
; 1847 : #if _HAS_CXX20
; 1848 :         if (!_STD is_constant_evaluated())
; 1849 : #endif // _HAS_CXX20
; 1850 :         {
; 1851 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1852 :                 _STD _Copy_memmove(_STD _To_address(_UFirst), _STD _To_address(_ULast), _STD _Unfancy(_Dest));
; 1853 :                 _Dest += _ULast - _UFirst;
; 1854 :             } else {
; 1855 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1856 :                 _STD _Copy_memmove_n(_STD _To_address(_UFirst), _Count, _STD _Unfancy(_Dest));
; 1857 :                 _Dest += _Count;
; 1858 :             }
; 1859 :             return _Dest;
; 1860 :         }
; 1861 :     }
; 1862 : 
; 1863 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1864 :     for (; _UFirst != _ULast; ++_UFirst) {

  0003a	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0003d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	3b f3		 cmp	 esi, ebx
  00046	74 1e		 je	 SHORT $LN3@Uninitiali
$LL4@Uninitiali:

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00048	56		 push	 esi
  00049	8b cf		 mov	 ecx, edi
  0004b	e8 00 00 00 00	 call	 ??0STerrainTexture@@QAE@ABU0@@Z

; 1808 :         ++_Last;

  00050	81 c7 9c 00 00
	00		 add	 edi, 156		; 0000009cH

; 1840 :     auto _ULast  = _STD _Get_unwrapped(_STD move(_Last));
; 1841 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1842 : 
; 1843 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1844 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1845 : 
; 1846 :     if constexpr (_Can_memmove) {
; 1847 : #if _HAS_CXX20
; 1848 :         if (!_STD is_constant_evaluated())
; 1849 : #endif // _HAS_CXX20
; 1850 :         {
; 1851 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1852 :                 _STD _Copy_memmove(_STD _To_address(_UFirst), _STD _To_address(_ULast), _STD _Unfancy(_Dest));
; 1853 :                 _Dest += _ULast - _UFirst;
; 1854 :             } else {
; 1855 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1856 :                 _STD _Copy_memmove_n(_STD _To_address(_UFirst), _Count, _STD _Unfancy(_Dest));
; 1857 :                 _Dest += _Count;
; 1858 :             }
; 1859 :             return _Dest;
; 1860 :         }
; 1861 :     }
; 1862 : 
; 1863 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1864 :     for (; _UFirst != _ULast; ++_UFirst) {

  00056	81 c6 9c 00 00
	00		 add	 esi, 156		; 0000009cH

; 1808 :         ++_Last;

  0005c	89 7d ec	 mov	 DWORD PTR __Backout$[ebp+4], edi

; 1840 :     auto _ULast  = _STD _Get_unwrapped(_STD move(_Last));
; 1841 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1842 : 
; 1843 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible
; 1844 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1845 : 
; 1846 :     if constexpr (_Can_memmove) {
; 1847 : #if _HAS_CXX20
; 1848 :         if (!_STD is_constant_evaluated())
; 1849 : #endif // _HAS_CXX20
; 1850 :         {
; 1851 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1852 :                 _STD _Copy_memmove(_STD _To_address(_UFirst), _STD _To_address(_ULast), _STD _Unfancy(_Dest));
; 1853 :                 _Dest += _ULast - _UFirst;
; 1854 :             } else {
; 1855 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1856 :                 _STD _Copy_memmove_n(_STD _To_address(_UFirst), _Count, _STD _Unfancy(_Dest));
; 1857 :                 _Dest += _Count;
; 1858 :             }
; 1859 :             return _Dest;
; 1860 :         }
; 1861 :     }
; 1862 : 
; 1863 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1864 :     for (; _UFirst != _ULast; ++_UFirst) {

  0005f	3b f3		 cmp	 esi, ebx
  00061	75 e5		 jne	 SHORT $LL4@Uninitiali
  00063	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
$LN3@Uninitiali:

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  00066	50		 push	 eax
  00067	57		 push	 edi
  00068	57		 push	 edi
  00069	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Destroy_range<std::allocator<STerrainTexture> >
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1865 :         _Backout._Emplace_back(*_UFirst);
; 1866 :     }
; 1867 : 
; 1868 :     return _Backout._Release();

  00071	8b c7		 mov	 eax, edi

; 1869 : }

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	5f		 pop	 edi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx
  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<STerrainTexture> >::~_Uninitialized_backout_al<std::allocator<STerrainTexture> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z ENDP ; std::_Uninitialized_copy<STerrainTexture *,STerrainTexture *,std::allocator<STerrainTexture> >
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Simple_reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Simple_reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ PROC ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Simple_reallocation_guard::~_Simple_reallocation_guard, COMDAT
; _this$ = ecx

; 622  :             if (_New_begin != nullptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 2b		 je	 SHORT $LN10@Simple_rea
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	69 49 08 9c 00
	00 00		 imul	 ecx, DWORD PTR [ecx+8], 156

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN21@Simple_rea

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 0d		 ja	 SHORT $LN18@Simple_rea

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN21@Simple_rea:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN10@Simple_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 625  :         }

  00032	c3		 ret	 0
$LN18@Simple_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00033	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??1_Simple_reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ENDP ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Simple_reallocation_guard::~_Simple_reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx

; 757  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 758  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 75 0c	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000d	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00011	75 34		 jne	 SHORT $LN39@Erase_tree
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00017	57		 push	 edi
$LL2@Erase_tree:

; 759  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 76 08	 push	 DWORD PTR [esi+8]
  0001b	8b c8		 mov	 ecx, eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b fe		 mov	 edi, esi

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 381  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00027	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  0002a	50		 push	 eax
  0002b	53		 push	 ebx
  0002c	e8 00 00 00 00	 call	 ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00031	6a 34		 push	 52			; 00000034H
  00033	57		 push	 edi
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 758  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0003c	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 758  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0003f	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00043	74 d3		 je	 SHORT $LL2@Erase_tree
  00045	5f		 pop	 edi
  00046	5b		 pop	 ebx
$LN39@Erase_tree:
  00047	5e		 pop	 esi

; 760  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 761  :         }
; 762  :     }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx

; 1168 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN10@Alloc_cons

; 289  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 34		 push	 52			; 00000034H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN10@Alloc_cons:

; 1169 :             _Al.deallocate(_Ptr, 1);
; 1170 :         }
; 1171 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1618 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1619 :         const auto _Scary = _Get_scary();
; 1620 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	89 37		 mov	 DWORD PTR [edi], esi

; 1621 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1622 :         while (!_Trynode->_Isnil) {

  0000f	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00013	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0001a	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0001d	75 32		 jne	 SHORT $LN13@Find_lower
  0001f	53		 push	 ebx
  00020	8b 5d 0c	 mov	 ebx, DWORD PTR __Keyval$[ebp]
$LL2@Find_lower:

; 1624 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00023	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00026	89 37		 mov	 DWORD PTR [edi], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits

; 2412 :         return _Left < _Right;

  00028	53		 push	 ebx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0002f	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1624 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00032	84 c0		 test	 al, al
  00034	74 07		 je	 SHORT $LN4@Find_lower

; 1625 :                 _Result._Location._Child = _Tree_child::_Right;
; 1626 :                 _Trynode                 = _Trynode->_Right;

  00036	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00039	33 c0		 xor	 eax, eax

; 1627 :             } else {

  0003b	eb 0a		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1628 :                 _Result._Location._Child = _Tree_child::_Left;
; 1629 :                 _Result._Bound           = _Trynode;

  0003d	89 77 08	 mov	 DWORD PTR [edi+8], esi

; 1630 :                 _Trynode                 = _Trynode->_Left;

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	8b 36		 mov	 esi, DWORD PTR [esi]
$LN5@Find_lower:

; 1621 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1622 :         while (!_Trynode->_Isnil) {

  00047	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0004a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0004e	74 d3		 je	 SHORT $LL2@Find_lower
  00050	5b		 pop	 ebx
$LN13@Find_lower:

; 1631 :             }
; 1632 :         }
; 1633 : 
; 1634 :         return _Result;
; 1635 :     }

  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Guard$2 = -36						; size = 20
__Oldsize$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Newsize$ = 8						; size = 4
$T3 = 8							; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1574 :     _CONSTEXPR20 void _Resize(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx

; 1575 :         // trim or append elements, provide strong guarantee
; 1576 :         auto& _Al           = _Getal();
; 1577 :         auto& _My_data      = _Mypair._Myval2;
; 1578 :         pointer& _Myfirst   = _My_data._Myfirst;
; 1579 :         pointer& _Mylast    = _My_data._Mylast;
; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0002a	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0002d	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
  00032	8b f1		 mov	 esi, ecx
  00034	2b 37		 sub	 esi, DWORD PTR [edi]
  00036	f7 ee		 imul	 esi
  00038	03 d6		 add	 edx, esi

; 1581 :         if (_Newsize < _Oldsize) { // trim

  0003a	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]
  0003d	c1 fa 07	 sar	 edx, 7
  00040	8b da		 mov	 ebx, edx
  00042	c1 eb 1f	 shr	 ebx, 31			; 0000001fH
  00045	03 da		 add	 ebx, edx
  00047	89 5d f0	 mov	 DWORD PTR __Oldsize$1$[ebp], ebx
  0004a	3b f3		 cmp	 esi, ebx
  0004c	73 18		 jae	 SHORT $LN2@Resize

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  0004e	69 f6 9c 00 00
	00		 imul	 esi, esi, 156

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);

  00054	57		 push	 edi
  00055	51		 push	 ecx
  00056	03 37		 add	 esi, DWORD PTR [edi]
  00058	56		 push	 esi
  00059	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Destroy_range<std::allocator<STerrainTexture> >

; 1585 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1586 :             _Mylast = _Newlast;

  0005e	89 77 04	 mov	 DWORD PTR [edi+4], esi

; 1587 :             return;

  00061	e9 0f 01 00 00	 jmp	 $LN37@Resize
$LN2@Resize:

; 1588 :         }
; 1589 : 
; 1590 :         if (_Newsize > _Oldsize) { // append

  00066	0f 86 0c 01 00
	00		 jbe	 $LN3@Resize

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0006c	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0006f	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
  00074	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00076	f7 e9		 imul	 ecx
  00078	03 d1		 add	 edx, ecx
  0007a	c1 fa 07	 sar	 edx, 7
  0007d	8b ca		 mov	 ecx, edx
  0007f	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00082	03 ca		 add	 ecx, edx

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  00084	3b f1		 cmp	 esi, ecx
  00086	0f 86 da 00 00
	00		 jbe	 $LN4@Resize

; 1538 :         if (_Newsize > max_size()) {

  0008c	81 fe 41 1a a4
	01		 cmp	 esi, 27531841		; 01a41a41H
  00092	0f 87 f4 00 00
	00		 ja	 $LN41@Resize

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00098	8b d1		 mov	 edx, ecx
  0009a	b8 41 1a a4 01	 mov	 eax, 27531841		; 01a41a41H
  0009f	d1 ea		 shr	 edx, 1
  000a1	2b c2		 sub	 eax, edx
  000a3	3b c8		 cmp	 ecx, eax
  000a5	76 12		 jbe	 SHORT $LN11@Resize

; 1997 :             return _Max; // geometric growth would overflow

  000a7	b8 9c ff ff ff	 mov	 eax, -100		; ffffff9cH
  000ac	bb 41 1a a4 01	 mov	 ebx, 27531841		; 01a41a41H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000b7	eb 38		 jmp	 SHORT $LN39@Resize
$LN11@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000b9	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  000bc	3b de		 cmp	 ebx, esi
  000be	73 0e		 jae	 SHORT $LN12@Resize

; 2003 :             return _Newsize; // geometric growth would be insufficient

  000c0	8b de		 mov	 ebx, esi
$LN22@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  000c2	69 c3 9c 00 00
	00		 imul	 eax, ebx, 156

; 227  :     if (_Bytes == 0) {

  000c8	85 c0		 test	 eax, eax
  000ca	75 10		 jne	 SHORT $LN26@Resize

; 228  :         return nullptr;

  000cc	eb 26		 jmp	 SHORT $LN38@Resize
$LN12@Resize:

; 117  :         if (_Count > _Max_possible) {

  000ce	81 fb 41 1a a4
	01		 cmp	 ebx, 27531841		; 01a41a41H
  000d4	0f 87 b7 00 00
	00		 ja	 $LN42@Resize
  000da	eb e6		 jmp	 SHORT $LN22@Resize
$LN26@Resize:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000dc	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000e1	72 08		 jb	 SHORT $LN27@Resize

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000e9	eb 06		 jmp	 SHORT $LN39@Resize
$LN27@Resize:

; 136  :         return ::operator new(_Bytes);

  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN39@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000f1	83 c4 04	 add	 esp, 4
$LN38@Resize:
  000f4	69 4d f0 9c 00
	00 00		 imul	 ecx, DWORD PTR __Oldsize$1$[ebp], 156
  000fb	89 45 08	 mov	 DWORD PTR $T3[ebp], eax

; 1552 : 
; 1553 :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Appended_first, _Appended_first};

  000fe	89 7d dc	 mov	 DWORD PTR __Guard$2[ebp], edi
  00101	89 45 e0	 mov	 DWORD PTR __Guard$2[ebp+4], eax
  00104	89 5d e4	 mov	 DWORD PTR __Guard$2[ebp+8], ebx
  00107	03 c8		 add	 ecx, eax
  00109	89 4d e8	 mov	 DWORD PTR __Guard$2[ebp+12], ecx
  0010c	89 4d ec	 mov	 DWORD PTR __Guard$2[ebp+16], ecx

; 1554 :         auto& _Appended_last = _Guard._Constructed_last;
; 1555 : 
; 1556 :         if constexpr (is_same_v<_Ty2, _Ty>) {
; 1557 :             _Appended_last = _Uninitialized_fill_n(_Appended_first, _Newsize - _Oldsize, _Val, _Al);
; 1558 :         } else {
; 1559 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1560 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

  0010f	8b c6		 mov	 eax, esi
  00111	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00118	2b 45 f0	 sub	 eax, DWORD PTR __Oldsize$1$[ebp]
  0011b	57		 push	 edi
  0011c	50		 push	 eax
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<STerrainTexture> >

; 1561 :         }
; 1562 : 
; 1563 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1564 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 1565 :         } else {
; 1566 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);

  00123	57		 push	 edi
  00124	ff 75 08	 push	 DWORD PTR $T3[ebp]
  00127	89 45 ec	 mov	 DWORD PTR __Guard$2[ebp+16], eax
  0012a	ff 77 04	 push	 DWORD PTR [edi+4]
  0012d	ff 37		 push	 DWORD PTR [edi]
  0012f	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Uninitialized_copy<STerrainTexture *,STerrainTexture *,std::allocator<STerrainTexture> >
  00134	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1567 :         }
; 1568 : 
; 1569 :         _Guard._New_begin = nullptr;

  00137	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Guard$2[ebp+4], 0

; 1570 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  0013e	8b cf		 mov	 ecx, edi
  00140	53		 push	 ebx
  00141	56		 push	 esi
  00142	ff 75 08	 push	 DWORD PTR $T3[ebp]
  00145	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXQAUSTerrainTexture@@II@Z ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Change_array

; 1571 :     }

  0014a	8d 4d dc	 lea	 ecx, DWORD PTR __Guard$2[ebp]
  0014d	e8 00 00 00 00	 call	 ??1_Reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Reallocation_guard::~_Reallocation_guard

; 1610 :     }

  00152	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00155	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015c	59		 pop	 ecx
  0015d	5f		 pop	 edi
  0015e	5e		 pop	 esi
  0015f	5b		 pop	 ebx
  00160	8b e5		 mov	 esp, ebp
  00162	5d		 pop	 ebp
  00163	c2 08 00	 ret	 8
$LN4@Resize:

; 1593 :                 _Resize_reallocate(_Newsize, _Val);
; 1594 :                 return;
; 1595 :             }
; 1596 : 
; 1597 :             _ASAN_VECTOR_EXTEND_GUARD(_Newsize);
; 1598 :             const pointer _Oldlast = _Mylast;
; 1599 :             if constexpr (is_same_v<_Ty2, _Ty>) {
; 1600 :                 _Mylast = _Uninitialized_fill_n(_Oldlast, _Newsize - _Oldsize, _Val, _Al);
; 1601 :             } else {
; 1602 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Ty2, _Value_init_tag>);
; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00166	57		 push	 edi
  00167	2b f3		 sub	 esi, ebx
  00169	56		 push	 esi
  0016a	ff 77 04	 push	 DWORD PTR [edi+4]
  0016d	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@IAAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<STerrainTexture> >
  00172	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN37@Resize:

; 1610 :     }

  00175	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Resize:
  00178	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00182	59		 pop	 ecx
  00183	5f		 pop	 edi
  00184	5e		 pop	 esi
  00185	5b		 pop	 ebx
  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c2 08 00	 ret	 8
$LN41@Resize:

; 1539 :             _Xlength();

  0018c	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@CAXXZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Xlength
$LN42@Resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00191	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN36@Resize:
  00196	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Guard$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Reallocation_guard::~_Reallocation_guard
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Resize<std::_Value_init_tag>
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$destroy@USTerrainTexture@@@?$_Default_allocator_traits@V?$allocator@USTerrainTexture@@@std@@@std@@SAXAAV?$allocator@USTerrainTexture@@@1@QAUSTerrainTexture@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@USTerrainTexture@@@?$_Default_allocator_traits@V?$allocator@USTerrainTexture@@@std@@@std@@SAXAAV?$allocator@USTerrainTexture@@@1@QAUSTerrainTexture@@@Z PROC ; std::_Default_allocator_traits<std::allocator<STerrainTexture> >::destroy<STerrainTexture>, COMDAT

; 737  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h

; 21   : 	}

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  0000a	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0000f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00012	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00015	76 27		 jbe	 SHORT $LN32@destroy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00019	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 12		 jb	 SHORT $LN43@destroy

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00022	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00025	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00028	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00030	77 20		 ja	 SHORT $LN40@destroy

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00032	8b c2		 mov	 eax, edx
$LN43@destroy:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00034	51		 push	 ecx
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN32@destroy:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  0003e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00045	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004f	5e		 pop	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 743  :     }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN40@destroy:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00052	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN55@destroy:
  00057	cc		 int	 3
??$destroy@USTerrainTexture@@@?$_Default_allocator_traits@V?$allocator@USTerrainTexture@@@std@@@std@@SAXAAV?$allocator@USTerrainTexture@@@1@QAUSTerrainTexture@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<STerrainTexture> >::destroy<STerrainTexture>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z PROC ; std::_Destroy_range<std::allocator<STerrainTexture> >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1098 :         for (; _First != _Last; ++_First) {

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 5a		 je	 SHORT $LN61@Destroy_ra
  0000f	83 c6 14	 add	 esi, 20			; 00000014H
  00012	57		 push	 edi
$LL4@Destroy_ra:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h

; 21   : 	}

  00013	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00016	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0001b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0001d	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00020	76 28		 jbe	 SHORT $LN64@Destroy_ra
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00022	8b 46 ec	 mov	 eax, DWORD PTR [esi-20]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00025	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00026	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002c	72 12		 jb	 SHORT $LN49@Destroy_ra

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00031	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00034	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00036	83 c0 fc	 add	 eax, -4			; fffffffcH
  00039	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0003c	77 2f		 ja	 SHORT $LN46@Destroy_ra

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003e	8b c2		 mov	 eax, edx
$LN49@Destroy_ra:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	51		 push	 ecx
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00047	83 c4 08	 add	 esp, 8
$LN64@Destroy_ra:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  0004a	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00051	c7 06 0f 00 00
	00		 mov	 DWORD PTR [esi], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00057	c6 46 ec 00	 mov	 BYTE PTR [esi-20], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  0005b	81 c6 9c 00 00
	00		 add	 esi, 156		; 0000009cH
  00061	8d 46 ec	 lea	 eax, DWORD PTR [esi-20]
  00064	3b c3		 cmp	 eax, ebx
  00066	75 ab		 jne	 SHORT $LL4@Destroy_ra
  00068	5f		 pop	 edi
$LN61@Destroy_ra:
  00069	5e		 pop	 esi

; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1100 :         }
; 1101 :     }
; 1102 : }

  0006a	5b		 pop	 ebx
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN46@Destroy_ra:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN70@Destroy_ra:
  00072	cc		 int	 3
??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<STerrainTexture> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 767  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 34		 push	 52			; 00000034H
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node, COMDAT
; _this$ = ecx

; 659  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 660  :         ++_Mysize;
; 661  :         const auto _Head  = _Myhead;
; 662  :         _Newnode->_Parent = _Loc._Parent;

  00004	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0000e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00010	ff 43 04	 inc	 DWORD PTR [ebx+4]
  00013	89 45 fc	 mov	 DWORD PTR __Head$1$[ebp], eax
  00016	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 663  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00019	3b d0		 cmp	 edx, eax
  0001b	75 16		 jne	 SHORT $LN5@Insert_nod

; 664  :             _Head->_Left     = _Newnode;

  0001d	89 38		 mov	 DWORD PTR [eax], edi

; 665  :             _Head->_Parent   = _Newnode;

  0001f	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 666  :             _Head->_Right    = _Newnode;

  00022	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 725  :         return _Newnode;
; 726  :     }

  00025	8b c7		 mov	 eax, edi
  00027	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
  0002b	5f		 pop	 edi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 667  :             _Newnode->_Color = _Black; // the root is black
; 668  :             return _Newnode;
; 669  :         }
; 670  : 
; 671  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 672  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00033	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00037	75 0d		 jne	 SHORT $LN6@Insert_nod

; 673  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 674  :             _Loc._Parent->_Right = _Newnode;

  00039	89 7a 08	 mov	 DWORD PTR [edx+8], edi

; 675  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003c	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003f	75 0d		 jne	 SHORT $LN9@Insert_nod

; 676  :                 _Head->_Right = _Newnode;

  00041	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 677  :             }
; 678  :         } else { // add to left of _Loc._Parent

  00044	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 679  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 680  :             _Loc._Parent->_Left = _Newnode;

  00046	89 3a		 mov	 DWORD PTR [edx], edi

; 681  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00048	3b 10		 cmp	 edx, DWORD PTR [eax]
  0004a	75 02		 jne	 SHORT $LN9@Insert_nod

; 682  :                 _Head->_Left = _Newnode;

  0004c	89 38		 mov	 DWORD PTR [eax], edi
$LN9@Insert_nod:

; 683  :             }
; 684  :         }
; 685  : 
; 686  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00051	8b c7		 mov	 eax, edi
  00053	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00057	0f 85 7d 01 00
	00		 jne	 $LN3@Insert_nod
  0005d	56		 push	 esi
  0005e	66 90		 npad	 2
$LL4@Insert_nod:

; 687  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00063	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00068	3b d1		 cmp	 edx, ecx
  0006a	0f 85 aa 00 00
	00		 jne	 $LN10@Insert_nod

; 688  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 689  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00073	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00077	0f 84 a3 00 00
	00		 je	 $LN82@Insert_nod

; 690  :                     _Pnode->_Parent->_Color          = _Black;
; 691  :                     _Parent_sibling->_Color          = _Black;
; 692  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 693  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 694  :                 } else { // parent's sibling has red and black children
; 695  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0007d	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00080	3b c6		 cmp	 eax, esi
  00082	75 37		 jne	 SHORT $LN57@Insert_nod

; 475  :         _Wherenode->_Right = _Pnode->_Left;

  00084	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 696  :                         _Pnode = _Pnode->_Parent;

  00086	8b c2		 mov	 eax, edx

; 475  :         _Wherenode->_Right = _Pnode->_Left;

  00088	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 476  : 
; 477  :         if (!_Pnode->_Left->_Isnil) {

  0008b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00091	75 03		 jne	 SHORT $LN21@Insert_nod

; 478  :             _Pnode->_Left->_Parent = _Wherenode;

  00093	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN21@Insert_nod:

; 479  :         }
; 480  : 
; 481  :         _Pnode->_Parent = _Wherenode->_Parent;

  00096	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00099	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 482  : 
; 483  :         if (_Wherenode == _Myhead->_Parent) {

  0009c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0009e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000a1	75 05		 jne	 SHORT $LN22@Insert_nod

; 484  :             _Myhead->_Parent = _Pnode;

  000a3	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  000a6	eb 0e		 jmp	 SHORT $LN25@Insert_nod
$LN22@Insert_nod:

; 485  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000a8	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000ab	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000ad	75 04		 jne	 SHORT $LN24@Insert_nod

; 486  :             _Wherenode->_Parent->_Left = _Pnode;

  000af	89 31		 mov	 DWORD PTR [ecx], esi

; 487  :         } else {

  000b1	eb 03		 jmp	 SHORT $LN25@Insert_nod
$LN24@Insert_nod:

; 488  :             _Wherenode->_Parent->_Right = _Pnode;

  000b3	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN25@Insert_nod:

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Left       = _Wherenode;

  000b6	89 06		 mov	 DWORD PTR [esi], eax

; 492  :         _Wherenode->_Parent = _Pnode;

  000b8	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN57@Insert_nod:

; 697  :                         _Lrotate(_Pnode);
; 698  :                     }
; 699  : 
; 700  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 701  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000c2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c8	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 702  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cf	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 496  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000d2	8b 32		 mov	 esi, DWORD PTR [edx]

; 497  :         _Wherenode->_Left = _Pnode->_Right;

  000d4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000d7	89 0a		 mov	 DWORD PTR [edx], ecx

; 498  : 
; 499  :         if (!_Pnode->_Right->_Isnil) {

  000d9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000dc	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000e0	75 03		 jne	 SHORT $LN29@Insert_nod

; 500  :             _Pnode->_Right->_Parent = _Wherenode;

  000e2	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN29@Insert_nod:

; 501  :         }
; 502  : 
; 503  :         _Pnode->_Parent = _Wherenode->_Parent;

  000e5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e8	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 504  : 
; 505  :         if (_Wherenode == _Myhead->_Parent) {

  000eb	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ed	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000f0	75 0b		 jne	 SHORT $LN30@Insert_nod

; 506  :             _Myhead->_Parent = _Pnode;

  000f2	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 511  :         }
; 512  : 
; 513  :         _Pnode->_Right      = _Wherenode;

  000f5	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 703  :                 }
; 704  :             } else { // fixup red-red in right subtree

  000f8	e9 cc 00 00 00	 jmp	 $LN81@Insert_nod
$LN30@Insert_nod:

; 507  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  000fd	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00100	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00103	75 0b		 jne	 SHORT $LN32@Insert_nod

; 508  :             _Wherenode->_Parent->_Right = _Pnode;

  00105	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 511  :         }
; 512  : 
; 513  :         _Pnode->_Right      = _Wherenode;

  00108	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 703  :                 }
; 704  :             } else { // fixup red-red in right subtree

  0010b	e9 b9 00 00 00	 jmp	 $LN81@Insert_nod
$LN32@Insert_nod:

; 510  :             _Wherenode->_Parent->_Left = _Pnode;

  00110	89 31		 mov	 DWORD PTR [ecx], esi

; 511  :         }
; 512  : 
; 513  :         _Pnode->_Right      = _Wherenode;

  00112	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 703  :                 }
; 704  :             } else { // fixup red-red in right subtree

  00115	e9 af 00 00 00	 jmp	 $LN81@Insert_nod
$LN10@Insert_nod:

; 705  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 706  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  0011a	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0011e	75 1d		 jne	 SHORT $LN15@Insert_nod
$LN82@Insert_nod:

; 683  :             }
; 684  :         }
; 685  : 
; 686  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00120	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1
  00124	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0012e	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00132	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00135	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00138	e9 8f 00 00 00	 jmp	 $LN2@Insert_nod
$LN15@Insert_nod:

; 707  :                     _Pnode->_Parent->_Color          = _Black;
; 708  :                     _Parent_sibling->_Color          = _Black;
; 709  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 710  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 711  :                 } else { // parent's sibling has red and black children
; 712  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  0013d	8b 32		 mov	 esi, DWORD PTR [edx]
  0013f	3b c6		 cmp	 eax, esi
  00141	75 3a		 jne	 SHORT $LN42@Insert_nod

; 497  :         _Wherenode->_Left = _Pnode->_Right;

  00143	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 713  :                         _Pnode = _Pnode->_Parent;

  00146	8b c2		 mov	 eax, edx

; 497  :         _Wherenode->_Left = _Pnode->_Right;

  00148	89 08		 mov	 DWORD PTR [eax], ecx

; 498  : 
; 499  :         if (!_Pnode->_Right->_Isnil) {

  0014a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0014d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00151	75 03		 jne	 SHORT $LN37@Insert_nod

; 500  :             _Pnode->_Right->_Parent = _Wherenode;

  00153	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN37@Insert_nod:

; 501  :         }
; 502  : 
; 503  :         _Pnode->_Parent = _Wherenode->_Parent;

  00156	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00159	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 504  : 
; 505  :         if (_Wherenode == _Myhead->_Parent) {

  0015c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0015e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00161	75 05		 jne	 SHORT $LN38@Insert_nod

; 506  :             _Myhead->_Parent = _Pnode;

  00163	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00166	eb 0f		 jmp	 SHORT $LN41@Insert_nod
$LN38@Insert_nod:

; 507  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00168	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0016b	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0016e	75 05		 jne	 SHORT $LN40@Insert_nod

; 508  :             _Wherenode->_Parent->_Right = _Pnode;

  00170	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 509  :         } else {

  00173	eb 02		 jmp	 SHORT $LN41@Insert_nod
$LN40@Insert_nod:

; 510  :             _Wherenode->_Parent->_Left = _Pnode;

  00175	89 31		 mov	 DWORD PTR [ecx], esi
$LN41@Insert_nod:

; 511  :         }
; 512  : 
; 513  :         _Pnode->_Right      = _Wherenode;

  00177	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 514  :         _Wherenode->_Parent = _Pnode;

  0017a	89 70 04	 mov	 DWORD PTR [eax+4], esi
$LN42@Insert_nod:

; 714  :                         _Rrotate(_Pnode);
; 715  :                     }
; 716  : 
; 717  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0017d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00180	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 718  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00184	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00187	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0018a	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 719  :                     _Lrotate(_Pnode->_Parent->_Parent);

  0018e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00191	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 474  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00194	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 475  :         _Wherenode->_Right = _Pnode->_Left;

  00197	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00199	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 476  : 
; 477  :         if (!_Pnode->_Left->_Isnil) {

  0019c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0019e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001a2	75 03		 jne	 SHORT $LN45@Insert_nod

; 478  :             _Pnode->_Left->_Parent = _Wherenode;

  001a4	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN45@Insert_nod:

; 479  :         }
; 480  : 
; 481  :         _Pnode->_Parent = _Wherenode->_Parent;

  001a7	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001aa	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 482  : 
; 483  :         if (_Wherenode == _Myhead->_Parent) {

  001ad	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001af	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001b2	75 05		 jne	 SHORT $LN46@Insert_nod

; 484  :             _Myhead->_Parent = _Pnode;

  001b4	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  001b7	eb 0e		 jmp	 SHORT $LN49@Insert_nod
$LN46@Insert_nod:

; 485  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001b9	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001bc	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001be	75 04		 jne	 SHORT $LN48@Insert_nod

; 486  :             _Wherenode->_Parent->_Left = _Pnode;

  001c0	89 31		 mov	 DWORD PTR [ecx], esi

; 487  :         } else {

  001c2	eb 03		 jmp	 SHORT $LN49@Insert_nod
$LN48@Insert_nod:

; 488  :             _Wherenode->_Parent->_Right = _Pnode;

  001c4	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN49@Insert_nod:

; 489  :         }
; 490  : 
; 491  :         _Pnode->_Left       = _Wherenode;

  001c7	89 16		 mov	 DWORD PTR [esi], edx
$LN81@Insert_nod:

; 683  :             }
; 684  :         }
; 685  : 
; 686  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001c9	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN2@Insert_nod:
  001cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001cf	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001d3	0f 84 87 fe ff
	ff		 je	 $LL4@Insert_nod
  001d9	5e		 pop	 esi
$LN3@Insert_nod:

; 720  :                 }
; 721  :             }
; 722  :         }
; 723  : 
; 724  :         _Head->_Parent->_Color = _Black; // root is always black

  001da	8b 45 fc	 mov	 eax, DWORD PTR __Head$1$[ebp]
  001dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e0	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 725  :         return _Newnode;
; 726  :     }

  001e4	8b c7		 mov	 eax, edi
  001e6	5f		 pop	 edi
  001e7	5b		 pop	 ebx
  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCTextureSet@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCTextureSet@@UAEPAXI@Z PROC				; CTextureSet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CTextureSet@@UAE@XZ	; CTextureSet::~CTextureSet
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN5@scalar
  00011	68 c4 00 00 00	 push	 196			; 000000c4H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCTextureSet@@UAEPAXI@Z ENDP				; CTextureSet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@CAXXZ PROC ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@CAXXZ ENDP ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXQAUSTerrainTexture@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXQAUSTerrainTexture@@II@Z PROC ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Change_array, COMDAT
; _this$ = ecx

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();
; 2047 :         auto& _My_data    = _Mypair._Myval2;
; 2048 :         pointer& _Myfirst = _My_data._Myfirst;
; 2049 :         pointer& _Mylast  = _My_data._Mylast;
; 2050 :         pointer& _Myend   = _My_data._Myend;
; 2051 : 
; 2052 :         _My_data._Orphan_all();
; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 53		 je	 SHORT $LN10@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000c	57		 push	 edi
  0000d	56		 push	 esi
  0000e	ff 76 04	 push	 DWORD PTR [esi+4]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Destroy_range<std::allocator<STerrainTexture> >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00017	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001a	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
  0001f	8b 3e		 mov	 edi, DWORD PTR [esi]
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	2b cf		 sub	 ecx, edi
  00026	f7 e9		 imul	 ecx
  00028	03 d1		 add	 edx, ecx
  0002a	c1 fa 07	 sar	 edx, 7
  0002d	8b c2		 mov	 eax, edx
  0002f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00032	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00034	69 c8 9c 00 00
	00		 imul	 ecx, eax, 156

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0003a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00040	72 12		 jb	 SHORT $LN21@Change_arr

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00042	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  00045	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00048	2b fa		 sub	 edi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004a	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  0004d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00050	77 2f		 ja	 SHORT $LN18@Change_arr

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00052	8b fa		 mov	 edi, edx
$LN21@Change_arr:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00054	51		 push	 ecx
  00055	57		 push	 edi
  00056	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005b	83 c4 08	 add	 esp, 8
  0005e	5f		 pop	 edi
$LN10@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0005f	69 45 0c 9c 00
	00 00		 imul	 eax, DWORD PTR __Newsize$[ebp], 156
  00066	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00069	89 0e		 mov	 DWORD PTR [esi], ecx
  0006b	03 c1		 add	 eax, ecx
  0006d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00070	69 45 10 9c 00
	00 00		 imul	 eax, DWORD PTR __Newcapacity$[ebp], 156
  00077	03 c1		 add	 eax, ecx
  00079	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0007c	5e		 pop	 esi

; 2064 :     }

  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
$LN18@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00081	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@Change_arr:
  00086	cc		 int	 3
?_Change_array@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXQAUSTerrainTexture@@II@Z ENDP ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ PROC ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::~vector<STerrainTexture,std::allocator<STerrainTexture> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 67		 je	 SHORT $LN5@vector
  00009	57		 push	 edi

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000a	56		 push	 esi
  0000b	ff 76 04	 push	 DWORD PTR [esi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Destroy_range<std::allocator<STerrainTexture> >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
  0001c	8b 3e		 mov	 edi, DWORD PTR [esi]
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	2b cf		 sub	 ecx, edi
  00023	f7 e9		 imul	 ecx
  00025	03 d1		 add	 edx, ecx
  00027	c1 fa 07	 sar	 edx, 7
  0002a	8b c2		 mov	 eax, edx
  0002c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002f	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00031	69 c8 9c 00 00
	00		 imul	 ecx, eax, 156

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00037	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003d	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003f	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  00042	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00045	2b fa		 sub	 edi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00047	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  0004a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004d	77 23		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004f	8b fa		 mov	 edi, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00051	51		 push	 ecx
  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00058	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0005b	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 2081 :             _Mylast  = nullptr;

  00061	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  00068	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0006f	5f		 pop	 edi
$LN5@vector:
  00070	5e		 pop	 esi

; 820  :     }

  00071	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00072	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00077	cc		 int	 3
??1?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ENDP ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::~vector<STerrainTexture,std::allocator<STerrainTexture> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?AddEmptyTexture@CTextureSet@@IAEXXZ
_TEXT	SEGMENT
_eraser$ = -172						; size = 156
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?AddEmptyTexture@CTextureSet@@IAEXXZ PROC		; CTextureSet::AddEmptyTexture, COMDAT
; _this$ = ecx

; 104  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddEmptyTexture@CTextureSet@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	8b f1		 mov	 esi, ecx

; 105  : 	TTerrainTexture eraser;

  0002e	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _eraser$[ebp]
  00034	e8 00 00 00 00	 call	 ??0STerrainTexture@@QAE@XZ ; STerrainTexture::STerrainTexture
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00039	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003c	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _eraser$[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 105  : 	TTerrainTexture eraser;

  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00049	51		 push	 ecx
  0004a	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  0004d	74 10		 je	 SHORT $LN7@AddEmptyTe
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0004f	8b c8		 mov	 ecx, eax
  00051	e8 00 00 00 00	 call	 ??0STerrainTexture@@QAE@ABU0@@Z
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 854  :         ++_Mylast;

  00056	81 46 08 9c 00
	00 00		 add	 DWORD PTR [esi+8], 156	; 0000009cH

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0005d	eb 09		 jmp	 SHORT $LN6@AddEmptyTe
$LN7@AddEmptyTe:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0005f	50		 push	 eax
  00060	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00063	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSTerrainTexture@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEPAUSTerrainTexture@@QAU2@ABU2@@Z ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Emplace_reallocate<STerrainTexture const &>
$LN6@AddEmptyTe:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h

; 21   : 	}

  00068	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR _eraser$[ebp+28]
  0006e	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00073	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _eraser$[ebp+20]
  00079	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0007c	76 2b		 jbe	 SHORT $LN38@AddEmptyTe
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0007e	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _eraser$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00084	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00085	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00087	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0008d	72 10		 jb	 SHORT $LN49@AddEmptyTe

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0008f	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00092	83 c1 23	 add	 ecx, 35			; 00000023H
  00095	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00097	83 c0 fc	 add	 eax, -4			; fffffffcH
  0009a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009d	77 24		 ja	 SHORT $LN60@AddEmptyTe
$LN49@AddEmptyTe:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0009f	51		 push	 ecx
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000a6	83 c4 08	 add	 esp, 8
$LN38@AddEmptyTe:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 107  : }

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b3	59		 pop	 ecx
  000b4	5e		 pop	 esi
  000b5	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b8	33 cd		 xor	 ecx, ebp
  000ba	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c3		 ret	 0
$LN60@AddEmptyTe:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000c3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN58@AddEmptyTe:
  000c8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddEmptyTexture@CTextureSet@@IAEXXZ$0:
  00000	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _eraser$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1STerrainTexture@@QAE@XZ ; STerrainTexture::~STerrainTexture
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?AddEmptyTexture@CTextureSet@@IAEXXZ:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 58 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-168]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddEmptyTexture@CTextureSet@@IAEXXZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddEmptyTexture@CTextureSet@@IAEXXZ ENDP		; CTextureSet::AddEmptyTexture
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z
_TEXT	SEGMENT
__Guard$2 = -40						; size = 12
__My_data$1$ = -28					; size = 4
tv414 = -24						; size = 4
__Mylast$1$ = -20					; size = 4
$T3 = -20						; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
tv409 = 8						; size = 4
__Size$1$ = 8						; size = 4
_fuScale$ = 12						; size = 4
_fvScale$ = 16						; size = 4
_fuOffset$ = 20						; size = 4
_fvOffset$ = 24						; size = 4
_bSplat$ = 28						; size = 1
_usBegin$ = 32						; size = 2
_usEnd$ = 36						; size = 2
_fTerrainTexCoordBase$ = 40				; size = 4
?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z PROC	; CTextureSet::AddTexture, COMDAT
; _this$ = ecx

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d f0	 mov	 DWORD PTR _this$1$[ebp], edi
  0002d	8b 5d 08	 mov	 ebx, DWORD PTR _c_szFileName$[ebp]

; 212  : 
; 213  : 
; 214  : 		//@natanek53
; 215  : 		if (!c_szFileName)

  00030	85 db		 test	 ebx, ebx
  00032	75 18		 jne	 SHORT $LN5@AddTexture

; 216  : 		{
; 217  : 			LogBox("CTextureSet::AddTexture: Błąd - Brak nazwy pliku. Przekazany wskaźnik na nazwę pliku jest niezdefiniowany (nullptr).", "Błąd");

  00034	53		 push	 ebx
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_06CEEECGLN@B?E?$IC?D?$IFd@
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0HJ@COHDILEG@CTextureSet?3?3AddTexture?3?5B?E?$IC?D?$IFd@
  0003f	e8 00 00 00 00	 call	 ?LogBox@@YAXPBD0PAUHWND__@@@Z ; LogBox
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 218  : 			return false;

  00047	e9 25 02 00 00	 jmp	 $LN96@AddTexture
$LN5@AddTexture:

; 219  : 		}
; 220  : 		//@natanek53
; 221  : 
; 222  : 	if (GetTextureCount() >= 256)

  0004c	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  00051	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00056	72 16		 jb	 SHORT $LN6@AddTexture

; 223  : 	{
; 224  : 		LogBox("You cannot add more than 255 texture.");

  00058	6a 00		 push	 0
  0005a	6a 00		 push	 0
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@GCCGCFA@You?5cannot?5add?5more?5than?5255?5te@
  00061	e8 00 00 00 00	 call	 ?LogBox@@YAXPBD0PAUHWND__@@@Z ; LogBox
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 225  : 		return false;

  00069	e9 03 02 00 00	 jmp	 $LN96@AddTexture
$LN6@AddTexture:

; 226  : 	}
; 227  : 
; 228  : 	for (unsigned long i = 1; i < GetTextureCount(); ++i)

  0006e	8b cf		 mov	 ecx, edi
  00070	be 01 00 00 00	 mov	 esi, 1
  00075	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  0007a	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0007d	3b c6		 cmp	 eax, esi
  0007f	76 72		 jbe	 SHORT $LN91@AddTexture
  00081	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00084	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
  00087	89 4d e4	 mov	 DWORD PTR __My_data$1$[ebp], ecx
  0008a	bf 9c 00 00 00	 mov	 edi, 156		; 0000009cH
  0008f	89 45 e8	 mov	 DWORD PTR tv414[ebp], eax
$LL4@AddTexture:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00092	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00094	8d 14 07	 lea	 edx, DWORD PTR [edi+eax]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00097	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0009a	89 45 08	 mov	 DWORD PTR tv409[ebp], eax
  0009d	0f 1f 00	 npad	 3
$LL92@AddTexture:
  000a0	8a 01		 mov	 al, BYTE PTR [ecx]
  000a2	41		 inc	 ecx
  000a3	84 c0		 test	 al, al
  000a5	75 f9		 jne	 SHORT $LL92@AddTexture
  000a7	2b 4d 08	 sub	 ecx, DWORD PTR tv409[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  000aa	8b c2		 mov	 eax, edx

; 434  :         return _Myres > _Small_string_capacity;

  000ac	83 7a 14 0f	 cmp	 DWORD PTR [edx+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  000b0	76 02		 jbe	 SHORT $LN21@AddTexture

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  000b2	8b 02		 mov	 eax, DWORD PTR [edx]
$LN21@AddTexture:

; 2876 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  000b4	51		 push	 ecx
  000b5	53		 push	 ebx
  000b6	ff 72 10	 push	 DWORD PTR [edx+16]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  000bf	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 230  : 		if (0 == m_Textures[i].stFilename.compare(c_szFileName))

  000c2	85 c0		 test	 eax, eax
  000c4	74 14		 je	 SHORT $LN86@AddTexture

; 226  : 	}
; 227  : 
; 228  : 	for (unsigned long i = 1; i < GetTextureCount(); ++i)

  000c6	8b 45 e8	 mov	 eax, DWORD PTR tv414[ebp]
  000c9	46		 inc	 esi
  000ca	81 c7 9c 00 00
	00		 add	 edi, 156		; 0000009cH
  000d0	3b 75 ec	 cmp	 esi, DWORD PTR $T3[ebp]
  000d3	72 bd		 jb	 SHORT $LL4@AddTexture

; 230  : 		if (0 == m_Textures[i].stFilename.compare(c_szFileName))

  000d5	8b 7d e4	 mov	 edi, DWORD PTR __My_data$1$[ebp]
  000d8	eb 1c		 jmp	 SHORT $LN89@AddTexture
$LN86@AddTexture:

; 231  : 		{
; 232  : 			LogBox("Texture of the same name already exists.", "Duplicate");

  000da	6a 00		 push	 0
  000dc	68 00 00 00 00	 push	 OFFSET ??_C@_09OINHJNMP@Duplicate@
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@ELAAMMOC@Texture?5of?5the?5same?5name?5alread@
  000e6	e8 00 00 00 00	 call	 ?LogBox@@YAXPBD0PAUHWND__@@@Z ; LogBox
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 233  : 			return false;

  000ee	e9 7e 01 00 00	 jmp	 $LN96@AddTexture
$LN91@AddTexture:
  000f3	83 c7 04	 add	 edi, 4
$LN89@AddTexture:

; 234  : 		}
; 235  : 	}
; 236  : 
; 237  : 	CResource * pResource = CResourceManager::Instance().GetResourcePointer(c_szFileName);

  000f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  000fc	53		 push	 ebx
  000fd	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00102	8b f0		 mov	 esi, eax

; 238  : 
; 239  : /*/
; 240  : 	if (!pResource->IsType(CGraphicImage::Type()))
; 241  : 	{
; 242  : 		LogBox("CTerrainImpl::GenerateTexture : It's not an image file. %s", pResource->GetFileName());
; 243  : 		return false;
; 244  : 	}
; 245  : /*/
; 246  : 	//@natanek53
; 247  : 	if (!pResource || !pResource->IsType(CGraphicImage::Type()))

  00104	85 f6		 test	 esi, esi
  00106	0f 84 57 01 00
	00		 je	 $LN9@AddTexture
  0010c	e8 00 00 00 00	 call	 ?Type@CGraphicImage@@SAKXZ ; CGraphicImage::Type
  00111	50		 push	 eax
  00112	8b ce		 mov	 ecx, esi
  00114	e8 00 00 00 00	 call	 ?IsType@CResource@@QAE_NK@Z ; CResource::IsType
  00119	84 c0		 test	 al, al
  0011b	0f 84 42 01 00
	00		 je	 $LN9@AddTexture
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00121	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00124	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00127	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00129	89 45 ec	 mov	 DWORD PTR __Mylast$1$[ebp], eax
  0012c	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
  00131	f7 e9		 imul	 ecx
  00133	03 d1		 add	 edx, ecx

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00135	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00138	2b 0f		 sub	 ecx, DWORD PTR [edi]

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0013a	c1 fa 07	 sar	 edx, 7
  0013d	8b c2		 mov	 eax, edx
  0013f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00142	03 c2		 add	 eax, edx
  00144	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00147	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
  0014c	f7 e9		 imul	 ecx
  0014e	03 d1		 add	 edx, ecx

; 1710 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00150	8b 4d 08	 mov	 ecx, DWORD PTR __Size$1$[ebp]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00153	c1 fa 07	 sar	 edx, 7
  00156	8b c2		 mov	 eax, edx
  00158	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0015b	03 c2		 add	 eax, edx

; 1710 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  0015d	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  00160	3b f0		 cmp	 esi, eax
  00162	76 79		 jbe	 SHORT $LN93@AddTexture

; 1711 :             if (_Newcapacity > max_size()) {

  00164	81 fe 41 1a a4
	01		 cmp	 esi, 27531841		; 01a41a41H
  0016a	0f 87 17 01 00
	00		 ja	 $LN99@AddTexture
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  00170	69 c6 9c 00 00
	00		 imul	 eax, esi, 156

; 227  :     if (_Bytes == 0) {

  00176	85 c0		 test	 eax, eax
  00178	75 04		 jne	 SHORT $LN49@AddTexture

; 228  :         return nullptr;

  0017a	33 f6		 xor	 esi, esi
  0017c	eb 1c		 jmp	 SHORT $LN48@AddTexture
$LN49@AddTexture:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0017e	50		 push	 eax
  0017f	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00184	72 07		 jb	 SHORT $LN50@AddTexture

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00186	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0018b	eb 05		 jmp	 SHORT $LN97@AddTexture
$LN50@AddTexture:

; 136  :         return ::operator new(_Bytes);

  0018d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN97@AddTexture:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1644 :         _Simple_reallocation_guard _Guard{_Al, _Newvec, _Newcapacity};

  00192	8b 4d 08	 mov	 ecx, DWORD PTR __Size$1$[ebp]
  00195	8b f0		 mov	 esi, eax
  00197	83 c4 04	 add	 esp, 4
$LN48@AddTexture:
  0019a	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0019d	89 7d d8	 mov	 DWORD PTR __Guard$2[ebp], edi
  001a0	89 75 dc	 mov	 DWORD PTR __Guard$2[ebp+4], esi
  001a3	89 45 e0	 mov	 DWORD PTR __Guard$2[ebp+8], eax

; 1645 : 
; 1646 :         if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 1647 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);
; 1648 :         } else {
; 1649 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);

  001a6	8b 45 ec	 mov	 eax, DWORD PTR __Mylast$1$[ebp]
  001a9	57		 push	 edi
  001aa	56		 push	 esi
  001ab	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  001b2	ff 30		 push	 DWORD PTR [eax]
  001b4	ff 37		 push	 DWORD PTR [edi]
  001b6	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAUSTerrainTexture@@PAU1@V?$allocator@USTerrainTexture@@@std@@@std@@YAPAUSTerrainTexture@@PAU1@00AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Uninitialized_copy<STerrainTexture *,STerrainTexture *,std::allocator<STerrainTexture> >

; 1650 :         }
; 1651 : 
; 1652 :         _Guard._New_begin = nullptr;
; 1653 :         _Change_array(_Newvec, _Size, _Newcapacity);

  001bb	8b 4d 08	 mov	 ecx, DWORD PTR __Size$1$[ebp]
  001be	83 c4 10	 add	 esp, 16			; 00000010H
  001c1	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  001c4	50		 push	 eax
  001c5	51		 push	 ecx
  001c6	56		 push	 esi
  001c7	8b cf		 mov	 ecx, edi
  001c9	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXQAUSTerrainTexture@@II@Z ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Change_array

; 1654 :     }

  001ce	8b 75 f0	 mov	 esi, DWORD PTR _this$1$[ebp]
  001d1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  001d8	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]

; 1710 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  001db	eb 03		 jmp	 SHORT $LN65@AddTexture
$LN93@AddTexture:
  001dd	8b 75 f0	 mov	 esi, DWORD PTR _this$1$[ebp]
$LN65@AddTexture:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 257  : 	AddEmptyTexture();

  001e0	8b ce		 mov	 ecx, esi
  001e2	e8 00 00 00 00	 call	 ?AddEmptyTexture@CTextureSet@@IAEXXZ ; CTextureSet::AddEmptyTexture

; 258  : 	SetTexture(m_Textures.size() - 1,

  001e7	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _fTerrainTexCoordBase$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001ec	8b 45 ec	 mov	 eax, DWORD PTR __Mylast$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 258  : 	SetTexture(m_Textures.size() - 1,

  001ef	51		 push	 ecx
  001f0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f5	ff 75 24	 push	 DWORD PTR _usEnd$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001fa	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 258  : 	SetTexture(m_Textures.size() - 1,

  001ff	ff 75 20	 push	 DWORD PTR _usBegin$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00202	2b 0f		 sub	 ecx, DWORD PTR [edi]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 258  : 	SetTexture(m_Textures.size() - 1,

  00204	ff 75 1c	 push	 DWORD PTR _bSplat$[ebp]
  00207	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _fvOffset$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0020c	f7 e9		 imul	 ecx
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 258  : 	SetTexture(m_Textures.size() - 1,

  0020e	83 ec 10	 sub	 esp, 16			; 00000010H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00211	03 d1		 add	 edx, ecx
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 258  : 	SetTexture(m_Textures.size() - 1,

  00213	8b ce		 mov	 ecx, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00215	c1 fa 07	 sar	 edx, 7
  00218	8b c2		 mov	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 258  : 	SetTexture(m_Textures.size() - 1,

  0021a	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00220	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fuOffset$[ebp]
  00225	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0022b	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fvScale$[ebp]
  00230	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00236	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fuScale$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0023b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 258  : 	SetTexture(m_Textures.size() - 1,

  0023e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00243	48		 dec	 eax
  00244	53		 push	 ebx
  00245	03 c2		 add	 eax, edx
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ?SetTexture@CTextureSet@@QAE_NKPBDMMMM_NGGM@Z ; CTextureSet::SetTexture

; 259  : 			   c_szFileName,
; 260  : 			   fuScale,
; 261  : 			   fvScale,
; 262  : 			   fuOffset,
; 263  : 			   fvOffset,
; 264  : 			   bSplat,
; 265  : 			   usBegin,
; 266  : 			   usEnd,
; 267  : 			   fTerrainTexCoordBase);
; 268  : 
; 269  : 	return true;

  0024d	b0 01		 mov	 al, 1

; 270  : }

  0024f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00252	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00259	59		 pop	 ecx
  0025a	5f		 pop	 edi
  0025b	5e		 pop	 esi
  0025c	5b		 pop	 ebx
  0025d	8b e5		 mov	 esp, ebp
  0025f	5d		 pop	 ebp
  00260	c2 24 00	 ret	 36			; 00000024H
$LN9@AddTexture:

; 248  : 	{
; 249  : 		TraceError("CTextureSet::AddTexture: Nie można ustawić tekstury. Tekstura '%s' nie istnieje", c_szFileName ? c_szFileName : "Nieznany");

  00263	53		 push	 ebx
  00264	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@LGIGBEJD@CTextureSet?3?3AddTexture?3?5Nie?5mo@
  00269	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0026e	83 c4 08	 add	 esp, 8
$LN96@AddTexture:

; 270  : }

  00271	32 c0		 xor	 al, al
  00273	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00276	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0027d	59		 pop	 ecx
  0027e	5f		 pop	 edi
  0027f	5e		 pop	 esi
  00280	5b		 pop	 ebx
  00281	8b e5		 mov	 esp, ebp
  00283	5d		 pop	 ebp
  00284	c2 24 00	 ret	 36			; 00000024H
$LN99@AddTexture:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1712 :                 _Xlength();

  00287	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@CAXXZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Xlength
$LN95@AddTexture:
  0028c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Guard$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Simple_reallocation_guard@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Simple_reallocation_guard::~_Simple_reallocation_guard
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddTexture@CTextureSet@@QAE_NPBDMMMM_NGGM@Z ENDP	; CTextureSet::AddTexture
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?Reload@CTextureSet@@QAEXM@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
tv244 = -12						; size = 4
_dwIndex$1$ = -8					; size = 4
tv245 = -4						; size = 4
_fTerrainTexCoordBase$ = 8				; size = 4
?Reload@CTextureSet@@QAEXM@Z PROC			; CTextureSet::Reload, COMDAT
; _this$ = ecx

; 188  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 189  : 	for (DWORD dwIndex = 1; dwIndex < GetTextureCount(); ++dwIndex)

  00009	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _dwIndex$1$[ebp], 1
  00010	89 75 f0	 mov	 DWORD PTR _this$1$[ebp], esi
  00013	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  00018	83 f8 01	 cmp	 eax, 1
  0001b	0f 86 c9 00 00
	00		 jbe	 $LN3@Reload
  00021	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fTerrainTexCoordBase$[ebp]
  00026	b8 9c 00 00 00	 mov	 eax, 156		; 0000009cH
  0002b	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00032	f3 0f 11 45 f4	 movss	 DWORD PTR tv244[ebp], xmm0
  00037	89 45 fc	 mov	 DWORD PTR tv245[ebp], eax
  0003a	57		 push	 edi
  0003b	0f 1f 44 00 00	 npad	 5
$LL4@Reload:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00040	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00043	03 f8		 add	 edi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  00045	8b c7		 mov	 eax, edi

; 434  :         return _Myres > _Small_string_capacity;

  00047	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0004b	76 02		 jbe	 SHORT $LN13@Reload

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0004d	8b 07		 mov	 eax, DWORD PTR [edi]
$LN13@Reload:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 193  : 		tex.ImageInstance.ReloadImagePointer((CGraphicImage *) CResourceManager::Instance().GetResourcePointer(tex.stFilename.c_str()));

  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0005b	50		 push	 eax
  0005c	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  0005f	e8 00 00 00 00	 call	 ?ReloadImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::ReloadImagePointer

; 194  : 		tex.pd3dTexture = tex.ImageInstance.GetTexturePointer()->GetD3DTexture();

  00064	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  00067	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  0006c	8b c8		 mov	 ecx, eax
  0006e	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture

; 195  : 
; 196  : 		D3DXMatrixScaling(&tex.m_matTransform, fTerrainTexCoordBase * tex.UScale, -fTerrainTexCoordBase * tex.VScale, 0.0f);

  00073	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv244[ebp]
  00078	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0007b	f3 0f 59 47 48	 mulss	 xmm0, DWORD PTR [edi+72]
  00080	89 47 18	 mov	 DWORD PTR [edi+24], eax
  00083	8d 47 5c	 lea	 eax, DWORD PTR [edi+92]
  00086	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  0008e	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00094	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fTerrainTexCoordBase$[ebp]
  00099	f3 0f 59 47 44	 mulss	 xmm0, DWORD PTR [edi+68]
  0009e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _D3DXMatrixScaling@16

; 197  : 		tex.m_matTransform._41 = tex.UOffset;
; 198  : 		tex.m_matTransform._42 = -tex.VOffset;

  000a9	f3 0f 10 47 50	 movss	 xmm0, DWORD PTR [edi+80]
  000ae	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  000b1	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000b8	8b 75 f0	 mov	 esi, DWORD PTR _this$1$[ebp]
  000bb	8b ce		 mov	 ecx, esi
  000bd	81 45 fc 9c 00
	00 00		 add	 DWORD PTR tv245[ebp], 156 ; 0000009cH
  000c4	89 87 8c 00 00
	00		 mov	 DWORD PTR [edi+140], eax
  000ca	f3 0f 11 87 90
	00 00 00	 movss	 DWORD PTR [edi+144], xmm0
  000d2	8b 7d f8	 mov	 edi, DWORD PTR _dwIndex$1$[ebp]
  000d5	47		 inc	 edi
  000d6	89 7d f8	 mov	 DWORD PTR _dwIndex$1$[ebp], edi
  000d9	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  000de	3b f8		 cmp	 edi, eax
  000e0	8b 45 fc	 mov	 eax, DWORD PTR tv245[ebp]
  000e3	0f 82 57 ff ff
	ff		 jb	 $LL4@Reload

; 189  : 	for (DWORD dwIndex = 1; dwIndex < GetTextureCount(); ++dwIndex)

  000e9	5f		 pop	 edi
$LN3@Reload:
  000ea	5e		 pop	 esi

; 199  : 	}
; 200  : }

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c2 04 00	 ret	 4
?Reload@CTextureSet@@QAEXM@Z ENDP			; CTextureSet::Reload
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?SetTexture@CTextureSet@@QAE_NKPBDMMMM_NGGM@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_ulIndex$ = 8						; size = 4
_c_szFileName$ = 12					; size = 4
_pResource$1$ = 12					; size = 4
_fuScale$ = 16						; size = 4
_fvScale$ = 20						; size = 4
_fuOffset$ = 24						; size = 4
_fvOffset$ = 28						; size = 4
_bSplat$ = 32						; size = 1
_usBegin$ = 36						; size = 2
_usEnd$ = 40						; size = 2
_fTerrainTexCoordBase$ = 44				; size = 4
?SetTexture@CTextureSet@@QAE_NKPBDMMMM_NGGM@Z PROC	; CTextureSet::SetTexture, COMDAT
; _this$ = ecx

; 132  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b 75 0c	 mov	 esi, DWORD PTR _c_szFileName$[ebp]
  00008	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx

; 133  : /*/
; 134  : 	if (ulIndex >= m_Textures.size())
; 135  : 	{
; 136  : 		TraceError("CTextureSet::SetTexture : Index Error : Index(%d) is Larger than TextureSet Size(%d)", ulIndex, m_Textures.size());
; 137  : 		return false;
; 138  : 	}
; 139  : /*/
; 140  : 
; 141  : 	//@natanek53
; 142  : 		if (!c_szFileName)

  0000b	85 f6		 test	 esi, esi
  0000d	75 1c		 jne	 SHORT $LN2@SetTexture

; 143  : 		{
; 144  : 			LogBox("CTextureSet::SetTexture: Błąd - Brak nazwy pliku. Przekazany wskaźnik na nazwę pliku jest niezdefiniowany (nullptr).", "Błąd");

  0000f	56		 push	 esi
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_06CEEECGLN@B?E?$IC?D?$IFd@
  00015	68 00 00 00 00	 push	 OFFSET ??_C@_0HJ@ILLJBGPC@CTextureSet?3?3SetTexture?3?5B?E?$IC?D?$IFd@
  0001a	e8 00 00 00 00	 call	 ?LogBox@@YAXPBD0PAUHWND__@@@Z ; LogBox
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  : 			return false;

  00022	32 c0		 xor	 al, al
  00024	5e		 pop	 esi

; 185  : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 28 00	 ret	 40			; 00000028H
$LN2@SetTexture:

; 146  : 		}
; 147  : 	//@natanek53
; 148  : 
; 149  : 	CResource * pResource = CResourceManager::Instance().GetResourcePointer(c_szFileName);

  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00031	57		 push	 edi
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00038	8b f8		 mov	 edi, eax
  0003a	89 7d 0c	 mov	 DWORD PTR _pResource$1$[ebp], edi

; 150  : /*/
; 151  : 	if (!pResource->IsType(CGraphicImage::Type()))
; 152  : 	{
; 153  : 		TraceError("CTerrainImpl::GenerateTexture : %s is NOT Image File", pResource->GetFileName());
; 154  : 		return false;
; 155  : 	}
; 156  : /*/
; 157  : 
; 158  : 	//@natanek53
; 159  : 	if (!pResource || !pResource->IsType(CGraphicImage::Type()))

  0003d	85 ff		 test	 edi, edi
  0003f	0f 84 f7 00 00
	00		 je	 $LN4@SetTexture
  00045	e8 00 00 00 00	 call	 ?Type@CGraphicImage@@SAKXZ ; CGraphicImage::Type
  0004a	50		 push	 eax
  0004b	8b cf		 mov	 ecx, edi
  0004d	e8 00 00 00 00	 call	 ?IsType@CResource@@QAE_NK@Z ; CResource::IsType
  00052	84 c0		 test	 al, al
  00054	0f 84 e2 00 00
	00		 je	 $LN4@SetTexture
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0005a	69 7d 08 9c 00
	00 00		 imul	 edi, DWORD PTR _ulIndex$[ebp], 156
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00061	8b ce		 mov	 ecx, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00066	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00069	03 78 04	 add	 edi, DWORD PTR [eax+4]
  0006c	0f 1f 40 00	 npad	 4
$LL16@SetTexture:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00070	8a 01		 mov	 al, BYTE PTR [ecx]
  00072	41		 inc	 ecx
  00073	84 c0		 test	 al, al
  00075	75 f9		 jne	 SHORT $LL16@SetTexture
  00077	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00079	51		 push	 ecx
  0007a	56		 push	 esi
  0007b	8b cf		 mov	 ecx, edi
  0007d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 170  : 	tex.UScale = fuScale;

  00082	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fuScale$[ebp]

; 171  : 	tex.VScale = fvScale;
; 172  : 	tex.UOffset = fuOffset;
; 173  : 	tex.VOffset = fvOffset;
; 174  : 	tex.bSplat = bSplat;
; 175  : 	tex.Begin = usBegin;
; 176  : 	tex.End = usEnd;
; 177  : 	tex.ImageInstance.SetImagePointer(static_cast<CGraphicImage *>(pResource));

  00087	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  0008a	8a 45 20	 mov	 al, BYTE PTR _bSplat$[ebp]
  0008d	ff 75 0c	 push	 DWORD PTR _pResource$1$[ebp]
  00090	f3 0f 11 47 44	 movss	 DWORD PTR [edi+68], xmm0
  00095	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fvScale$[ebp]
  0009a	f3 0f 11 47 48	 movss	 DWORD PTR [edi+72], xmm0
  0009f	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _fuOffset$[ebp]
  000a4	88 47 54	 mov	 BYTE PTR [edi+84], al
  000a7	66 8b 45 24	 mov	 ax, WORD PTR _usBegin$[ebp]
  000ab	f3 0f 11 47 4c	 movss	 DWORD PTR [edi+76], xmm0
  000b0	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _fvOffset$[ebp]
  000b5	66 89 47 56	 mov	 WORD PTR [edi+86], ax
  000b9	66 8b 45 28	 mov	 ax, WORD PTR _usEnd$[ebp]
  000bd	f3 0f 11 47 50	 movss	 DWORD PTR [edi+80], xmm0
  000c2	66 89 47 58	 mov	 WORD PTR [edi+88], ax
  000c6	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 178  : 	tex.pd3dTexture = tex.ImageInstance.GetTexturePointer()->GetD3DTexture();

  000cb	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
  000ce	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  000d3	8b c8		 mov	 ecx, eax
  000d5	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture

; 179  : 
; 180  : 
; 181  : 	D3DXMatrixScaling(&tex.m_matTransform, fTerrainTexCoordBase * tex.UScale, -fTerrainTexCoordBase * tex.VScale, 0.0f);

  000da	f3 0f 10 4d 2c	 movss	 xmm1, DWORD PTR _fTerrainTexCoordBase$[ebp]
  000df	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000e2	0f 28 c1	 movaps	 xmm0, xmm1
  000e5	89 47 18	 mov	 DWORD PTR [edi+24], eax
  000e8	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000ef	8d 47 5c	 lea	 eax, DWORD PTR [edi+92]
  000f2	f3 0f 59 47 48	 mulss	 xmm0, DWORD PTR [edi+72]
  000f7	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  000ff	f3 0f 59 4f 44	 mulss	 xmm1, DWORD PTR [edi+68]
  00104	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0010a	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 _D3DXMatrixScaling@16

; 182  : 	tex.m_matTransform._41 = tex.UOffset;
; 183  : 	tex.m_matTransform._42 = -tex.VOffset;

  00115	f3 0f 10 47 50	 movss	 xmm0, DWORD PTR [edi+80]
  0011a	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  0011d	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00124	89 87 8c 00 00
	00		 mov	 DWORD PTR [edi+140], eax

; 184  : 	return true;

  0012a	b0 01		 mov	 al, 1
  0012c	f3 0f 11 87 90
	00 00 00	 movss	 DWORD PTR [edi+144], xmm0
  00134	5f		 pop	 edi
  00135	5e		 pop	 esi

; 185  : }

  00136	8b e5		 mov	 esp, ebp
  00138	5d		 pop	 ebp
  00139	c2 28 00	 ret	 40			; 00000028H
$LN4@SetTexture:

; 160  : 	{
; 161  : 		TraceError("CTextureSet::SetTexture: Nie można ustawić tekstury. Tekstura '%s' nie istnieje.", c_szFileName ? c_szFileName : "Nieznany");

  0013c	56		 push	 esi
  0013d	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@HGCGEJHO@CTextureSet?3?3SetTexture?3?5Nie?5mo@
  00142	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00147	83 c4 08	 add	 esp, 8

; 162  : 		return false;

  0014a	32 c0		 xor	 al, al
  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi

; 185  : }

  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c2 28 00	 ret	 40			; 00000028H
?SetTexture@CTextureSet@@QAE_NKPBDMMMM_NGGM@Z ENDP	; CTextureSet::SetTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\eterLib\Ref.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?RemoveTexture@CTextureSet@@QAE_NK@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
__Last$1$ = -4						; size = 4
_ulIndex$ = 8						; size = 4
tv1523 = 8						; size = 4
?RemoveTexture@CTextureSet@@QAE_NK@Z PROC		; CTextureSet::RemoveTexture, COMDAT
; _this$ = ecx

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx

; 274  : 	if (GetTextureCount() <= ulIndex)

  00009	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR _ulIndex$[ebp]
  00011	3b c1		 cmp	 eax, ecx
  00013	77 09		 ja	 SHORT $LN2@RemoveText

; 275  : 		return false;

  00015	32 c0		 xor	 al, al
  00017	5b		 pop	 ebx

; 280  : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
$LN2@RemoveText:
  0001e	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 129  :         _Ptr += _Off;

  0001f	69 f9 9c 00 00
	00		 imul	 edi, ecx, 156

; 1827 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00025	83 c3 04	 add	 ebx, 4
  00028	89 5d f8	 mov	 DWORD PTR _this$1$[ebp], ebx

; 1760 :         _STD _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

  0002b	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]

; 129  :         _Ptr += _Off;

  0002e	81 c7 9c 00 00
	00		 add	 edi, 156		; 0000009cH

; 1760 :         _STD _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

  00034	89 4d fc	 mov	 DWORD PTR __Last$1$[ebp], ecx
  00037	03 3b		 add	 edi, DWORD PTR [ebx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 5167 :         for (; _First != _Last; ++_Dest, (void) ++_First) {

  00039	3b f9		 cmp	 edi, ecx
  0003b	0f 84 08 01 00
	00		 je	 $LN26@RemoveText
  00041	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1827 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00042	8d 77 84	 lea	 esi, DWORD PTR [edi-124]
$LL27@RemoveText:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1371 :         if (this == _STD addressof(_Right)) {

  00045	8d 46 e0	 lea	 eax, DWORD PTR [esi-32]
  00048	3b c7		 cmp	 eax, edi
  0004a	74 1c		 je	 SHORT $LN31@RemoveText

; 434  :         return _Myres > _Small_string_capacity;

  0004c	83 be 90 00 00
	00 0f		 cmp	 DWORD PTR [esi+144], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00053	8b c7		 mov	 eax, edi

; 426  :         if (_Large_mode_engaged()) {

  00055	76 02		 jbe	 SHORT $LN35@RemoveText

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00057	8b 07		 mov	 eax, DWORD PTR [edi]
$LN35@RemoveText:

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00059	ff b6 8c 00 00
	00		 push	 DWORD PTR [esi+140]
  0005f	8d 4e e0	 lea	 ecx, DWORD PTR [esi-32]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN31@RemoveText:
  00068	8b 86 94 00 00
	00		 mov	 eax, DWORD PTR [esi+148]
  0006e	89 46 f8	 mov	 DWORD PTR [esi-8], eax
  00071	8d 86 9c 00 00
	00		 lea	 eax, DWORD PTR [esi+156]
  00077	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  0007a	89 45 08	 mov	 DWORD PTR tv1523[ebp], eax
  0007d	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00080	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  00086	8b 8e b0 00 00
	00		 mov	 ecx, DWORD PTR [esi+176]
  0008c	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0008f	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
  00092	8b 8e b8 00 00
	00		 mov	 ecx, DWORD PTR [esi+184]
  00098	8b 86 b4 00 00
	00		 mov	 eax, DWORD PTR [esi+180]
  0009e	89 46 18	 mov	 DWORD PTR [esi+24], eax
  000a1	89 4e 1c	 mov	 DWORD PTR [esi+28], ecx
; File C:\Marty 5.5\Src-Client\Client\eterLib\Ref.h

; 69   : 			m_pObject = pObject;

  000a4	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [esi+188]
  000aa	8b 5e 20	 mov	 ebx, DWORD PTR [esi+32]
  000ad	89 4e 20	 mov	 DWORD PTR [esi+32], ecx

; 70   : 
; 71   : 			if (m_pObject)

  000b0	85 c9		 test	 ecx, ecx
  000b2	74 05		 je	 SHORT $LN46@RemoveText

; 72   : 				m_pObject->AddReference();

  000b4	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN46@RemoveText:

; 73   : 
; 74   : 			if (pOldObject)

  000b9	85 db		 test	 ebx, ebx
  000bb	74 07		 je	 SHORT $LN47@RemoveText

; 75   : 				pOldObject->Release();

  000bd	8b cb		 mov	 ecx, ebx
  000bf	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN47@RemoveText:
  000c4	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 5167 :         for (; _First != _Last; ++_Dest, (void) ++_First) {

  000ca	81 c7 9c 00 00
	00		 add	 edi, 156		; 0000009cH
  000d0	89 46 24	 mov	 DWORD PTR [esi+36], eax
  000d3	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]
  000d9	89 46 28	 mov	 DWORD PTR [esi+40], eax
  000dc	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  000e2	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000e5	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  000eb	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000ee	8a 86 d0 00 00
	00		 mov	 al, BYTE PTR [esi+208]
  000f4	88 46 34	 mov	 BYTE PTR [esi+52], al
  000f7	0f b7 86 d2 00
	00 00		 movzx	 eax, WORD PTR [esi+210]
  000fe	66 89 46 36	 mov	 WORD PTR [esi+54], ax
  00102	0f b7 86 d4 00
	00 00		 movzx	 eax, WORD PTR [esi+212]
  00109	66 89 46 38	 mov	 WORD PTR [esi+56], ax
  0010d	0f 10 86 d8 00
	00 00		 movups	 xmm0, XMMWORD PTR [esi+216]
  00114	0f 11 46 3c	 movups	 XMMWORD PTR [esi+60], xmm0
  00118	0f 10 86 e8 00
	00 00		 movups	 xmm0, XMMWORD PTR [esi+232]
  0011f	0f 11 46 4c	 movups	 XMMWORD PTR [esi+76], xmm0
  00123	0f 10 86 f8 00
	00 00		 movups	 xmm0, XMMWORD PTR [esi+248]
  0012a	0f 11 46 5c	 movups	 XMMWORD PTR [esi+92], xmm0
  0012e	0f 10 86 08 01
	00 00		 movups	 xmm0, XMMWORD PTR [esi+264]
  00135	0f 11 46 6c	 movups	 XMMWORD PTR [esi+108], xmm0
  00139	8b 75 08	 mov	 esi, DWORD PTR tv1523[ebp]
  0013c	3b 7d fc	 cmp	 edi, DWORD PTR __Last$1$[ebp]
  0013f	0f 85 00 ff ff
	ff		 jne	 $LL27@RemoveText
  00145	8b 5d f8	 mov	 ebx, DWORD PTR _this$1$[ebp]
  00148	5e		 pop	 esi
$LN26@RemoveText:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1761 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  00149	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  0014c	2d 9c 00 00 00	 sub	 eax, 156		; 0000009cH
  00151	50		 push	 eax
  00152	53		 push	 ebx
  00153	e8 00 00 00 00	 call	 ??$destroy@USTerrainTexture@@@?$_Default_allocator_traits@V?$allocator@USTerrainTexture@@@std@@@std@@SAXAAV?$allocator@USTerrainTexture@@@1@QAUSTerrainTexture@@@Z ; std::_Default_allocator_traits<std::allocator<STerrainTexture> >::destroy<STerrainTexture>
  00158	83 c4 08	 add	 esp, 8
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 279  : 	return true;

  0015b	b0 01		 mov	 al, 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1763 :         --_Mylast;

  0015d	81 43 04 64 ff
	ff ff		 add	 DWORD PTR [ebx+4], -156	; ffffff64H
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 279  : 	return true;

  00164	5f		 pop	 edi
  00165	5b		 pop	 ebx

; 280  : }

  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c2 04 00	 ret	 4
?RemoveTexture@CTextureSet@@QAE_NK@Z ENDP		; CTextureSet::RemoveTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z
_TEXT	SEGMENT
_ulIndex$ = 8						; size = 4
?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z PROC ; CTextureSet::GetTexture, COMDAT
; _this$ = ecx

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 116  : 	if (GetTextureCount() <= ulIndex)

  00006	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _ulIndex$[ebp]
  0000e	3b c1		 cmp	 eax, ecx
  00010	77 08		 ja	 SHORT $LN2@GetTexture

; 117  : 		return m_ErrorTexture;

  00012	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00015	5e		 pop	 esi

; 120  : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@GetTexture:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0001a	69 c1 9c 00 00
	00		 imul	 eax, ecx, 156
  00020	03 46 04	 add	 eax, DWORD PTR [esi+4]
  00023	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 120  : }

  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z ENDP ; CTextureSet::GetTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?GetTextureCount@CTextureSet@@QAEKXZ
_TEXT	SEGMENT
?GetTextureCount@CTextureSet@@QAEKXZ PROC		; CTextureSet::GetTextureCount, COMDAT
; _this$ = ecx

; 110  : {

  00000	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00001	8b 71 08	 mov	 esi, DWORD PTR [ecx+8]
  00004	b8 d3 20 0d d2	 mov	 eax, -770891565		; d20d20d3H
  00009	2b 71 04	 sub	 esi, DWORD PTR [ecx+4]
  0000c	f7 ee		 imul	 esi
  0000e	03 d6		 add	 edx, esi
  00010	c1 fa 07	 sar	 edx, 7
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 111  : 	return m_Textures.size();

  0001a	5e		 pop	 esi

; 112  : }

  0001b	c3		 ret	 0
?GetTextureCount@CTextureSet@@QAEKXZ ENDP		; CTextureSet::GetTextureCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?Save@CTextureSet@@QAE_NPBD@Z
_TEXT	SEGMENT
tv278 = -4						; size = 4
_c_pszFileName$ = 8					; size = 4
_i$1$ = 8						; size = 4
?Save@CTextureSet@@QAE_NPBD@Z PROC			; CTextureSet::Save, COMDAT
; _this$ = ecx

; 283  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi

; 284  : 	FILE * pFile = fopen(c_pszFileName, "w");

  00006	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w@
  0000b	ff 75 08	 push	 DWORD PTR _c_pszFileName$[ebp]
  0000e	8b d9		 mov	 ebx, ecx
  00010	e8 00 00 00 00	 call	 _fopen
  00015	8b f8		 mov	 edi, eax
  00017	83 c4 08	 add	 esp, 8

; 285  : 
; 286  : 	if (!pFile)

  0001a	85 ff		 test	 edi, edi
  0001c	75 0a		 jne	 SHORT $LN5@Save

; 287  : 		return false;

  0001e	5f		 pop	 edi
  0001f	32 c0		 xor	 al, al

; 314  : }

  00021	5b		 pop	 ebx
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
$LN5@Save:

; 288  : 
; 289  : 	fprintf(pFile, "TextureSet\n");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0M@MPCHGPBP@TextureSet?6@
  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 _fprintf

; 290  : 	fprintf(pFile, "\n");

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00038	57		 push	 edi
  00039	e8 00 00 00 00	 call	 _fprintf
  0003e	83 c4 10	 add	 esp, 16			; 00000010H

; 291  : 
; 292  : 	// @fixme004
; 293  : 	fprintf(pFile, "TextureCount %ld\n", GetTextureCount()?(GetTextureCount() - 1):0);

  00041	8b cb		 mov	 ecx, ebx
  00043	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  00048	85 c0		 test	 eax, eax
  0004a	74 0a		 je	 SHORT $LN7@Save
  0004c	8b cb		 mov	 ecx, ebx
  0004e	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  00053	48		 dec	 eax
  00054	eb 02		 jmp	 SHORT $LN8@Save
$LN7@Save:
  00056	33 c0		 xor	 eax, eax
$LN8@Save:
  00058	50		 push	 eax
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GGJBGKJP@TextureCount?5?$CFld?6@
  0005e	57		 push	 edi
  0005f	e8 00 00 00 00	 call	 _fprintf

; 294  : 	fprintf(pFile, "\n");

  00064	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00069	57		 push	 edi
  0006a	e8 00 00 00 00	 call	 _fprintf
  0006f	83 c4 14	 add	 esp, 20			; 00000014H

; 295  : 
; 296  : 	for (DWORD i = 1; i < GetTextureCount(); ++i)

  00072	c7 45 08 01 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 1
  00079	8b cb		 mov	 ecx, ebx
  0007b	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  00080	83 f8 01	 cmp	 eax, 1
  00083	0f 86 01 01 00
	00		 jbe	 $LN3@Save

; 291  : 
; 292  : 	// @fixme004
; 293  : 	fprintf(pFile, "TextureCount %ld\n", GetTextureCount()?(GetTextureCount() - 1):0);

  00089	b8 9c 00 00 00	 mov	 eax, 156		; 0000009cH
  0008e	89 45 fc	 mov	 DWORD PTR tv278[ebp], eax
  00091	56		 push	 esi
$LL4@Save:

; 300  : 		fprintf(pFile, "Start Texture%03d\n", i);

  00092	ff 75 08	 push	 DWORD PTR _i$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00095	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 300  : 		fprintf(pFile, "Start Texture%03d\n", i);

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@BJELLKNB@Start?5Texture?$CF03d?6@
  0009d	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0009e	03 f0		 add	 esi, eax
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 300  : 		fprintf(pFile, "Start Texture%03d\n", i);

  000a0	e8 00 00 00 00	 call	 _fprintf
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  000a8	8b c6		 mov	 eax, esi

; 434  :         return _Myres > _Small_string_capacity;

  000aa	83 7e 14 0f	 cmp	 DWORD PTR [esi+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  000ae	76 02		 jbe	 SHORT $LN16@Save

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  000b0	8b 06		 mov	 eax, DWORD PTR [esi]
$LN16@Save:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 301  : 		fprintf(pFile, "    \"%s\"\n", rTex.stFilename.c_str());

  000b2	50		 push	 eax
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_09BMPLDMAP@?5?5?5?5?$CC?$CFs?$CC?6@
  000b8	57		 push	 edi
  000b9	e8 00 00 00 00	 call	 _fprintf
  000be	f3 0f 10 46 44	 movss	 xmm0, DWORD PTR [esi+68]

; 302  : 		fprintf(pFile, "    %f\n", rTex.UScale);

  000c3	83 c4 04	 add	 esp, 4
  000c6	0f 5a c0	 cvtps2pd xmm0, xmm0
  000c9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_07ELCCFBHK@?5?5?5?5?$CFf?6@
  000d3	57		 push	 edi
  000d4	e8 00 00 00 00	 call	 _fprintf
  000d9	f3 0f 10 46 48	 movss	 xmm0, DWORD PTR [esi+72]

; 303  : 		fprintf(pFile, "    %f\n", rTex.VScale);

  000de	83 c4 08	 add	 esp, 8
  000e1	0f 5a c0	 cvtps2pd xmm0, xmm0
  000e4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_07ELCCFBHK@?5?5?5?5?$CFf?6@
  000ee	57		 push	 edi
  000ef	e8 00 00 00 00	 call	 _fprintf
  000f4	f3 0f 10 46 4c	 movss	 xmm0, DWORD PTR [esi+76]

; 304  : 		fprintf(pFile, "    %f\n", rTex.UOffset);

  000f9	83 c4 08	 add	 esp, 8
  000fc	0f 5a c0	 cvtps2pd xmm0, xmm0
  000ff	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00104	68 00 00 00 00	 push	 OFFSET ??_C@_07ELCCFBHK@?5?5?5?5?$CFf?6@
  00109	57		 push	 edi
  0010a	e8 00 00 00 00	 call	 _fprintf
  0010f	f3 0f 10 46 50	 movss	 xmm0, DWORD PTR [esi+80]

; 305  : 		fprintf(pFile, "    %f\n", rTex.VOffset);

  00114	83 c4 08	 add	 esp, 8
  00117	0f 5a c0	 cvtps2pd xmm0, xmm0
  0011a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011f	68 00 00 00 00	 push	 OFFSET ??_C@_07ELCCFBHK@?5?5?5?5?$CFf?6@
  00124	57		 push	 edi
  00125	e8 00 00 00 00	 call	 _fprintf

; 306  : 		fprintf(pFile, "    %d\n", rTex.bSplat);

  0012a	0f b6 46 54	 movzx	 eax, BYTE PTR [esi+84]
  0012e	50		 push	 eax
  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_07EIKGIFBE@?5?5?5?5?$CFd?6@
  00134	57		 push	 edi
  00135	e8 00 00 00 00	 call	 _fprintf

; 307  : 		fprintf(pFile, "    %hu\n", rTex.Begin);

  0013a	0f b7 46 56	 movzx	 eax, WORD PTR [esi+86]
  0013e	50		 push	 eax
  0013f	68 00 00 00 00	 push	 OFFSET ??_C@_08PFAGAKKH@?5?5?5?5?$CFhu?6@
  00144	57		 push	 edi
  00145	e8 00 00 00 00	 call	 _fprintf

; 308  : 		fprintf(pFile, "    %hu\n", rTex.End);

  0014a	0f b7 46 58	 movzx	 eax, WORD PTR [esi+88]
  0014e	50		 push	 eax
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_08PFAGAKKH@?5?5?5?5?$CFhu?6@
  00154	57		 push	 edi
  00155	e8 00 00 00 00	 call	 _fprintf

; 309  : 		fprintf(pFile, "End Texture%03d\n", i);

  0015a	8b 75 08	 mov	 esi, DWORD PTR _i$1$[ebp]
  0015d	56		 push	 esi
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GNLMPHOK@End?5Texture?$CF03d?6@
  00163	57		 push	 edi
  00164	e8 00 00 00 00	 call	 _fprintf
  00169	81 45 fc 9c 00
	00 00		 add	 DWORD PTR tv278[ebp], 156 ; 0000009cH
  00170	83 c4 40	 add	 esp, 64			; 00000040H
  00173	46		 inc	 esi
  00174	8b cb		 mov	 ecx, ebx
  00176	89 75 08	 mov	 DWORD PTR _i$1$[ebp], esi
  00179	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  0017e	3b f0		 cmp	 esi, eax
  00180	8b 45 fc	 mov	 eax, DWORD PTR tv278[ebp]
  00183	0f 82 09 ff ff
	ff		 jb	 $LL4@Save

; 295  : 
; 296  : 	for (DWORD i = 1; i < GetTextureCount(); ++i)

  00189	5e		 pop	 esi
$LN3@Save:

; 310  : 	}
; 311  : 
; 312  : 	fclose(pFile);

  0018a	57		 push	 edi
  0018b	e8 00 00 00 00	 call	 _fclose
  00190	83 c4 04	 add	 esp, 4

; 313  : 	return true;

  00193	b0 01		 mov	 al, 1
  00195	5f		 pop	 edi

; 314  : }

  00196	5b		 pop	 ebx
  00197	8b e5		 mov	 esp, ebp
  00199	5d		 pop	 ebp
  0019a	c2 04 00	 ret	 4
?Save@CTextureSet@@QAE_NPBD@Z ENDP			; CTextureSet::Save
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?Load@CTextureSet@@QAE_NPBDM@Z
_TEXT	SEGMENT
__Loc$2 = -348						; size = 12
_lCount$1$ = -336					; size = 4
_fuScale$3 = -332					; size = 4
_fvScale$4 = -328					; size = 4
_fuOffset$5 = -324					; size = 4
_fvOffset$6 = -320					; size = 4
$T7 = -316						; size = 8
$T8 = -316						; size = 8
_bSplat$9 = -308					; size = 1
__Loc$10 = -304						; size = 12
__Loc$11 = -304						; size = 12
__Loc$12 = -304						; size = 12
__Loc$13 = -304						; size = 12
$T14 = -292						; size = 4
_i$1$ = -288						; size = 4
_this$GSCopy$1$ = -284					; size = 4
_stTokenVectorMap$ = -280				; size = 8
$T15 = -269						; size = 1
$T16 = -269						; size = 1
_$S2$17 = -268						; size = 24
_$S3$18 = -244						; size = 24
_$S4$19 = -220						; size = 24
_$S5$20 = -196						; size = 24
_$S6$21 = -172						; size = 24
_$S7$22 = -148						; size = 24
_$S8$23 = -124						; size = 24
$T24 = -100						; size = 24
$T25 = -100						; size = 24
_$S1$26 = -100						; size = 24
$T27 = -76						; size = 24
$T28 = -76						; size = 24
$T29 = -76						; size = 24
_szTextureName$ = -52					; size = 33
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szTextureSetFileName$ = 8				; size = 4
_fTerrainTexCoordBase$ = 12				; size = 4
?Load@CTextureSet@@QAE_NPBDM@Z PROC			; CTextureSet::Load, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Load@CTextureSet@@QAE_NPBDM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b c1		 mov	 eax, ecx
  0002f	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax
  00035	8b 75 08	 mov	 esi, DWORD PTR _c_szTextureSetFileName$[ebp]
  00038	89 b5 dc fe ff
	ff		 mov	 DWORD PTR $T14[ebp], esi

; 27   : 	Clear();

  0003e	e8 00 00 00 00	 call	 ?Clear@CTextureSet@@QAEXXZ ; CTextureSet::Clear
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 136  :         return ::operator new(_Bytes);

  00043	6a 34		 push	 52			; 00000034H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 450  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00045	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVectorMap$[ebp], 0
  0004f	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVectorMap$[ebp+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 136  :         return ::operator new(_Bytes);

  00059	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 346  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0005e	89 00		 mov	 DWORD PTR [eax], eax

; 347  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00060	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 348  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  00063	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 349  :         _Pnode->_Color = _Black;

  00066	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1947 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  0006c	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _stTokenVectorMap$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 31   : 	if (!LoadMultipleTextData(c_szTextureSetFileName, stTokenVectorMap))

  00072	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  00078	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0007f	50		 push	 eax
  00080	56		 push	 esi
  00081	e8 00 00 00 00	 call	 ?LoadMultipleTextData@@YA_NPBDAAV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@@Z ; LoadMultipleTextData
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	84 c0		 test	 al, al
  0008b	75 0a		 jne	 SHORT $LN5@Load

; 32   : 	{
; 33   : 		TraceError("TextureSet::Load : cannot load %s", c_szTextureSetFileName);

  0008d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0CC@NFEEIIKK@TextureSet?3?3Load?5?3?5cannot?5load?5@
  00092	e9 72 09 00 00	 jmp	 $LN28@Load
$LN5@Load:

; 37   : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("textureset"))

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FLIBEPMB@textureset@
  0009c	8d 4d 9c	 lea	 ecx, DWORD PTR $T24[ebp]
  0009f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1374 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  000a4	8d 45 9c	 lea	 eax, DWORD PTR $T24[ebp]
  000a7	50		 push	 eax
  000a8	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR __Loc$10[ebp]
  000ae	50		 push	 eax
  000af	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  000b5	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  000ba	8b b5 d8 fe ff
	ff		 mov	 esi, DWORD PTR __Loc$10[ebp+8]
  000c0	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _stTokenVectorMap$[ebp]
  000c6	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  000ca	75 14		 jne	 SHORT $LN183@Load
  000cc	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits

; 2412 :         return _Left < _Right;

  000cf	50		 push	 eax
  000d0	8d 45 9c	 lea	 eax, DWORD PTR $T24[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  000d9	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  000dc	84 c0		 test	 al, al
  000de	74 02		 je	 SHORT $LN182@Load
$LN183@Load:

; 1379 :         return _Get_scary()->_Myhead;

  000e0	8b f7		 mov	 esi, edi
$LN182@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000e2	8b 4d b0	 mov	 ecx, DWORD PTR $T24[ebp+20]
  000e5	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  000e8	76 2c		 jbe	 SHORT $LN236@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ea	8b 55 9c	 mov	 edx, DWORD PTR $T24[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000ed	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ee	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000f0	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f6	72 14		 jb	 SHORT $LN247@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f8	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000fb	83 c1 23	 add	 ecx, 35			; 00000023H
  000fe	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00100	83 c0 fc	 add	 eax, -4			; fffffffcH
  00103	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00106	0f 87 58 09 00
	00		 ja	 $LN766@Load
$LN247@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0010c	51		 push	 ecx
  0010d	52		 push	 edx
  0010e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00113	83 c4 08	 add	 esp, 8
$LN236@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 37   : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("textureset"))

  00116	3b fe		 cmp	 edi, esi
  00118	75 0a		 jne	 SHORT $LN6@Load

; 38   : 	{
; 39   : 		TraceError("TextureSet::Load : syntax error, TextureSet (filename: %s)", c_szTextureSetFileName);
; 40   : 		return false;

  0011a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DL@HIELGKBC@TextureSet?3?3Load?5?3?5syntax?5error@
  0011f	e9 df 08 00 00	 jmp	 $LN1147@Load
$LN6@Load:

; 43   : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("texturecount"))

  00124	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MMECMGAI@texturecount@
  00129	8d 4d 9c	 lea	 ecx, DWORD PTR $T25[ebp]
  0012c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1374 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00131	8d 45 9c	 lea	 eax, DWORD PTR $T25[ebp]
  00134	50		 push	 eax
  00135	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR __Loc$12[ebp]
  0013b	50		 push	 eax
  0013c	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00142	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00147	8b bd d8 fe ff
	ff		 mov	 edi, DWORD PTR __Loc$12[ebp+8]
  0014d	80 7f 0d 00	 cmp	 BYTE PTR [edi+13], 0
  00151	0f 85 9f 08 00
	00		 jne	 $LN922@Load
  00157	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits

; 2412 :         return _Left < _Right;

  0015a	50		 push	 eax
  0015b	8d 45 9c	 lea	 eax, DWORD PTR $T25[ebp]
  0015e	50		 push	 eax
  0015f	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  00164	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00167	84 c0		 test	 al, al
  00169	0f 85 87 08 00
	00		 jne	 $LN922@Load

; 37   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0016f	8b b5 e8 fe ff
	ff		 mov	 esi, DWORD PTR _stTokenVectorMap$[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 43   : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("texturecount"))

  00175	8d 4d 9c	 lea	 ecx, DWORD PTR $T25[ebp]
  00178	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0017d	3b f7		 cmp	 esi, edi
  0017f	0f 84 79 08 00
	00		 je	 $LN1141@Load

; 47   : 	}
; 48   : 
; 49   : 	Create();

  00185	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  0018b	8b cf		 mov	 ecx, edi
  0018d	e8 00 00 00 00	 call	 ?Create@CTextureSet@@QAEXXZ ; CTextureSet::Create

; 51   : 	const std::string & c_rstrCount = stTokenVectorMap["texturecount"][0];

  00192	68 00 00 00 00	 push	 OFFSET ??_C@_0N@MMECMGAI@texturecount@
  00197	8d 4d b4	 lea	 ecx, DWORD PTR $T29[ebp]
  0019a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 197  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

  0019f	8d 45 b4	 lea	 eax, DWORD PTR $T29[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 51   : 	const std::string & c_rstrCount = stTokenVectorMap["texturecount"][0];

  001a2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 197  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

  001a6	50		 push	 eax
  001a7	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR __Loc$11[ebp]
  001ad	50		 push	 eax
  001ae	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  001b4	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  001b9	8b b5 d8 fe ff
	ff		 mov	 esi, DWORD PTR __Loc$11[ebp+8]
  001bf	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  001c3	75 18		 jne	 SHORT $LN968@Load
  001c5	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits

; 2412 :         return _Left < _Right;

  001c8	50		 push	 eax
  001c9	8d 45 b4	 lea	 eax, DWORD PTR $T29[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  001d2	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  001d5	84 c0		 test	 al, al
  001d7	0f 84 b0 00 00
	00		 je	 $LN967@Load
$LN968@Load:

; 1638 :         if (max_size() == _Get_scary()->_Mysize) {

  001dd	81 bd ec fe ff
	ff c4 4e ec 04	 cmp	 DWORD PTR _stTokenVectorMap$[ebp+4], 82595524 ; 04ec4ec4H
  001e7	0f 84 7c 08 00
	00		 je	 $LN1130@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 205  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  001ed	8b b5 e8 fe ff
	ff		 mov	 esi, DWORD PTR _stTokenVectorMap$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1156 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  001f3	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  001f9	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax

; 136  :         return ::operator new(_Bytes);

  001ff	6a 34		 push	 52			; 00000034H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 798  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00201	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1163 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00205	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], 0

; 136  :         return ::operator new(_Bytes);

  0020f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00214	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 211  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00217	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 136  :         return ::operator new(_Bytes);

  0021d	83 c4 04	 add	 esp, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00220	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00224	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0022b	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00232	0f 10 45 b4	 movups	 xmm0, XMMWORD PTR $T29[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 211  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00236	50		 push	 eax
  00237	ff b5 d4 fe ff
	ff		 push	 DWORD PTR __Loc$11[ebp+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0023d	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  00241	f3 0f 7e 45 c4	 movq	 xmm0, QWORD PTR $T29[ebp+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 211  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00246	ff b5 d0 fe ff
	ff		 push	 DWORD PTR __Loc$11[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0024c	66 0f d6 40 20	 movq	 QWORD PTR [eax+32], xmm0

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

  00251	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T29[ebp+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  00258	c7 45 c8 0f 00
	00 00		 mov	 DWORD PTR $T29[ebp+20], 15 ; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  0025f	c6 45 b4 00	 mov	 BYTE PTR $T29[ebp], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00263	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  0026a	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00271	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 821  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00278	89 30		 mov	 DWORD PTR [eax], esi

; 822  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  0027a	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 823  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  0027d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 824  :         this->_Ptr->_Color = _Red;

  00280	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 211  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00286	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
  0028b	8b f0		 mov	 esi, eax
$LN967@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 51   : 	const std::string & c_rstrCount = stTokenVectorMap["texturecount"][0];

  0028d	8b 76 28	 mov	 esi, DWORD PTR [esi+40]
  00290	8d 4d b4	 lea	 ecx, DWORD PTR $T29[ebp]
  00293	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00297	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0029c	83 7e 14 0f	 cmp	 DWORD PTR [esi+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  002a0	76 02		 jbe	 SHORT $LN1123@Load

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  002a2	8b 36		 mov	 esi, DWORD PTR [esi]
$LN1123@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 53   : 	long lCount = atol(c_rstrCount.c_str());

  002a4	56		 push	 esi
  002a5	e8 00 00 00 00	 call	 _atol
  002aa	8b f0		 mov	 esi, eax
  002ac	83 c4 04	 add	 esp, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1615 :         _Resize(_Newsize, _Value_init_tag{});

  002af	8d 85 f3 fe ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 53   : 	long lCount = atol(c_rstrCount.c_str());

  002b5	89 b5 b0 fe ff
	ff		 mov	 DWORD PTR _lCount$1$[ebp], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1615 :         _Resize(_Newsize, _Value_init_tag{});

  002bb	50		 push	 eax
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 56   : 	m_Textures.resize(lCount + 1);

  002bc	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1615 :         _Resize(_Newsize, _Value_init_tag{});

  002bf	51		 push	 ecx
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 56   : 	m_Textures.resize(lCount + 1);

  002c0	8d 4f 04	 lea	 ecx, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1615 :         _Resize(_Newsize, _Value_init_tag{});

  002c3	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::_Resize<std::_Value_init_tag>
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 58   : 	for (long i = 0; i < lCount; ++i)

  002c8	33 c0		 xor	 eax, eax
  002ca	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  002d0	85 f6		 test	 esi, esi
  002d2	0f 8e f4 06 00
	00		 jle	 $LN1132@Load
$LL4@Load:

; 59   : 	{
; 60   : 		_snprintf(szTextureName, sizeof(szTextureName), "texture%03d", i + 1);

  002d8	40		 inc	 eax
  002d9	50		 push	 eax
  002da	68 00 00 00 00	 push	 OFFSET ??_C@_0M@NDPMIDHE@texture?$CF03d@
  002df	8d 45 cc	 lea	 eax, DWORD PTR _szTextureName$[ebp]
  002e2	6a 21		 push	 33			; 00000021H
  002e4	50		 push	 eax
  002e5	e8 00 00 00 00	 call	 __snprintf
  002ea	83 c4 10	 add	 esp, 16			; 00000010H

; 62   : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szTextureName))

  002ed	8d 45 cc	 lea	 eax, DWORD PTR _szTextureName$[ebp]
  002f0	8d 4d b4	 lea	 ecx, DWORD PTR $T28[ebp]
  002f3	50		 push	 eax
  002f4	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1374 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  002f9	8d 45 b4	 lea	 eax, DWORD PTR $T28[ebp]
  002fc	50		 push	 eax
  002fd	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR __Loc$2[ebp]
  00303	50		 push	 eax
  00304	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  0030a	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0030f	8b b5 ac fe ff
	ff		 mov	 esi, DWORD PTR __Loc$2[ebp+8]
  00315	8b bd e8 fe ff
	ff		 mov	 edi, DWORD PTR _stTokenVectorMap$[ebp]
  0031b	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0031f	75 14		 jne	 SHORT $LN105@Load
  00321	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits

; 2412 :         return _Left < _Right;

  00324	50		 push	 eax
  00325	8d 45 b4	 lea	 eax, DWORD PTR $T28[ebp]
  00328	50		 push	 eax
  00329	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0032e	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00331	84 c0		 test	 al, al
  00333	74 02		 je	 SHORT $LN104@Load
$LN105@Load:

; 1379 :         return _Get_scary()->_Myhead;

  00335	8b f7		 mov	 esi, edi
$LN104@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00337	8b 4d c8	 mov	 ecx, DWORD PTR $T28[ebp+20]
  0033a	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0033d	76 2c		 jbe	 SHORT $LN158@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0033f	8b 55 b4	 mov	 edx, DWORD PTR $T28[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00342	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00343	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00345	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0034b	72 14		 jb	 SHORT $LN169@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0034d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00350	83 c1 23	 add	 ecx, 35			; 00000023H
  00353	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00355	83 c0 fc	 add	 eax, -4			; fffffffcH
  00358	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0035b	0f 87 03 07 00
	00		 ja	 $LN766@Load
$LN169@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00361	51		 push	 ecx
  00362	52		 push	 edx
  00363	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00368	83 c4 08	 add	 esp, 8
$LN158@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 62   : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szTextureName))

  0036b	3b fe		 cmp	 edi, esi
  0036d	0f 84 3a 06 00
	00		 je	 $LN1144@Load

; 65   : 		const CTokenVector & rVector = stTokenVectorMap[szTextureName];

  00373	8d 45 cc	 lea	 eax, DWORD PTR _szTextureName$[ebp]
  00376	50		 push	 eax
  00377	8d 4d b4	 lea	 ecx, DWORD PTR $T27[ebp]
  0037a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 197  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

  0037f	8d 45 b4	 lea	 eax, DWORD PTR $T27[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 65   : 		const CTokenVector & rVector = stTokenVectorMap[szTextureName];

  00382	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 197  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

  00386	50		 push	 eax
  00387	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR __Loc$13[ebp]
  0038d	50		 push	 eax
  0038e	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00394	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00399	8b b5 d8 fe ff
	ff		 mov	 esi, DWORD PTR __Loc$13[ebp+8]
  0039f	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  003a3	75 18		 jne	 SHORT $LN592@Load
  003a5	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\type_traits

; 2412 :         return _Left < _Right;

  003a8	50		 push	 eax
  003a9	8d 45 b4	 lea	 eax, DWORD PTR $T27[ebp]
  003ac	50		 push	 eax
  003ad	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  003b2	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1614 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  003b5	84 c0		 test	 al, al
  003b7	0f 84 ba 00 00
	00		 je	 $LN591@Load
$LN592@Load:

; 1638 :         if (max_size() == _Get_scary()->_Mysize) {

  003bd	81 bd ec fe ff
	ff c4 4e ec 04	 cmp	 DWORD PTR _stTokenVectorMap$[ebp+4], 82595524 ; 04ec4ec4H
  003c7	0f 84 9c 06 00
	00		 je	 $LN1130@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 205  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  003cd	8b b5 e8 fe ff
	ff		 mov	 esi, DWORD PTR _stTokenVectorMap$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1156 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  003d3	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  003d9	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax

; 136  :         return ::operator new(_Bytes);

  003df	6a 34		 push	 52			; 00000034H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 798  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  003e1	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1163 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  003e5	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+4], 0

; 136  :         return ::operator new(_Bytes);

  003ef	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003f4	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

  003f7	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 136  :         return ::operator new(_Bytes);

  00401	83 c4 04	 add	 esp, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 211  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00404	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0040a	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  0040e	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00415	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0041c	0f 10 45 b4	 movups	 xmm0, XMMWORD PTR $T27[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 211  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00420	50		 push	 eax
  00421	ff b5 d4 fe ff
	ff		 push	 DWORD PTR __Loc$13[ebp+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00427	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  0042b	f3 0f 7e 45 c4	 movq	 xmm0, QWORD PTR $T27[ebp+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 211  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00430	ff b5 d0 fe ff
	ff		 push	 DWORD PTR __Loc$13[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00436	66 0f d6 40 20	 movq	 QWORD PTR [eax+32], xmm0

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

  0043b	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T27[ebp+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  00442	c7 45 c8 0f 00
	00 00		 mov	 DWORD PTR $T27[ebp+20], 15 ; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00449	c6 45 b4 00	 mov	 BYTE PTR $T27[ebp], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0044d	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  00454	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  0045b	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 821  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00462	89 30		 mov	 DWORD PTR [eax], esi

; 822  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00464	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 823  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  00467	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 824  :         this->_Ptr->_Color = _Red;

  0046a	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\map

; 211  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00470	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
  00475	8b f0		 mov	 esi, eax
$LN591@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00477	8b 4d c8	 mov	 ecx, DWORD PTR $T27[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 65   : 		const CTokenVector & rVector = stTokenVectorMap[szTextureName];

  0047a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0047e	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00481	76 2c		 jbe	 SHORT $LN758@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00483	8b 55 b4	 mov	 edx, DWORD PTR $T27[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00486	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00487	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00489	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0048f	72 14		 jb	 SHORT $LN769@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00491	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00494	83 c1 23	 add	 ecx, 35			; 00000023H
  00497	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00499	83 c0 fc	 add	 eax, -4			; fffffffcH
  0049c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0049f	0f 87 bf 05 00
	00		 ja	 $LN766@Load
$LN769@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  004a5	51		 push	 ecx
  004a6	52		 push	 edx
  004a7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004ac	83 c4 08	 add	 esp, 8
$LN758@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  004af	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T27[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  004b6	c7 45 c8 0f 00
	00 00		 mov	 DWORD PTR $T27[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  004bd	c6 45 b4 00	 mov	 BYTE PTR $T27[ebp], 0

; 2328 :         return _Mypair._Myval2._Myptr();

  004c1	8b 46 28	 mov	 eax, DWORD PTR [esi+40]

; 434  :         return _Myres > _Small_string_capacity;

  004c4	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  004c8	76 02		 jbe	 SHORT $LN782@Load

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  004ca	8b 00		 mov	 eax, DWORD PTR [eax]
$LN782@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 67   : 		const std::string & c_rstrFileName	= rVector[0].c_str();

  004cc	50		 push	 eax
  004cd	8d 4d 9c	 lea	 ecx, DWORD PTR _$S1$26[ebp]
  004d0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1929 :         return _My_data._Myfirst[_Pos];

  004d5	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  004d8	83 c0 18	 add	 eax, 24			; 00000018H
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 67   : 		const std::string & c_rstrFileName	= rVector[0].c_str();

  004db	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  004df	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  004e3	76 02		 jbe	 SHORT $LN795@Load

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  004e5	8b 00		 mov	 eax, DWORD PTR [eax]
$LN795@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 68   : 		const std::string & c_rstrUScale	= rVector[1].c_str();

  004e7	50		 push	 eax
  004e8	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _$S2$17[ebp]
  004ee	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1929 :         return _My_data._Myfirst[_Pos];

  004f3	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  004f6	83 c0 30	 add	 eax, 48			; 00000030H
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 68   : 		const std::string & c_rstrUScale	= rVector[1].c_str();

  004f9	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  004fd	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00501	76 02		 jbe	 SHORT $LN277@Load

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00503	8b 00		 mov	 eax, DWORD PTR [eax]
$LN277@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 69   : 		const std::string & c_rstrVScale	= rVector[2].c_str();

  00505	50		 push	 eax
  00506	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _$S3$18[ebp]
  0050c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1929 :         return _My_data._Myfirst[_Pos];

  00511	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00514	83 c0 48	 add	 eax, 72			; 00000048H
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 69   : 		const std::string & c_rstrVScale	= rVector[2].c_str();

  00517	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0051b	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0051f	76 02		 jbe	 SHORT $LN821@Load

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00521	8b 00		 mov	 eax, DWORD PTR [eax]
$LN821@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 70   : 		const std::string & c_rstrUOffset	= rVector[3].c_str();

  00523	50		 push	 eax
  00524	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _$S4$19[ebp]
  0052a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1929 :         return _My_data._Myfirst[_Pos];

  0052f	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00532	83 c0 60	 add	 eax, 96			; 00000060H
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 70   : 		const std::string & c_rstrUOffset	= rVector[3].c_str();

  00535	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00539	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0053d	76 02		 jbe	 SHORT $LN834@Load

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0053f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN834@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 71   : 		const std::string & c_rstrVOffset	= rVector[4].c_str();

  00541	50		 push	 eax
  00542	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _$S5$20[ebp]
  00548	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1929 :         return _My_data._Myfirst[_Pos];

  0054d	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  00550	83 c0 78	 add	 eax, 120		; 00000078H
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 71   : 		const std::string & c_rstrVOffset	= rVector[4].c_str();

  00553	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00557	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0055b	76 02		 jbe	 SHORT $LN847@Load

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0055d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN847@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 72   : 		const std::string & c_rstrbSplat	= rVector[5].c_str();

  0055f	50		 push	 eax
  00560	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _$S6$21[ebp]
  00566	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1929 :         return _My_data._Myfirst[_Pos];

  0056b	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0056e	05 90 00 00 00	 add	 eax, 144		; 00000090H
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 72   : 		const std::string & c_rstrbSplat	= rVector[5].c_str();

  00573	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00577	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0057b	76 02		 jbe	 SHORT $LN860@Load

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0057d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN860@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 73   : 		const std::string & c_rstrBegin		= rVector[6].c_str();

  0057f	50		 push	 eax
  00580	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _$S7$22[ebp]
  00586	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1929 :         return _My_data._Myfirst[_Pos];

  0058b	8b 46 28	 mov	 eax, DWORD PTR [esi+40]
  0058e	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 73   : 		const std::string & c_rstrBegin		= rVector[6].c_str();

  00593	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00597	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0059b	76 02		 jbe	 SHORT $LN873@Load

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0059d	8b 00		 mov	 eax, DWORD PTR [eax]
$LN873@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 74   : 		const std::string & c_rstrEnd		= rVector[7].c_str();

  0059f	50		 push	 eax
  005a0	8d 4d 84	 lea	 ecx, DWORD PTR _$S8$23[ebp]
  005a3	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  005a8	83 bd 08 ff ff
	ff 0f		 cmp	 DWORD PTR _$S2$17[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  005af	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _$S2$17[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 74   : 		const std::string & c_rstrEnd		= rVector[7].c_str();

  005b5	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  005b9	0f 47 85 f4 fe
	ff ff		 cmova	 eax, DWORD PTR _$S2$17[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 80   : 		fuScale	= atof(c_rstrUScale.c_str());

  005c0	50		 push	 eax
  005c1	e8 00 00 00 00	 call	 _atof
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  005c6	83 bd 20 ff ff
	ff 0f		 cmp	 DWORD PTR _$S3$18[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  005cd	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _$S3$18[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 80   : 		fuScale	= atof(c_rstrUScale.c_str());

  005d3	d9 9d b4 fe ff
	ff		 fstp	 DWORD PTR _fuScale$3[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  005d9	0f 47 85 0c ff
	ff ff		 cmova	 eax, DWORD PTR _$S3$18[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 81   : 		fvScale = atof(c_rstrVScale.c_str());

  005e0	50		 push	 eax
  005e1	e8 00 00 00 00	 call	 _atof
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  005e6	83 bd 38 ff ff
	ff 0f		 cmp	 DWORD PTR _$S4$19[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  005ed	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _$S4$19[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 81   : 		fvScale = atof(c_rstrVScale.c_str());

  005f3	d9 9d b8 fe ff
	ff		 fstp	 DWORD PTR _fvScale$4[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  005f9	0f 47 85 24 ff
	ff ff		 cmova	 eax, DWORD PTR _$S4$19[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 82   : 		fuOffset = atof(c_rstrUOffset.c_str());

  00600	50		 push	 eax
  00601	e8 00 00 00 00	 call	 _atof
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00606	83 bd 50 ff ff
	ff 0f		 cmp	 DWORD PTR _$S5$20[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  0060d	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _$S5$20[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 82   : 		fuOffset = atof(c_rstrUOffset.c_str());

  00613	d9 9d bc fe ff
	ff		 fstp	 DWORD PTR _fuOffset$5[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  00619	0f 47 85 3c ff
	ff ff		 cmova	 eax, DWORD PTR _$S5$20[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 83   : 		fvOffset = atof(c_rstrVOffset.c_str());

  00620	50		 push	 eax
  00621	e8 00 00 00 00	 call	 _atof
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00626	83 bd 68 ff ff
	ff 0f		 cmp	 DWORD PTR _$S6$21[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  0062d	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _$S6$21[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 83   : 		fvOffset = atof(c_rstrVOffset.c_str());

  00633	d9 9d c0 fe ff
	ff		 fstp	 DWORD PTR _fvOffset$6[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  00639	0f 47 85 54 ff
	ff ff		 cmova	 eax, DWORD PTR _$S6$21[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 84   : 		bSplat = 0 != atoi(c_rstrbSplat.c_str());

  00640	50		 push	 eax
  00641	e8 00 00 00 00	 call	 __atoi64
  00646	83 c4 14	 add	 esp, 20			; 00000014H
  00649	85 c0		 test	 eax, eax
  0064b	75 0a		 jne	 SHORT $LN1142@Load
  0064d	88 85 cc fe ff
	ff		 mov	 BYTE PTR _bSplat$9[ebp], al
  00653	85 d2		 test	 edx, edx
  00655	74 07		 je	 SHORT $LN12@Load
$LN1142@Load:
  00657	c6 85 cc fe ff
	ff 01		 mov	 BYTE PTR _bSplat$9[ebp], 1
$LN12@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0065e	83 7d 80 0f	 cmp	 DWORD PTR _$S7$22[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00662	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR _$S7$22[ebp]

; 426  :         if (_Large_mode_engaged()) {

  00668	0f 47 85 6c ff
	ff ff		 cmova	 eax, DWORD PTR _$S7$22[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 85   : 		usBegin = static_cast<unsigned short>(atoi(c_rstrBegin.c_str()));

  0066f	50		 push	 eax
  00670	e8 00 00 00 00	 call	 __atoi64
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00675	83 7d 98 0f	 cmp	 DWORD PTR _$S8$23[ebp+20], 15 ; 0000000fH
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 85   : 		usBegin = static_cast<unsigned short>(atoi(c_rstrBegin.c_str()));

  00679	0f b7 f0	 movzx	 esi, ax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  0067c	8d 45 84	 lea	 eax, DWORD PTR _$S8$23[ebp]

; 426  :         if (_Large_mode_engaged()) {

  0067f	0f 47 45 84	 cmova	 eax, DWORD PTR _$S8$23[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 86   : 		usEnd = static_cast<unsigned short>(atoi(c_rstrEnd.c_str()));

  00683	50		 push	 eax
  00684	e8 00 00 00 00	 call	 __atoi64
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00689	83 7d b0 0f	 cmp	 DWORD PTR _$S1$26[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  0068d	8d 4d 9c	 lea	 ecx, DWORD PTR _$S1$26[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 88   : 		if (!SetTexture(i + 1, c_rstrFileName.c_str(), fuScale, fvScale, fuOffset, fvOffset, bSplat, usBegin, usEnd, fTerrainTexCoordBase))

  00690	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fTerrainTexCoordBase$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  00695	0f 47 4d 9c	 cmova	 ecx, DWORD PTR _$S1$26[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 88   : 		if (!SetTexture(i + 1, c_rstrFileName.c_str(), fuScale, fvScale, fuOffset, fvOffset, bSplat, usBegin, usEnd, fTerrainTexCoordBase))

  00699	83 c4 04	 add	 esp, 4
  0069c	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  006a2	0f b7 c0	 movzx	 eax, ax
  006a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006aa	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _fvOffset$6[ebp]
  006b2	50		 push	 eax
  006b3	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  006b9	56		 push	 esi
  006ba	ff b5 cc fe ff
	ff		 push	 DWORD PTR _bSplat$9[ebp]
  006c0	40		 inc	 eax
  006c1	83 ec 10	 sub	 esp, 16			; 00000010H
  006c4	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  006ca	f3 0f 10 85 bc
	fe ff ff	 movss	 xmm0, DWORD PTR _fuOffset$5[ebp]
  006d2	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  006d8	f3 0f 10 85 b8
	fe ff ff	 movss	 xmm0, DWORD PTR _fvScale$4[ebp]
  006e0	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  006e6	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _fuScale$3[ebp]
  006ee	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006f3	51		 push	 ecx
  006f4	50		 push	 eax
  006f5	8b cf		 mov	 ecx, edi
  006f7	e8 00 00 00 00	 call	 ?SetTexture@CTextureSet@@QAE_NKPBDMMMM_NGGM@Z ; CTextureSet::SetTexture
  006fc	84 c0		 test	 al, al
  006fe	75 19		 jne	 SHORT $LN9@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00700	83 7d b0 0f	 cmp	 DWORD PTR _$S1$26[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00704	8d 45 9c	 lea	 eax, DWORD PTR _$S1$26[ebp]

; 426  :         if (_Large_mode_engaged()) {

  00707	0f 47 45 9c	 cmova	 eax, DWORD PTR _$S1$26[ebp]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 89   : 			TraceError("CTextureSet::Load : SetTexture failed : Filename: %s", c_rstrFileName.c_str());

  0070b	50		 push	 eax
  0070c	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@CFOIFDDM@CTextureSet?3?3Load?5?3?5SetTexture?5@
  00711	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00716	83 c4 08	 add	 esp, 8
$LN9@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00719	8b 4d 98	 mov	 ecx, DWORD PTR _$S8$23[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 90   : 	}

  0071c	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00720	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00723	76 2c		 jbe	 SHORT $LN313@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00725	8b 55 84	 mov	 edx, DWORD PTR _$S8$23[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00728	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00729	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0072b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00731	72 14		 jb	 SHORT $LN324@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00733	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00736	83 c1 23	 add	 ecx, 35			; 00000023H
  00739	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0073b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0073e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00741	0f 87 1d 03 00
	00		 ja	 $LN766@Load
$LN324@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00747	51		 push	 ecx
  00748	52		 push	 edx
  00749	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0074e	83 c4 08	 add	 esp, 8
$LN313@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00751	8b 4d 80	 mov	 ecx, DWORD PTR _$S7$22[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  00754	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _$S8$23[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  0075b	c7 45 98 0f 00
	00 00		 mov	 DWORD PTR _$S8$23[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00762	c6 45 84 00	 mov	 BYTE PTR _$S8$23[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 90   : 	}

  00766	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0076a	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0076d	76 2f		 jbe	 SHORT $LN572@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0076f	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR _$S7$22[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00775	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00776	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00778	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0077e	72 14		 jb	 SHORT $LN583@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00780	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00783	83 c1 23	 add	 ecx, 35			; 00000023H
  00786	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00788	83 c0 fc	 add	 eax, -4			; fffffffcH
  0078b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0078e	0f 87 d0 02 00
	00		 ja	 $LN766@Load
$LN583@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00794	51		 push	 ecx
  00795	52		 push	 edx
  00796	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0079b	83 c4 08	 add	 esp, 8
$LN572@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0079e	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _$S6$21[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  007a4	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S7$22[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  007ae	c7 45 80 0f 00
	00 00		 mov	 DWORD PTR _$S7$22[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  007b5	c6 85 6c ff ff
	ff 00		 mov	 BYTE PTR _$S7$22[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 90   : 	}

  007bc	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  007c0	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  007c3	76 2f		 jbe	 SHORT $LN350@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007c5	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _$S6$21[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  007cb	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007cc	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  007ce	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  007d4	72 14		 jb	 SHORT $LN361@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  007d6	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  007d9	83 c1 23	 add	 ecx, 35			; 00000023H
  007dc	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  007de	83 c0 fc	 add	 eax, -4			; fffffffcH
  007e1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  007e4	0f 87 7a 02 00
	00		 ja	 $LN766@Load
$LN361@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  007ea	51		 push	 ecx
  007eb	52		 push	 edx
  007ec	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  007f1	83 c4 08	 add	 esp, 8
$LN350@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  007f4	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _$S5$20[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  007fa	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S6$21[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00804	c7 85 68 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S6$21[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0080e	c6 85 54 ff ff
	ff 00		 mov	 BYTE PTR _$S6$21[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 90   : 	}

  00815	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00819	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0081c	76 2f		 jbe	 SHORT $LN387@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0081e	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR _$S5$20[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00824	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00825	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00827	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0082d	72 14		 jb	 SHORT $LN398@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0082f	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00832	83 c1 23	 add	 ecx, 35			; 00000023H
  00835	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00837	83 c0 fc	 add	 eax, -4			; fffffffcH
  0083a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0083d	0f 87 21 02 00
	00		 ja	 $LN766@Load
$LN398@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00843	51		 push	 ecx
  00844	52		 push	 edx
  00845	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0084a	83 c4 08	 add	 esp, 8
$LN387@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0084d	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR _$S4$19[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  00853	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S5$20[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  0085d	c7 85 50 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S5$20[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00867	c6 85 3c ff ff
	ff 00		 mov	 BYTE PTR _$S5$20[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 90   : 	}

  0086e	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00872	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00875	76 2f		 jbe	 SHORT $LN424@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00877	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _$S4$19[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0087d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0087e	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00880	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00886	72 14		 jb	 SHORT $LN435@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00888	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0088b	83 c1 23	 add	 ecx, 35			; 00000023H
  0088e	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00890	83 c0 fc	 add	 eax, -4			; fffffffcH
  00893	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00896	0f 87 c8 01 00
	00		 ja	 $LN766@Load
$LN435@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0089c	51		 push	 ecx
  0089d	52		 push	 edx
  0089e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008a3	83 c4 08	 add	 esp, 8
$LN424@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  008a6	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR _$S3$18[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  008ac	c7 85 34 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S4$19[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  008b6	c7 85 38 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S4$19[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  008c0	c6 85 24 ff ff
	ff 00		 mov	 BYTE PTR _$S4$19[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 90   : 	}

  008c7	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  008cb	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  008ce	76 2f		 jbe	 SHORT $LN461@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008d0	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR _$S3$18[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  008d6	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008d7	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  008d9	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  008df	72 14		 jb	 SHORT $LN472@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  008e1	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  008e4	83 c1 23	 add	 ecx, 35			; 00000023H
  008e7	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  008e9	83 c0 fc	 add	 eax, -4			; fffffffcH
  008ec	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008ef	0f 87 6f 01 00
	00		 ja	 $LN766@Load
$LN472@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  008f5	51		 push	 ecx
  008f6	52		 push	 edx
  008f7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008fc	83 c4 08	 add	 esp, 8
$LN461@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  008ff	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR _$S2$17[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  00905	c7 85 1c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S3$18[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  0090f	c7 85 20 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S3$18[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00919	c6 85 0c ff ff
	ff 00		 mov	 BYTE PTR _$S3$18[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 90   : 	}

  00920	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00924	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00927	76 2f		 jbe	 SHORT $LN498@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00929	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR _$S2$17[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0092f	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00930	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00932	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00938	72 14		 jb	 SHORT $LN509@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0093a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0093d	83 c1 23	 add	 ecx, 35			; 00000023H
  00940	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00942	83 c0 fc	 add	 eax, -4			; fffffffcH
  00945	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00948	0f 87 16 01 00
	00		 ja	 $LN766@Load
$LN509@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0094e	51		 push	 ecx
  0094f	52		 push	 edx
  00950	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00955	83 c4 08	 add	 esp, 8
$LN498@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00958	8b 4d b0	 mov	 ecx, DWORD PTR _$S1$26[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  0095b	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S2$17[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00965	c7 85 08 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S2$17[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0096f	c6 85 f4 fe ff
	ff 00		 mov	 BYTE PTR _$S2$17[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 90   : 	}

  00976	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0097a	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0097d	76 34		 jbe	 SHORT $LN2@Load
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0097f	8b 55 9c	 mov	 edx, DWORD PTR _$S1$26[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00982	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00983	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00985	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0098b	72 14		 jb	 SHORT $LN546@Load

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0098d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00990	83 c1 23	 add	 ecx, 35			; 00000023H
  00993	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00995	83 c0 fc	 add	 eax, -4			; fffffffcH
  00998	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0099b	0f 87 c3 00 00
	00		 ja	 $LN766@Load
$LN546@Load:

; 289  :         ::operator delete(_Ptr, _Bytes);

  009a1	51		 push	 ecx
  009a2	52		 push	 edx
  009a3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009a8	83 c4 08	 add	 esp, 8
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 62   : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szTextureName))

  009ab	eb 06		 jmp	 SHORT $LN2@Load
$LN1144@Load:
  009ad	8b bd e4 fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN2@Load:

; 58   : 	for (long i = 0; i < lCount; ++i)

  009b3	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  009b9	40		 inc	 eax
  009ba	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  009c0	3b 85 b0 fe ff
	ff		 cmp	 eax, DWORD PTR _lCount$1$[ebp]
  009c6	0f 8c 0c f9 ff
	ff		 jl	 $LL4@Load
$LN1132@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  009cc	8b b5 dc fe ff
	ff		 mov	 esi, DWORD PTR $T14[ebp]
  009d2	8b ce		 mov	 ecx, esi
  009d4	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL1143@Load:
  009d7	8a 01		 mov	 al, BYTE PTR [ecx]
  009d9	41		 inc	 ecx
  009da	84 c0		 test	 al, al
  009dc	75 f9		 jne	 SHORT $LL1143@Load
  009de	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  009e0	51		 push	 ecx
  009e1	56		 push	 esi
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 92   : 	m_stFileName.assign(c_szTextureSetFileName);

  009e2	8d 8f ac 00 00
	00		 lea	 ecx, DWORD PTR [edi+172]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  009e8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 93   : 	return true;

  009ed	c6 85 f3 fe ff
	ff 01		 mov	 BYTE PTR $T16[ebp], 1
  009f4	eb 24		 jmp	 SHORT $LN29@Load
$LN922@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 1379 :         return _Get_scary()->_Myhead;

  009f6	8d 4d 9c	 lea	 ecx, DWORD PTR $T25[ebp]
  009f9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1141@Load:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 46   : 		return false;

  009fe	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DN@FCLAEMJC@TextureSet?3?3Load?5?3?5syntax?5error@
$LN1147@Load:
  00a03	8b b5 dc fe ff
	ff		 mov	 esi, DWORD PTR $T14[ebp]
$LN28@Load:
  00a09	56		 push	 esi
  00a0a	50		 push	 eax
  00a0b	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00a10	83 c4 08	 add	 esp, 8
  00a13	c6 85 f3 fe ff
	ff 00		 mov	 BYTE PTR $T16[ebp], 0
$LN29@Load:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree

; 767  :         _Erase_tree(_Al, _Myhead->_Parent);

  00a1a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  00a20	ff 70 04	 push	 DWORD PTR [eax+4]
  00a23	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  00a29	50		 push	 eax
  00a2a	8b c8		 mov	 ecx, eax
  00a2c	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00a31	6a 34		 push	 52			; 00000034H
  00a33	ff b5 e8 fe ff
	ff		 push	 DWORD PTR _stTokenVectorMap$[ebp]
  00a39	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 93   : 	return true;

  00a3e	8a 85 f3 fe ff
	ff		 mov	 al, BYTE PTR $T16[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00a44	83 c4 08	 add	 esp, 8
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 94   : }

  00a47	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00a4a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00a51	59		 pop	 ecx
  00a52	5f		 pop	 edi
  00a53	5e		 pop	 esi
  00a54	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a57	33 cd		 xor	 ecx, ebp
  00a59	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a5e	8b e5		 mov	 esp, ebp
  00a60	5d		 pop	 ebp
  00a61	c2 08 00	 ret	 8
$LN766@Load:
  00a64	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1130@Load:
  00a69	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN1146@Load:
  00a6e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$0:
  00000	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$3:
  0000b	8d 4d b4	 lea	 ecx, DWORD PTR $T29[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$37:
  00013	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$5:
  0001e	8d 4d b4	 lea	 ecx, DWORD PTR $T27[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$28:
  00026	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$6:
  00031	8d 4d 9c	 lea	 ecx, DWORD PTR _$S1$26[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$7:
  00039	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _$S2$17[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$8:
  00044	8d 8d 0c ff ff
	ff		 lea	 ecx, DWORD PTR _$S3$18[ebp]
  0004a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$9:
  0004f	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _$S4$19[ebp]
  00055	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$10:
  0005a	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _$S5$20[ebp]
  00060	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$11:
  00065	8d 8d 54 ff ff
	ff		 lea	 ecx, DWORD PTR _$S6$21[ebp]
  0006b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$12:
  00070	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR _$S7$22[ebp]
  00076	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CTextureSet@@QAE_NPBDM@Z$13:
  0007b	8d 4d 84	 lea	 ecx, DWORD PTR _$S8$23[ebp]
  0007e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
__ehhandler$?Load@CTextureSet@@QAE_NPBDM@Z:
  00088	90		 npad	 1
  00089	90		 npad	 1
  0008a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0008e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00091	8b 8a a4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-348]
  00097	33 c8		 xor	 ecx, eax
  00099	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000a1	33 c8		 xor	 ecx, eax
  000a3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a8	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CTextureSet@@QAE_NPBDM@Z
  000ad	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CTextureSet@@QAE_NPBDM@Z ENDP			; CTextureSet::Load
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?Create@CTextureSet@@QAEXXZ
_TEXT	SEGMENT
?Create@CTextureSet@@QAEXXZ PROC			; CTextureSet::Create, COMDAT
; _this$ = ecx

; 19   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 20   : 	CResource * pResource = CResourceManager::Instance().GetResourcePointer("d:/ymir work/special/error.tga");

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PGALBFBK@d?3?1ymir?5work?1special?1error?4tga@
  0000e	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer

; 21   : 	m_ErrorTexture.ImageInstance.SetImagePointer(static_cast<CGraphicImage *> (pResource));

  00013	50		 push	 eax
  00014	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00017	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 22   : 	AddEmptyTexture();

  0001c	8b ce		 mov	 ecx, esi
  0001e	5e		 pop	 esi
  0001f	e9 00 00 00 00	 jmp	 ?AddEmptyTexture@CTextureSet@@IAEXXZ ; CTextureSet::AddEmptyTexture
?Create@CTextureSet@@QAEXXZ ENDP			; CTextureSet::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?Clear@CTextureSet@@QAEXXZ
_TEXT	SEGMENT
?Clear@CTextureSet@@QAEXXZ PROC				; CTextureSet::Clear, COMDAT
; _this$ = ecx

; 97   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 98   : 	m_ErrorTexture.ImageInstance.Destroy();

  00003	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
  00006	e8 00 00 00 00	 call	 ?Destroy@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Destroy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 99   : 	m_Textures.clear();

  0000e	83 c6 04	 add	 esi, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00011	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00014	3b c1		 cmp	 eax, ecx
  00016	74 10		 je	 SHORT $LN3@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  00018	56		 push	 esi
  00019	51		 push	 ecx
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USTerrainTexture@@@std@@@std@@YAXPAUSTerrainTexture@@QAU1@AAV?$allocator@USTerrainTexture@@@0@@Z ; std::_Destroy_range<std::allocator<STerrainTexture> >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00020	8b 06		 mov	 eax, DWORD PTR [esi]
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH
  00025	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN3@Clear:
  00028	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 101  : }

  00029	c3		 ret	 0
?Clear@CTextureSet@@QAEXXZ ENDP				; CTextureSet::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ?Initialize@CTextureSet@@QAEXXZ
_TEXT	SEGMENT
?Initialize@CTextureSet@@QAEXXZ PROC			; CTextureSet::Initialize, COMDAT
; _this$ = ecx

; 16   : }

  00000	c2 00 00	 ret	 0
?Initialize@CTextureSet@@QAEXXZ ENDP			; CTextureSet::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ??1CTextureSet@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CTextureSet@@UAE@XZ PROC				; CTextureSet::~CTextureSet, COMDAT
; _this$ = ecx

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CTextureSet@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CTextureSet@@6B@

; 11   : 	Clear();

  0002b	e8 00 00 00 00	 call	 ?Clear@CTextureSet@@QAEXXZ ; CTextureSet::Clear
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00030	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [esi+192]
  00036	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00039	76 2f		 jbe	 SHORT $LN24@CTextureSe
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003b	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00041	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00042	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00048	72 16		 jb	 SHORT $LN35@CTextureSe

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0004a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0004d	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00050	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00052	83 c0 fc	 add	 eax, -4			; fffffffcH
  00055	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00058	0f 87 89 00 00
	00		 ja	 $LN75@CTextureSe

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0005e	8b c2		 mov	 eax, edx
$LN35@CTextureSe:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00060	51		 push	 ecx
  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00067	83 c4 08	 add	 esp, 8
$LN24@CTextureSe:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h

; 21   : 	}

  0006a	8d 4e 2c	 lea	 ecx, DWORD PTR [esi+44]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  0006d	c7 86 bc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+188], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00077	c7 86 c0 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+192], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00081	c6 86 ac 00 00
	00 00		 mov	 BYTE PTR [esi+172], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h

; 21   : 	}

  00088	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0008d	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  00090	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00093	76 28		 jbe	 SHORT $LN67@CTextureSe
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00095	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00098	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00099	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009f	72 12		 jb	 SHORT $LN78@CTextureSe

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000a1	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000a4	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000a7	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a9	83 c0 fc	 add	 eax, -4			; fffffffcH
  000ac	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000af	77 36		 ja	 SHORT $LN75@CTextureSe

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000b1	8b c2		 mov	 eax, edx
$LN78@CTextureSe:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b3	51		 push	 ecx
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ba	83 c4 08	 add	 esp, 8
$LN67@CTextureSe:
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 12   : }

  000bd	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  000c0	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  000c7	c7 46 24 0f 00
	00 00		 mov	 DWORD PTR [esi+36], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000ce	c6 46 10 00	 mov	 BYTE PTR [esi+16], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 12   : }

  000d2	e8 00 00 00 00	 call	 ??1?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::~vector<STerrainTexture,std::allocator<STerrainTexture> >
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e1	59		 pop	 ecx
  000e2	5e		 pop	 esi
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
$LN75@CTextureSe:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000e7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN86@CTextureSe:
  000ec	cc		 int	 3
  000ed	cc		 int	 3
  000ee	cc		 int	 3
  000ef	cc		 int	 3
  000f0	cc		 int	 3
  000f1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CTextureSet@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CTextureSet@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CTextureSet@@UAE@XZ ENDP				; CTextureSet::~CTextureSet
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp
;	COMDAT ??0CTextureSet@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CTextureSet@@QAE@XZ PROC				; CTextureSet::CTextureSet, COMDAT
; _this$ = ecx

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTextureSet@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CTextureSet@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00036	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0003d	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 5    : {

  00044	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0004e	e8 00 00 00 00	 call	 ??0STerrainTexture@@QAE@XZ ; STerrainTexture::STerrainTexture
  00053	0f 57 c0	 xorps	 xmm0, xmm0

; 7    : }

  00056	8b c6		 mov	 eax, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00058	0f 11 86 ac 00
	00 00		 movups	 XMMWORD PTR [esi+172], xmm0

; 836  :         _My_data._Mysize = 0;

  0005f	c7 86 bc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+188], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00069	c7 86 c0 00 00
	00 0f 00 00 00	 mov	 DWORD PTR [esi+192], 15	; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00073	c6 86 ac 00 00
	00 00		 mov	 BYTE PTR [esi+172], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.cpp

; 7    : }

  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00084	59		 pop	 ecx
  00085	5e		 pop	 esi
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTextureSet@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@USTerrainTexture@@V?$allocator@USTerrainTexture@@@std@@@std@@QAE@XZ ; std::vector<STerrainTexture,std::allocator<STerrainTexture> >::~vector<STerrainTexture,std::allocator<STerrainTexture> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0CTextureSet@@QAE@XZ:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CTextureSet@@QAE@XZ
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CTextureSet@@QAE@XZ ENDP				; CTextureSet::CTextureSet
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Ref.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0STerrainTexture@@QAE@ABU0@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Result$1$ = -20					; size = 4
__Count$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
_this$ = 8						; size = 4
??0STerrainTexture@@QAE@ABU0@@Z PROC			; STerrainTexture::STerrainTexture, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0STerrainTexture@@QAE@ABU0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f1		 mov	 esi, ecx
  00029	89 75 e8	 mov	 DWORD PTR _this$[ebp], esi

; 425  :         const value_type* _Result = _Bx._Buf;

  0002c	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  0002f	0f 57 c0	 xorps	 xmm0, xmm0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00032	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00035	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 425  :         const value_type* _Result = _Bx._Buf;

  0003c	8b cf		 mov	 ecx, edi

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0003e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 434  :         return _Myres > _Small_string_capacity;

  00045	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00049	89 7d ec	 mov	 DWORD PTR __Result$1$[ebp], edi

; 426  :         if (_Large_mode_engaged()) {

  0004c	76 05		 jbe	 SHORT $LN21@STerrainTe

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0004e	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00050	89 4d ec	 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN21@STerrainTe:

; 694  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00053	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00056	89 45 f0	 mov	 DWORD PTR __Count$1$[ebp], eax

; 857  :         if (_Count > max_size()) {

  00059	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0005e	0f 87 36 01 00
	00		 ja	 $LN72@STerrainTe

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();
; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

  00064	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00067	77 12		 ja	 SHORT $LN29@STerrainTe

; 866  :             _My_data._Mysize = _Count;

  00069	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 867  :             _My_data._Myres  = _Small_string_capacity;

  0006c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00073	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00076	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 884  :             return;

  00079	eb 67		 jmp	 SHORT $LN55@STerrainTe
$LN29@STerrainTe:

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  0007b	8b f8		 mov	 edi, eax
  0007d	83 cf 0f	 or	 edi, 15			; 0000000fH
  00080	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00086	76 12		 jbe	 SHORT $LN35@STerrainTe

; 2944 :             return _Max;

  00088	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0008d	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00092	51		 push	 ecx
  00093	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00098	eb 27		 jmp	 SHORT $LN70@STerrainTe
$LN35@STerrainTe:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0009a	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0009f	3b f9		 cmp	 edi, ecx
  000a1	0f 42 f9	 cmovb	 edi, ecx

; 801  :         ++_Capacity; // Take null terminator into consideration

  000a4	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  000a7	85 c9		 test	 ecx, ecx
  000a9	74 1e		 je	 SHORT $LN48@STerrainTe
$LN49@STerrainTe:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000ab	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000b1	72 08		 jb	 SHORT $LN50@STerrainTe

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000b9	eb 06		 jmp	 SHORT $LN70@STerrainTe
$LN50@STerrainTe:

; 136  :         return ::operator new(_Bytes);

  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN70@STerrainTe:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000c1	8b c8		 mov	 ecx, eax
  000c3	83 c4 04	 add	 esp, 4
  000c6	8b 45 f0	 mov	 eax, DWORD PTR __Count$1$[ebp]
$LN48@STerrainTe:

; 890  : 
; 891  :         _My_data._Mysize = _Count;

  000c9	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  000cc	40		 inc	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cd	50		 push	 eax
  000ce	ff 75 ec	 push	 DWORD PTR __Result$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000d1	89 0e		 mov	 DWORD PTR [esi], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d3	51		 push	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 892  :         _My_data._Myres  = _New_capacity;

  000d4	89 7e 14	 mov	 DWORD PTR [esi+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d7	e8 00 00 00 00	 call	 _memcpy
  000dc	8b 7d 08	 mov	 edi, DWORD PTR ___that$[ebp]
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN55@STerrainTe:
  000e2	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  000e5	8d 56 1c	 lea	 edx, DWORD PTR [esi+28]
  000e8	89 46 18	 mov	 DWORD PTR [esi+24], eax
  000eb	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7CGraphicImageInstance@@6B@
  000f1	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [edi+32]
  000f5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000fc	89 55 08	 mov	 DWORD PTR _this$[ebp], edx
  000ff	0f 11 42 04	 movups	 XMMWORD PTR [edx+4], xmm0
  00103	8b 47 30	 mov	 eax, DWORD PTR [edi+48]
  00106	8b 4f 34	 mov	 ecx, DWORD PTR [edi+52]
  00109	89 42 14	 mov	 DWORD PTR [edx+20], eax
  0010c	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  0010f	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
  00112	8b 47 38	 mov	 eax, DWORD PTR [edi+56]
  00115	89 42 1c	 mov	 DWORD PTR [edx+28], eax
  00118	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
; File C:\Marty 5.5\Src-Client\Client\eterLib\Ref.h

; 32   : 			m_pObject = NULL;

  0011b	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], 0

; 94   : 			m_pObject = pObject;

  00122	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
  00125	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 95   : 
; 96   : 			if (m_pObject)

  00128	85 c9		 test	 ecx, ecx
  0012a	74 05		 je	 SHORT $LN65@STerrainTe

; 97   : 				m_pObject->AddReference();

  0012c	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN65@STerrainTe:
  00131	8b 47 44	 mov	 eax, DWORD PTR [edi+68]
  00134	89 46 44	 mov	 DWORD PTR [esi+68], eax
  00137	8b 47 48	 mov	 eax, DWORD PTR [edi+72]
  0013a	89 46 48	 mov	 DWORD PTR [esi+72], eax
  0013d	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00140	89 46 4c	 mov	 DWORD PTR [esi+76], eax
  00143	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
  00146	89 46 50	 mov	 DWORD PTR [esi+80], eax
  00149	8a 47 54	 mov	 al, BYTE PTR [edi+84]
  0014c	88 46 54	 mov	 BYTE PTR [esi+84], al
  0014f	0f b7 47 56	 movzx	 eax, WORD PTR [edi+86]
  00153	66 89 46 56	 mov	 WORD PTR [esi+86], ax
  00157	0f b7 47 58	 movzx	 eax, WORD PTR [edi+88]
  0015b	66 89 46 58	 mov	 WORD PTR [esi+88], ax
  0015f	8b c6		 mov	 eax, esi
  00161	0f 10 47 5c	 movups	 xmm0, XMMWORD PTR [edi+92]
  00165	0f 11 46 5c	 movups	 XMMWORD PTR [esi+92], xmm0
  00169	0f 10 47 6c	 movups	 xmm0, XMMWORD PTR [edi+108]
  0016d	0f 11 46 6c	 movups	 XMMWORD PTR [esi+108], xmm0
  00171	0f 10 47 7c	 movups	 xmm0, XMMWORD PTR [edi+124]
  00175	0f 11 46 7c	 movups	 XMMWORD PTR [esi+124], xmm0
  00179	0f 10 87 8c 00
	00 00		 movups	 xmm0, XMMWORD PTR [edi+140]
  00180	0f 11 86 8c 00
	00 00		 movups	 XMMWORD PTR [esi+140], xmm0
  00187	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0018a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00191	59		 pop	 ecx
  00192	5f		 pop	 edi
  00193	5e		 pop	 esi
  00194	8b e5		 mov	 esp, ebp
  00196	5d		 pop	 ebp
  00197	c2 04 00	 ret	 4
$LN72@STerrainTe:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 858  :             _Xlen_string(); // result too long

  0019a	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN69@STerrainTe:
  0019f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0STerrainTexture@@QAE@ABU0@@Z$0:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0STerrainTexture@@QAE@ABU0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0STerrainTexture@@QAE@ABU0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0STerrainTexture@@QAE@ABU0@@Z ENDP			; STerrainTexture::STerrainTexture
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h
;	COMDAT ??1STerrainTexture@@QAE@XZ
_TEXT	SEGMENT
??1STerrainTexture@@QAE@XZ PROC				; STerrainTexture::~STerrainTexture, COMDAT
; _this$ = ecx

; 20   : 	{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 21   : 	}

  00003	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00006	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0000b	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000e	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00011	76 27		 jbe	 SHORT $LN24@STerrainTe
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00013	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00015	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00016	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001c	72 12		 jb	 SHORT $LN35@STerrainTe

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00021	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00024	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00026	83 c0 fc	 add	 eax, -4			; fffffffcH
  00029	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002c	77 1f		 ja	 SHORT $LN32@STerrainTe

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002e	8b c2		 mov	 eax, edx
$LN35@STerrainTe:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00030	51		 push	 ecx
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00037	83 c4 08	 add	 esp, 8
$LN24@STerrainTe:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  0003a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00041	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00048	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004b	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h

; 21   : 	}

  0004c	c3		 ret	 0
$LN32@STerrainTe:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN45@STerrainTe:
  00052	cc		 int	 3
??1STerrainTexture@@QAE@XZ ENDP				; STerrainTexture::~STerrainTexture
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h
;	COMDAT ??0STerrainTexture@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0STerrainTexture@@QAE@XZ PROC				; STerrainTexture::STerrainTexture, COMDAT
; _this$ = ecx

; 16   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0STerrainTexture@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0002c	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  0002f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00036	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 836  :         _My_data._Mysize = 0;

  0003d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00044	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004b	c6 06 00	 mov	 BYTE PTR [esi], 0
; File C:\Marty 5.5\Src-Client\Client\PRTerrainLib\TextureSet.h

; 16   : 	{

  0004e	8d 4e 1c	 lea	 ecx, DWORD PTR [esi+28]
  00051	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00058	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0005f	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  00064	33 c0		 xor	 eax, eax
  00066	c7 46 44 00 00
	80 40		 mov	 DWORD PTR [esi+68], 1082130432 ; 40800000H
  0006d	89 46 56	 mov	 DWORD PTR [esi+86], eax

; 17   : 	}

  00070	8b c6		 mov	 eax, esi
  00072	c7 46 48 00 00
	80 40		 mov	 DWORD PTR [esi+72], 1082130432 ; 40800000H
  00079	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  00080	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0
  00087	c6 46 54 01	 mov	 BYTE PTR [esi+84], 1
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	5e		 pop	 esi
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0STerrainTexture@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0STerrainTexture@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0STerrainTexture@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0STerrainTexture@@QAE@XZ ENDP				; STerrainTexture::STerrainTexture
; Function compile flags: /Ogtp
;	COMDAT ??_GCGraphicImageInstance@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCGraphicImageInstance@@UAEPAXI@Z PROC		; CGraphicImageInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 28		 push	 40			; 00000028H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCGraphicImageInstance@@UAEPAXI@Z ENDP		; CGraphicImageInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z PROC ; std::_Traits_compare<std::char_traits<char> >, COMDAT

; 591  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 413  :         return _CSTD memcmp(_First1, _First2, _Count);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 591  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Left_size$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility

; 101  :     return _Right < _Left ? _Right : _Left;

  0000a	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 591  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  0000c	56		 push	 esi

; 413  :         return _CSTD memcmp(_First1, _First2, _Count);

  0000d	8b 75 10	 mov	 esi, DWORD PTR __Right$[ebp]

; 591  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00010	57		 push	 edi
  00011	8b 7d 14	 mov	 edi, DWORD PTR __Right_size$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility

; 101  :     return _Right < _Left ? _Right : _Left;

  00014	3b fb		 cmp	 edi, ebx
  00016	0f 42 cf	 cmovb	 ecx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 413  :         return _CSTD memcmp(_First1, _First2, _Count);

  00019	83 e9 04	 sub	 ecx, 4
  0001c	72 13		 jb	 SHORT $LN15@Traits_com
  0001e	66 90		 npad	 2
$LL16@Traits_com:
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	3b 06		 cmp	 eax, DWORD PTR [esi]
  00024	75 10		 jne	 SHORT $LN14@Traits_com
  00026	83 c2 04	 add	 edx, 4
  00029	83 c6 04	 add	 esi, 4
  0002c	83 e9 04	 sub	 ecx, 4
  0002f	73 ef		 jae	 SHORT $LL16@Traits_com
$LN15@Traits_com:
  00031	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00034	74 34		 je	 SHORT $LN13@Traits_com
$LN14@Traits_com:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	3a 06		 cmp	 al, BYTE PTR [esi]
  0003a	75 27		 jne	 SHORT $LN17@Traits_com
  0003c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0003f	74 29		 je	 SHORT $LN13@Traits_com
  00041	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00044	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00047	75 1a		 jne	 SHORT $LN17@Traits_com
  00049	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0004c	74 1c		 je	 SHORT $LN13@Traits_com
  0004e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00051	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00054	75 0d		 jne	 SHORT $LN17@Traits_com
  00056	83 f9 ff	 cmp	 ecx, -1
  00059	74 0f		 je	 SHORT $LN13@Traits_com
  0005b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0005e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00061	74 07		 je	 SHORT $LN13@Traits_com
$LN17@Traits_com:
  00063	1b c0		 sbb	 eax, eax
  00065	83 c8 01	 or	 eax, 1
  00068	eb 02		 jmp	 SHORT $LN18@Traits_com
$LN13@Traits_com:
  0006a	33 c0		 xor	 eax, eax
$LN18@Traits_com:

; 592  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 593  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));
; 594  : 
; 595  :     if (_Ans != 0) {

  0006c	85 c0		 test	 eax, eax
  0006e	75 10		 jne	 SHORT $LN1@Traits_com

; 596  :         return _Ans;
; 597  :     }
; 598  : 
; 599  :     if (_Left_size < _Right_size) {

  00070	3b fb		 cmp	 edi, ebx
  00072	76 08		 jbe	 SHORT $LN29@Traits_com

; 604  :         return 1;
; 605  :     }
; 606  : 
; 607  :     return 0;
; 608  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	83 c8 ff	 or	 eax, -1
  00079	5b		 pop	 ebx
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN29@Traits_com:

; 600  :         return -1;
; 601  :     }
; 602  : 
; 603  :     if (_Left_size > _Right_size) {

  0007c	1b c0		 sbb	 eax, eax
  0007e	f7 d8		 neg	 eax
$LN1@Traits_com:

; 604  :         return 1;
; 605  :     }
; 606  : 
; 607  :     return 0;
; 608  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ENDP ; std::_Traits_compare<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	0f 84 a6 00 00
	00		 je	 $LN5@vector
  0000e	53		 push	 ebx

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000f	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00012	3b f3		 cmp	 esi, ebx
  00014	74 47		 je	 SHORT $LN87@vector
$LL11@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00016	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00019	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0001c	76 27		 jbe	 SHORT $LN40@vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00020	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00021	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00027	72 12		 jb	 SHORT $LN51@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00029	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00031	83 c0 fc	 add	 eax, -4			; fffffffcH
  00034	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00037	77 7e		 ja	 SHORT $LN74@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00039	8b c2		 mov	 eax, edx
$LN51@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00042	83 c4 08	 add	 esp, 8
$LN40@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00045	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  0004c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00053	c6 06 00	 mov	 BYTE PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00056	83 c6 18	 add	 esi, 24			; 00000018H
  00059	3b f3		 cmp	 esi, ebx
  0005b	75 b9		 jne	 SHORT $LL11@vector
$LN87@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0005d	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00060	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00065	8b 37		 mov	 esi, DWORD PTR [edi]
  00067	2b ce		 sub	 ecx, esi
  00069	f7 e9		 imul	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0006b	5b		 pop	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006c	c1 fa 02	 sar	 edx, 2
  0006f	8b c2		 mov	 eax, edx
  00071	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00074	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00076	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00079	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0007c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00082	72 12		 jb	 SHORT $LN77@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00084	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00087	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0008a	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0008c	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0008f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00092	77 23		 ja	 SHORT $LN74@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00094	8b f2		 mov	 esi, edx
$LN77@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00096	51		 push	 ecx
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0009d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000a3	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000a6	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 2082 :             _Myend   = nullptr;

  000ad	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN5@vector:
  000b4	5f		 pop	 edi

; 820  :     }

  000b5	5e		 pop	 esi
  000b6	c3		 ret	 0
$LN74@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN95@vector:
  000bc	cc		 int	 3
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 417  :     _Xlength_error("map/set too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Throw_tree:
  0000a	cc		 int	 3
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
$T1 = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1592 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1593 :         // assign [_Ptr, _Ptr + _Count)
; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 416  :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 434  :         return _Myres > _Small_string_capacity;

  00018	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 417  :         if (_Large_mode_engaged()) {

  0001b	76 02		 jbe	 SHORT $LN5@assign

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1597 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 1609 :             },
; 1610 :             _Ptr);
; 1611 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 2962 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 c7 00 00
	00		 ja	 $LN87@assign

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 12		 jbe	 SHORT $LN23@assign

; 2944 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	eb 45		 jmp	 SHORT $LN85@assign
$LN23@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00069	8b d1		 mov	 edx, ecx
  0006b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00070	d1 ea		 shr	 edx, 1
  00072	2b c2		 sub	 eax, edx
  00074	3b c8		 cmp	 ecx, eax
  00076	76 12		 jbe	 SHORT $LN24@assign

; 2948 :             return _Max;

  00078	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0007d	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00088	eb 24		 jmp	 SHORT $LN85@assign
$LN24@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0008a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0008d	3b f8		 cmp	 edi, eax
  0008f	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  00092	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  00095	85 c0		 test	 eax, eax
  00097	74 18		 je	 SHORT $LN84@assign
$LN37@assign:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00099	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0009e	72 08		 jb	 SHORT $LN38@assign

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a6	eb 06		 jmp	 SHORT $LN85@assign
$LN38@assign:

; 136  :         return ::operator new(_Bytes);

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN85@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000ae	83 c4 04	 add	 esp, 4
$LN84@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b1	53		 push	 ebx
  000b2	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000b5	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b8	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000b9	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  000bc	89 7e 14	 mov	 DWORD PTR [esi+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bf	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000c4	8b 7d 0c	 mov	 edi, DWORD PTR $T1[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  000ca	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000cd	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  000d1	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000d4	76 29		 jbe	 SHORT $LN16@assign

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000d6	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000db	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000e1	72 12		 jb	 SHORT $LN66@assign

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000e3	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000e6	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000e9	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000eb	83 c0 fc	 add	 eax, -4			; fffffffcH
  000ee	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f1	77 19		 ja	 SHORT $LN63@assign

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000f3	8b c2		 mov	 eax, edx
$LN66@assign:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000f5	51		 push	 ecx
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000fc	83 c4 08	 add	 esp, 8
$LN16@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1604 :         return _Reallocate_for(

  000ff	89 3e		 mov	 DWORD PTR [esi], edi

; 1609 :             },
; 1610 :             _Ptr);
; 1611 :     }

  00101	8b c6		 mov	 eax, esi
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 08 00	 ret	 8
$LN63@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN87@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2963 :             _Xlen_string(); // result too long

  00111	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN82@assign:
  00116	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 27		 jbe	 SHORT $LN19@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN30@basic_stri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN27@basic_stri

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN30@basic_stri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN19@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 1366 :     }

  00044	c3		 ret	 0
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 744  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b d9		 mov	 ebx, ecx
  00008	0f 57 c0	 xorps	 xmm0, xmm0
  0000b	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000c	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  0000f	8b f7		 mov	 esi, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00011	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00014	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001b	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00022	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL51@basic_stri:
  00025	8a 06		 mov	 al, BYTE PTR [esi]
  00027	46		 inc	 esi
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL51@basic_stri
  0002c	2b f1		 sub	 esi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 857  :         if (_Count > max_size()) {

  0002e	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00034	0f 87 9b 00 00
	00		 ja	 $LN62@basic_stri

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();
; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

  0003a	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0003d	77 24		 ja	 SHORT $LN21@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0003f	56		 push	 esi
  00040	57		 push	 edi
  00041	53		 push	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 866  :             _My_data._Mysize = _Count;

  00042	89 73 10	 mov	 DWORD PTR [ebx+16], esi

; 867  :             _My_data._Myres  = _Small_string_capacity;

  00045	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0004c	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00051	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 746  :     }

  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	8b c3		 mov	 eax, ebx
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN21@basic_stri:

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00063	8b fe		 mov	 edi, esi
  00065	83 cf 0f	 or	 edi, 15			; 0000000fH
  00068	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006e	76 12		 jbe	 SHORT $LN27@basic_stri

; 2944 :             return _Max;

  00070	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00075	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00080	eb 26		 jmp	 SHORT $LN60@basic_stri
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00082	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00087	3b f8		 cmp	 edi, eax
  00089	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0008c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  0008f	85 c0		 test	 eax, eax
  00091	74 18		 je	 SHORT $LN59@basic_stri
$LN41@basic_stri:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00093	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00098	72 08		 jb	 SHORT $LN42@basic_stri

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a0	eb 06		 jmp	 SHORT $LN60@basic_stri
$LN42@basic_stri:

; 136  :         return ::operator new(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN60@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000a8	83 c4 04	 add	 esp, 4
$LN59@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ab	56		 push	 esi
  000ac	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000af	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b2	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000b3	89 03		 mov	 DWORD PTR [ebx], eax

; 890  : 
; 891  :         _My_data._Mysize = _Count;

  000b5	89 73 10	 mov	 DWORD PTR [ebx+16], esi

; 892  :         _My_data._Myres  = _New_capacity;

  000b8	89 7b 14	 mov	 DWORD PTR [ebx+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bb	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000c0	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 746  :     }

  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	5f		 pop	 edi

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000c7	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 746  :     }

  000cb	8b c3		 mov	 eax, ebx
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 04 00	 ret	 4
$LN62@basic_stri:

; 858  :             _Xlen_string(); // result too long

  000d5	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN57@basic_stri:
  000da	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 512  :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1947 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);
; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1952 :         __crt_va_end(_ArgList);
; 1953 :         return _Result;
; 1954 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 837  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0000f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00014	ff 70 04	 push	 DWORD PTR [eax+4]
  00017	ff 30		 push	 DWORD PTR [eax]
  00019	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0001e	83 c4 18	 add	 esp, 24			; 00000018H

; 838  :         int _Result;
; 839  :         va_list _ArgList;
; 840  :         __crt_va_start(_ArgList, _Format);
; 841  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);
; 842  :         __crt_va_end(_ArgList);
; 843  :         return _Result;
; 844  :     }

  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
