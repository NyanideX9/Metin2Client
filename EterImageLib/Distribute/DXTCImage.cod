; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\eterImageLib\Distribute\DXTCImage.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CDXTCImage@@QAE@XZ				; CDXTCImage::CDXTCImage
PUBLIC	??1CDXTCImage@@UAE@XZ				; CDXTCImage::~CDXTCImage
PUBLIC	?Initialize@CDXTCImage@@QAEXXZ			; CDXTCImage::Initialize
PUBLIC	?Clear@CDXTCImage@@QAEXXZ			; CDXTCImage::Clear
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?LoadFromFile@CDXTCImage@@QAE_NPBD@Z		; CDXTCImage::LoadFromFile
PUBLIC	?LoadFromMemory@CDXTCImage@@QAE_NPBEI@Z		; CDXTCImage::LoadFromMemory
PUBLIC	?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBEI@Z	; CDXTCImage::LoadHeaderFromMemory
PUBLIC	?Copy@CDXTCImage@@QAE_NHPAEJ@Z			; CDXTCImage::Copy
PUBLIC	?Decompress@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::Decompress
PUBLIC	?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT1
PUBLIC	?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT3
PUBLIC	?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT5
PUBLIC	?DecompressARGB@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressARGB
PUBLIC	?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ; CDXTCImage::DecodePixelFormat
PUBLIC	?Unextract@CDXTCImage@@QAEXPAEHHH@Z		; CDXTCImage::Unextract
PUBLIC	??_GCDXTCImage@@UAEPAXI@Z			; CDXTCImage::`scalar deleting destructor'
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??$_Copy_memmove_tail@PAE@std@@YAPAEQBDQAEII@Z	; std::_Copy_memmove_tail<unsigned char *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_7CDXTCImage@@6B@				; CDXTCImage::`vftable'
PUBLIC	??_C@_04LFFPHNGG@?4DDS@				; `string'
PUBLIC	??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@ ; `string'
PUBLIC	??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@ ; `string'
PUBLIC	??_C@_07FBMAHCAD@?9premul@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@ ; `string'
PUBLIC	??_C@_04DHPPFAPI@DXT1@				; `string'
PUBLIC	??_C@_04BMNCADDL@DXT2@				; `string'
PUBLIC	??_C@_04FMJDCHK@DXT3@				; `string'
PUBLIC	??_C@_04EKIIKELN@DXT4@				; `string'
PUBLIC	??_C@_04FDJDJFPM@DXT5@				; `string'
PUBLIC	??_C@_0P@NBMDABNO@Format?5Unknown@		; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CDXTCImage@@6B@				; CDXTCImage::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDXTCImage@@@8				; CDXTCImage `RTTI Type Descriptor'
PUBLIC	??_R3CDXTCImage@@8				; CDXTCImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDXTCImage@@8				; CDXTCImage::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDXTCImage@@8			; CDXTCImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__xmm@00000006000000040000000200000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_strstr:PROC
EXTRN	_strncpy:PROC
EXTRN	__strupr:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Create@CMappedFile@@QAEHPBDPAPBXHH@Z:PROC	; CMappedFile::Create
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	?Tracef@@YAXPBDZZ:PROC				; Tracef
EXTRN	??_ECDXTCImage@@UAEPAXI@Z:PROC			; CDXTCImage::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
_BSS	SEGMENT
?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA DB 0105H DUP (?) ; `CDXTCImage::LoadFromFile'::`2'::fileupper
_BSS	ENDS
_BSS	SEGMENT
?gBits@@3PAY03EA DB 010H DUP (?)			; gBits
?gAlphas@@3PAGA DW 08H DUP (?)				; gAlphas
?gACol@@3PAY03UColor8888@@A DD 010H DUP (?)		; gACol
_BSS	ENDS
;	COMDAT __xmm@00000006000000040000000200000000
CONST	SEGMENT
__xmm@00000006000000040000000200000000 DB 00H, 00H, 00H, 00H, 02H, 00H, 00H
	DB	00H, 04H, 00H, 00H, 00H, 06H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CDXTCImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDXTCImage@@8 DD FLAT:??_R0?AVCDXTCImage@@@8 ; CDXTCImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R2CDXTCImage@@8
rdata$r	SEGMENT
??_R2CDXTCImage@@8 DD FLAT:??_R1A@?0A@EA@CDXTCImage@@8	; CDXTCImage::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDXTCImage@@8
rdata$r	SEGMENT
??_R3CDXTCImage@@8 DD 00H				; CDXTCImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDXTCImage@@@8
data$rs	SEGMENT
??_R0?AVCDXTCImage@@@8 DD FLAT:??_7type_info@@6B@	; CDXTCImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDXTCImage@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDXTCImage@@6B@
rdata$r	SEGMENT
??_R4CDXTCImage@@6B@ DD 00H				; CDXTCImage::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDXTCImage@@@8
	DD	FLAT:??_R3CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NBMDABNO@Format?5Unknown@
CONST	SEGMENT
??_C@_0P@NBMDABNO@Format?5Unknown@ DB 'Format Unknown', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FDJDJFPM@DXT5@
CONST	SEGMENT
??_C@_04FDJDJFPM@DXT5@ DB 'DXT5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKIIKELN@DXT4@
CONST	SEGMENT
??_C@_04EKIIKELN@DXT4@ DB 'DXT4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMJDCHK@DXT3@
CONST	SEGMENT
??_C@_04FMJDCHK@DXT3@ DB 'DXT3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BMNCADDL@DXT2@
CONST	SEGMENT
??_C@_04BMNCADDL@DXT2@ DB 'DXT2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DHPPFAPI@DXT1@
CONST	SEGMENT
??_C@_04DHPPFAPI@DXT1@ DB 'DXT1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@
CONST	SEGMENT
??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@ DB 'ARGB-%d%d%d%d%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBMAHCAD@?9premul@
CONST	SEGMENT
??_C@_07FBMAHCAD@?9premul@ DB '-premul', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@ DB 'Yo'
	DB	'ur logic is jacked! bits == 0x%x', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@
CONST	SEGMENT
??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@ DB 'Ca'
	DB	'n''t open file for reading! [%s]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@
CONST	SEGMENT
??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@ DB 'Unknown file f'
	DB	'ormat encountered! [%s]', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFFPHNGG@?4DDS@
CONST	SEGMENT
??_C@_04LFFPHNGG@?4DDS@ DB '.DDS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CDXTCImage@@6B@
CONST	SEGMENT
??_7CDXTCImage@@6B@ DD FLAT:??_R4CDXTCImage@@6B@	; CDXTCImage::`vftable'
	DD	FLAT:??_ECDXTCImage@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z$0
__ehfuncinfo$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CDXTCImage@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAE@std@@YAPAEQBDQAEII@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAE@std@@YAPAEQBDQAEII@Z PROC	; std::_Copy_memmove_tail<unsigned char *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAE@std@@YAPAEQBDQAEII@Z ENDP	; std::_Copy_memmove_tail<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  0000b	50		 push	 eax
  0000c	50		 push	 eax
  0000d	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAE@std@@YAPAEQBDQAEII@Z ; std::_Copy_memmove_tail<unsigned char *>
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 2032 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2033 :     char* const _First_ch = reinterpret_cast<char*>(_STD _To_address(_First));
; 2034 :     char* const _Last_ch  = reinterpret_cast<char*>(_STD _To_address(_Last));
; 2035 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 2036 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2037 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?GetNumberOfBits@@YAGK@Z
_TEXT	SEGMENT
_dwMask$ = 8						; size = 4
?GetNumberOfBits@@YAGK@Z PROC				; GetNumberOfBits, COMDAT

; 949  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 950  : 	WORD wBits;
; 951  :     for (wBits = 0; dwMask; wBits++)

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _dwMask$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	85 c9		 test	 ecx, ecx
  0000a	74 0c		 je	 SHORT $LN3@GetNumberO
  0000c	0f 1f 40 00	 npad	 4
$LL4@GetNumberO:

; 952  :         dwMask = (dwMask & (dwMask - 1));

  00010	8d 51 ff	 lea	 edx, DWORD PTR [ecx-1]
  00013	40		 inc	 eax
  00014	23 ca		 and	 ecx, edx
  00016	75 f8		 jne	 SHORT $LL4@GetNumberO
$LN3@GetNumberO:

; 953  : 
; 954  :     return wBits;
; 955  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?GetNumberOfBits@@YAGK@Z ENDP				; GetNumberOfBits
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCDXTCImage@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDXTCImage@@UAEPAXI@Z PROC				; CDXTCImage::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDXTCImage@@UAE@XZ	; CDXTCImage::~CDXTCImage
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN5@scalar
  00011	68 28 01 00 00	 push	 296			; 00000128H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCDXTCImage@@UAEPAXI@Z ENDP				; CDXTCImage::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Unextract@CDXTCImage@@QAEXPAEHHH@Z
_TEXT	SEGMENT
_xblocks$1$ = -4					; size = 4
_pbDest$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_iPitch$ = 20						; size = 4
_yblocks$1$ = 20					; size = 4
?Unextract@CDXTCImage@@QAEXPAEHHH@Z PROC		; CDXTCImage::Unextract, COMDAT
; _this$ = ecx

; 338  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	8b d9		 mov	 ebx, ecx
  00007	56		 push	 esi

; 339  : 	if (!m_pbCompBufferByLevels[0])

  00008	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]
  0000b	85 f6		 test	 esi, esi
  0000d	74 5a		 je	 SHORT $LN3@Unextract

; 340  : 		return;
; 341  : 
; 342  : 	DXTColBlock * pBlock;
; 343  : 	BYTE * pPos = (BYTE *) &m_pbCompBufferByLevels[0][0];
; 344  : 	int xblocks = m_nWidth / 4;

  0000f	57		 push	 edi
  00010	8b bb 00 01 00
	00		 mov	 edi, DWORD PTR [ebx+256]
  00016	8b c7		 mov	 eax, edi
  00018	99		 cdq
  00019	83 e2 03	 and	 edx, 3
  0001c	03 c2		 add	 eax, edx
  0001e	c1 f8 02	 sar	 eax, 2
  00021	89 45 fc	 mov	 DWORD PTR _xblocks$1$[ebp], eax

; 345  : 	int yblocks = (m_nHeight / 4) * ((iPitch / m_nWidth) / 2);

  00024	8b 45 14	 mov	 eax, DWORD PTR _iPitch$[ebp]
  00027	99		 cdq
  00028	f7 ff		 idiv	 edi
  0002a	99		 cdq
  0002b	2b c2		 sub	 eax, edx
  0002d	8b c8		 mov	 ecx, eax
  0002f	8b 83 04 01 00
	00		 mov	 eax, DWORD PTR [ebx+260]
  00035	99		 cdq
  00036	83 e2 03	 and	 edx, 3
  00039	d1 f9		 sar	 ecx, 1
  0003b	03 c2		 add	 eax, edx
  0003d	c1 f8 02	 sar	 eax, 2
  00040	0f af c8	 imul	 ecx, eax
  00043	89 4d 14	 mov	 DWORD PTR _yblocks$1$[ebp], ecx

; 346  : 
; 347  : 	for (int y = 0; y < yblocks; ++y)

  00046	85 c9		 test	 ecx, ecx
  00048	7e 1e		 jle	 SHORT $LN13@Unextract

; 340  : 		return;
; 341  : 
; 342  : 	DXTColBlock * pBlock;
; 343  : 	BYTE * pPos = (BYTE *) &m_pbCompBufferByLevels[0][0];
; 344  : 	int xblocks = m_nWidth / 4;

  0004a	8b 7d fc	 mov	 edi, DWORD PTR _xblocks$1$[ebp]
  0004d	8b 5d 08	 mov	 ebx, DWORD PTR _pbDest$[ebp]
  00050	c1 e7 03	 shl	 edi, 3
$LL4@Unextract:

; 348  : 	{
; 349  : 		pBlock = (DXTColBlock*) (pPos + y * xblocks * 8);
; 350  : 
; 351  : 		memcpy(pbDest, pBlock, xblocks * 8);

  00053	57		 push	 edi
  00054	56		 push	 esi
  00055	53		 push	 ebx
  00056	e8 00 00 00 00	 call	 _memcpy
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 352  : 		pbDest += xblocks * 8;

  0005e	03 df		 add	 ebx, edi
  00060	03 f7		 add	 esi, edi
  00062	83 6d 14 01	 sub	 DWORD PTR _yblocks$1$[ebp], 1
  00066	75 eb		 jne	 SHORT $LL4@Unextract
$LN13@Unextract:
  00068	5f		 pop	 edi
$LN3@Unextract:
  00069	5e		 pop	 esi

; 353  : 	}
; 354  : 
; 355  : 	/*
; 356  : 	for (int y = 0; y < iHeight; ++y)
; 357  : 	{
; 358  : 		memcpy(pbDest, &m_pbCompBufferByLevels[0][0] + y*iWidth, iWidth);
; 359  : 		pbDest += iWidth;
; 360  : 	}
; 361  : 	*/
; 362  : }

  0006a	5b		 pop	 ebx
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 10 00	 ret	 16			; 00000010H
?Unextract@CDXTCImage@@QAEXPAEHHH@Z ENDP		; CDXTCImage::Unextract
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z
_TEXT	SEGMENT
_strPixelFormat$ = 8					; size = 4
_pxddpf$ = 12						; size = 4
?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z PROC ; CDXTCImage::DecodePixelFormat, COMDAT
; _this$ = ecx

; 964  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 965  : 	switch (pxddpf->dwFourCC)

  00005	8b 7d 0c	 mov	 edi, DWORD PTR _pxddpf$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  0000d	3d 44 58 54 33	 cmp	 eax, 861165636		; 33545844H
  00012	0f 87 f5 00 00
	00		 ja	 $LN12@DecodePixe
  00018	0f 84 cd 00 00
	00		 je	 $LN7@DecodePixe
  0001e	85 c0		 test	 eax, eax
  00020	74 56		 je	 SHORT $LN4@DecodePixe
  00022	3d 44 58 54 31	 cmp	 eax, 827611204		; 31545844H
  00027	74 2d		 je	 SHORT $LN5@DecodePixe
  00029	3d 44 58 54 32	 cmp	 eax, 844388420		; 32545844H
  0002e	0f 85 e7 00 00
	00		 jne	 $LN10@DecodePixe

; 983  : 			m_CompFormat = PF_DXT1;
; 984  : 			break;
; 985  : 
; 986  : 		case MAKEFOURCC('D','X','T','2'):
; 987  : 			strncpy(strPixelFormat, "DXT2", 31);

  00034	6a 1f		 push	 31			; 0000001fH
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_04BMNCADDL@DXT2@
  0003b	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  0003e	e8 00 00 00 00	 call	 _strncpy

; 1009 : 			break;
; 1010 : 	}
; 1011 : }

  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	c7 86 ec 00 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+236], 2
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
$LN5@DecodePixe:

; 978  : 			}
; 979  : 			break;
; 980  : 
; 981  : 		case MAKEFOURCC('D','X','T','1'):
; 982  : 			strncpy(strPixelFormat, "DXT1", 31);

  00056	6a 1f		 push	 31			; 0000001fH
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_04DHPPFAPI@DXT1@
  0005d	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  00060	e8 00 00 00 00	 call	 _strncpy

; 1009 : 			break;
; 1010 : 	}
; 1011 : }

  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	c7 86 ec 00 00
	00 01 00 00 00	 mov	 DWORD PTR [esi+236], 1
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5d		 pop	 ebp
  00075	c2 08 00	 ret	 8
$LN4@DecodePixe:

; 966  : 	{
; 967  : 		case 0:
; 968  : 			{
; 969  : 				// This dds texture isn't compressed so write out ARGB format
; 970  : 				WORD a = GetNumberOfBits(pxddpf->dwRGBAlphaBitMask);
; 971  : 				WORD r = GetNumberOfBits(pxddpf->dwRBitMask);
; 972  : 				WORD g = GetNumberOfBits(pxddpf->dwGBitMask);
; 973  : 				WORD b = GetNumberOfBits(pxddpf->dwBBitMask);
; 974  : 
; 975  : 				_snprintf(strPixelFormat, 31, "ARGB-%d%d%d%d%s", a, r, g, b,

  00078	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  0007b	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_00CNPNBAHC@@
  00080	f7 c1 00 80 00
	00		 test	 ecx, 32768		; 00008000H
  00086	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07FBMAHCAD@?9premul@
  0008b	0f 44 c2	 cmove	 eax, edx
  0008e	50		 push	 eax
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  00095	83 c4 04	 add	 esp, 4
  00098	0f b7 c0	 movzx	 eax, ax
  0009b	50		 push	 eax
  0009c	ff 77 14	 push	 DWORD PTR [edi+20]
  0009f	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  000a4	83 c4 04	 add	 esp, 4
  000a7	0f b7 c0	 movzx	 eax, ax
  000aa	50		 push	 eax
  000ab	ff 77 10	 push	 DWORD PTR [edi+16]
  000ae	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  000b3	83 c4 04	 add	 esp, 4
  000b6	0f b7 c0	 movzx	 eax, ax
  000b9	50		 push	 eax
  000ba	ff 77 1c	 push	 DWORD PTR [edi+28]
  000bd	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  000c2	83 c4 04	 add	 esp, 4
  000c5	0f b7 c0	 movzx	 eax, ax
  000c8	50		 push	 eax
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@
  000ce	6a 1f		 push	 31			; 0000001fH
  000d0	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  000d3	e8 00 00 00 00	 call	 __snprintf
  000d8	83 c4 20	 add	 esp, 32			; 00000020H

; 976  : 					pxddpf->dwBBitMask & DDPF_ALPHAPREMULT ? "-premul" : "");
; 977  : 				m_CompFormat = PF_ARGB;

  000db	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
  000e5	5f		 pop	 edi

; 1009 : 			break;
; 1010 : 	}
; 1011 : }

  000e6	5e		 pop	 esi
  000e7	5d		 pop	 ebp
  000e8	c2 08 00	 ret	 8
$LN7@DecodePixe:

; 988  : 			m_CompFormat = PF_DXT2;
; 989  : 			break;
; 990  : 
; 991  : 		case MAKEFOURCC('D','X','T','3'):
; 992  : 			strncpy(strPixelFormat, "DXT3", 31);

  000eb	6a 1f		 push	 31			; 0000001fH
  000ed	68 00 00 00 00	 push	 OFFSET ??_C@_04FMJDCHK@DXT3@
  000f2	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  000f5	e8 00 00 00 00	 call	 _strncpy

; 1009 : 			break;
; 1010 : 	}
; 1011 : }

  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fd	c7 86 ec 00 00
	00 03 00 00 00	 mov	 DWORD PTR [esi+236], 3
  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5d		 pop	 ebp
  0010a	c2 08 00	 ret	 8
$LN12@DecodePixe:

; 965  : 	switch (pxddpf->dwFourCC)

  0010d	3d 44 58 54 34	 cmp	 eax, 877942852		; 34545844H
  00112	74 62		 je	 SHORT $LN8@DecodePixe
  00114	3d 44 58 54 35	 cmp	 eax, 894720068		; 35545844H
  00119	74 39		 je	 SHORT $LN9@DecodePixe
$LN10@DecodePixe:

; 1003 : 			m_CompFormat = PF_DXT5;
; 1004 : 			break;
; 1005 : 
; 1006 : 		default:
; 1007 : 			strcpy(strPixelFormat, "Format Unknown");

  0011b	8b 4d 08	 mov	 ecx, DWORD PTR _strPixelFormat$[ebp]
  0011e	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0P@NBMDABNO@Format?5Unknown@
  00126	5f		 pop	 edi
  00127	66 0f d6 01	 movq	 QWORD PTR [ecx], xmm0
  0012b	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0P@NBMDABNO@Format?5Unknown@+8
  00130	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00133	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0P@NBMDABNO@Format?5Unknown@+12
  00139	66 89 41 0c	 mov	 WORD PTR [ecx+12], ax
  0013d	a0 0e 00 00 00	 mov	 al, BYTE PTR ??_C@_0P@NBMDABNO@Format?5Unknown@+14
  00142	88 41 0e	 mov	 BYTE PTR [ecx+14], al

; 1008 : 			m_CompFormat = PF_UNKNOWN;

  00145	c7 86 ec 00 00
	00 06 00 00 00	 mov	 DWORD PTR [esi+236], 6

; 1009 : 			break;
; 1010 : 	}
; 1011 : }

  0014f	5e		 pop	 esi
  00150	5d		 pop	 ebp
  00151	c2 08 00	 ret	 8
$LN9@DecodePixe:

; 998  : 			m_CompFormat = PF_DXT4;
; 999  : 			break;
; 1000 : 
; 1001 : 		case MAKEFOURCC('D','X','T','5'):
; 1002 : 			strncpy(strPixelFormat, "DXT5", 31);

  00154	6a 1f		 push	 31			; 0000001fH
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_04FDJDJFPM@DXT5@
  0015b	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  0015e	e8 00 00 00 00	 call	 _strncpy

; 1009 : 			break;
; 1010 : 	}
; 1011 : }

  00163	83 c4 0c	 add	 esp, 12			; 0000000cH
  00166	c7 86 ec 00 00
	00 05 00 00 00	 mov	 DWORD PTR [esi+236], 5
  00170	5f		 pop	 edi
  00171	5e		 pop	 esi
  00172	5d		 pop	 ebp
  00173	c2 08 00	 ret	 8
$LN8@DecodePixe:

; 993  : 			m_CompFormat = PF_DXT3;
; 994  : 			break;
; 995  : 
; 996  : 		case MAKEFOURCC('D','X','T','4'):
; 997  : 			strncpy(strPixelFormat, "DXT4", 31);

  00176	6a 1f		 push	 31			; 0000001fH
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_04EKIIKELN@DXT4@
  0017d	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  00180	e8 00 00 00 00	 call	 _strncpy

; 1009 : 			break;
; 1010 : 	}
; 1011 : }

  00185	83 c4 0c	 add	 esp, 12			; 0000000cH
  00188	c7 86 ec 00 00
	00 04 00 00 00	 mov	 DWORD PTR [esi+236], 4
  00192	5f		 pop	 edi
  00193	5e		 pop	 esi
  00194	5d		 pop	 ebp
  00195	c2 08 00	 ret	 8
?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ENDP ; CDXTCImage::DecodePixelFormat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressARGB@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_level$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressARGB@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressARGB, COMDAT
; _this$ = ecx

; 905  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 906  : 	UINT lPitch = m_lPitch >> (level * 2);

  00003	8b 55 08	 mov	 edx, DWORD PTR _level$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  0000c	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  00012	d3 f8		 sar	 eax, cl

; 907  : 	memcpy(pdwDest, &m_bCompVector[level][0], lPitch);

  00014	50		 push	 eax
  00015	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  00018	ff 74 86 34	 push	 DWORD PTR [esi+eax*4+52]
  0001c	ff 75 0c	 push	 DWORD PTR _pdwDest$[ebp]
  0001f	e8 00 00 00 00	 call	 _memcpy
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	5e		 pop	 esi

; 908  : }

  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
?DecompressARGB@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressARGB
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_shift$1 = -128						; size = 16
_masks$2 = -112						; size = 16
tv2505 = -96						; size = 4
tv2504 = -92						; size = 4
_alphazero$1$ = -88					; size = 4
_pImPos$1$ = -84					; size = 4
tv2553 = -84						; size = 4
_yblocks$1$ = -80					; size = 4
_pPos$1$ = -76						; size = 4
_xblocks$1$ = -72					; size = 4
tv2565 = -68						; size = 4
_pBlock$1$ = -64					; size = 4
_nWidth$1$ = -60					; size = 4
_pAlphaBlock$1$ = -56					; size = 4
tv2556 = -52						; size = 4
tv2561 = -52						; size = 4
tv2566 = -52						; size = 4
tv2546 = -48						; size = 4
tv2572 = -48						; size = 4
tv2554 = -44						; size = 4
tv2372 = -40						; size = 4
tv2377 = -36						; size = 4
tv2370 = -32						; size = 4
tv2375 = -28						; size = 4
$T3 = -28						; size = 4
tv2507 = -24						; size = 4
_col_1$ = -20						; size = 4
_col_2$ = -16						; size = 4
_col_3$ = -12						; size = 4
_col_0$ = -8						; size = 4
tv2573 = -1						; size = 1
_pImPos$1$ = 8						; size = 4
tv2548 = 8						; size = 4
_level$ = 8						; size = 4
tv2571 = 11						; size = 1
_pdwDest$ = 12						; size = 4
?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT5, COMDAT
; _this$ = ecx

; 830  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	8b d1		 mov	 edx, ecx

; 846  : 	UINT nHeight = m_nHeight >> level;
; 847  : 
; 848  : 	xblocks = nWidth / 4;
; 849  : 	yblocks = nHeight / 4;
; 850  : 
; 851  : 	int x, y;
; 852  : 
; 853  : 	DWORD * pBase = (DWORD *) pdwDest;
; 854  : 	WORD  * pPos = pPos = (WORD *) &m_bCompVector[level][0]; // pos in compressed data
; 855  : 	DWORD * pImPos;	// pos in decompressed data
; 856  : 
; 857  : 	DXTColBlock	* pBlock;
; 858  : 	DXTAlphaBlock3BitLinear * pAlphaBlock;
; 859  : 
; 860  : 	Color8888 col_0, col_1, col_2, col_3;
; 861  : 	WORD wrd;
; 862  : 
; 863  : 	// fill alphazero with appropriate value to zero out alpha when
; 864  : 	// alphazero is ANDed with the image color 32 bit DWORD:
; 865  : 	col_0.a = 0;
; 866  : 	col_0.r = col_0.g = col_0.b = 0xff;

  0000b	c7 45 f8 ff ff
	ff 00		 mov	 DWORD PTR _col_0$[ebp], 16777215 ; 00ffffffH
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _level$[ebp]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b b2 00 01 00
	00		 mov	 esi, DWORD PTR [edx+256]
  0001d	8b ba 04 01 00
	00		 mov	 edi, DWORD PTR [edx+260]
  00023	d3 fe		 sar	 esi, cl
  00025	8b c6		 mov	 eax, esi
  00027	d3 ff		 sar	 edi, cl
  00029	c1 e8 02	 shr	 eax, 2
  0002c	89 45 b8	 mov	 DWORD PTR _xblocks$1$[ebp], eax
  0002f	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00032	8b 4c 82 34	 mov	 ecx, DWORD PTR [edx+eax*4+52]

; 867  : 	DWORD alphazero = *((DWORD *) &col_0);

  00036	8b 45 f8	 mov	 eax, DWORD PTR _col_0$[ebp]
  00039	c1 ef 02	 shr	 edi, 2
  0003c	89 75 c4	 mov	 DWORD PTR _nWidth$1$[ebp], esi
  0003f	89 7d b0	 mov	 DWORD PTR _yblocks$1$[ebp], edi
  00042	89 4d b4	 mov	 DWORD PTR _pPos$1$[ebp], ecx
  00045	89 45 a8	 mov	 DWORD PTR _alphazero$1$[ebp], eax

; 868  : 
; 869  : 	////////////////////////////////
; 870  : 	// Tracef("blocks: x: %d y: %d\n", xblocks, yblocks);
; 871  : 	for (y = 0; y < yblocks; ++y)

  00048	85 ff		 test	 edi, edi
  0004a	0f 84 6d 05 00
	00		 je	 $LN66@Decompress

; 831  : 	int xblocks, yblocks;
; 832  : #ifdef DEBUG
; 833  : 	if ((ddsd.dwWidth % 4) != 0)
; 834  : 	{
; 835  : 		Tracef("****** warning width not div by 4! %d\n", ddsd.dwWidth);
; 836  : 	}
; 837  : 
; 838  : 	if ((ddsd.dwHeight % 4) != 0)
; 839  : 	{
; 840  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 841  : 	}
; 842  : 
; 843  : 	Tracef("end check\n");
; 844  : #endif
; 845  : 	UINT nWidth = m_nWidth >> level;

  00050	8b 55 b8	 mov	 edx, DWORD PTR _xblocks$1$[ebp]
  00053	8b c6		 mov	 eax, esi
  00055	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000
  0005c	c1 e0 06	 shl	 eax, 6
  0005f	89 45 a0	 mov	 DWORD PTR tv2505[ebp], eax
  00062	8b c2		 mov	 eax, edx
  00064	c1 e0 05	 shl	 eax, 5
  00067	89 45 a4	 mov	 DWORD PTR tv2504[ebp], eax
  0006a	8b 45 0c	 mov	 eax, DWORD PTR _pdwDest$[ebp]
  0006d	0f 1f 00	 npad	 3
$LL4@Decompress:

; 872  : 	{
; 873  : 		// 8 bytes per block
; 874  : 		// 1 block for alpha, 1 block for color
; 875  : 		pBlock = (DXTColBlock*) ((DWORD) (pPos + y * xblocks * 16));

  00070	8b f1		 mov	 esi, ecx

; 876  : 
; 877  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00072	85 d2		 test	 edx, edx
  00074	0f 84 2b 05 00
	00		 je	 $LN2@Decompress

; 872  : 	{
; 873  : 		// 8 bytes per block
; 874  : 		// 1 block for alpha, 1 block for color
; 875  : 		pBlock = (DXTColBlock*) ((DWORD) (pPos + y * xblocks * 16));

  0007a	8b 45 0c	 mov	 eax, DWORD PTR _pdwDest$[ebp]

; 408  : 	col_0->a = 0xff;

  0007d	c6 45 fb ff	 mov	 BYTE PTR _col_0$[ebp+3], 255 ; 000000ffH

; 415  : 
; 416  : 	pCol = (Color565*) & (pBlock->col1);
; 417  : 	col_1->a = 0xff;

  00081	c6 45 ef ff	 mov	 BYTE PTR _col_1$[ebp+3], 255 ; 000000ffH

; 465  : 		col_2->r = (BYTE)wrd;
; 466  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g) / 2);
; 467  : 		col_2->g = (BYTE)wrd;
; 468  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b) / 2);
; 469  : 		col_2->b = (BYTE)wrd;
; 470  : 		col_2->a = 0xff;

  00085	c6 45 f3 ff	 mov	 BYTE PTR _col_2$[ebp+3], 255 ; 000000ffH

; 493  : 	const DWORD masks[] = { 3, 12, 3 << 4, 3 << 6 };

  00089	c7 45 90 03 00
	00 00		 mov	 DWORD PTR _masks$2[ebp], 3
  00090	c7 45 94 0c 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+4], 12 ; 0000000cH
  00097	c7 45 98 30 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+8], 48 ; 00000030H
  0009e	c7 45 9c c0 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+12], 192 ; 000000c0H

; 494  : 	const int   shift[] = { 0, 2, 4, 6 };

  000a5	0f 11 45 80	 movups	 XMMWORD PTR _shift$1[ebp], xmm0

; 872  : 	{
; 873  : 		// 8 bytes per block
; 874  : 		// 1 block for alpha, 1 block for color
; 875  : 		pBlock = (DXTColBlock*) ((DWORD) (pPos + y * xblocks * 16));

  000a9	89 45 e8	 mov	 DWORD PTR tv2507[ebp], eax
  000ac	89 55 bc	 mov	 DWORD PTR tv2565[ebp], edx
  000af	90		 npad	 1
$LL7@Decompress:

; 409  : 	col_0->r = pCol->nRed;

  000b0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000b3	8b d1		 mov	 edx, ecx
  000b5	c1 ea 0b	 shr	 edx, 11			; 0000000bH

; 411  : 	col_0->g = pCol->nGreen;

  000b8	8b c1		 mov	 eax, ecx

; 878  : 		{
; 879  : 			// inline
; 880  : 			// Get alpha block
; 881  : 			pAlphaBlock = (DXTAlphaBlock3BitLinear*) pBlock;

  000ba	89 75 c8	 mov	 DWORD PTR _pAlphaBlock$1$[ebp], esi

; 882  : 
; 883  : 			// inline func:
; 884  : 			// Get color block & colors
; 885  : 			pBlock++;

  000bd	83 c6 08	 add	 esi, 8

; 410  : 	col_0->r <<= 3;				// shift to full precision

  000c0	c0 e2 03	 shl	 dl, 3

; 411  : 	col_0->g = pCol->nGreen;

  000c3	c1 e8 05	 shr	 eax, 5
  000c6	89 55 e0	 mov	 DWORD PTR tv2370[ebp], edx
  000c9	88 55 fa	 mov	 BYTE PTR _col_0$[ebp+2], dl

; 412  : 	col_0->g <<= 2;

  000cc	c0 e0 02	 shl	 al, 2
  000cf	89 45 d8	 mov	 DWORD PTR tv2372[ebp], eax
  000d2	88 45 f9	 mov	 BYTE PTR _col_0$[ebp+1], al

; 413  : 	col_0->b = pCol->nBlue;
; 414  : 	col_0->b <<= 3;

  000d5	8a c1		 mov	 al, cl
  000d7	c0 e0 03	 shl	 al, 3
  000da	88 45 ff	 mov	 BYTE PTR tv2573[ebp], al
  000dd	88 45 f8	 mov	 BYTE PTR _col_0$[ebp], al

; 418  : 	col_1->r = pCol->nRed;

  000e0	8b 46 02	 mov	 eax, DWORD PTR [esi+2]
  000e3	8b d0		 mov	 edx, eax
  000e5	c1 ea 0b	 shr	 edx, 11			; 0000000bH

; 419  : 	col_1->r <<= 3;				// shift to full precision

  000e8	c0 e2 03	 shl	 dl, 3
  000eb	89 55 e4	 mov	 DWORD PTR tv2375[ebp], edx
  000ee	88 55 ee	 mov	 BYTE PTR _col_1$[ebp+2], dl

; 420  : 	col_1->g = pCol->nGreen;

  000f1	8b d0		 mov	 edx, eax
  000f3	c1 ea 05	 shr	 edx, 5

; 421  : 	col_1->g <<= 2;

  000f6	c0 e2 02	 shl	 dl, 2
  000f9	89 55 dc	 mov	 DWORD PTR tv2377[ebp], edx
  000fc	88 55 ed	 mov	 BYTE PTR _col_1$[ebp+1], dl

; 422  : 	col_1->b = pCol->nBlue;
; 423  : 	col_1->b <<= 3;

  000ff	8a d0		 mov	 dl, al
  00101	c0 e2 03	 shl	 dl, 3

; 424  : 
; 425  : 	if (pBlock->col0 > pBlock->col1)

  00104	66 3b c8	 cmp	 cx, ax
  00107	88 55 0b	 mov	 BYTE PTR tv2571[ebp], dl
  0010a	88 55 ec	 mov	 BYTE PTR _col_1$[ebp], dl
  0010d	8b 55 e4	 mov	 edx, DWORD PTR tv2375[ebp]

; 882  : 
; 883  : 			// inline func:
; 884  : 			// Get color block & colors
; 885  : 			pBlock++;

  00110	89 75 c0	 mov	 DWORD PTR _pBlock$1$[ebp], esi

; 423  : 	col_1->b <<= 3;

  00113	0f b6 f2	 movzx	 esi, dl
  00116	8b 55 dc	 mov	 edx, DWORD PTR tv2377[ebp]
  00119	0f b6 fa	 movzx	 edi, dl
  0011c	0f b6 55 0b	 movzx	 edx, BYTE PTR tv2571[ebp]
  00120	89 55 cc	 mov	 DWORD PTR tv2556[ebp], edx
  00123	8b 55 e0	 mov	 edx, DWORD PTR tv2370[ebp]
  00126	0f b6 d2	 movzx	 edx, dl
  00129	89 55 d4	 mov	 DWORD PTR tv2554[ebp], edx
  0012c	8b 55 d8	 mov	 edx, DWORD PTR tv2372[ebp]

; 424  : 
; 425  : 	if (pBlock->col0 > pBlock->col1)

  0012f	8b 45 d4	 mov	 eax, DWORD PTR tv2554[ebp]
  00132	0f b6 d2	 movzx	 edx, dl
  00135	89 55 d0	 mov	 DWORD PTR tv2572[ebp], edx
  00138	0f b6 55 ff	 movzx	 edx, BYTE PTR tv2573[ebp]
  0013c	89 55 ac	 mov	 DWORD PTR tv2553[ebp], edx
  0013f	0f 86 89 00 00
	00		 jbe	 $LN13@Decompress

; 426  : 	{
; 427  : 		// Four-color block: derive the other two colors.
; 428  : 		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
; 429  : 		// These two bit codes correspond to the 2-bit fields
; 430  : 		// stored in the 64-bit block.
; 431  : 		wrd = (WORD) (((WORD) col_0->r * 2 + (WORD) col_1->r) / 3);

  00145	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]

; 432  : 		// no +1 for rounding
; 433  : 		// as bits have been shifted to 888
; 434  : 		col_2->r = (BYTE)wrd;
; 435  : 
; 436  : 		wrd = (WORD) (((WORD) col_0->g * 2 + (WORD) col_1->g) / 3);
; 437  : 		col_2->g = (BYTE)wrd;
; 438  : 
; 439  : 		wrd = (WORD) (((WORD) col_0->b * 2 + (WORD) col_1->b) / 3);
; 440  : 		col_2->b = (BYTE)wrd;
; 441  : 		col_2->a = 0xff;
; 442  : 
; 443  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r * 2) / 3);
; 444  : 		col_3->r = (BYTE)wrd;
; 445  : 
; 446  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g * 2) / 3);
; 447  : 		col_3->g = (BYTE)wrd;
; 448  : 
; 449  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b * 2) / 3);
; 450  : 		col_3->b = (BYTE)wrd;
; 451  : 		col_3->a = 0xff;

  00148	c6 45 f7 ff	 mov	 BYTE PTR _col_3$[ebp+3], 255 ; 000000ffH
  0014c	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00151	f7 e1		 mul	 ecx
  00153	8b 45 d0	 mov	 eax, DWORD PTR tv2572[ebp]
  00156	d1 ea		 shr	 edx, 1
  00158	88 55 f2	 mov	 BYTE PTR _col_2$[ebp+2], dl
  0015b	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  0015e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00163	f7 e1		 mul	 ecx
  00165	8b 45 cc	 mov	 eax, DWORD PTR tv2556[ebp]
  00168	8b 4d ac	 mov	 ecx, DWORD PTR tv2553[ebp]
  0016b	d1 ea		 shr	 edx, 1
  0016d	88 55 f1	 mov	 BYTE PTR _col_2$[ebp+1], dl
  00170	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00173	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00178	f7 e1		 mul	 ecx
  0017a	8b 45 e4	 mov	 eax, DWORD PTR tv2375[ebp]
  0017d	0f b6 c8	 movzx	 ecx, al
  00180	8b 45 e0	 mov	 eax, DWORD PTR tv2370[ebp]
  00183	0f b6 c0	 movzx	 eax, al
  00186	d1 ea		 shr	 edx, 1
  00188	88 55 f0	 mov	 BYTE PTR _col_2$[ebp], dl
  0018b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0018e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00193	f7 e1		 mul	 ecx
  00195	8b 45 dc	 mov	 eax, DWORD PTR tv2377[ebp]
  00198	0f b6 c8	 movzx	 ecx, al
  0019b	8b 45 d8	 mov	 eax, DWORD PTR tv2372[ebp]
  0019e	0f b6 c0	 movzx	 eax, al
  001a1	d1 ea		 shr	 edx, 1
  001a3	88 55 f6	 mov	 BYTE PTR _col_3$[ebp+2], dl
  001a6	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  001a9	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001ae	f7 e1		 mul	 ecx
  001b0	0f b6 45 ff	 movzx	 eax, BYTE PTR tv2573[ebp]
  001b4	0f b6 4d 0b	 movzx	 ecx, BYTE PTR tv2571[ebp]
  001b8	d1 ea		 shr	 edx, 1
  001ba	88 55 f5	 mov	 BYTE PTR _col_3$[ebp+1], dl
  001bd	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  001c0	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001c5	f7 e1		 mul	 ecx
  001c7	d1 ea		 shr	 edx, 1
  001c9	88 55 f4	 mov	 BYTE PTR _col_3$[ebp], dl

; 452  : 	}

  001cc	eb 29		 jmp	 SHORT $LN14@Decompress
$LN13@Decompress:

; 453  : 	else
; 454  : 	{
; 455  : 		// Three-color block: derive the other color.
; 456  : 		// 00 = color_0,  01 = color_1,  10 = color_2,
; 457  : 		// 11 = transparent.
; 458  : 		// These two bit codes correspond to the 2-bit fields
; 459  : 		// stored in the 64-bit block.
; 460  : 
; 461  : 		// explicit for each component, unlike some refrasts...
; 462  : 
; 463  : 		// Tracef("block has alpha\n");
; 464  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r) / 2);

  001ce	03 c6		 add	 eax, esi

; 471  : 
; 472  : 		col_3->r = 0x00;		// random color to indicate alpha
; 473  : 		col_3->g = 0x00;

  001d0	66 c7 45 f5 00
	00		 mov	 WORD PTR _col_3$[ebp+1], 0
  001d6	d1 e8		 shr	 eax, 1
  001d8	88 45 f2	 mov	 BYTE PTR _col_2$[ebp+2], al
  001db	8b 45 d0	 mov	 eax, DWORD PTR tv2572[ebp]
  001de	03 c7		 add	 eax, edi

; 474  : 		col_3->b = 0x00;

  001e0	c6 45 f4 00	 mov	 BYTE PTR _col_3$[ebp], 0
  001e4	d1 e8		 shr	 eax, 1
  001e6	88 45 f1	 mov	 BYTE PTR _col_2$[ebp+1], al
  001e9	8b 45 cc	 mov	 eax, DWORD PTR tv2556[ebp]
  001ec	03 c2		 add	 eax, edx

; 475  : 		col_3->a = 0x00;

  001ee	c6 45 f7 00	 mov	 BYTE PTR _col_3$[ebp+3], 0
  001f2	d1 e8		 shr	 eax, 1
  001f4	88 45 f0	 mov	 BYTE PTR _col_2$[ebp], al
$LN14@Decompress:

; 886  : 
; 887  : 			// Tracef("pBlock: 0x%.8x\n", pBlock);
; 888  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 889  : 
; 890  : 			// Decode the color block into the bitmap bits
; 891  : 			// inline func:
; 892  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 893  : 
; 894  : 			//DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);
; 895  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  001f7	8b 45 e8	 mov	 eax, DWORD PTR tv2507[ebp]

; 497  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001fa	8b 75 f8	 mov	 esi, DWORD PTR _col_0$[ebp]
  001fd	8b 7d f4	 mov	 edi, DWORD PTR _col_3$[ebp]

; 886  : 
; 887  : 			// Tracef("pBlock: 0x%.8x\n", pBlock);
; 888  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 889  : 
; 890  : 			// Decode the color block into the bitmap bits
; 891  : 			// inline func:
; 892  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 893  : 
; 894  : 			//DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);
; 895  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  00200	89 45 08	 mov	 DWORD PTR _pImPos$1$[ebp], eax

; 497  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  00203	b8 04 00 00 00	 mov	 eax, 4
  00208	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  0020b	0f 1f 44 00 00	 npad	 5
$LL19@Decompress:

; 498  : 	{
; 499  : 		// width * 4 bytes per pixel per line
; 500  : 		// each j dxtc row is 4 lines of pixels
; 501  : 
; 502  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 503  : 
; 504  : 		// n steps through pixels
; 505  : 		for (n = 0; n < 4; ++n)

  00210	33 d2		 xor	 edx, edx
  00212	89 55 cc	 mov	 DWORD PTR tv2566[ebp], edx
$LL22@Decompress:

; 506  : 		{
; 507  : 			bits = pColorBlock->row[y] & masks[n];

  00215	8b 4d c0	 mov	 ecx, DWORD PTR _pBlock$1$[ebp]
  00218	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  0021c	8b 44 15 90	 mov	 eax, DWORD PTR _masks$2[ebp+edx]
  00220	23 c1		 and	 eax, ecx

; 508  : 			bits >>= shift[n];

  00222	8b 4c 15 80	 mov	 ecx, DWORD PTR _shift$1[ebp+edx]
  00226	d3 e8		 shr	 eax, cl

; 509  : 
; 510  : 			switch (bits)

  00228	83 f8 03	 cmp	 eax, 3
  0022b	77 29		 ja	 SHORT $LN29@Decompress
  0022d	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN93@Decompress[eax*4]
$LN25@Decompress:

; 511  : 			{
; 512  : 				case 0:
; 513  : 					*pImPos = *col_0;

  00234	8b 45 08	 mov	 eax, DWORD PTR _pImPos$1$[ebp]
  00237	89 30		 mov	 DWORD PTR [eax], esi

; 514  : 					pImPos++; // increment to next DWORD
; 515  : 					break;

  00239	eb 2f		 jmp	 SHORT $LN20@Decompress
$LN26@Decompress:

; 516  : 
; 517  : 				case 1:
; 518  : 					*pImPos = *col_1;

  0023b	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$1$[ebp]
  0023e	8b 45 ec	 mov	 eax, DWORD PTR _col_1$[ebp]
  00241	89 01		 mov	 DWORD PTR [ecx], eax

; 519  : 					pImPos++;
; 520  : 					break;

  00243	eb 22		 jmp	 SHORT $LN104@Decompress
$LN27@Decompress:

; 521  : 
; 522  : 				case 2:
; 523  : 					*pImPos = *col_2;

  00245	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$1$[ebp]
  00248	8b 45 f0	 mov	 eax, DWORD PTR _col_2$[ebp]
  0024b	89 01		 mov	 DWORD PTR [ecx], eax

; 524  : 					pImPos++;
; 525  : 					break;

  0024d	eb 18		 jmp	 SHORT $LN104@Decompress
$LN28@Decompress:

; 526  : 
; 527  : 				case 3:
; 528  : 					*pImPos = *col_3;

  0024f	8b 45 08	 mov	 eax, DWORD PTR _pImPos$1$[ebp]
  00252	89 38		 mov	 DWORD PTR [eax], edi

; 529  : 					pImPos++;
; 530  : 					break;

  00254	eb 14		 jmp	 SHORT $LN20@Decompress
$LN29@Decompress:

; 531  : 
; 532  : 				default:
; 533  : 					Tracef("Your logic is jacked! bits == 0x%x\n", bits);

  00256	50		 push	 eax
  00257	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
  0025c	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00261	8b 55 cc	 mov	 edx, DWORD PTR tv2566[ebp]
  00264	83 c4 08	 add	 esp, 8
$LN104@Decompress:

; 498  : 	{
; 499  : 		// width * 4 bytes per pixel per line
; 500  : 		// each j dxtc row is 4 lines of pixels
; 501  : 
; 502  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 503  : 
; 504  : 		// n steps through pixels
; 505  : 		for (n = 0; n < 4; ++n)

  00267	8b 45 08	 mov	 eax, DWORD PTR _pImPos$1$[ebp]
$LN20@Decompress:
  0026a	83 c0 04	 add	 eax, 4
  0026d	83 c2 04	 add	 edx, 4
  00270	89 45 08	 mov	 DWORD PTR _pImPos$1$[ebp], eax
  00273	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00276	89 55 cc	 mov	 DWORD PTR tv2566[ebp], edx
  00279	83 fa 10	 cmp	 edx, 16			; 00000010H
  0027c	7c 97		 jl	 SHORT $LL22@Decompress

; 495  : 
; 496  : 	// r steps through lines in y
; 497  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  0027e	8b 55 08	 mov	 edx, DWORD PTR _pImPos$1$[ebp]
  00281	8b 45 c4	 mov	 eax, DWORD PTR _nWidth$1$[ebp]
  00284	8d 14 82	 lea	 edx, DWORD PTR [edx+eax*4]
  00287	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  0028a	40		 inc	 eax
  0028b	83 c2 f0	 add	 edx, -16		; fffffff0H
  0028e	89 55 08	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  00291	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00294	83 f8 08	 cmp	 eax, 8
  00297	0f 85 73 ff ff
	ff		 jne	 $LL19@Decompress

; 598  : 	gAlphas[0] = pAlphaBlock->alpha0;

  0029d	8b 45 c8	 mov	 eax, DWORD PTR _pAlphaBlock$1$[ebp]

; 896  : 
; 897  : 			// Overwrite the previous alpha bits with the alpha block
; 898  : 			//  info
; 899  : 			DecodeAlpha3BitLinear(pImPos, pAlphaBlock, nWidth, alphazero);

  002a0	8b 7d e8	 mov	 edi, DWORD PTR tv2507[ebp]
  002a3	89 7d ac	 mov	 DWORD PTR _pImPos$1$[ebp], edi

; 598  : 	gAlphas[0] = pAlphaBlock->alpha0;

  002a6	8a 10		 mov	 dl, BYTE PTR [eax]

; 599  : 	gAlphas[1] = pAlphaBlock->alpha1;

  002a8	8a 40 01	 mov	 al, BYTE PTR [eax+1]
  002ab	0f b6 fa	 movzx	 edi, dl
  002ae	0f b6 c8	 movzx	 ecx, al
  002b1	89 7d cc	 mov	 DWORD PTR tv2561[ebp], edi
  002b4	0f b6 f2	 movzx	 esi, dl
  002b7	0f b6 f8	 movzx	 edi, al
  002ba	66 3b f1	 cmp	 si, cx
  002bd	0f b6 c0	 movzx	 eax, al
  002c0	89 45 d0	 mov	 DWORD PTR tv2546[ebp], eax

; 600  : 
; 601  : 	// 8-alpha or 6-alpha block?
; 602  : 	if (gAlphas[0] > gAlphas[1])

  002c3	8b 45 cc	 mov	 eax, DWORD PTR tv2561[ebp]
  002c6	0f b6 d2	 movzx	 edx, dl
  002c9	66 89 35 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA, si
  002d0	8b 75 d0	 mov	 esi, DWORD PTR tv2546[ebp]
  002d3	66 89 0d 02 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+2, cx
  002da	89 55 08	 mov	 DWORD PTR tv2548[ebp], edx
  002dd	0f 86 bf 00 00
	00		 jbe	 $LN44@Decompress

; 603  : 	{
; 604  : 		// 8-alpha block:  derive the other 6 alphas.
; 605  : 		// 000 = alpha_0, 001 = alpha_1, others are interpolated
; 606  : 		gAlphas[2] = (WORD) ((6 * gAlphas[0] +     gAlphas[1]) / 7);	// Bit code 010

  002e3	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  002e6	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  002e9	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  002ee	f7 e1		 mul	 ecx

; 607  : 		gAlphas[3] = (WORD) ((5 * gAlphas[0] + 2 * gAlphas[1]) / 7);	// Bit code 011

  002f0	8b 45 08	 mov	 eax, DWORD PTR tv2548[ebp]
  002f3	2b ca		 sub	 ecx, edx
  002f5	d1 e9		 shr	 ecx, 1
  002f7	03 ca		 add	 ecx, edx
  002f9	c1 e9 02	 shr	 ecx, 2
  002fc	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  002ff	66 89 0d 04 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+4, cx
  00306	8d 0c 70	 lea	 ecx, DWORD PTR [eax+esi*2]
  00309	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  0030e	f7 e1		 mul	 ecx

; 608  : 		gAlphas[4] = (WORD) ((4 * gAlphas[0] + 3 * gAlphas[1]) / 7);	// Bit code 100

  00310	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00313	2b ca		 sub	 ecx, edx
  00315	d1 e9		 shr	 ecx, 1
  00317	03 ca		 add	 ecx, edx
  00319	c1 e9 02	 shr	 ecx, 2
  0031c	66 89 0d 06 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+6, cx
  00323	8b 4d 08	 mov	 ecx, DWORD PTR tv2548[ebp]
  00326	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00329	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  0032e	f7 e1		 mul	 ecx

; 609  : 		gAlphas[5] = (WORD) ((3 * gAlphas[0] + 4 * gAlphas[1]) / 7);	// Bit code 101

  00330	8b 45 08	 mov	 eax, DWORD PTR tv2548[ebp]
  00333	2b ca		 sub	 ecx, edx
  00335	d1 e9		 shr	 ecx, 1
  00337	03 ca		 add	 ecx, edx
  00339	c1 e9 02	 shr	 ecx, 2
  0033c	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0033f	66 89 0d 08 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+8, cx
  00346	8d 0c b0	 lea	 ecx, DWORD PTR [eax+esi*4]
  00349	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  0034e	f7 e1		 mul	 ecx

; 610  : 		gAlphas[6] = (WORD) ((2 * gAlphas[0] + 5 * gAlphas[1]) / 7);	// Bit code 110

  00350	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  00353	2b ca		 sub	 ecx, edx
  00355	d1 e9		 shr	 ecx, 1
  00357	03 ca		 add	 ecx, edx
  00359	c1 e9 02	 shr	 ecx, 2
  0035c	66 89 0d 0a 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+10, cx
  00363	8b 4d 08	 mov	 ecx, DWORD PTR tv2548[ebp]
  00366	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00369	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  0036e	f7 e1		 mul	 ecx

; 611  : 		gAlphas[7] = (WORD) ((    gAlphas[0] + 6 * gAlphas[1]) / 7);	// Bit code 111

  00370	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  00373	2b ca		 sub	 ecx, edx
  00375	d1 e9		 shr	 ecx, 1
  00377	03 ca		 add	 ecx, edx
  00379	c1 e9 02	 shr	 ecx, 2
  0037c	66 89 0d 0c 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+12, cx
  00383	8b 4d 08	 mov	 ecx, DWORD PTR tv2548[ebp]
  00386	8d 0c 41	 lea	 ecx, DWORD PTR [ecx+eax*2]
  00389	b8 25 49 92 24	 mov	 eax, 613566757		; 24924925H
  0038e	f7 e1		 mul	 ecx
  00390	2b ca		 sub	 ecx, edx
  00392	d1 e9		 shr	 ecx, 1
  00394	03 ca		 add	 ecx, edx
  00396	c1 e9 02	 shr	 ecx, 2
  00399	66 89 0d 0e 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+14, cx

; 612  : 	}

  003a0	eb 69		 jmp	 SHORT $LN45@Decompress
$LN44@Decompress:

; 613  : 	else
; 614  : 	{
; 615  : 		// 6-alpha block:  derive the other alphas.
; 616  : 		// 000 = alpha_0, 001 = alpha_1, others are interpolated
; 617  : 		gAlphas[2] = (WORD) ((4 * gAlphas[0] +     gAlphas[1]) / 5);	// Bit code 010

  003a2	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 618  : 		gAlphas[3] = (WORD) ((3 * gAlphas[0] + 2 * gAlphas[1]) / 5);	// Bit code 011
; 619  : 		gAlphas[4] = (WORD) ((2 * gAlphas[0] + 3 * gAlphas[1]) / 5);	// Bit code 100
; 620  : 		gAlphas[5] = (WORD) ((   gAlphas[0] + 4 * gAlphas[1]) / 5);		// Bit code 101
; 621  : 		gAlphas[6] = 0;													// Bit code 110

  003a5	c7 05 0c 00 00
	00 00 00 ff 00	 mov	 DWORD PTR ?gAlphas@@3PAGA+12, 16711680 ; 00ff0000H
  003af	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  003b4	f7 e1		 mul	 ecx
  003b6	8b 45 08	 mov	 eax, DWORD PTR tv2548[ebp]
  003b9	c1 ea 02	 shr	 edx, 2
  003bc	66 89 15 04 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+4, dx
  003c3	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  003c6	8d 0c 70	 lea	 ecx, DWORD PTR [eax+esi*2]
  003c9	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  003ce	f7 e1		 mul	 ecx
  003d0	8b 4d 08	 mov	 ecx, DWORD PTR tv2548[ebp]
  003d3	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  003d6	c1 ea 02	 shr	 edx, 2
  003d9	66 89 15 06 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+6, dx
  003e0	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  003e3	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  003e8	f7 e1		 mul	 ecx
  003ea	8b 45 08	 mov	 eax, DWORD PTR tv2548[ebp]
  003ed	c1 ea 02	 shr	 edx, 2
  003f0	66 89 15 08 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+8, dx
  003f7	8d 0c b0	 lea	 ecx, DWORD PTR [eax+esi*4]
  003fa	b8 cd cc cc cc	 mov	 eax, -858993459		; cccccccdH
  003ff	f7 e1		 mul	 ecx
  00401	c1 ea 02	 shr	 edx, 2
  00404	66 89 15 0a 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA+10, dx
$LN45@Decompress:

; 622  : 		gAlphas[7] = 255;												// Bit code 111
; 623  : 	}
; 624  : 
; 625  : 	// Decode 3-bit fields into array of 16 BYTES with same value
; 626  : 
; 627  : 	// first two rows of 4 pixels each:
; 628  : 	// pRows = (Alpha3BitRows*) & (pAlphaBlock->stuff[0]);
; 629  : 	const DWORD mask = 0x00000007;		// bits = 00 00 01 11
; 630  : 	DWORD bits = *((DWORD*) & (pAlphaBlock->stuff[0]));

  0040b	8b 55 c8	 mov	 edx, DWORD PTR _pAlphaBlock$1$[ebp]
  0040e	8b 7d ac	 mov	 edi, DWORD PTR _pImPos$1$[ebp]
  00411	8b 4a 02	 mov	 ecx, DWORD PTR [edx+2]

; 631  : 
; 632  : 	gBits[0][0] = (BYTE) (bits & mask);

  00414	8a c1		 mov	 al, cl
  00416	24 07		 and	 al, 7

; 633  : 	bits >>= 3;

  00418	c1 e9 03	 shr	 ecx, 3
  0041b	a2 00 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA, al

; 634  : 	gBits[0][1] = (BYTE) (bits & mask);

  00420	8a c1		 mov	 al, cl
  00422	24 07		 and	 al, 7

; 635  : 	bits >>= 3;

  00424	c1 e9 03	 shr	 ecx, 3
  00427	a2 01 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+1, al

; 636  : 	gBits[0][2] = (BYTE) (bits & mask);

  0042c	8a c1		 mov	 al, cl
  0042e	24 07		 and	 al, 7

; 637  : 	bits >>= 3;

  00430	c1 e9 03	 shr	 ecx, 3
  00433	a2 02 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+2, al

; 638  : 	gBits[0][3] = (BYTE) (bits & mask);

  00438	8a c1		 mov	 al, cl
  0043a	24 07		 and	 al, 7

; 639  : 	bits >>= 3;

  0043c	c1 e9 03	 shr	 ecx, 3
  0043f	a2 03 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+3, al

; 640  : 	gBits[1][0] = (BYTE) (bits & mask);

  00444	8a c1		 mov	 al, cl
  00446	24 07		 and	 al, 7

; 641  : 	bits >>= 3;

  00448	c1 e9 03	 shr	 ecx, 3
  0044b	a2 04 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+4, al

; 642  : 	gBits[1][1] = (BYTE) (bits & mask);

  00450	8a c1		 mov	 al, cl
  00452	24 07		 and	 al, 7

; 643  : 	bits >>= 3;

  00454	c1 e9 03	 shr	 ecx, 3
  00457	a2 05 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+5, al

; 644  : 	gBits[1][2] = (BYTE) (bits & mask);

  0045c	8a c1		 mov	 al, cl
  0045e	24 07		 and	 al, 7

; 645  : 	bits >>= 3;

  00460	c1 e9 03	 shr	 ecx, 3
  00463	a2 06 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+6, al

; 646  : 	gBits[1][3] = (BYTE) (bits & mask);

  00468	80 e1 07	 and	 cl, 7
  0046b	88 0d 07 00 00
	00		 mov	 BYTE PTR ?gBits@@3PAY03EA+7, cl

; 647  : 
; 648  : 	// now for last two rows:
; 649  : 	bits = *((DWORD*) & (pAlphaBlock->stuff[3]));		// last 3 bytes

  00471	8b 4a 05	 mov	 ecx, DWORD PTR [edx+5]

; 650  : 
; 651  : 	gBits[2][0] = (BYTE) (bits & mask);

  00474	8a c1		 mov	 al, cl
  00476	24 07		 and	 al, 7

; 652  : 	bits >>= 3;

  00478	c1 e9 03	 shr	 ecx, 3
  0047b	a2 08 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+8, al
  00480	ba 07 00 00 00	 mov	 edx, OFFSET ?gACol@@3PAY03UColor8888@@A+7

; 653  : 	gBits[2][1] = (BYTE) (bits & mask);

  00485	8a c1		 mov	 al, cl

; 654  : 	bits >>= 3;

  00487	c1 e9 03	 shr	 ecx, 3
  0048a	24 07		 and	 al, 7
  0048c	a2 09 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+9, al

; 655  : 	gBits[2][2] = (BYTE) (bits & mask);

  00491	8a c1		 mov	 al, cl
  00493	24 07		 and	 al, 7

; 656  : 	bits >>= 3;

  00495	c1 e9 03	 shr	 ecx, 3
  00498	a2 0a 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+10, al

; 657  : 	gBits[2][3] = (BYTE) (bits & mask);

  0049d	8a c1		 mov	 al, cl
  0049f	24 07		 and	 al, 7

; 658  : 	bits >>= 3;

  004a1	c1 e9 03	 shr	 ecx, 3
  004a4	a2 0b 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+11, al

; 659  : 	gBits[3][0] = (BYTE) (bits & mask);

  004a9	8a c1		 mov	 al, cl
  004ab	24 07		 and	 al, 7

; 660  : 	bits >>= 3;

  004ad	c1 e9 03	 shr	 ecx, 3
  004b0	a2 0c 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+12, al

; 661  : 	gBits[3][1] = (BYTE) (bits & mask);

  004b5	8a c1		 mov	 al, cl
  004b7	24 07		 and	 al, 7

; 662  : 	bits >>= 3;

  004b9	c1 e9 03	 shr	 ecx, 3
  004bc	a2 0d 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+13, al

; 663  : 	gBits[3][2] = (BYTE) (bits & mask);

  004c1	8a c1		 mov	 al, cl

; 664  : 	bits >>= 3;

  004c3	c1 e9 03	 shr	 ecx, 3
  004c6	24 07		 and	 al, 7

; 665  : 	gBits[3][3] = (BYTE) (bits & mask);

  004c8	80 e1 07	 and	 cl, 7
  004cb	a2 0e 00 00 00	 mov	 BYTE PTR ?gBits@@3PAY03EA+14, al
  004d0	88 0d 0f 00 00
	00		 mov	 BYTE PTR ?gBits@@3PAY03EA+15, cl
  004d6	b9 01 00 00 00	 mov	 ecx, OFFSET ?gBits@@3PAY03EA+1
  004db	0f 1f 44 00 00	 npad	 5
$LL34@Decompress:

; 666  : 
; 667  : 	// decode the codes into alpha values
; 668  : 	int row, pix;
; 669  : 
; 670  : 	for (row = 0; row < 4; ++row)
; 671  : 	{
; 672  : 		for (pix = 0; pix < 4; ++pix)
; 673  : 		{
; 674  : 			gACol[row][pix].a = (BYTE) gAlphas[gBits[row][pix]];

  004e0	0f b6 41 ff	 movzx	 eax, BYTE PTR [ecx-1]
  004e4	8d 52 10	 lea	 edx, DWORD PTR [edx+16]
  004e7	0f b6 04 45 00
	00 00 00	 movzx	 eax, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  004ef	88 42 ec	 mov	 BYTE PTR [edx-20], al
  004f2	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  004f5	0f b6 04 45 00
	00 00 00	 movzx	 eax, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  004fd	88 42 f0	 mov	 BYTE PTR [edx-16], al
  00500	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00504	0f b6 04 45 00
	00 00 00	 movzx	 eax, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  0050c	88 42 f4	 mov	 BYTE PTR [edx-12], al
  0050f	0f b6 41 02	 movzx	 eax, BYTE PTR [ecx+2]
  00513	83 c1 04	 add	 ecx, 4
  00516	0f b6 04 45 00
	00 00 00	 movzx	 eax, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  0051e	88 42 f8	 mov	 BYTE PTR [edx-8], al
  00521	81 f9 11 00 00
	00		 cmp	 ecx, OFFSET ?gBits@@3PAY03EA+17
  00527	7c b7		 jl	 SHORT $LL34@Decompress
  00529	8b 75 a8	 mov	 esi, DWORD PTR _alphazero$1$[ebp]

; 675  : 
; 676  : 			assert(gACol[row][pix].r == 0);
; 677  : 			assert(gACol[row][pix].g == 0);
; 678  : 			assert(gACol[row][pix].b == 0);
; 679  : 		}
; 680  : 	}
; 681  : 
; 682  : 	// Write out alpha values to the image bits
; 683  : 	for (row = 0; row < 4; ++row, pImPos += width - 4)

  0052c	ba 04 00 00 00	 mov	 edx, OFFSET ?gACol@@3PAY03UColor8888@@A+4
$LL40@Decompress:

; 684  : 	{
; 685  : 		// pImPow += pImPos += width - 4 moves to next row down
; 686  : 		for (pix = 0; pix < 4; ++pix)
; 687  : 		{
; 688  : 			// zero the alpha bits of image pixel
; 689  : 			*pImPos &= alphazero;

  00531	21 37		 and	 DWORD PTR [edi], esi

; 690  : 			*pImPos |= *((DWORD*) &(gACol[row][pix]));	// or the bits into the prev. nulled alpha

  00533	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  00536	09 07		 or	 DWORD PTR [edi], eax
  00538	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0053b	23 ce		 and	 ecx, esi
  0053d	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00540	8b 02		 mov	 eax, DWORD PTR [edx]
  00542	0b c1		 or	 eax, ecx
  00544	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00547	23 ce		 and	 ecx, esi
  00549	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0054c	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  0054f	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00552	0b c1		 or	 eax, ecx
  00554	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  00557	23 ce		 and	 ecx, esi
  00559	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0055c	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  0055f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00562	83 c2 10	 add	 edx, 16			; 00000010H
  00565	0b c1		 or	 eax, ecx
  00567	8b 4d c4	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  0056a	89 47 0c	 mov	 DWORD PTR [edi+12], eax
  0056d	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00574	03 f8		 add	 edi, eax
  00576	81 fa 44 00 00
	00		 cmp	 edx, OFFSET ?gACol@@3PAY03UColor8888@@A+68
  0057c	7c b3		 jl	 SHORT $LL40@Decompress

; 876  : 
; 877  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  0057e	8b 75 c0	 mov	 esi, DWORD PTR _pBlock$1$[ebp]
  00581	83 45 e8 40	 add	 DWORD PTR tv2507[ebp], 64 ; 00000040H
  00585	83 c6 08	 add	 esi, 8
  00588	83 6d bc 01	 sub	 DWORD PTR tv2565[ebp], 1
  0058c	0f 85 1e fb ff
	ff		 jne	 $LL7@Decompress
  00592	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000
  00599	8b 7d b0	 mov	 edi, DWORD PTR _yblocks$1$[ebp]
  0059c	8b 4d b4	 mov	 ecx, DWORD PTR _pPos$1$[ebp]
  0059f	8b 45 0c	 mov	 eax, DWORD PTR _pdwDest$[ebp]
  005a2	8b 55 b8	 mov	 edx, DWORD PTR _xblocks$1$[ebp]
$LN2@Decompress:

; 868  : 
; 869  : 	////////////////////////////////
; 870  : 	// Tracef("blocks: x: %d y: %d\n", xblocks, yblocks);
; 871  : 	for (y = 0; y < yblocks; ++y)

  005a5	03 4d a4	 add	 ecx, DWORD PTR tv2504[ebp]
  005a8	03 45 a0	 add	 eax, DWORD PTR tv2505[ebp]
  005ab	83 ef 01	 sub	 edi, 1
  005ae	89 4d b4	 mov	 DWORD PTR _pPos$1$[ebp], ecx
  005b1	89 45 0c	 mov	 DWORD PTR _pdwDest$[ebp], eax
  005b4	89 7d b0	 mov	 DWORD PTR _yblocks$1$[ebp], edi
  005b7	0f 85 b3 fa ff
	ff		 jne	 $LL4@Decompress
$LN66@Decompress:
  005bd	5f		 pop	 edi

; 900  : 		}
; 901  : 	}
; 902  : }	// dxt5

  005be	5e		 pop	 esi
  005bf	8b e5		 mov	 esp, ebp
  005c1	5d		 pop	 ebp
  005c2	c2 08 00	 ret	 8
  005c5	0f 1f 00	 npad	 3
$LN93@Decompress:
  005c8	00 00 00 00	 DD	 $LN25@Decompress
  005cc	00 00 00 00	 DD	 $LN26@Decompress
  005d0	00 00 00 00	 DD	 $LN27@Decompress
  005d4	00 00 00 00	 DD	 $LN28@Decompress
?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT5
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_shift$1 = -132						; size = 16
_masks$2 = -116						; size = 16
tv1765 = -100						; size = 4
tv1764 = -96						; size = 4
tv1790 = -92						; size = 4
tv1792 = -88						; size = 4
_yblocks$1$ = -84					; size = 4
_pPos$1$ = -80						; size = 4
_xblocks$1$ = -76					; size = 4
tv1791 = -72						; size = 4
_pAlphaBlock$1$ = -68					; size = 4
_nWidth$1$ = -64					; size = 4
tv1804 = -60						; size = 4
tv1803 = -56						; size = 4
tv1695 = -52						; size = 4
tv1701 = -48						; size = 4
tv1693 = -44						; size = 4
_alphazero$1$ = -40					; size = 4
tv1767 = -36						; size = 4
_col_1$ = -32						; size = 4
tv1798 = -28						; size = 4
tv1807 = -28						; size = 4
tv1699 = -24						; size = 4
$T3 = -24						; size = 4
_col_2$ = -20						; size = 4
_col_3$ = -16						; size = 4
_col_0$ = -12						; size = 4
_col$4 = -8						; size = 4
tv1810 = -1						; size = 1
_miplevel$ = 8						; size = 4
_pImPos$1$ = 8						; size = 4
_wrd$5 = 8						; size = 2
tv1801 = 11						; size = 1
_pdwDest$ = 12						; size = 4
?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT3, COMDAT
; _this$ = ecx

; 756  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	8b d1		 mov	 edx, ecx

; 772  : 	UINT nHeight = m_nHeight >> miplevel;
; 773  : 
; 774  : 	xblocks = nWidth / 4;
; 775  : 	yblocks = nHeight / 4;
; 776  : 
; 777  : 	int		x, y;
; 778  : 	DWORD * pBase	= (DWORD *) pdwDest;
; 779  : 	WORD  * pPos	= (WORD *) &m_bCompVector[miplevel][0]; // pos in compressed data
; 780  : 	DWORD * pImPos;	// pos in decompressed data
; 781  : 
; 782  : 	DXTColBlock	* pBlock;
; 783  : 	DXTAlphaBlockExplicit * pAlphaBlock;
; 784  : 
; 785  : 	Color8888 col_0, col_1, col_2, col_3;
; 786  : 	WORD wrd;
; 787  : 
; 788  : 	// fill alphazero with appropriate value to zero out alpha when
; 789  : 	//  alphazero is ANDed with the image color 32 bit DWORD:
; 790  : 	col_0.a = 0;
; 791  : 	col_0.r = col_0.g = col_0.b = 0xff;

  0000b	c7 45 f4 ff ff
	ff 00		 mov	 DWORD PTR _col_0$[ebp], 16777215 ; 00ffffffH
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	8b b2 00 01 00
	00		 mov	 esi, DWORD PTR [edx+256]
  0001d	8b ba 04 01 00
	00		 mov	 edi, DWORD PTR [edx+260]
  00023	d3 fe		 sar	 esi, cl
  00025	8b c6		 mov	 eax, esi
  00027	d3 ff		 sar	 edi, cl
  00029	c1 e8 02	 shr	 eax, 2
  0002c	89 45 b4	 mov	 DWORD PTR _xblocks$1$[ebp], eax
  0002f	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00032	8b 44 82 34	 mov	 eax, DWORD PTR [edx+eax*4+52]

; 792  : 
; 793  : 	DWORD alphazero = *((DWORD *) &col_0);

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _col_0$[ebp]
  00039	c1 ef 02	 shr	 edi, 2
  0003c	89 75 c0	 mov	 DWORD PTR _nWidth$1$[ebp], esi
  0003f	89 7d ac	 mov	 DWORD PTR _yblocks$1$[ebp], edi
  00042	89 45 b0	 mov	 DWORD PTR _pPos$1$[ebp], eax
  00045	89 4d d8	 mov	 DWORD PTR _alphazero$1$[ebp], ecx

; 794  : 
; 795  : 	for (y = 0; y < yblocks; ++y)

  00048	85 ff		 test	 edi, edi
  0004a	0f 84 41 03 00
	00		 je	 $LN3@Decompress

; 757  : 	int xblocks, yblocks;
; 758  : #ifdef DEBUG
; 759  : 	if ((ddsd.dwWidth % 4) != 0)
; 760  : 	{
; 761  : 		Tracef("****** warning width not div by 4! %d\n", ddsd.dwWidth);
; 762  : 	}
; 763  : 
; 764  : 	if ((ddsd.dwHeight % 4) != 0)
; 765  : 	{
; 766  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 767  : 	}
; 768  : 
; 769  : 	Tracef("end check\n");
; 770  : #endif
; 771  : 	UINT nWidth = m_nWidth >> miplevel;

  00050	8b 55 b4	 mov	 edx, DWORD PTR _xblocks$1$[ebp]
  00053	8b ce		 mov	 ecx, esi
  00055	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000
  0005c	c1 e1 06	 shl	 ecx, 6
  0005f	89 4d 9c	 mov	 DWORD PTR tv1765[ebp], ecx
  00062	8b ca		 mov	 ecx, edx
  00064	c1 e1 05	 shl	 ecx, 5
  00067	89 4d a0	 mov	 DWORD PTR tv1764[ebp], ecx
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwDest$[ebp]
  0006d	0f 1f 00	 npad	 3
$LL4@Decompress:

; 796  : 	{
; 797  : 		// 8 bytes per block
; 798  : 		// 1 block for alpha, 1 block for color
; 799  : 		pBlock = (DXTColBlock *) ((DWORD) (pPos + y * xblocks * 16));

  00070	8b f0		 mov	 esi, eax

; 800  : 
; 801  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00072	85 d2		 test	 edx, edx
  00074	0f 84 ff 02 00
	00		 je	 $LN2@Decompress

; 408  : 	col_0->a = 0xff;

  0007a	c6 45 f7 ff	 mov	 BYTE PTR _col_0$[ebp+3], 255 ; 000000ffH

; 415  : 
; 416  : 	pCol = (Color565*) & (pBlock->col1);
; 417  : 	col_1->a = 0xff;

  0007e	c6 45 e3 ff	 mov	 BYTE PTR _col_1$[ebp+3], 255 ; 000000ffH

; 465  : 		col_2->r = (BYTE)wrd;
; 466  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g) / 2);
; 467  : 		col_2->g = (BYTE)wrd;
; 468  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b) / 2);
; 469  : 		col_2->b = (BYTE)wrd;
; 470  : 		col_2->a = 0xff;

  00082	c6 45 ef ff	 mov	 BYTE PTR _col_2$[ebp+3], 255 ; 000000ffH

; 493  : 	const DWORD masks[] = { 3, 12, 3 << 4, 3 << 6 };

  00086	c7 45 8c 03 00
	00 00		 mov	 DWORD PTR _masks$2[ebp], 3
  0008d	c7 45 90 0c 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+4], 12 ; 0000000cH
  00094	c7 45 94 30 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+8], 48 ; 00000030H
  0009b	c7 45 98 c0 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+12], 192 ; 000000c0H

; 494  : 	const int   shift[] = { 0, 2, 4, 6 };

  000a2	0f 11 85 7c ff
	ff ff		 movups	 XMMWORD PTR _shift$1[ebp], xmm0

; 556  : 	col.r = col.g = col.b = 0;

  000a9	66 c7 45 f8 00
	00		 mov	 WORD PTR _col$4[ebp], 0
  000af	c6 45 fa 00	 mov	 BYTE PTR _col$4[ebp+2], 0

; 796  : 	{
; 797  : 		// 8 bytes per block
; 798  : 		// 1 block for alpha, 1 block for color
; 799  : 		pBlock = (DXTColBlock *) ((DWORD) (pPos + y * xblocks * 16));

  000b3	89 4d dc	 mov	 DWORD PTR tv1767[ebp], ecx
  000b6	89 55 b8	 mov	 DWORD PTR tv1791[ebp], edx
  000b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@Decompress:

; 409  : 	col_0->r = pCol->nRed;

  000c0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000c3	8b d1		 mov	 edx, ecx
  000c5	c1 ea 0b	 shr	 edx, 11			; 0000000bH

; 411  : 	col_0->g = pCol->nGreen;

  000c8	8b c1		 mov	 eax, ecx

; 802  : 		{
; 803  : 			// inline
; 804  : 			// Get alpha block
; 805  : 			pAlphaBlock = (DXTAlphaBlockExplicit *) pBlock;

  000ca	89 75 a4	 mov	 DWORD PTR tv1790[ebp], esi

; 806  : 
; 807  : 			// inline func:
; 808  : 			// Get color block & colors
; 809  : 			pBlock++;

  000cd	83 c6 08	 add	 esi, 8

; 410  : 	col_0->r <<= 3;				// shift to full precision

  000d0	c0 e2 03	 shl	 dl, 3

; 411  : 	col_0->g = pCol->nGreen;

  000d3	c1 e8 05	 shr	 eax, 5
  000d6	89 55 d4	 mov	 DWORD PTR tv1693[ebp], edx
  000d9	88 55 f6	 mov	 BYTE PTR _col_0$[ebp+2], dl

; 412  : 	col_0->g <<= 2;

  000dc	c0 e0 02	 shl	 al, 2
  000df	89 45 cc	 mov	 DWORD PTR tv1695[ebp], eax
  000e2	88 45 f5	 mov	 BYTE PTR _col_0$[ebp+1], al

; 413  : 	col_0->b = pCol->nBlue;
; 414  : 	col_0->b <<= 3;

  000e5	8a c1		 mov	 al, cl
  000e7	c0 e0 03	 shl	 al, 3
  000ea	88 45 ff	 mov	 BYTE PTR tv1810[ebp], al
  000ed	88 45 f4	 mov	 BYTE PTR _col_0$[ebp], al

; 418  : 	col_1->r = pCol->nRed;

  000f0	8b 46 02	 mov	 eax, DWORD PTR [esi+2]
  000f3	8b d0		 mov	 edx, eax
  000f5	c1 ea 0b	 shr	 edx, 11			; 0000000bH

; 419  : 	col_1->r <<= 3;				// shift to full precision

  000f8	c0 e2 03	 shl	 dl, 3
  000fb	89 55 e8	 mov	 DWORD PTR tv1699[ebp], edx
  000fe	88 55 e2	 mov	 BYTE PTR _col_1$[ebp+2], dl

; 420  : 	col_1->g = pCol->nGreen;

  00101	8b d0		 mov	 edx, eax
  00103	c1 ea 05	 shr	 edx, 5

; 421  : 	col_1->g <<= 2;

  00106	c0 e2 02	 shl	 dl, 2
  00109	89 55 d0	 mov	 DWORD PTR tv1701[ebp], edx
  0010c	88 55 e1	 mov	 BYTE PTR _col_1$[ebp+1], dl

; 422  : 	col_1->b = pCol->nBlue;
; 423  : 	col_1->b <<= 3;

  0010f	8a d0		 mov	 dl, al
  00111	c0 e2 03	 shl	 dl, 3

; 424  : 
; 425  : 	if (pBlock->col0 > pBlock->col1)

  00114	66 3b c8	 cmp	 cx, ax
  00117	88 55 0b	 mov	 BYTE PTR tv1801[ebp], dl
  0011a	88 55 e0	 mov	 BYTE PTR _col_1$[ebp], dl
  0011d	8b 55 e8	 mov	 edx, DWORD PTR tv1699[ebp]

; 806  : 
; 807  : 			// inline func:
; 808  : 			// Get color block & colors
; 809  : 			pBlock++;

  00120	89 75 bc	 mov	 DWORD PTR _pAlphaBlock$1$[ebp], esi

; 423  : 	col_1->b <<= 3;

  00123	0f b6 f2	 movzx	 esi, dl
  00126	8b 55 d0	 mov	 edx, DWORD PTR tv1701[ebp]
  00129	0f b6 fa	 movzx	 edi, dl
  0012c	0f b6 55 0b	 movzx	 edx, BYTE PTR tv1801[ebp]
  00130	89 55 e4	 mov	 DWORD PTR tv1798[ebp], edx
  00133	8b 55 d4	 mov	 edx, DWORD PTR tv1693[ebp]
  00136	0f b6 d2	 movzx	 edx, dl
  00139	89 55 c8	 mov	 DWORD PTR tv1803[ebp], edx
  0013c	8b 55 cc	 mov	 edx, DWORD PTR tv1695[ebp]

; 424  : 
; 425  : 	if (pBlock->col0 > pBlock->col1)

  0013f	8b 45 c8	 mov	 eax, DWORD PTR tv1803[ebp]
  00142	0f b6 d2	 movzx	 edx, dl
  00145	89 55 c4	 mov	 DWORD PTR tv1804[ebp], edx
  00148	0f b6 55 ff	 movzx	 edx, BYTE PTR tv1810[ebp]
  0014c	89 55 a8	 mov	 DWORD PTR tv1792[ebp], edx
  0014f	0f 86 89 00 00
	00		 jbe	 $LN13@Decompress

; 426  : 	{
; 427  : 		// Four-color block: derive the other two colors.
; 428  : 		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
; 429  : 		// These two bit codes correspond to the 2-bit fields
; 430  : 		// stored in the 64-bit block.
; 431  : 		wrd = (WORD) (((WORD) col_0->r * 2 + (WORD) col_1->r) / 3);

  00155	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]

; 432  : 		// no +1 for rounding
; 433  : 		// as bits have been shifted to 888
; 434  : 		col_2->r = (BYTE)wrd;
; 435  : 
; 436  : 		wrd = (WORD) (((WORD) col_0->g * 2 + (WORD) col_1->g) / 3);
; 437  : 		col_2->g = (BYTE)wrd;
; 438  : 
; 439  : 		wrd = (WORD) (((WORD) col_0->b * 2 + (WORD) col_1->b) / 3);
; 440  : 		col_2->b = (BYTE)wrd;
; 441  : 		col_2->a = 0xff;
; 442  : 
; 443  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r * 2) / 3);
; 444  : 		col_3->r = (BYTE)wrd;
; 445  : 
; 446  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g * 2) / 3);
; 447  : 		col_3->g = (BYTE)wrd;
; 448  : 
; 449  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b * 2) / 3);
; 450  : 		col_3->b = (BYTE)wrd;
; 451  : 		col_3->a = 0xff;

  00158	c6 45 f3 ff	 mov	 BYTE PTR _col_3$[ebp+3], 255 ; 000000ffH
  0015c	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00161	f7 e1		 mul	 ecx
  00163	8b 45 c4	 mov	 eax, DWORD PTR tv1804[ebp]
  00166	d1 ea		 shr	 edx, 1
  00168	88 55 ee	 mov	 BYTE PTR _col_2$[ebp+2], dl
  0016b	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  0016e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00173	f7 e1		 mul	 ecx
  00175	8b 45 e4	 mov	 eax, DWORD PTR tv1798[ebp]
  00178	8b 4d a8	 mov	 ecx, DWORD PTR tv1792[ebp]
  0017b	d1 ea		 shr	 edx, 1
  0017d	88 55 ed	 mov	 BYTE PTR _col_2$[ebp+1], dl
  00180	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00183	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00188	f7 e1		 mul	 ecx
  0018a	8b 45 e8	 mov	 eax, DWORD PTR tv1699[ebp]
  0018d	0f b6 c8	 movzx	 ecx, al
  00190	8b 45 d4	 mov	 eax, DWORD PTR tv1693[ebp]
  00193	0f b6 c0	 movzx	 eax, al
  00196	d1 ea		 shr	 edx, 1
  00198	88 55 ec	 mov	 BYTE PTR _col_2$[ebp], dl
  0019b	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0019e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001a3	f7 e1		 mul	 ecx
  001a5	8b 45 d0	 mov	 eax, DWORD PTR tv1701[ebp]
  001a8	0f b6 c8	 movzx	 ecx, al
  001ab	8b 45 cc	 mov	 eax, DWORD PTR tv1695[ebp]
  001ae	0f b6 c0	 movzx	 eax, al
  001b1	d1 ea		 shr	 edx, 1
  001b3	88 55 f2	 mov	 BYTE PTR _col_3$[ebp+2], dl
  001b6	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  001b9	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001be	f7 e1		 mul	 ecx
  001c0	0f b6 45 ff	 movzx	 eax, BYTE PTR tv1810[ebp]
  001c4	0f b6 4d 0b	 movzx	 ecx, BYTE PTR tv1801[ebp]
  001c8	d1 ea		 shr	 edx, 1
  001ca	88 55 f1	 mov	 BYTE PTR _col_3$[ebp+1], dl
  001cd	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  001d0	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  001d5	f7 e1		 mul	 ecx
  001d7	d1 ea		 shr	 edx, 1
  001d9	88 55 f0	 mov	 BYTE PTR _col_3$[ebp], dl

; 452  : 	}

  001dc	eb 29		 jmp	 SHORT $LN14@Decompress
$LN13@Decompress:

; 453  : 	else
; 454  : 	{
; 455  : 		// Three-color block: derive the other color.
; 456  : 		// 00 = color_0,  01 = color_1,  10 = color_2,
; 457  : 		// 11 = transparent.
; 458  : 		// These two bit codes correspond to the 2-bit fields
; 459  : 		// stored in the 64-bit block.
; 460  : 
; 461  : 		// explicit for each component, unlike some refrasts...
; 462  : 
; 463  : 		// Tracef("block has alpha\n");
; 464  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r) / 2);

  001de	03 c6		 add	 eax, esi

; 471  : 
; 472  : 		col_3->r = 0x00;		// random color to indicate alpha
; 473  : 		col_3->g = 0x00;

  001e0	66 c7 45 f1 00
	00		 mov	 WORD PTR _col_3$[ebp+1], 0
  001e6	d1 e8		 shr	 eax, 1
  001e8	88 45 ee	 mov	 BYTE PTR _col_2$[ebp+2], al
  001eb	8b 45 c4	 mov	 eax, DWORD PTR tv1804[ebp]
  001ee	03 c7		 add	 eax, edi

; 474  : 		col_3->b = 0x00;

  001f0	c6 45 f0 00	 mov	 BYTE PTR _col_3$[ebp], 0
  001f4	d1 e8		 shr	 eax, 1
  001f6	88 45 ed	 mov	 BYTE PTR _col_2$[ebp+1], al
  001f9	8b 45 e4	 mov	 eax, DWORD PTR tv1798[ebp]
  001fc	03 c2		 add	 eax, edx

; 475  : 		col_3->a = 0x00;

  001fe	c6 45 f3 00	 mov	 BYTE PTR _col_3$[ebp+3], 0
  00202	d1 e8		 shr	 eax, 1
  00204	88 45 ec	 mov	 BYTE PTR _col_2$[ebp], al
$LN14@Decompress:

; 810  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 811  : 
; 812  : 			// Decode the color block into the bitmap bits
; 813  : 			// inline func:
; 814  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 815  : 
; 816  : 			DecodeColorBlock(pImPos,

  00207	8b 45 dc	 mov	 eax, DWORD PTR tv1767[ebp]

; 497  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  0020a	8b 75 f4	 mov	 esi, DWORD PTR _col_0$[ebp]
  0020d	8b 7d f0	 mov	 edi, DWORD PTR _col_3$[ebp]

; 810  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 811  : 
; 812  : 			// Decode the color block into the bitmap bits
; 813  : 			// inline func:
; 814  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));
; 815  : 
; 816  : 			DecodeColorBlock(pImPos,

  00210	89 45 08	 mov	 DWORD PTR _pImPos$1$[ebp], eax

; 497  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  00213	b8 04 00 00 00	 mov	 eax, 4
  00218	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  0021b	0f 1f 44 00 00	 npad	 5
$LL19@Decompress:

; 498  : 	{
; 499  : 		// width * 4 bytes per pixel per line
; 500  : 		// each j dxtc row is 4 lines of pixels
; 501  : 
; 502  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 503  : 
; 504  : 		// n steps through pixels
; 505  : 		for (n = 0; n < 4; ++n)

  00220	33 d2		 xor	 edx, edx
  00222	89 55 e4	 mov	 DWORD PTR tv1807[ebp], edx
$LL22@Decompress:

; 506  : 		{
; 507  : 			bits = pColorBlock->row[y] & masks[n];

  00225	8b 4d bc	 mov	 ecx, DWORD PTR _pAlphaBlock$1$[ebp]
  00228	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  0022c	8b 44 15 8c	 mov	 eax, DWORD PTR _masks$2[ebp+edx]
  00230	23 c1		 and	 eax, ecx

; 508  : 			bits >>= shift[n];

  00232	8b 8c 15 7c ff
	ff ff		 mov	 ecx, DWORD PTR _shift$1[ebp+edx]
  00239	d3 e8		 shr	 eax, cl

; 509  : 
; 510  : 			switch (bits)

  0023b	83 f8 03	 cmp	 eax, 3
  0023e	77 29		 ja	 SHORT $LN29@Decompress
  00240	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN71@Decompress[eax*4]
$LN25@Decompress:

; 511  : 			{
; 512  : 				case 0:
; 513  : 					*pImPos = *col_0;

  00247	8b 45 08	 mov	 eax, DWORD PTR _pImPos$1$[ebp]
  0024a	89 30		 mov	 DWORD PTR [eax], esi

; 514  : 					pImPos++; // increment to next DWORD
; 515  : 					break;

  0024c	eb 2f		 jmp	 SHORT $LN20@Decompress
$LN26@Decompress:

; 516  : 
; 517  : 				case 1:
; 518  : 					*pImPos = *col_1;

  0024e	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$1$[ebp]
  00251	8b 45 e0	 mov	 eax, DWORD PTR _col_1$[ebp]
  00254	89 01		 mov	 DWORD PTR [ecx], eax

; 519  : 					pImPos++;
; 520  : 					break;

  00256	eb 22		 jmp	 SHORT $LN80@Decompress
$LN27@Decompress:

; 521  : 
; 522  : 				case 2:
; 523  : 					*pImPos = *col_2;

  00258	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$1$[ebp]
  0025b	8b 45 ec	 mov	 eax, DWORD PTR _col_2$[ebp]
  0025e	89 01		 mov	 DWORD PTR [ecx], eax

; 524  : 					pImPos++;
; 525  : 					break;

  00260	eb 18		 jmp	 SHORT $LN80@Decompress
$LN28@Decompress:

; 526  : 
; 527  : 				case 3:
; 528  : 					*pImPos = *col_3;

  00262	8b 45 08	 mov	 eax, DWORD PTR _pImPos$1$[ebp]
  00265	89 38		 mov	 DWORD PTR [eax], edi

; 529  : 					pImPos++;
; 530  : 					break;

  00267	eb 14		 jmp	 SHORT $LN20@Decompress
$LN29@Decompress:

; 531  : 
; 532  : 				default:
; 533  : 					Tracef("Your logic is jacked! bits == 0x%x\n", bits);

  00269	50		 push	 eax
  0026a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
  0026f	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00274	8b 55 e4	 mov	 edx, DWORD PTR tv1807[ebp]
  00277	83 c4 08	 add	 esp, 8
$LN80@Decompress:

; 498  : 	{
; 499  : 		// width * 4 bytes per pixel per line
; 500  : 		// each j dxtc row is 4 lines of pixels
; 501  : 
; 502  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 503  : 
; 504  : 		// n steps through pixels
; 505  : 		for (n = 0; n < 4; ++n)

  0027a	8b 45 08	 mov	 eax, DWORD PTR _pImPos$1$[ebp]
$LN20@Decompress:
  0027d	83 c0 04	 add	 eax, 4
  00280	83 c2 04	 add	 edx, 4
  00283	89 45 08	 mov	 DWORD PTR _pImPos$1$[ebp], eax
  00286	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00289	89 55 e4	 mov	 DWORD PTR tv1807[ebp], edx
  0028c	83 fa 10	 cmp	 edx, 16			; 00000010H
  0028f	7c 94		 jl	 SHORT $LL22@Decompress

; 495  : 
; 496  : 	// r steps through lines in y
; 497  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  00291	8b 55 08	 mov	 edx, DWORD PTR _pImPos$1$[ebp]
  00294	8b 45 c0	 mov	 eax, DWORD PTR _nWidth$1$[ebp]
  00297	8d 14 82	 lea	 edx, DWORD PTR [edx+eax*4]
  0029a	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0029d	40		 inc	 eax
  0029e	83 c2 f0	 add	 edx, -16		; fffffff0H
  002a1	89 55 08	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  002a4	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  002a7	83 f8 08	 cmp	 eax, 8
  002aa	0f 85 70 ff ff
	ff		 jne	 $LL19@Decompress

; 817  : 							 pBlock,
; 818  : 							 nWidth,
; 819  : 							 (DWORD *) &col_0, (DWORD *) &col_1, (DWORD *) &col_2, (DWORD *) &col_3);
; 820  : 
; 821  : 			// Overwrite the previous alpha bits with the alpha block
; 822  : 			//  info
; 823  : 			// inline func:
; 824  : 			DecodeAlphaExplicit(pImPos, pAlphaBlock, nWidth, alphazero);

  002b0	8b 75 dc	 mov	 esi, DWORD PTR tv1767[ebp]
  002b3	33 ff		 xor	 edi, edi
  002b5	8b 55 d8	 mov	 edx, DWORD PTR _alphazero$1$[ebp]
$LL34@Decompress:

; 562  : 		wrd = pAlphaBlock->row[row];

  002b8	8b 45 a4	 mov	 eax, DWORD PTR tv1790[ebp]
  002bb	0f b7 04 78	 movzx	 eax, WORD PTR [eax+edi*2]
  002bf	47		 inc	 edi
  002c0	89 45 08	 mov	 DWORD PTR _wrd$5[ebp], eax

; 563  : 
; 564  : 		// Tracef("0x%.8x\t\t", wrd);
; 565  : 		for (pix = 0; pix < 4; ++pix)
; 566  : 		{
; 567  : 			// zero the alpha bits of image pixel
; 568  : 			*pImPos &= alphazero;
; 569  : 
; 570  : 			col.a = (BYTE) (wrd & 0x000f);		// get only low 4 bits

  002c3	8a c8		 mov	 cl, al

; 571  : 			//			col.a <<= 4;				// shift to full byte precision
; 572  : 			// NOTE:  with just a << 4 you'll never have alpha
; 573  : 			// of 0xff,  0xf0 is max so pure shift doesn't quite
; 574  : 			// cover full alpha range.
; 575  : 			// It's much cheaper than divide & scale though.
; 576  : 			// To correct for this, and get 0xff for max alpha,
; 577  : 			//  or the low bits back in after left shifting
; 578  : 			col.a = (BYTE) (col.a | (col.a << 4));	// This allows max 4 bit alpha to be 0xff alpha

  002c5	24 0f		 and	 al, 15			; 0000000fH
  002c7	c0 e1 04	 shl	 cl, 4
  002ca	32 c1		 xor	 al, cl
  002cc	88 45 fb	 mov	 BYTE PTR _col$4[ebp+3], al
  002cf	8b 06		 mov	 eax, DWORD PTR [esi]
  002d1	23 c2		 and	 eax, edx

; 579  : 			//  in final image, and is crude approach to full
; 580  : 			//  range scale
; 581  : 
; 582  : 			*pImPos |= *((DWORD*)&col);	// or the bits into the prev. nulled alpha
; 583  : 
; 584  : 			wrd >>= 4; // move next bits to lowest 4

  002d3	66 8b 55 08	 mov	 dx, WORD PTR _wrd$5[ebp]
  002d7	0b 45 f8	 or	 eax, DWORD PTR _col$4[ebp]
  002da	89 06		 mov	 DWORD PTR [esi], eax
  002dc	66 c1 ea 04	 shr	 dx, 4
  002e0	8a ca		 mov	 cl, dl
  002e2	66 89 55 08	 mov	 WORD PTR _wrd$5[ebp], dx
  002e6	8a c1		 mov	 al, cl
  002e8	66 c1 ea 04	 shr	 dx, 4
  002ec	24 0f		 and	 al, 15			; 0000000fH
  002ee	c0 e1 04	 shl	 cl, 4
  002f1	32 c1		 xor	 al, cl
  002f3	66 89 55 08	 mov	 WORD PTR _wrd$5[ebp], dx
  002f7	88 45 fb	 mov	 BYTE PTR _col$4[ebp+3], al
  002fa	8a ca		 mov	 cl, dl
  002fc	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  002ff	23 45 d8	 and	 eax, DWORD PTR _alphazero$1$[ebp]
  00302	0b 45 f8	 or	 eax, DWORD PTR _col$4[ebp]
  00305	8b 55 d8	 mov	 edx, DWORD PTR _alphazero$1$[ebp]
  00308	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0030b	8a c1		 mov	 al, cl
  0030d	24 0f		 and	 al, 15			; 0000000fH
  0030f	c0 e1 04	 shl	 cl, 4
  00312	32 c1		 xor	 al, cl
  00314	8b 4d 08	 mov	 ecx, DWORD PTR _wrd$5[ebp]
  00317	88 45 fb	 mov	 BYTE PTR _col$4[ebp+3], al
  0031a	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0031d	23 c2		 and	 eax, edx
  0031f	c1 e9 04	 shr	 ecx, 4
  00322	0b 45 f8	 or	 eax, DWORD PTR _col$4[ebp]
  00325	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00328	8a c1		 mov	 al, cl
  0032a	c0 e0 04	 shl	 al, 4
  0032d	0a c1		 or	 al, cl
  0032f	8b 4d c0	 mov	 ecx, DWORD PTR _nWidth$1$[ebp]
  00332	88 45 fb	 mov	 BYTE PTR _col$4[ebp+3], al
  00335	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00338	23 c2		 and	 eax, edx
  0033a	0b 45 f8	 or	 eax, DWORD PTR _col$4[ebp]
  0033d	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00340	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00347	03 f0		 add	 esi, eax
  00349	83 ff 04	 cmp	 edi, 4
  0034c	0f 8c 66 ff ff
	ff		 jl	 $LL34@Decompress

; 800  : 
; 801  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00352	8b 75 bc	 mov	 esi, DWORD PTR _pAlphaBlock$1$[ebp]
  00355	83 45 dc 40	 add	 DWORD PTR tv1767[ebp], 64 ; 00000040H
  00359	83 c6 08	 add	 esi, 8
  0035c	83 6d b8 01	 sub	 DWORD PTR tv1791[ebp], 1
  00360	0f 85 5a fd ff
	ff		 jne	 $LL7@Decompress
  00366	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000
  0036d	8b 7d ac	 mov	 edi, DWORD PTR _yblocks$1$[ebp]
  00370	8b 45 b0	 mov	 eax, DWORD PTR _pPos$1$[ebp]
  00373	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwDest$[ebp]
  00376	8b 55 b4	 mov	 edx, DWORD PTR _xblocks$1$[ebp]
$LN2@Decompress:

; 794  : 
; 795  : 	for (y = 0; y < yblocks; ++y)

  00379	03 45 a0	 add	 eax, DWORD PTR tv1764[ebp]
  0037c	03 4d 9c	 add	 ecx, DWORD PTR tv1765[ebp]
  0037f	83 ef 01	 sub	 edi, 1
  00382	89 45 b0	 mov	 DWORD PTR _pPos$1$[ebp], eax
  00385	89 4d 0c	 mov	 DWORD PTR _pdwDest$[ebp], ecx
  00388	89 7d ac	 mov	 DWORD PTR _yblocks$1$[ebp], edi
  0038b	0f 85 df fc ff
	ff		 jne	 $LL4@Decompress
$LN3@Decompress:
  00391	5f		 pop	 edi

; 825  : 		}
; 826  : 	}
; 827  : }

  00392	5e		 pop	 esi
  00393	8b e5		 mov	 esp, ebp
  00395	5d		 pop	 ebp
  00396	c2 08 00	 ret	 8
  00399	0f 1f 00	 npad	 3
$LN71@Decompress:
  0039c	00 00 00 00	 DD	 $LN25@Decompress
  003a0	00 00 00 00	 DD	 $LN26@Decompress
  003a4	00 00 00 00	 DD	 $LN27@Decompress
  003a8	00 00 00 00	 DD	 $LN28@Decompress
?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT3
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_shift$1 = -116						; size = 16
_masks$2 = -100						; size = 16
tv1119 = -84						; size = 4
_nWidth$1$ = -80					; size = 4
tv1102 = -76						; size = 4
_yblocks$1$ = -72					; size = 4
_pPos$1$ = -68						; size = 4
_xblocks$1$ = -64					; size = 4
tv1138 = -60						; size = 4
tv1108 = -56						; size = 4
tv1140 = -56						; size = 4
tv1104 = -52						; size = 4
tv1106 = -48						; size = 4
tv1049 = -44						; size = 4
tv1054 = -40						; size = 4
tv1047 = -36						; size = 4
_pBlock$1$ = -32					; size = 4
tv1122 = -28						; size = 4
tv1052 = -24						; size = 4
$T3 = -24						; size = 4
_col_1$ = -20						; size = 4
_col_0$ = -16						; size = 4
_col_2$ = -12						; size = 4
_col_3$ = -8						; size = 4
tv1103 = -1						; size = 1
_miplevel$ = 8						; size = 4
_pImPos$1$ = 8						; size = 4
tv1109 = 11						; size = 1
_pdwDest$ = 12						; size = 4
?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT1, COMDAT
; _this$ = ecx

; 697  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	8b d1		 mov	 edx, ecx

; 698  : 	// This was hacked up pretty quick & slopily
; 699  : 	// decompresses to 32 bit format 0xARGB
; 700  : 	int xblocks, yblocks;
; 701  : #ifdef DEBUG
; 702  : 	if ((ddsd.dwWidth % 4) != 0)
; 703  : 	{
; 704  : 		Tracef("****** warning width not div by 4!  %d\n", ddsd.dwWidth);
; 705  : 	}
; 706  : 
; 707  : 	if ((ddsd.dwHeight % 4) != 0)
; 708  : 	{
; 709  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 710  : 	}
; 711  : 
; 712  : 	Tracef("end check\n");
; 713  : #endif
; 714  : 	UINT nWidth = m_nWidth >> miplevel;

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b b2 00 01 00
	00		 mov	 esi, DWORD PTR [edx+256]

; 715  : 	UINT nHeight = m_nHeight >> miplevel;

  00013	8b ba 04 01 00
	00		 mov	 edi, DWORD PTR [edx+260]
  00019	d3 fe		 sar	 esi, cl

; 716  : 
; 717  : 	xblocks = nWidth / 4;

  0001b	8b c6		 mov	 eax, esi
  0001d	d3 ff		 sar	 edi, cl
  0001f	c1 e8 02	 shr	 eax, 2
  00022	89 45 c0	 mov	 DWORD PTR _xblocks$1$[ebp], eax

; 718  : 	yblocks = nHeight / 4;
; 719  : 
; 720  : 	int		x, y;
; 721  : 	DWORD * pBase	= (DWORD *) pdwDest;
; 722  : 	WORD  * pPos	= (WORD *) &m_bCompVector[miplevel][0];;	// pos in compressed data

  00025	8d 04 49	 lea	 eax, DWORD PTR [ecx+ecx*2]
  00028	8b 44 82 34	 mov	 eax, DWORD PTR [edx+eax*4+52]
  0002c	c1 ef 02	 shr	 edi, 2
  0002f	89 75 b0	 mov	 DWORD PTR _nWidth$1$[ebp], esi
  00032	89 7d b8	 mov	 DWORD PTR _yblocks$1$[ebp], edi
  00035	89 45 bc	 mov	 DWORD PTR _pPos$1$[ebp], eax

; 723  : 	DWORD * pImPos;
; 724  : 
; 725  : 	DXTColBlock	* pBlock;
; 726  : 
; 727  : 	Color8888 col_0, col_1, col_2, col_3;
; 728  : 	WORD wrd;
; 729  : 
; 730  : 	for (y = 0; y < yblocks; ++y)

  00038	85 ff		 test	 edi, edi
  0003a	0f 84 7f 02 00
	00		 je	 $LN3@Decompress

; 698  : 	// This was hacked up pretty quick & slopily
; 699  : 	// decompresses to 32 bit format 0xARGB
; 700  : 	int xblocks, yblocks;
; 701  : #ifdef DEBUG
; 702  : 	if ((ddsd.dwWidth % 4) != 0)
; 703  : 	{
; 704  : 		Tracef("****** warning width not div by 4!  %d\n", ddsd.dwWidth);
; 705  : 	}
; 706  : 
; 707  : 	if ((ddsd.dwHeight % 4) != 0)
; 708  : 	{
; 709  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 710  : 	}
; 711  : 
; 712  : 	Tracef("end check\n");
; 713  : #endif
; 714  : 	UINT nWidth = m_nWidth >> miplevel;

  00040	8b 55 c0	 mov	 edx, DWORD PTR _xblocks$1$[ebp]
  00043	8b ce		 mov	 ecx, esi
  00045	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000
  0004c	c1 e1 04	 shl	 ecx, 4
  0004f	89 4d ac	 mov	 DWORD PTR tv1119[ebp], ecx
  00052	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwDest$[ebp]
$LL4@Decompress:

; 731  : 	{
; 732  : 		// 8 bytes per block
; 733  : 		pBlock = (DXTColBlock *) ((DWORD) pPos + y * xblocks * 8);

  00055	8b f0		 mov	 esi, eax
  00057	89 75 e0	 mov	 DWORD PTR _pBlock$1$[ebp], esi

; 734  : 
; 735  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  0005a	85 d2		 test	 edx, edx
  0005c	0f 84 3f 02 00
	00		 je	 $LN2@Decompress

; 408  : 	col_0->a = 0xff;

  00062	c6 45 f3 ff	 mov	 BYTE PTR _col_0$[ebp+3], 255 ; 000000ffH

; 415  : 
; 416  : 	pCol = (Color565*) & (pBlock->col1);
; 417  : 	col_1->a = 0xff;

  00066	c6 45 ef ff	 mov	 BYTE PTR _col_1$[ebp+3], 255 ; 000000ffH

; 465  : 		col_2->r = (BYTE)wrd;
; 466  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g) / 2);
; 467  : 		col_2->g = (BYTE)wrd;
; 468  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b) / 2);
; 469  : 		col_2->b = (BYTE)wrd;
; 470  : 		col_2->a = 0xff;

  0006a	c6 45 f7 ff	 mov	 BYTE PTR _col_2$[ebp+3], 255 ; 000000ffH

; 493  : 	const DWORD masks[] = { 3, 12, 3 << 4, 3 << 6 };

  0006e	c7 45 9c 03 00
	00 00		 mov	 DWORD PTR _masks$2[ebp], 3
  00075	c7 45 a0 0c 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+4], 12 ; 0000000cH
  0007c	c7 45 a4 30 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+8], 48 ; 00000030H
  00083	c7 45 a8 c0 00
	00 00		 mov	 DWORD PTR _masks$2[ebp+12], 192 ; 000000c0H

; 494  : 	const int   shift[] = { 0, 2, 4, 6 };

  0008a	0f 11 45 8c	 movups	 XMMWORD PTR _shift$1[ebp], xmm0

; 731  : 	{
; 732  : 		// 8 bytes per block
; 733  : 		pBlock = (DXTColBlock *) ((DWORD) pPos + y * xblocks * 8);

  0008e	89 4d e4	 mov	 DWORD PTR tv1122[ebp], ecx
  00091	89 55 c4	 mov	 DWORD PTR tv1138[ebp], edx
$LL7@Decompress:

; 409  : 	col_0->r = pCol->nRed;

  00094	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 410  : 	col_0->r <<= 3;				// shift to full precision
; 411  : 	col_0->g = pCol->nGreen;

  00096	8b c1		 mov	 eax, ecx
  00098	c1 e8 05	 shr	 eax, 5
  0009b	8b d1		 mov	 edx, ecx
  0009d	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  000a0	c0 e2 03	 shl	 dl, 3
  000a3	89 55 dc	 mov	 DWORD PTR tv1047[ebp], edx
  000a6	88 55 f2	 mov	 BYTE PTR _col_0$[ebp+2], dl

; 412  : 	col_0->g <<= 2;

  000a9	c0 e0 02	 shl	 al, 2
  000ac	89 45 d4	 mov	 DWORD PTR tv1049[ebp], eax
  000af	88 45 f1	 mov	 BYTE PTR _col_0$[ebp+1], al

; 413  : 	col_0->b = pCol->nBlue;
; 414  : 	col_0->b <<= 3;

  000b2	8a c1		 mov	 al, cl
  000b4	c0 e0 03	 shl	 al, 3
  000b7	88 45 ff	 mov	 BYTE PTR tv1103[ebp], al
  000ba	88 45 f0	 mov	 BYTE PTR _col_0$[ebp], al

; 418  : 	col_1->r = pCol->nRed;

  000bd	8b 46 02	 mov	 eax, DWORD PTR [esi+2]
  000c0	8b d0		 mov	 edx, eax
  000c2	c1 ea 0b	 shr	 edx, 11			; 0000000bH

; 419  : 	col_1->r <<= 3;				// shift to full precision

  000c5	c0 e2 03	 shl	 dl, 3
  000c8	89 55 e8	 mov	 DWORD PTR tv1052[ebp], edx
  000cb	88 55 ee	 mov	 BYTE PTR _col_1$[ebp+2], dl

; 420  : 	col_1->g = pCol->nGreen;

  000ce	8b d0		 mov	 edx, eax
  000d0	c1 ea 05	 shr	 edx, 5

; 421  : 	col_1->g <<= 2;

  000d3	c0 e2 02	 shl	 dl, 2
  000d6	89 55 d8	 mov	 DWORD PTR tv1054[ebp], edx
  000d9	88 55 ed	 mov	 BYTE PTR _col_1$[ebp+1], dl

; 422  : 	col_1->b = pCol->nBlue;
; 423  : 	col_1->b <<= 3;

  000dc	8a d0		 mov	 dl, al
  000de	c0 e2 03	 shl	 dl, 3

; 424  : 
; 425  : 	if (pBlock->col0 > pBlock->col1)

  000e1	66 3b c8	 cmp	 cx, ax
  000e4	88 55 0b	 mov	 BYTE PTR tv1109[ebp], dl
  000e7	88 55 ec	 mov	 BYTE PTR _col_1$[ebp], dl
  000ea	8b 55 e8	 mov	 edx, DWORD PTR tv1052[ebp]
  000ed	0f b6 f2	 movzx	 esi, dl
  000f0	8b 55 d8	 mov	 edx, DWORD PTR tv1054[ebp]
  000f3	0f b6 fa	 movzx	 edi, dl
  000f6	0f b6 55 0b	 movzx	 edx, BYTE PTR tv1109[ebp]
  000fa	89 55 c8	 mov	 DWORD PTR tv1108[ebp], edx
  000fd	8b 55 dc	 mov	 edx, DWORD PTR tv1047[ebp]
  00100	0f b6 d2	 movzx	 edx, dl
  00103	89 55 d0	 mov	 DWORD PTR tv1106[ebp], edx
  00106	8b 55 d4	 mov	 edx, DWORD PTR tv1049[ebp]
  00109	8b 45 d0	 mov	 eax, DWORD PTR tv1106[ebp]
  0010c	0f b6 d2	 movzx	 edx, dl
  0010f	89 55 cc	 mov	 DWORD PTR tv1104[ebp], edx
  00112	0f b6 55 ff	 movzx	 edx, BYTE PTR tv1103[ebp]
  00116	89 55 b4	 mov	 DWORD PTR tv1102[ebp], edx
  00119	0f 86 89 00 00
	00		 jbe	 $LN13@Decompress

; 426  : 	{
; 427  : 		// Four-color block: derive the other two colors.
; 428  : 		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
; 429  : 		// These two bit codes correspond to the 2-bit fields
; 430  : 		// stored in the 64-bit block.
; 431  : 		wrd = (WORD) (((WORD) col_0->r * 2 + (WORD) col_1->r) / 3);

  0011f	8d 0c 46	 lea	 ecx, DWORD PTR [esi+eax*2]

; 432  : 		// no +1 for rounding
; 433  : 		// as bits have been shifted to 888
; 434  : 		col_2->r = (BYTE)wrd;
; 435  : 
; 436  : 		wrd = (WORD) (((WORD) col_0->g * 2 + (WORD) col_1->g) / 3);
; 437  : 		col_2->g = (BYTE)wrd;
; 438  : 
; 439  : 		wrd = (WORD) (((WORD) col_0->b * 2 + (WORD) col_1->b) / 3);
; 440  : 		col_2->b = (BYTE)wrd;
; 441  : 		col_2->a = 0xff;
; 442  : 
; 443  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r * 2) / 3);
; 444  : 		col_3->r = (BYTE)wrd;
; 445  : 
; 446  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g * 2) / 3);
; 447  : 		col_3->g = (BYTE)wrd;
; 448  : 
; 449  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b * 2) / 3);
; 450  : 		col_3->b = (BYTE)wrd;
; 451  : 		col_3->a = 0xff;

  00122	c6 45 fb ff	 mov	 BYTE PTR _col_3$[ebp+3], 255 ; 000000ffH
  00126	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0012b	f7 e1		 mul	 ecx
  0012d	8b 45 cc	 mov	 eax, DWORD PTR tv1104[ebp]
  00130	d1 ea		 shr	 edx, 1
  00132	88 55 f6	 mov	 BYTE PTR _col_2$[ebp+2], dl
  00135	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]
  00138	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0013d	f7 e1		 mul	 ecx
  0013f	8b 45 c8	 mov	 eax, DWORD PTR tv1108[ebp]
  00142	8b 4d b4	 mov	 ecx, DWORD PTR tv1102[ebp]
  00145	d1 ea		 shr	 edx, 1
  00147	88 55 f5	 mov	 BYTE PTR _col_2$[ebp+1], dl
  0014a	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0014d	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00152	f7 e1		 mul	 ecx
  00154	8b 45 e8	 mov	 eax, DWORD PTR tv1052[ebp]
  00157	0f b6 c8	 movzx	 ecx, al
  0015a	8b 45 dc	 mov	 eax, DWORD PTR tv1047[ebp]
  0015d	0f b6 c0	 movzx	 eax, al
  00160	d1 ea		 shr	 edx, 1
  00162	88 55 f4	 mov	 BYTE PTR _col_2$[ebp], dl
  00165	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00168	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0016d	f7 e1		 mul	 ecx
  0016f	8b 45 d8	 mov	 eax, DWORD PTR tv1054[ebp]
  00172	0f b6 c8	 movzx	 ecx, al
  00175	8b 45 d4	 mov	 eax, DWORD PTR tv1049[ebp]
  00178	0f b6 c0	 movzx	 eax, al
  0017b	d1 ea		 shr	 edx, 1
  0017d	88 55 fa	 mov	 BYTE PTR _col_3$[ebp+2], dl
  00180	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00183	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00188	f7 e1		 mul	 ecx
  0018a	0f b6 45 ff	 movzx	 eax, BYTE PTR tv1103[ebp]
  0018e	0f b6 4d 0b	 movzx	 ecx, BYTE PTR tv1109[ebp]
  00192	d1 ea		 shr	 edx, 1
  00194	88 55 f9	 mov	 BYTE PTR _col_3$[ebp+1], dl
  00197	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  0019a	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0019f	f7 e1		 mul	 ecx
  001a1	d1 ea		 shr	 edx, 1
  001a3	88 55 f8	 mov	 BYTE PTR _col_3$[ebp], dl

; 452  : 	}

  001a6	eb 29		 jmp	 SHORT $LN14@Decompress
$LN13@Decompress:

; 453  : 	else
; 454  : 	{
; 455  : 		// Three-color block: derive the other color.
; 456  : 		// 00 = color_0,  01 = color_1,  10 = color_2,
; 457  : 		// 11 = transparent.
; 458  : 		// These two bit codes correspond to the 2-bit fields
; 459  : 		// stored in the 64-bit block.
; 460  : 
; 461  : 		// explicit for each component, unlike some refrasts...
; 462  : 
; 463  : 		// Tracef("block has alpha\n");
; 464  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r) / 2);

  001a8	03 c6		 add	 eax, esi

; 471  : 
; 472  : 		col_3->r = 0x00;		// random color to indicate alpha
; 473  : 		col_3->g = 0x00;

  001aa	66 c7 45 f9 00
	00		 mov	 WORD PTR _col_3$[ebp+1], 0
  001b0	d1 e8		 shr	 eax, 1
  001b2	88 45 f6	 mov	 BYTE PTR _col_2$[ebp+2], al
  001b5	8b 45 cc	 mov	 eax, DWORD PTR tv1104[ebp]
  001b8	03 c7		 add	 eax, edi

; 474  : 		col_3->b = 0x00;

  001ba	c6 45 f8 00	 mov	 BYTE PTR _col_3$[ebp], 0
  001be	d1 e8		 shr	 eax, 1
  001c0	88 45 f5	 mov	 BYTE PTR _col_2$[ebp+1], al
  001c3	8b 45 c8	 mov	 eax, DWORD PTR tv1108[ebp]
  001c6	03 c2		 add	 eax, edx

; 475  : 		col_3->a = 0x00;

  001c8	c6 45 fb 00	 mov	 BYTE PTR _col_3$[ebp+3], 0
  001cc	d1 e8		 shr	 eax, 1
  001ce	88 45 f4	 mov	 BYTE PTR _col_2$[ebp], al
$LN14@Decompress:

; 736  : 		{
; 737  : 			// inline func:
; 738  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 739  : 
; 740  : 			pImPos = (DWORD *) ((DWORD) pBase + x*16 + (y*4) * nWidth * 4);
; 741  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  001d1	8b 45 e4	 mov	 eax, DWORD PTR tv1122[ebp]

; 497  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001d4	8b 75 f8	 mov	 esi, DWORD PTR _col_3$[ebp]
  001d7	8b 7d f4	 mov	 edi, DWORD PTR _col_2$[ebp]

; 736  : 		{
; 737  : 			// inline func:
; 738  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);
; 739  : 
; 740  : 			pImPos = (DWORD *) ((DWORD) pBase + x*16 + (y*4) * nWidth * 4);
; 741  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  001da	89 45 08	 mov	 DWORD PTR _pImPos$1$[ebp], eax

; 497  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  001dd	b8 04 00 00 00	 mov	 eax, 4
  001e2	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
$LL19@Decompress:

; 498  : 	{
; 499  : 		// width * 4 bytes per pixel per line
; 500  : 		// each j dxtc row is 4 lines of pixels
; 501  : 
; 502  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 503  : 
; 504  : 		// n steps through pixels
; 505  : 		for (n = 0; n < 4; ++n)

  001e5	33 d2		 xor	 edx, edx
  001e7	89 55 c8	 mov	 DWORD PTR tv1140[ebp], edx
  001ea	66 0f 1f 44 00
	00		 npad	 6
$LL22@Decompress:

; 506  : 		{
; 507  : 			bits = pColorBlock->row[y] & masks[n];

  001f0	8b 4d e0	 mov	 ecx, DWORD PTR _pBlock$1$[ebp]
  001f3	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  001f7	8b 44 15 9c	 mov	 eax, DWORD PTR _masks$2[ebp+edx]
  001fb	23 c1		 and	 eax, ecx

; 508  : 			bits >>= shift[n];

  001fd	8b 4c 15 8c	 mov	 ecx, DWORD PTR _shift$1[ebp+edx]
  00201	d3 e8		 shr	 eax, cl

; 509  : 
; 510  : 			switch (bits)

  00203	83 f8 03	 cmp	 eax, 3
  00206	77 29		 ja	 SHORT $LN29@Decompress
  00208	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN47@Decompress[eax*4]
$LN25@Decompress:

; 511  : 			{
; 512  : 				case 0:
; 513  : 					*pImPos = *col_0;

  0020f	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$1$[ebp]
  00212	8b 45 f0	 mov	 eax, DWORD PTR _col_0$[ebp]
  00215	89 01		 mov	 DWORD PTR [ecx], eax

; 514  : 					pImPos++; // increment to next DWORD
; 515  : 					break;

  00217	eb 29		 jmp	 SHORT $LN55@Decompress
$LN26@Decompress:

; 516  : 
; 517  : 				case 1:
; 518  : 					*pImPos = *col_1;

  00219	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$1$[ebp]
  0021c	8b 45 ec	 mov	 eax, DWORD PTR _col_1$[ebp]
  0021f	89 01		 mov	 DWORD PTR [ecx], eax

; 519  : 					pImPos++;
; 520  : 					break;

  00221	eb 1f		 jmp	 SHORT $LN55@Decompress
$LN27@Decompress:

; 521  : 
; 522  : 				case 2:
; 523  : 					*pImPos = *col_2;

  00223	8b 45 08	 mov	 eax, DWORD PTR _pImPos$1$[ebp]
  00226	89 38		 mov	 DWORD PTR [eax], edi

; 524  : 					pImPos++;
; 525  : 					break;

  00228	eb 1b		 jmp	 SHORT $LN20@Decompress
$LN28@Decompress:

; 526  : 
; 527  : 				case 3:
; 528  : 					*pImPos = *col_3;

  0022a	8b 45 08	 mov	 eax, DWORD PTR _pImPos$1$[ebp]
  0022d	89 30		 mov	 DWORD PTR [eax], esi

; 529  : 					pImPos++;
; 530  : 					break;

  0022f	eb 14		 jmp	 SHORT $LN20@Decompress
$LN29@Decompress:

; 531  : 
; 532  : 				default:
; 533  : 					Tracef("Your logic is jacked! bits == 0x%x\n", bits);

  00231	50		 push	 eax
  00232	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
  00237	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0023c	8b 55 c8	 mov	 edx, DWORD PTR tv1140[ebp]
  0023f	83 c4 08	 add	 esp, 8
$LN55@Decompress:

; 498  : 	{
; 499  : 		// width * 4 bytes per pixel per line
; 500  : 		// each j dxtc row is 4 lines of pixels
; 501  : 
; 502  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 503  : 
; 504  : 		// n steps through pixels
; 505  : 		for (n = 0; n < 4; ++n)

  00242	8b 45 08	 mov	 eax, DWORD PTR _pImPos$1$[ebp]
$LN20@Decompress:
  00245	83 c0 04	 add	 eax, 4
  00248	83 c2 04	 add	 edx, 4
  0024b	89 45 08	 mov	 DWORD PTR _pImPos$1$[ebp], eax
  0024e	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00251	89 55 c8	 mov	 DWORD PTR tv1140[ebp], edx
  00254	83 fa 10	 cmp	 edx, 16			; 00000010H
  00257	7c 97		 jl	 SHORT $LL22@Decompress

; 495  : 
; 496  : 	// r steps through lines in y
; 497  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  00259	8b 55 08	 mov	 edx, DWORD PTR _pImPos$1$[ebp]
  0025c	8b 45 b0	 mov	 eax, DWORD PTR _nWidth$1$[ebp]
  0025f	8d 14 82	 lea	 edx, DWORD PTR [edx+eax*4]
  00262	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00265	40		 inc	 eax
  00266	83 c2 f0	 add	 edx, -16		; fffffff0H
  00269	89 55 08	 mov	 DWORD PTR _pImPos$1$[ebp], edx
  0026c	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  0026f	83 f8 08	 cmp	 eax, 8
  00272	0f 85 6d ff ff
	ff		 jne	 $LL19@Decompress

; 734  : 
; 735  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00278	8b 75 e0	 mov	 esi, DWORD PTR _pBlock$1$[ebp]
  0027b	83 45 e4 10	 add	 DWORD PTR tv1122[ebp], 16 ; 00000010H
  0027f	03 f0		 add	 esi, eax
  00281	83 6d c4 01	 sub	 DWORD PTR tv1138[ebp], 1
  00285	89 75 e0	 mov	 DWORD PTR _pBlock$1$[ebp], esi
  00288	0f 85 06 fe ff
	ff		 jne	 $LL7@Decompress
  0028e	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR __xmm@00000006000000040000000200000000
  00295	8b 7d b8	 mov	 edi, DWORD PTR _yblocks$1$[ebp]
  00298	8b 45 bc	 mov	 eax, DWORD PTR _pPos$1$[ebp]
  0029b	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwDest$[ebp]
  0029e	8b 55 c0	 mov	 edx, DWORD PTR _xblocks$1$[ebp]
$LN2@Decompress:

; 723  : 	DWORD * pImPos;
; 724  : 
; 725  : 	DXTColBlock	* pBlock;
; 726  : 
; 727  : 	Color8888 col_0, col_1, col_2, col_3;
; 728  : 	WORD wrd;
; 729  : 
; 730  : 	for (y = 0; y < yblocks; ++y)

  002a1	03 4d ac	 add	 ecx, DWORD PTR tv1119[ebp]
  002a4	8d 34 d5 00 00
	00 00		 lea	 esi, DWORD PTR [edx*8]
  002ab	03 c6		 add	 eax, esi
  002ad	89 4d 0c	 mov	 DWORD PTR _pdwDest$[ebp], ecx
  002b0	83 ef 01	 sub	 edi, 1
  002b3	89 45 bc	 mov	 DWORD PTR _pPos$1$[ebp], eax
  002b6	89 7d b8	 mov	 DWORD PTR _yblocks$1$[ebp], edi
  002b9	0f 85 96 fd ff
	ff		 jne	 $LL4@Decompress
$LN3@Decompress:
  002bf	5f		 pop	 edi

; 742  : 			// Set to RGB test pattern
; 743  : 			//	pImPos = (DWORD*) ((DWORD) pBase + i * 4 + j * m_nWidth * 4);
; 744  : 			//	*pImPos = ((i * 4) << 16) | ((j * 4) << 8) | ((63 - i) * 4);
; 745  : 
; 746  : 			// checkerboard of only col_0 and col_1 basis colors:
; 747  : 			//	pImPos = (DWORD *) ((DWORD) pBase + i * 8 + j * m_nWidth * 8);
; 748  : 			//	*pImPos = *((DWORD *) &col_0);
; 749  : 			//	pImPos += 1 + m_nWidth;
; 750  : 			//	*pImPos = *((DWORD *) &col_1);
; 751  : 		}
; 752  : 	}
; 753  : }

  002c0	5e		 pop	 esi
  002c1	8b e5		 mov	 esp, ebp
  002c3	5d		 pop	 ebp
  002c4	c2 08 00	 ret	 8
  002c7	90		 npad	 1
$LN47@Decompress:
  002c8	00 00 00 00	 DD	 $LN25@Decompress
  002cc	00 00 00 00	 DD	 $LN26@Decompress
  002d0	00 00 00 00	 DD	 $LN27@Decompress
  002d4	00 00 00 00	 DD	 $LN28@Decompress
?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT1
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Decompress@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_miplevel$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?Decompress@CDXTCImage@@QAEXHPAK@Z PROC			; CDXTCImage::Decompress, COMDAT
; _this$ = ecx

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 366  : 	switch (m_CompFormat)

  00003	8b 81 ec 00 00
	00		 mov	 eax, DWORD PTR [ecx+236]
  00009	83 f8 05	 cmp	 eax, 5
  0000c	77 1f		 ja	 SHORT $LN8@Decompress
  0000e	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN10@Decompress[eax*4]
$LN4@Decompress:

; 382  : 			break;
; 383  : 
; 384  : 		case PF_UNKNOWN:
; 385  : 			break;
; 386  : 	}
; 387  : }

  00015	5d		 pop	 ebp

; 367  : 	{
; 368  : 		case PF_DXT1:
; 369  : 			DecompressDXT1(miplevel, pdwDest);

  00016	e9 00 00 00 00	 jmp	 ?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT1
$LN5@Decompress:

; 382  : 			break;
; 383  : 
; 384  : 		case PF_UNKNOWN:
; 385  : 			break;
; 386  : 	}
; 387  : }

  0001b	5d		 pop	 ebp

; 370  : 			break;
; 371  : 
; 372  : 		case PF_DXT3:
; 373  : 			DecompressDXT3(miplevel, pdwDest);

  0001c	e9 00 00 00 00	 jmp	 ?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT3
$LN6@Decompress:

; 382  : 			break;
; 383  : 
; 384  : 		case PF_UNKNOWN:
; 385  : 			break;
; 386  : 	}
; 387  : }

  00021	5d		 pop	 ebp

; 374  : 			break;
; 375  : 
; 376  : 		case PF_DXT5:
; 377  : 			DecompressDXT5(miplevel, pdwDest);

  00022	e9 00 00 00 00	 jmp	 ?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT5
$LN7@Decompress:

; 382  : 			break;
; 383  : 
; 384  : 		case PF_UNKNOWN:
; 385  : 			break;
; 386  : 	}
; 387  : }

  00027	5d		 pop	 ebp

; 378  : 			break;
; 379  : 
; 380  : 		case PF_ARGB:
; 381  : 			DecompressARGB(miplevel, pdwDest);

  00028	e9 00 00 00 00	 jmp	 ?DecompressARGB@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressARGB
$LN8@Decompress:

; 382  : 			break;
; 383  : 
; 384  : 		case PF_UNKNOWN:
; 385  : 			break;
; 386  : 	}
; 387  : }

  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
  00031	0f 1f 00	 npad	 3
$LN10@Decompress:
  00034	00 00 00 00	 DD	 $LN7@Decompress
  00038	00 00 00 00	 DD	 $LN4@Decompress
  0003c	00 00 00 00	 DD	 $LN8@Decompress
  00040	00 00 00 00	 DD	 $LN5@Decompress
  00044	00 00 00 00	 DD	 $LN8@Decompress
  00048	00 00 00 00	 DD	 $LN6@Decompress
?Decompress@CDXTCImage@@QAEXHPAK@Z ENDP			; CDXTCImage::Decompress
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Copy@CDXTCImage@@QAE_NHPAEJ@Z
_TEXT	SEGMENT
_miplevel$ = 8						; size = 4
_pbDest$ = 12						; size = 4
_lDestPitch$ = 16					; size = 4
?Copy@CDXTCImage@@QAE_NHPAEJ@Z PROC			; CDXTCImage::Copy, COMDAT
; _this$ = ecx

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 312  : 	if (!(m_dwFlags & DDSD_MIPMAPCOUNT))

  00003	8b 55 08	 mov	 edx, DWORD PTR _miplevel$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	f7 86 fc 00 00
	00 00 00 02 00	 test	 DWORD PTR [esi+252], 131072 ; 00020000H
  00013	75 0b		 jne	 SHORT $LN3@Copy

; 313  : 		if (miplevel)

  00015	85 d2		 test	 edx, edx
  00017	74 07		 je	 SHORT $LN3@Copy

; 314  : 			return false;

  00019	32 c0		 xor	 al, al
  0001b	5e		 pop	 esi

; 335  : }

  0001c	5d		 pop	 ebp
  0001d	c2 0c 00	 ret	 12			; 0000000cH
$LN3@Copy:

; 315  : 
; 316  : 	/*
; 317  : 	DXTColBlock * pBlock;
; 318  : 	WORD * pPos = (WORD *) &m_pbCompBufferByLevels[miplevel][0];
; 319  : 	int xblocks = (m_nWidth >> miplevel) / 4;
; 320  : 	int yblocks = (m_nHeight >> miplevel) / 4;
; 321  : 
; 322  : 	for (int y = 0; y < yblocks; ++y)
; 323  : 	{
; 324  : 		// 8 bytes per block
; 325  : 		pBlock = (DXTColBlock*) ((DWORD) pPos + y * xblocks * 8);
; 326  : 
; 327  : 		memcpy(pbDest, pBlock, xblocks * 8);
; 328  : 		pbDest += lDestPitch;
; 329  : 	}
; 330  : 	*/
; 331  : 
; 332  : 	memcpy(pbDest, m_pbCompBufferByLevels[miplevel], m_lPitch >> (miplevel * 2));

  00020	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  00026	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  00029	d3 f8		 sar	 eax, cl
  0002b	50		 push	 eax
  0002c	ff 74 96 04	 push	 DWORD PTR [esi+edx*4+4]
  00030	ff 75 0c	 push	 DWORD PTR _pbDest$[ebp]
  00033	e8 00 00 00 00	 call	 _memcpy
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH

; 333  : 	pbDest += lDestPitch;
; 334  : 	return true;

  0003b	b0 01		 mov	 al, 1
  0003d	5e		 pop	 esi

; 335  : }

  0003e	5d		 pop	 ebp
  0003f	c2 0c 00	 ret	 12			; 0000000cH
?Copy@CDXTCImage@@QAE_NHPAEJ@Z ENDP			; CDXTCImage::Copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBEI@Z
_TEXT	SEGMENT
_ddsd$ = -128						; size = 124
_this$1$ = -4						; size = 4
_c_pbMap$ = 8						; size = 4
_fileSize$ = 12						; size = 4
?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBEI@Z PROC	; CDXTCImage::LoadHeaderFromMemory, COMDAT
; _this$ = ecx

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H

; 136  : 	//////////////////////////////////////
; 137  : 	// start reading the file
; 138  : 	// from Microsoft's mssdk D3DIM example "Compress"
; 139  : 	DWORD dwMagic;
; 140  : 
; 141  : 			//@natanek103
; 142  : 		const size_t DDS_HEADER_SIZE = sizeof(DWORD) + sizeof(DDSURFACEDESC2);
; 143  : 
; 144  : 		// Check if the file is large enough to contain the DDS header
; 145  : 		if (fileSize < DDS_HEADER_SIZE) 

  00009	8b 45 0c	 mov	 eax, DWORD PTR _fileSize$[ebp]
  0000c	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00017	0f 82 2f 01 00
	00		 jb	 $LN19@LoadHeader

; 146  : 		{
; 147  : 			return false;
; 148  : 		}
; 149  : 			//@natanek103
; 150  : 
; 151  : 	// Read magic number
; 152  : //	dwMagic = *(DWORD *) c_pbMap;
; 153  : //	c_pbMap += sizeof(DWORD);
; 154  : 
; 155  : 
; 156  : 			//@natanek103
; 157  : 		dwMagic = *(DWORD*)c_pbMap;

  0001d	8b 5d 08	 mov	 ebx, DWORD PTR _c_pbMap$[ebp]

; 158  : 		c_pbMap += sizeof(DWORD);
; 159  : 		fileSize -= sizeof(DWORD);
; 160  : 			//@natanek103
; 161  : 
; 162  : //!@#
; 163  : //	if (dwMagic != MAKEFOURCC('D','D','S',' '))
; 164  : //		return false;
; 165  : 
; 166  : 				//@natanek103
; 167  : 	if (dwMagic != MAKEFOURCC('D', 'D', 'S', ' '))

  00020	81 3b 44 44 53
	20		 cmp	 DWORD PTR [ebx], 542327876 ; 20534444H
  00026	0f 85 20 01 00
	00		 jne	 $LN19@LoadHeader

; 168  : 	{
; 169  : 		return false;
; 170  : 	}
; 171  : 				//@natanek103
; 172  : 
; 173  : 
; 174  : 	DDSURFACEDESC2 ddsd; // read from dds file
; 175  : 
; 176  : 						//@natanek103
; 177  : 		if (fileSize < sizeof(DDSURFACEDESC2))

  0002c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002f	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  00032	0f 82 14 01 00
	00		 jb	 $LN19@LoadHeader

; 178  : 		{
; 179  : 			return false;
; 180  : 		}
; 181  : 						//@natanek103
; 182  : 
; 183  : 
; 184  : 	// Read the surface description
; 185  : 	memcpy(&ddsd, c_pbMap, sizeof(DDSURFACEDESC2));

  00038	8d 73 04	 lea	 esi, DWORD PTR [ebx+4]
  0003b	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  00040	8d 7d 80	 lea	 edi, DWORD PTR _ddsd$[ebp]

; 186  : 	c_pbMap += sizeof(DDSURFACEDESC2);

  00043	83 eb 80	 sub	 ebx, -128		; ffffff80H
  00046	f3 a5		 rep movsd

; 187  : 	fileSize -= sizeof(DDSURFACEDESC2); //@natanek103
; 188  : 
; 189  : 	// Does texture have mipmaps?
; 190  : 	m_bMipTexture = (ddsd.dwMipMapCount > 0) ? TRUE : FALSE;

  00048	8b 75 fc	 mov	 esi, DWORD PTR _this$1$[ebp]
  0004b	8b 7d 98	 mov	 edi, DWORD PTR _ddsd$[ebp+24]

; 191  : 
; 192  : 	// Clear unwanted flags
; 193  : 	// Can't do this!!!  surface not re-created here
; 194  : 	//    ddsd.dwFlags &= (~DDSD_PITCH);
; 195  : 	//    ddsd.dwFlags &= (~DDSD_LINEARSIZE);
; 196  : 
; 197  : 	// Is it DXTC ?
; 198  : 	// I sure hope pixelformat is valid!
; 199  : 	m_xddPixelFormat.dwFlags = ddsd.ddpfPixelFormat.dwFlags;
; 200  : 	m_xddPixelFormat.dwFourCC = ddsd.ddpfPixelFormat.dwFourCC;
; 201  : 	m_xddPixelFormat.dwSize = ddsd.ddpfPixelFormat.dwSize;

  0004e	8d 8e 08 01 00
	00		 lea	 ecx, DWORD PTR [esi+264]
  00054	85 ff		 test	 edi, edi

; 202  : 	m_xddPixelFormat.dwRGBBitCount = ddsd.ddpfPixelFormat.dwRGBBitCount;
; 203  : 	m_xddPixelFormat.dwRGBAlphaBitMask = ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;
; 204  : 	m_xddPixelFormat.dwRBitMask = ddsd.ddpfPixelFormat.dwRBitMask;
; 205  : 	m_xddPixelFormat.dwGBitMask = ddsd.ddpfPixelFormat.dwGBitMask;
; 206  : 	m_xddPixelFormat.dwBBitMask = ddsd.ddpfPixelFormat.dwBBitMask;
; 207  : 
; 208  : 	DecodePixelFormat(m_strFormat, &m_xddPixelFormat);

  00056	51		 push	 ecx
  00057	0f 95 c0	 setne	 al
  0005a	88 86 f8 00 00
	00		 mov	 BYTE PTR [esi+248], al
  00060	8b 45 cc	 mov	 eax, DWORD PTR _ddsd$[ebp+76]
  00063	89 86 0c 01 00
	00		 mov	 DWORD PTR [esi+268], eax
  00069	8b 45 d0	 mov	 eax, DWORD PTR _ddsd$[ebp+80]
  0006c	89 86 10 01 00
	00		 mov	 DWORD PTR [esi+272], eax
  00072	8b 45 c8	 mov	 eax, DWORD PTR _ddsd$[ebp+72]
  00075	89 01		 mov	 DWORD PTR [ecx], eax
  00077	8b ce		 mov	 ecx, esi
  00079	8b 45 d4	 mov	 eax, DWORD PTR _ddsd$[ebp+84]
  0007c	89 86 14 01 00
	00		 mov	 DWORD PTR [esi+276], eax
  00082	8b 45 e4	 mov	 eax, DWORD PTR _ddsd$[ebp+100]
  00085	89 86 24 01 00
	00		 mov	 DWORD PTR [esi+292], eax
  0008b	8b 45 d8	 mov	 eax, DWORD PTR _ddsd$[ebp+88]
  0008e	89 86 18 01 00
	00		 mov	 DWORD PTR [esi+280], eax
  00094	8b 45 dc	 mov	 eax, DWORD PTR _ddsd$[ebp+92]
  00097	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax
  0009d	8b 45 e0	 mov	 eax, DWORD PTR _ddsd$[ebp+96]
  000a0	89 86 20 01 00
	00		 mov	 DWORD PTR [esi+288], eax
  000a6	8d 86 cc 00 00
	00		 lea	 eax, DWORD PTR [esi+204]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ; CDXTCImage::DecodePixelFormat

; 209  : 
; 210  : 	if (m_CompFormat != PF_DXT1 &&
; 211  : 		m_CompFormat != PF_DXT3 &&

  000b2	8b 86 ec 00 00
	00		 mov	 eax, DWORD PTR [esi+236]
  000b8	83 f8 01	 cmp	 eax, 1
  000bb	74 0e		 je	 SHORT $LN8@LoadHeader
  000bd	83 f8 03	 cmp	 eax, 3
  000c0	74 09		 je	 SHORT $LN8@LoadHeader
  000c2	83 f8 05	 cmp	 eax, 5
  000c5	0f 85 81 00 00
	00		 jne	 $LN19@LoadHeader
$LN8@LoadHeader:

; 212  : 		m_CompFormat != PF_DXT5)
; 213  : 	{
; 214  : 		return false;
; 215  : 	}
; 216  : 
; 217  : 	if (ddsd.dwMipMapCount > MAX_MIPLEVELS)
; 218  : 		ddsd.dwMipMapCount = MAX_MIPLEVELS;
; 219  : 
; 220  : 	m_nWidth		= ddsd.dwWidth;
; 221  : 	m_nHeight		= ddsd.dwHeight;
; 222  : 	//!@#
; 223  : 	m_dwMipMapCount = max(1, ddsd.dwMipMapCount);
; 224  : 	m_dwFlags		= ddsd.dwFlags;

  000cb	8b 4d 84	 mov	 ecx, DWORD PTR _ddsd$[ebp+4]
  000ce	b8 0c 00 00 00	 mov	 eax, 12			; 0000000cH
  000d3	3b f8		 cmp	 edi, eax
  000d5	89 8e fc 00 00
	00		 mov	 DWORD PTR [esi+252], ecx
  000db	0f 47 f8	 cmova	 edi, eax
  000de	8b 45 8c	 mov	 eax, DWORD PTR _ddsd$[ebp+12]
  000e1	89 86 00 01 00
	00		 mov	 DWORD PTR [esi+256], eax
  000e7	8b 45 88	 mov	 eax, DWORD PTR _ddsd$[ebp+8]
  000ea	89 86 04 01 00
	00		 mov	 DWORD PTR [esi+260], eax
  000f0	b8 01 00 00 00	 mov	 eax, 1
  000f5	3b f8		 cmp	 edi, eax
  000f7	0f 42 f8	 cmovb	 edi, eax

; 225  : 
; 226  : 	if (ddsd.dwFlags & DDSD_PITCH)

  000fa	8b 45 90	 mov	 eax, DWORD PTR _ddsd$[ebp+16]
  000fd	89 be f4 00 00
	00		 mov	 DWORD PTR [esi+244], edi
  00103	89 86 f0 00 00
	00		 mov	 DWORD PTR [esi+240], eax
  00109	f6 c1 08	 test	 cl, 8
  0010c	75 30		 jne	 SHORT $LN12@LoadHeader

; 227  : 	{
; 228  : 		m_lPitch = ddsd.lPitch;
; 229  : 		m_pbCompBufferByLevels[0] = c_pbMap;
; 230  : 	}
; 231  : 	else
; 232  : 	{
; 233  : 		m_lPitch = ddsd.dwLinearSize;
; 234  : 
; 235  : 		if (ddsd.dwFlags & DDSD_MIPMAPCOUNT)

  0010e	f7 c1 00 00 02
	00		 test	 ecx, 131072		; 00020000H
  00114	74 28		 je	 SHORT $LN12@LoadHeader

; 236  : 		{
; 237  : 			for (DWORD dwLinearSize = ddsd.dwLinearSize, i = 0; i < m_dwMipMapCount; ++i, dwLinearSize >>= 2)

  00116	33 d2		 xor	 edx, edx
  00118	85 ff		 test	 edi, edi
  0011a	74 25		 je	 SHORT $LN13@LoadHeader
  0011c	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0011f	90		 npad	 1
$LL4@LoadHeader:

; 238  : 			{
; 239  : 				m_pbCompBufferByLevels[i] = c_pbMap;

  00120	89 19		 mov	 DWORD PTR [ecx], ebx
  00122	8d 49 04	 lea	 ecx, DWORD PTR [ecx+4]

; 240  : 				c_pbMap += dwLinearSize;

  00125	03 d8		 add	 ebx, eax
  00127	42		 inc	 edx
  00128	c1 e8 02	 shr	 eax, 2
  0012b	3b 96 f4 00 00
	00		 cmp	 edx, DWORD PTR [esi+244]
  00131	72 ed		 jb	 SHORT $LL4@LoadHeader

; 250  : }

  00133	5f		 pop	 edi
  00134	5e		 pop	 esi
  00135	b0 01		 mov	 al, 1
  00137	5b		 pop	 ebx
  00138	8b e5		 mov	 esp, ebp
  0013a	5d		 pop	 ebp
  0013b	c2 08 00	 ret	 8
$LN12@LoadHeader:

; 241  : 			}
; 242  : 		}
; 243  : 		else
; 244  : 		{
; 245  : 			m_pbCompBufferByLevels[0] = c_pbMap;
; 246  : 		}
; 247  : 	}
; 248  : 
; 249  : 	return true;

  0013e	89 5e 04	 mov	 DWORD PTR [esi+4], ebx
$LN13@LoadHeader:
  00141	5f		 pop	 edi

; 250  : }

  00142	5e		 pop	 esi
  00143	b0 01		 mov	 al, 1
  00145	5b		 pop	 ebx
  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c2 08 00	 ret	 8
$LN19@LoadHeader:
  0014c	5f		 pop	 edi
  0014d	5e		 pop	 esi
  0014e	32 c0		 xor	 al, al
  00150	5b		 pop	 ebx
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 08 00	 ret	 8
?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBEI@Z ENDP	; CDXTCImage::LoadHeaderFromMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadFromMemory@CDXTCImage@@QAE_NPBEI@Z
_TEXT	SEGMENT
_c_pbMap$ = 8						; size = 4
_dwBytesPerRow$1$ = 8					; size = 4
_fileSize$ = 12						; size = 4
_yp$1$ = 12						; size = 4
_i$1$ = 12						; size = 4
?LoadFromMemory@CDXTCImage@@QAE_NPBEI@Z PROC		; CDXTCImage::LoadFromMemory, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 257  : //	if (!LoadHeaderFromMemory(c_pbMap))
; 258  : //		return false;
; 259  : 
; 260  : 
; 261  : 		//@natanek103
; 262  : 
; 263  : 		if (!LoadHeaderFromMemory(c_pbMap, fileSize))

  00004	ff 75 0c	 push	 DWORD PTR _fileSize$[ebp]
  00007	8b f1		 mov	 esi, ecx
  00009	ff 75 08	 push	 DWORD PTR _c_pbMap$[ebp]
  0000c	e8 00 00 00 00	 call	 ?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBEI@Z ; CDXTCImage::LoadHeaderFromMemory
  00011	84 c0		 test	 al, al
  00013	75 05		 jne	 SHORT $LN8@LoadFromMe
  00015	5e		 pop	 esi

; 308  : }

  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
$LN8@LoadFromMe:

; 264  : 		{
; 265  : 			return false;
; 266  : 		}
; 267  : 		//@natanek103
; 268  : 
; 269  : 
; 270  : 	if (m_dwFlags & DDSD_PITCH)

  0001a	8b 86 fc 00 00
	00		 mov	 eax, DWORD PTR [esi+252]
  00020	53		 push	 ebx
  00021	57		 push	 edi
  00022	a8 08		 test	 al, 8
  00024	74 7e		 je	 SHORT $LN9@LoadFromMe

; 271  : 	{
; 272  : 		DWORD dwBytesPerRow = m_nWidth * m_xddPixelFormat.dwRGBBitCount / 8;

  00026	8b 8e 14 01 00
	00		 mov	 ecx, DWORD PTR [esi+276]
  0002c	0f af 8e 00 01
	00 00		 imul	 ecx, DWORD PTR [esi+256]

; 273  : 
; 274  : 		m_nCompSize = m_lPitch * m_nHeight;

  00033	8b 86 04 01 00
	00		 mov	 eax, DWORD PTR [esi+260]
  00039	0f af 86 f0 00
	00 00		 imul	 eax, DWORD PTR [esi+240]
  00040	c1 e9 03	 shr	 ecx, 3
  00043	89 4d 08	 mov	 DWORD PTR _dwBytesPerRow$1$[ebp], ecx

; 275  : 		m_nCompLineSz = dwBytesPerRow;

  00046	89 8e c8 00 00
	00		 mov	 DWORD PTR [esi+200], ecx

; 276  : 
; 277  : 		m_bCompVector[0].resize(m_nCompSize);

  0004c	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
  0004f	50		 push	 eax
  00050	89 86 c4 00 00
	00		 mov	 DWORD PTR [esi+196], eax
  00056	e8 00 00 00 00	 call	 ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 278  : 		BYTE * pDest = &m_bCompVector[0][0];
; 279  : 
; 280  : 		c_pbMap = m_pbCompBufferByLevels[0];
; 281  : 
; 282  : 		for (int yp = 0; yp < m_nHeight; ++yp)

  0005b	83 be 04 01 00
	00 00		 cmp	 DWORD PTR [esi+260], 0
  00062	8b 7e 34	 mov	 edi, DWORD PTR [esi+52]
  00065	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00068	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _yp$1$[ebp], 0
  0006f	0f 8e 9d 00 00
	00		 jle	 $LN12@LoadFromMe
$LL4@LoadFromMe:

; 283  : 		{
; 284  : 			memcpy(pDest, c_pbMap, dwBytesPerRow);

  00075	ff 75 08	 push	 DWORD PTR _dwBytesPerRow$1$[ebp]
  00078	53		 push	 ebx
  00079	57		 push	 edi
  0007a	e8 00 00 00 00	 call	 _memcpy

; 285  : 			pDest += m_lPitch;

  0007f	8b 86 f0 00 00
	00		 mov	 eax, DWORD PTR [esi+240]
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH
  00088	03 f8		 add	 edi, eax

; 286  : 			c_pbMap += m_lPitch;

  0008a	03 d8		 add	 ebx, eax
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _yp$1$[ebp]
  0008f	40		 inc	 eax
  00090	89 45 0c	 mov	 DWORD PTR _yp$1$[ebp], eax
  00093	3b 86 04 01 00
	00		 cmp	 eax, DWORD PTR [esi+260]
  00099	7c da		 jl	 SHORT $LL4@LoadFromMe

; 303  : 		}
; 304  : 	}
; 305  : 
; 306  : 	// done reading file
; 307  : 	return true;

  0009b	5f		 pop	 edi
  0009c	5b		 pop	 ebx
  0009d	b0 01		 mov	 al, 1
  0009f	5e		 pop	 esi

; 308  : }

  000a0	5d		 pop	 ebp
  000a1	c2 08 00	 ret	 8
$LN9@LoadFromMe:

; 287  : 		}
; 288  : 	}
; 289  : 	else
; 290  : 	{
; 291  : 		if (m_dwFlags & DDSD_MIPMAPCOUNT)

  000a4	8b 9e f0 00 00
	00		 mov	 ebx, DWORD PTR [esi+240]
  000aa	a9 00 00 02 00	 test	 eax, 131072		; 00020000H
  000af	74 46		 je	 SHORT $LN11@LoadFromMe

; 292  : 		{
; 293  : 			for (DWORD dwLinearSize = m_lPitch, i = 0; i < m_dwMipMapCount; ++i, dwLinearSize >>= 2)

  000b1	83 be f4 00 00
	00 00		 cmp	 DWORD PTR [esi+244], 0
  000b8	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _i$1$[ebp], 0
  000bf	76 51		 jbe	 SHORT $LN12@LoadFromMe
  000c1	8d 7e 34	 lea	 edi, DWORD PTR [esi+52]
$LL7@LoadFromMe:

; 294  : 			{
; 295  : 				m_bCompVector[i].resize(dwLinearSize);

  000c4	53		 push	 ebx
  000c5	8b cf		 mov	 ecx, edi
  000c7	e8 00 00 00 00	 call	 ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 296  : 				Copy(i, &m_bCompVector[i][0], dwLinearSize);

  000cc	53		 push	 ebx
  000cd	ff 37		 push	 DWORD PTR [edi]
  000cf	8b ce		 mov	 ecx, esi
  000d1	ff 75 0c	 push	 DWORD PTR _i$1$[ebp]
  000d4	e8 00 00 00 00	 call	 ?Copy@CDXTCImage@@QAE_NHPAEJ@Z ; CDXTCImage::Copy
  000d9	8b 45 0c	 mov	 eax, DWORD PTR _i$1$[ebp]
  000dc	83 c7 0c	 add	 edi, 12			; 0000000cH
  000df	40		 inc	 eax
  000e0	c1 eb 02	 shr	 ebx, 2
  000e3	89 45 0c	 mov	 DWORD PTR _i$1$[ebp], eax
  000e6	3b 86 f4 00 00
	00		 cmp	 eax, DWORD PTR [esi+244]
  000ec	72 d6		 jb	 SHORT $LL7@LoadFromMe

; 303  : 		}
; 304  : 	}
; 305  : 
; 306  : 	// done reading file
; 307  : 	return true;

  000ee	5f		 pop	 edi
  000ef	5b		 pop	 ebx
  000f0	b0 01		 mov	 al, 1
  000f2	5e		 pop	 esi

; 308  : }

  000f3	5d		 pop	 ebp
  000f4	c2 08 00	 ret	 8
$LN11@LoadFromMe:

; 297  : 			}
; 298  : 		}
; 299  : 		else
; 300  : 		{
; 301  : 			m_bCompVector[0].resize(m_lPitch);

  000f7	53		 push	 ebx
  000f8	8d 4e 34	 lea	 ecx, DWORD PTR [esi+52]
  000fb	e8 00 00 00 00	 call	 ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::resize

; 302  : 			Copy(0, &m_bCompVector[0][0], m_lPitch);

  00100	ff b6 f0 00 00
	00		 push	 DWORD PTR [esi+240]
  00106	8b ce		 mov	 ecx, esi
  00108	ff 76 34	 push	 DWORD PTR [esi+52]
  0010b	6a 00		 push	 0
  0010d	e8 00 00 00 00	 call	 ?Copy@CDXTCImage@@QAE_NHPAEJ@Z ; CDXTCImage::Copy
$LN12@LoadFromMe:

; 303  : 		}
; 304  : 	}
; 305  : 
; 306  : 	// done reading file
; 307  : 	return true;

  00112	5f		 pop	 edi
  00113	5b		 pop	 ebx
  00114	b0 01		 mov	 al, 1
  00116	5e		 pop	 esi

; 308  : }

  00117	5d		 pop	 ebp
  00118	c2 08 00	 ret	 8
?LoadFromMemory@CDXTCImage@@QAE_NPBEI@Z ENDP		; CDXTCImage::LoadFromMemory
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\string.h
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_pvMap$ = -344						; size = 4
_mappedFile$ = -340					; size = 324
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_filename$ = 8						; size = 4
?LoadFromFile@CDXTCImage@@QAE_NPBD@Z PROC		; CDXTCImage::LoadFromFile, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx
  00030	8b 7d 08	 mov	 edi, DWORD PTR _filename$[ebp]

; 88   : 	// only understands .dds files for now
; 89   : 	// return true if success
; 90   : 	int next = 1;
; 91   : 
; 92   : 	static char fileupper[MAX_PATH+1];
; 93   : 
; 94   : 	strncpy(fileupper, filename, MAX_PATH);

  00033	68 04 01 00 00	 push	 260			; 00000104H
  00038	57		 push	 edi
  00039	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  0003e	e8 00 00 00 00	 call	 _strncpy

; 95   : 	_strupr(fileupper);

  00043	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  00048	e8 00 00 00 00	 call	 __strupr
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 96   : 
; 97   : 	int i;
; 98   : 	bool knownformat = false;
; 99   : 
; 100  : 	for (i = 0; i < next; ++i)

  00050	33 f6		 xor	 esi, esi
  00052	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL4@LoadFromFi:
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\string.h

; 520  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00060	68 00 00 00 00	 push	 OFFSET ??_C@_04LFFPHNGG@?4DDS@
  00065	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  0006a	e8 00 00 00 00	 call	 _strstr
  0006f	83 c4 08	 add	 esp, 8
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp

; 104  : 		if (found != NULL)

  00072	85 c0		 test	 eax, eax
  00074	75 18		 jne	 SHORT $LN6@LoadFromFi

; 96   : 
; 97   : 	int i;
; 98   : 	bool knownformat = false;
; 99   : 
; 100  : 	for (i = 0; i < next; ++i)

  00076	46		 inc	 esi
  00077	83 fe 01	 cmp	 esi, 1
  0007a	7c e4		 jl	 SHORT $LL4@LoadFromFi

; 105  : 		{
; 106  : 			knownformat = true;
; 107  : 			break;
; 108  : 		}
; 109  : 	}
; 110  : 
; 111  : 	if (knownformat == false)
; 112  : 	{
; 113  : 		Tracef("Unknown file format encountered! [%s]\n", filename);

  0007c	57		 push	 edi
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@
  00082	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00087	83 c4 08	 add	 esp, 8

; 114  : 		return(false);

  0008a	32 c0		 xor	 al, al
  0008c	eb 67		 jmp	 SHORT $LN1@LoadFromFi
$LN6@LoadFromFi:

; 115  : 	}
; 116  : 
; 117  : 	CMappedFile mappedFile;

  0008e	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  00094	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 118  : 	LPCVOID pvMap;
; 119  : 
; 120  : 	if (!mappedFile.Create(filename, &pvMap, 0, 0))

  00099	6a 00		 push	 0
  0009b	6a 00		 push	 0
  0009d	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _pvMap$[ebp]
  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000aa	50		 push	 eax
  000ab	57		 push	 edi
  000ac	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  000b2	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  000b7	85 c0		 test	 eax, eax
  000b9	75 12		 jne	 SHORT $LN7@LoadFromFi

; 121  : 	{
; 122  : 		Tracef("Can't open file for reading! [%s]\n", filename);

  000bb	57		 push	 edi
  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@
  000c1	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  000c6	83 c4 08	 add	 esp, 8
  000c9	32 db		 xor	 bl, bl
  000cb	eb 1b		 jmp	 SHORT $LN10@LoadFromFi
$LN7@LoadFromFi:

; 123  : 		return false;
; 124  : 	}
; 125  : 
; 126  : //	return LoadFromMemory((const BYTE*) pvMap);
; 127  : 	return LoadFromMemory((const BYTE*)pvMap, mappedFile.Size()); //@natanek103

  000cd	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  000d3	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000d8	50		 push	 eax
  000d9	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _pvMap$[ebp]
  000df	8b cb		 mov	 ecx, ebx
  000e1	e8 00 00 00 00	 call	 ?LoadFromMemory@CDXTCImage@@QAE_NPBEI@Z ; CDXTCImage::LoadFromMemory
  000e6	8a d8		 mov	 bl, al
$LN10@LoadFromFi:
  000e8	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  000ee	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  000f3	8a c3		 mov	 al, bl
$LN1@LoadFromFi:

; 128  : 
; 129  : }

  000f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ff	59		 pop	 ecx
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5b		 pop	 ebx
  00103	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	8b e5		 mov	 esp, ebp
  0010f	5d		 pop	 ebp
  00110	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z$0:
  00000	8d 8d ac fe ff
	ff		 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a a4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-348]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadFromFile@CDXTCImage@@QAE_NPBD@Z ENDP		; CDXTCImage::LoadFromFile
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Oldsize$1$ = -8					; size = 4
tv656 = -8						; size = 4
tv657 = -4						; size = 4
__Newsize$ = 8						; size = 4
$T1 = 8							; size = 4
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::resize, COMDAT
; _this$ = ecx

; 1613 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 1581 :         if (_Newsize < _Oldsize) { // trim

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]

; 1613 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0000d	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00010	8b ca		 mov	 ecx, edx
  00012	8b 07		 mov	 eax, DWORD PTR [edi]
  00014	2b c8		 sub	 ecx, eax
  00016	89 4d f8	 mov	 DWORD PTR __Oldsize$1$[ebp], ecx

; 1581 :         if (_Newsize < _Oldsize) { // trim

  00019	3b d9		 cmp	 ebx, ecx
  0001b	73 0d		 jae	 SHORT $LN4@resize

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  0001d	03 c3		 add	 eax, ebx

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1585 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1586 :             _Mylast = _Newlast;

  0001f	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00022	5f		 pop	 edi

; 1616 :     }

  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
$LN4@resize:

; 1590 :         if (_Newsize > _Oldsize) { // append

  0002a	0f 86 de 00 00
	00		 jbe	 $LN5@resize

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00030	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00033	2b c8		 sub	 ecx, eax
  00035	56		 push	 esi

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  00036	3b d9		 cmp	 ebx, ecx
  00038	0f 86 bf 00 00
	00		 jbe	 $LN6@resize

; 1538 :         if (_Newsize > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 cc 00 00
	00		 ja	 $LN132@resize

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004a	8b d1		 mov	 edx, ecx
  0004c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00051	d1 ea		 shr	 edx, 1
  00053	2b c2		 sub	 eax, edx
  00055	3b c8		 cmp	 ecx, eax
  00057	76 0d		 jbe	 SHORT $LN13@resize

; 1997 :             return _Max; // geometric growth would overflow

  00059	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00064	eb 27		 jmp	 SHORT $LN130@resize
$LN13@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00066	8d 34 0a	 lea	 esi, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00069	3b f3		 cmp	 esi, ebx
  0006b	0f 42 f3	 cmovb	 esi, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  0006e	8b c6		 mov	 eax, esi
  00070	85 f6		 test	 esi, esi
  00072	75 04		 jne	 SHORT $LN24@resize

; 228  :         return nullptr;

  00074	33 c9		 xor	 ecx, ecx
  00076	eb 1a		 jmp	 SHORT $LN129@resize
$LN24@resize:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00078	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007d	72 08		 jb	 SHORT $LN25@resize

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00085	eb 06		 jmp	 SHORT $LN130@resize
$LN25@resize:

; 136  :         return ::operator new(_Bytes);

  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN130@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  0008d	8b c8		 mov	 ecx, eax
  0008f	83 c4 04	 add	 esp, 4
$LN129@resize:
  00092	8b 45 f8	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  00095	03 c1		 add	 eax, ecx
  00097	89 4d 08	 mov	 DWORD PTR $T1[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  0009a	03 cb		 add	 ecx, ebx
  0009c	51		 push	 ecx
  0009d	50		 push	 eax
  0009e	89 4d f8	 mov	 DWORD PTR tv656[ebp], ecx
  000a1	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000a6	8b 5d 08	 mov	 ebx, DWORD PTR $T1[ebp]
  000a9	53		 push	 ebx
  000aa	ff 77 04	 push	 DWORD PTR [edi+4]
  000ad	ff 37		 push	 DWORD PTR [edi]
  000af	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ; std::_Copy_memmove<unsigned char *,unsigned char *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000b4	8b 07		 mov	 eax, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b6	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000b9	85 c0		 test	 eax, eax
  000bb	74 29		 je	 SHORT $LN62@resize

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000bd	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000c0	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000c2	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000c8	72 12		 jb	 SHORT $LN73@resize

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ca	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000cd	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000d0	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000d2	83 c0 fc	 add	 eax, -4			; fffffffcH
  000d5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000d8	77 41		 ja	 SHORT $LN70@resize

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000da	8b c2		 mov	 eax, edx
$LN73@resize:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000dc	51		 push	 ecx
  000dd	50		 push	 eax
  000de	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000e3	83 c4 08	 add	 esp, 8
$LN62@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  000e6	8b 45 f8	 mov	 eax, DWORD PTR tv656[ebp]
  000e9	89 1f		 mov	 DWORD PTR [edi], ebx
  000eb	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  000ee	8d 04 33	 lea	 eax, DWORD PTR [ebx+esi]
  000f1	5e		 pop	 esi
  000f2	89 47 08	 mov	 DWORD PTR [edi+8], eax
  000f5	5f		 pop	 edi

; 1616 :     }

  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
$LN6@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  000fd	8d 34 18	 lea	 esi, DWORD PTR [eax+ebx]
  00100	56		 push	 esi
  00101	52		 push	 edx
  00102	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>
  00107	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  0010a	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0010d	5e		 pop	 esi
$LN5@resize:
  0010e	5f		 pop	 edi

; 1616 :     }

  0010f	5b		 pop	 ebx
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 04 00	 ret	 4
$LN132@resize:

; 1539 :             _Xlength();

  00116	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN70@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0011b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN128@resize:
  00120	cc		 int	 3
?resize@?$vector@EV?$allocator@E@std@@@std@@QAEXI@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 3d		 je	 SHORT $LN5@vector

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 22		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00035	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00038	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  0003f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00046	5e		 pop	 esi

; 820  :     }

  00047	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00048	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  0004d	cc		 int	 3
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 656  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 657  :     }

  00006	8b c1		 mov	 eax, ecx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 656  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 657  :     }

  00016	c3		 ret	 0
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Clear@CDXTCImage@@QAEXXZ
_TEXT	SEGMENT
?Clear@CDXTCImage@@QAEXXZ PROC				; CDXTCImage::Clear, COMDAT
; _this$ = ecx

; 79   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 80   : 	for (int i = 0; i < MAX_MIPLEVELS; ++i)

  00003	ba 02 00 00 00	 mov	 edx, 2
  00008	8d 46 44	 lea	 eax, DWORD PTR [esi+68]
  0000b	0f 1f 44 00 00	 npad	 5
$LL4@Clear:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00010	8b 48 f0	 mov	 ecx, DWORD PTR [eax-16]
  00013	3b 48 f4	 cmp	 ecx, DWORD PTR [eax-12]
  00016	74 03		 je	 SHORT $LN2@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00018	89 48 f4	 mov	 DWORD PTR [eax-12], ecx
$LN2@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0001b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00020	74 02		 je	 SHORT $LN14@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00022	89 08		 mov	 DWORD PTR [eax], ecx
$LN14@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00024	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00027	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0002a	74 03		 je	 SHORT $LN15@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0002c	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
$LN15@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0002f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00032	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00035	74 03		 je	 SHORT $LN16@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00037	89 48 18	 mov	 DWORD PTR [eax+24], ecx
$LN16@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0003a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0003d	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00040	74 03		 je	 SHORT $LN17@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00042	89 48 24	 mov	 DWORD PTR [eax+36], ecx
$LN17@Clear:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00045	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  00048	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  0004b	74 03		 je	 SHORT $LN18@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0004d	89 48 30	 mov	 DWORD PTR [eax+48], ecx
$LN18@Clear:
  00050	83 c0 48	 add	 eax, 72			; 00000048H
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp

; 80   : 	for (int i = 0; i < MAX_MIPLEVELS; ++i)

  00053	83 ea 01	 sub	 edx, 1
  00056	75 b8		 jne	 SHORT $LL4@Clear

; 81   : 		m_bCompVector[i].clear();
; 82   : 
; 83   : 	Initialize();

  00058	8b ce		 mov	 ecx, esi
  0005a	5e		 pop	 esi
  0005b	e9 00 00 00 00	 jmp	 ?Initialize@CDXTCImage@@QAEXXZ ; CDXTCImage::Initialize
?Clear@CDXTCImage@@QAEXXZ ENDP				; CDXTCImage::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Initialize@CDXTCImage@@QAEXXZ
_TEXT	SEGMENT
?Initialize@CDXTCImage@@QAEXXZ PROC			; CDXTCImage::Initialize, COMDAT
; _this$ = ecx

; 70   : {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 71   : 	m_nWidth = 0;

  00003	c7 81 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+256], 0

; 72   : 	m_nHeight = 0;

  0000d	c7 81 04 01 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+260], 0
  00017	0f 11 41 04	 movups	 XMMWORD PTR [ecx+4], xmm0
  0001b	0f 11 41 14	 movups	 XMMWORD PTR [ecx+20], xmm0
  0001f	0f 11 41 24	 movups	 XMMWORD PTR [ecx+36], xmm0

; 73   : 
; 74   : 	for (int i = 0; i < MAX_MIPLEVELS; ++i)
; 75   : 		m_pbCompBufferByLevels[i] = NULL;
; 76   : }

  00023	c3		 ret	 0
?Initialize@CDXTCImage@@QAEXXZ ENDP			; CDXTCImage::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ??1CDXTCImage@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CDXTCImage@@UAE@XZ PROC				; CDXTCImage::~CDXTCImage, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CDXTCImage@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 67   : }

  00022	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00027	6a 0c		 push	 12			; 0000000cH
  00029	6a 0c		 push	 12			; 0000000cH
  0002b	8d 41 34	 lea	 eax, DWORD PTR [ecx+52]
  0002e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDXTCImage@@6B@
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00044	59		 pop	 ecx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
  00049	cc		 int	 3
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CDXTCImage@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CDXTCImage@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CDXTCImage@@UAE@XZ ENDP				; CDXTCImage::~CDXTCImage
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterImageLib\DXTCImage.cpp
;	COMDAT ??0CDXTCImage@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CDXTCImage@@QAE@XZ PROC				; CDXTCImage::CDXTCImage, COMDAT
; _this$ = ecx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  0000a	8b f1		 mov	 esi, ecx
  0000c	68 00 00 00 00	 push	 OFFSET ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
  00011	6a 0c		 push	 12			; 0000000cH
  00013	6a 0c		 push	 12			; 0000000cH
  00015	8d 46 34	 lea	 eax, DWORD PTR [esi+52]
  00018	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0001b	50		 push	 eax
  0001c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDXTCImage@@6B@
  00022	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z

; 62   : 	Initialize();

  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 ?Initialize@CDXTCImage@@QAEXXZ ; CDXTCImage::Initialize

; 63   : }

  0002e	8b c6		 mov	 eax, esi
  00030	5e		 pop	 esi
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??0CDXTCImage@@QAE@XZ ENDP				; CDXTCImage::CDXTCImage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1947 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);
; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1952 :         __crt_va_end(_ArgList);
; 1953 :         return _Result;
; 1954 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
