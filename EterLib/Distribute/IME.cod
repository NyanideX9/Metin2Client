; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\EterLib\Distribute\IME.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?s_aszIndicator@@3PAY02_WA			; s_aszIndicator
PUBLIC	?gs_codePage@@3KA				; gs_codePage
PUBLIC	?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A	; CTsfUiLessMode::m_tm
PUBLIC	?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA	; CTsfUiLessMode::m_dwUIElementSinkCookie
PUBLIC	?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA		; CTsfUiLessMode::m_dwAlpnSinkCookie
PUBLIC	?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA	; CTsfUiLessMode::m_dwOpenModeSinkCookie
PUBLIC	?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA	; CTsfUiLessMode::m_dwConvModeSinkCookie
PUBLIC	?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
PUBLIC	?m_nCandidateRefCount@CTsfUiLessMode@@1HA	; CTsfUiLessMode::m_nCandidateRefCount
PUBLIC	?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA ; CIME::_ImmLockIMC
PUBLIC	?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA	; CIME::_ImmUnlockIMC
PUBLIC	?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA	; CIME::_ImmLockIMCC
PUBLIC	?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA	; CIME::_ImmUnlockIMCC
PUBLIC	?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA ; CIME::_GetReadingString
PUBLIC	?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA	; CIME::_ShowReadingWindow
PUBLIC	?ms_bInitialized@CIME@@2_NA			; CIME::ms_bInitialized
PUBLIC	?ms_bDisableIMECompletely@CIME@@2_NA		; CIME::ms_bDisableIMECompletely
PUBLIC	?ms_bUILessMode@CIME@@2_NA			; CIME::ms_bUILessMode
PUBLIC	?ms_bImeEnabled@CIME@@2_NA			; CIME::ms_bImeEnabled
PUBLIC	?ms_bCaptureInput@CIME@@2_NA			; CIME::ms_bCaptureInput
PUBLIC	?ms_bChineseIME@CIME@@2_NA			; CIME::ms_bChineseIME
PUBLIC	?ms_bUseIMMCandidate@CIME@@2_NA			; CIME::ms_bUseIMMCandidate
PUBLIC	?ms_hWnd@CIME@@2PAUHWND__@@A			; CIME::ms_hWnd
PUBLIC	?ms_hklCurrent@CIME@@2PAUHKL__@@A		; CIME::ms_hklCurrent
PUBLIC	?ms_szKeyboardLayout@CIME@@2PADA		; CIME::ms_szKeyboardLayout
PUBLIC	?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A		; CIME::ms_stOSVI
PUBLIC	?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A		; CIME::ms_hImm32Dll
PUBLIC	?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A	; CIME::ms_hCurrentImeDll
PUBLIC	?ms_dwImeState@CIME@@2KA			; CIME::ms_dwImeState
PUBLIC	?ms_adwId@CIME@@2PAKA				; CIME::ms_adwId
PUBLIC	?ms_dwIMELevel@CIME@@2KA			; CIME::ms_dwIMELevel
PUBLIC	?ms_dwIMELevelSaved@CIME@@2KA			; CIME::ms_dwIMELevelSaved
PUBLIC	?ms_bCandidateList@CIME@@2_NA			; CIME::ms_bCandidateList
PUBLIC	?ms_dwCandidateCount@CIME@@2KA			; CIME::ms_dwCandidateCount
PUBLIC	?ms_bVerticalCandidate@CIME@@2_NA		; CIME::ms_bVerticalCandidate
PUBLIC	?ms_iCandListIndexBase@CIME@@2HA		; CIME::ms_iCandListIndexBase
PUBLIC	?ms_wszCandidate@CIME@@2PAY0BAA@_WA		; CIME::ms_wszCandidate
PUBLIC	?ms_dwCandidateSelection@CIME@@2KA		; CIME::ms_dwCandidateSelection
PUBLIC	?ms_dwCandidatePageSize@CIME@@2KA		; CIME::ms_dwCandidatePageSize
PUBLIC	?ms_bReadingInformation@CIME@@2_NA		; CIME::ms_bReadingInformation
PUBLIC	?ms_iReadingError@CIME@@2HA			; CIME::ms_iReadingError
PUBLIC	?ms_bHorizontalReading@CIME@@2_NA		; CIME::ms_bHorizontalReading
PUBLIC	?ms_wszCurrentIndicator@CIME@@2PA_WA		; CIME::ms_wszCurrentIndicator
PUBLIC	?ms_pEvent@CIME@@2PAVIIMEEventSink@@A		; CIME::ms_pEvent
PUBLIC	?m_wText@CIME@@2PA_WA				; CIME::m_wText
PUBLIC	?ms_compLen@CIME@@2HA				; CIME::ms_compLen
PUBLIC	?ms_curpos@CIME@@2HA				; CIME::ms_curpos
PUBLIC	?ms_lastpos@CIME@@2HA				; CIME::ms_lastpos
PUBLIC	?ms_ulbegin@CIME@@2HA				; CIME::ms_ulbegin
PUBLIC	?ms_ulend@CIME@@2HA				; CIME::ms_ulend
PUBLIC	?ms_uOutputCodePage@CIME@@2IA			; CIME::ms_uOutputCodePage
PUBLIC	?ms_uInputCodePage@CIME@@2IA			; CIME::ms_uInputCodePage
_BSS	SEGMENT
?gs_codePage@@3KA DD 01H DUP (?)			; gs_codePage
?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A DD 01H DUP (?) ; CTsfUiLessMode::m_tm
?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A DD 01H DUP (?) ; CTsfUiLessMode::m_TsfSink
?m_nCandidateRefCount@CTsfUiLessMode@@1HA DD 01H DUP (?) ; CTsfUiLessMode::m_nCandidateRefCount
?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA DD 01H DUP (?) ; CIME::_ImmLockIMC
?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA DD 01H DUP (?)	; CIME::_ImmUnlockIMC
?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA DD 01H DUP (?) ; CIME::_ImmLockIMCC
?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA DD 01H DUP (?) ; CIME::_ImmUnlockIMCC
?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA DD 01H DUP (?) ; CIME::_GetReadingString
?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA DD 01H DUP (?) ; CIME::_ShowReadingWindow
?ms_bInitialized@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bInitialized
	ALIGN	4

?ms_bDisableIMECompletely@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bDisableIMECompletely
	ALIGN	4

?ms_bUILessMode@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bUILessMode
	ALIGN	4

?ms_bImeEnabled@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bImeEnabled
	ALIGN	4

?ms_bCaptureInput@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bCaptureInput
	ALIGN	4

?ms_bChineseIME@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bChineseIME
	ALIGN	4

?ms_bUseIMMCandidate@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bUseIMMCandidate
	ALIGN	4

?ms_hWnd@CIME@@2PAUHWND__@@A DD 01H DUP (?)		; CIME::ms_hWnd
?ms_hklCurrent@CIME@@2PAUHKL__@@A DD 01H DUP (?)	; CIME::ms_hklCurrent
?ms_szKeyboardLayout@CIME@@2PADA DB 0aH DUP (?)		; CIME::ms_szKeyboardLayout
	ALIGN	4

?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A DB 094H DUP (?)	; CIME::ms_stOSVI
?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A DD 01H DUP (?)	; CIME::ms_hImm32Dll
?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A DD 01H DUP (?) ; CIME::ms_hCurrentImeDll
?ms_dwImeState@CIME@@2KA DD 01H DUP (?)			; CIME::ms_dwImeState
?ms_adwId@CIME@@2PAKA DD 02H DUP (?)			; CIME::ms_adwId
?ms_dwIMELevel@CIME@@2KA DD 01H DUP (?)			; CIME::ms_dwIMELevel
?ms_dwIMELevelSaved@CIME@@2KA DD 01H DUP (?)		; CIME::ms_dwIMELevelSaved
?ms_bCandidateList@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bCandidateList
	ALIGN	4

?ms_dwCandidateCount@CIME@@2KA DD 01H DUP (?)		; CIME::ms_dwCandidateCount
?ms_bVerticalCandidate@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bVerticalCandidate
	ALIGN	4

?ms_iCandListIndexBase@CIME@@2HA DD 01H DUP (?)		; CIME::ms_iCandListIndexBase
?ms_wszCandidate@CIME@@2PAY0BAA@_WA DW 0a00H DUP (?)	; CIME::ms_wszCandidate
?ms_dwCandidateSelection@CIME@@2KA DD 01H DUP (?)	; CIME::ms_dwCandidateSelection
?ms_dwCandidatePageSize@CIME@@2KA DD 01H DUP (?)	; CIME::ms_dwCandidatePageSize
?ms_bReadingInformation@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bReadingInformation
	ALIGN	4

?ms_iReadingError@CIME@@2HA DD 01H DUP (?)		; CIME::ms_iReadingError
?ms_bHorizontalReading@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bHorizontalReading
	ALIGN	4

?ms_wszCurrentIndicator@CIME@@2PA_WA DD 01H DUP (?)	; CIME::ms_wszCurrentIndicator
?ms_pEvent@CIME@@2PAVIIMEEventSink@@A DD 01H DUP (?)	; CIME::ms_pEvent
?m_wText@CIME@@2PA_WA DW 0400H DUP (?)			; CIME::m_wText
?ms_compLen@CIME@@2HA DD 01H DUP (?)			; CIME::ms_compLen
?ms_curpos@CIME@@2HA DD 01H DUP (?)			; CIME::ms_curpos
?ms_lastpos@CIME@@2HA DD 01H DUP (?)			; CIME::ms_lastpos
?ms_ulbegin@CIME@@2HA DD 01H DUP (?)			; CIME::ms_ulbegin
?ms_ulend@CIME@@2HA DD 01H DUP (?)			; CIME::ms_ulend
?ms_uOutputCodePage@CIME@@2IA DD 01H DUP (?)		; CIME::ms_uOutputCodePage
?ms_uInputCodePage@CIME@@2IA DD 01H DUP (?)		; CIME::ms_uInputCodePage
_BSS	ENDS
_DATA	SEGMENT
?s_aszIndicator@@3PAY02_WA DB 'E', 00H, 'n', 00H, 00H, 00H ; s_aszIndicator
	DB	080H, '{', 00H, 00H
	ORG $+2
	DB	'A~', 00H, 00H
	ORG $+2
	DB	00H, 0acH, 00H, 00H
	ORG $+2
	DB	'B0', 00H, 00H
	ORG $+2
	ORG $+2
?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH ; CTsfUiLessMode::m_dwUIElementSinkCookie
?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH	; CTsfUiLessMode::m_dwAlpnSinkCookie
?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH ; CTsfUiLessMode::m_dwOpenModeSinkCookie
?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH ; CTsfUiLessMode::m_dwConvModeSinkCookie
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CIME@@QAE@XZ					; CIME::CIME
PUBLIC	??1CIME@@UAE@XZ					; CIME::~CIME
PUBLIC	?Initialize@CIME@@QAE_NPAUHWND__@@@Z		; CIME::Initialize
PUBLIC	?Uninitialize@CIME@@QAEXXZ			; CIME::Uninitialize
PUBLIC	?Clear@CIME@@SAXXZ				; CIME::Clear
PUBLIC	?SetMax@CIME@@QAEXH@Z				; CIME::SetMax
PUBLIC	?SetUserMax@CIME@@QAEXH@Z			; CIME::SetUserMax
PUBLIC	?SetText@CIME@@QAEXPBDH@Z			; CIME::SetText
PUBLIC	?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CIME::GetText
PUBLIC	?GetCodePageText@CIME@@QAEPBDXZ			; CIME::GetCodePageText
PUBLIC	?GetCodePage@CIME@@QAEHXZ			; CIME::GetCodePage
PUBLIC	?GetCandidateCount@CIME@@QAEHXZ			; CIME::GetCandidateCount
PUBLIC	?GetCandidatePageCount@CIME@@QAEHXZ		; CIME::GetCandidatePageCount
PUBLIC	?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CIME::GetCandidate
PUBLIC	?GetCandidateSelection@CIME@@QAEHXZ		; CIME::GetCandidateSelection
PUBLIC	?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CIME::GetReading
PUBLIC	?GetReadingError@CIME@@QAEHXZ			; CIME::GetReadingError
PUBLIC	?SetInputMode@CIME@@QAEXK@Z			; CIME::SetInputMode
PUBLIC	?GetInputMode@CIME@@QAEKXZ			; CIME::GetInputMode
PUBLIC	?IsIMEEnabled@CIME@@QAE_NXZ			; CIME::IsIMEEnabled
PUBLIC	?EnableIME@CIME@@QAEX_N@Z			; CIME::EnableIME
PUBLIC	?DisableIME@CIME@@QAEXXZ			; CIME::DisableIME
PUBLIC	?EnableCaptureInput@CIME@@QAEXXZ		; CIME::EnableCaptureInput
PUBLIC	?DisableCaptureInput@CIME@@QAEXXZ		; CIME::DisableCaptureInput
PUBLIC	?IsCaptureEnabled@CIME@@QAE_NXZ			; CIME::IsCaptureEnabled
PUBLIC	?SetNumberMode@CIME@@QAEXXZ			; CIME::SetNumberMode
PUBLIC	?SetStringMode@CIME@@QAEXXZ			; CIME::SetStringMode
PUBLIC	?__IsWritable@CIME@@QAE_N_W@Z			; CIME::__IsWritable
PUBLIC	?AddExceptKey@CIME@@QAEX_W@Z			; CIME::AddExceptKey
PUBLIC	?ClearExceptKey@CIME@@QAEXXZ			; CIME::ClearExceptKey
PUBLIC	?PasteTextFromClipBoard@CIME@@QAEXXZ		; CIME::PasteTextFromClipBoard
PUBLIC	?EnablePaste@CIME@@QAEX_N@Z			; CIME::EnablePaste
PUBLIC	?PasteString@CIME@@QAEXPBD@Z			; CIME::PasteString
PUBLIC	?FinalizeString@CIME@@SAX_N@Z			; CIME::FinalizeString
PUBLIC	?UseDefaultIME@CIME@@QAEXXZ			; CIME::UseDefaultIME
PUBLIC	?GetCurPos@CIME@@SAHXZ				; CIME::GetCurPos
PUBLIC	?GetCompLen@CIME@@SAHXZ				; CIME::GetCompLen
PUBLIC	?GetULBegin@CIME@@SAHXZ				; CIME::GetULBegin
PUBLIC	?GetULEnd@CIME@@SAHXZ				; CIME::GetULEnd
PUBLIC	?CloseCandidateList@CIME@@SAXXZ			; CIME::CloseCandidateList
PUBLIC	?CloseReadingInformation@CIME@@SAXXZ		; CIME::CloseReadingInformation
PUBLIC	?ChangeInputLanguage@CIME@@SAXXZ		; CIME::ChangeInputLanguage
PUBLIC	?ChangeInputLanguageWorker@CIME@@SAXXZ		; CIME::ChangeInputLanguageWorker
PUBLIC	?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMInputLanguage
PUBLIC	?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMStartComposition
PUBLIC	?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMComposition
PUBLIC	?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMEndComposition
PUBLIC	?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z		; CIME::WMNotify
PUBLIC	?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z		; CIME::WMChar
PUBLIC	?IncCurPos@CIME@@IAEXXZ				; CIME::IncCurPos
PUBLIC	?DecCurPos@CIME@@IAEXXZ				; CIME::DecCurPos
PUBLIC	?SetCurPos@CIME@@IAEXH@Z			; CIME::SetCurPos
PUBLIC	?DelCurPos@CIME@@IAEXXZ				; CIME::DelCurPos
PUBLIC	?CheckInputLocale@CIME@@KAXXZ			; CIME::CheckInputLocale
PUBLIC	?CheckToggleState@CIME@@KAXXZ			; CIME::CheckToggleState
PUBLIC	?SetSupportLevel@CIME@@KAXK@Z			; CIME::SetSupportLevel
PUBLIC	?InsertString@CIME@@IAEXPA_WH@Z			; CIME::InsertString
PUBLIC	?OnChar@CIME@@IAEX_W@Z				; CIME::OnChar
PUBLIC	?GetCodePageFromLang@CIME@@IAEIG@Z		; CIME::GetCodePageFromLang
PUBLIC	?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z		; CIME::ResultProcess
PUBLIC	?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CompositionProcessBuilding
PUBLIC	?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z	; CIME::CompositionProcess
PUBLIC	?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z	; CIME::AttributeProcess
PUBLIC	?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z	; CIME::CandidateProcess
PUBLIC	?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z		; CIME::ReadingProcess
PUBLIC	?IsMax@CIME@@IAE_NPB_WH@Z			; CIME::IsMax
PUBLIC	?GetImeId@CIME@@IAEKI@Z				; CIME::GetImeId
PUBLIC	?GetReadingWindowOrientation@CIME@@IAE_NXZ	; CIME::GetReadingWindowOrientation
PUBLIC	?SetupImeApi@CIME@@KAXXZ			; CIME::SetupImeApi
PUBLIC	?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::resize
PUBLIC	?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
PUBLIC	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
PUBLIC	??_GCIME@@UAEPAXI@Z				; CIME::`scalar deleting destructor'
PUBLIC	??0CUIElementSink@CTsfUiLessMode@@QAE@XZ	; CTsfUiLessMode::CUIElementSink::CUIElementSink
PUBLIC	??1CUIElementSink@CTsfUiLessMode@@QAE@XZ	; CTsfUiLessMode::CUIElementSink::~CUIElementSink
PUBLIC	?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ; CTsfUiLessMode::CUIElementSink::QueryInterface
PUBLIC	?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ	; CTsfUiLessMode::CUIElementSink::AddRef
PUBLIC	?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ	; CTsfUiLessMode::CUIElementSink::Release
PUBLIC	?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z ; CTsfUiLessMode::CUIElementSink::BeginUIElement
PUBLIC	?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ; CTsfUiLessMode::CUIElementSink::UpdateUIElement
PUBLIC	?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ; CTsfUiLessMode::CUIElementSink::EndUIElement
PUBLIC	?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z ; CTsfUiLessMode::CUIElementSink::OnActivated
PUBLIC	?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z ; CTsfUiLessMode::CUIElementSink::OnChange
PUBLIC	?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ; CTsfUiLessMode::MakeReadingInformationString
PUBLIC	?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ; CTsfUiLessMode::MakeCandidateStrings
PUBLIC	?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
PUBLIC	?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ; CTsfUiLessMode::GetCompartments
PUBLIC	?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks
PUBLIC	?SetupSinks@CTsfUiLessMode@@SAHXZ		; CTsfUiLessMode::SetupSinks
PUBLIC	?ReleaseSinks@CTsfUiLessMode@@SAXXZ		; CTsfUiLessMode::ReleaseSinks
PUBLIC	?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ	; CTsfUiLessMode::CurrentInputLocaleIsIme
PUBLIC	?UpdateImeState@CTsfUiLessMode@@SAXH@Z		; CTsfUiLessMode::UpdateImeState
PUBLIC	?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z	; CTsfUiLessMode::EnableUiUpdates
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	??$_Assign_counted_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_WI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_counted_range<wchar_t *>
PUBLIC	??$_Find_vectorized@_W_W@std@@YAPA_WQA_W0_W@Z	; std::_Find_vectorized<wchar_t,wchar_t>
PUBLIC	??$_Copy_memmove_n@PA_WPA_W@std@@YAPA_WPA_WI0@Z	; std::_Copy_memmove_n<wchar_t *,wchar_t *>
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z		; std::_Zero_range<wchar_t *>
PUBLIC	??$_Copy_memmove_tail@PA_W@std@@YAPA_WQBDQA_WII@Z ; std::_Copy_memmove_tail<wchar_t *>
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z	; std::_Copy_memmove<wchar_t *,wchar_t *>
PUBLIC	??$_Copy_memmove_tail@PAE@std@@YAPAEQBDQAEII@Z	; std::_Copy_memmove_tail<unsigned char *>
PUBLIC	?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{4}'
PUBLIC	?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{4}'
PUBLIC	?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{4}'
PUBLIC	?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{8}'
PUBLIC	?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{8}'
PUBLIC	?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{8}'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
PUBLIC	??_7CIME@@6B@					; CIME::`vftable'
PUBLIC	??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
PUBLIC	??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
PUBLIC	??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
PUBLIC	__GUID_aa80e801_2021_11d2_93e0_0060b067b86e
PUBLIC	??_C@_0L@LPOFADGE@?2imm32?4dll@			; `string'
PUBLIC	??_C@_0L@JGAMEFKO@ImmLockIMC@			; `string'
PUBLIC	??_C@_0N@PDIACEGP@ImmUnlockIMC@			; `string'
PUBLIC	??_C@_0M@OKKMJOGM@ImmLockIMCC@			; `string'
PUBLIC	??_C@_0O@GKKOACL@ImmUnlockIMCC@			; `string'
PUBLIC	??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@	; `string'
PUBLIC	??_C@_05JKJMOPAK@?$EA?$CF04d@			; `string'
PUBLIC	??_C@_05EFEJGKEJ@?$EA9999@			; `string'
PUBLIC	??_C@_0N@FFMHCBAD@TINTLGNT?4IME@		; `string'
PUBLIC	??_C@_0N@JMLDIBIB@CINTLGNT?4IME@		; `string'
PUBLIC	??_C@_0N@FHDFFBN@MSTCIPHA?4IME@			; `string'
PUBLIC	??_C@_0N@JFHOELJF@PINTLGNT?4IME@		; `string'
PUBLIC	??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@		; `string'
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@ ; `string'
PUBLIC	??_C@_07DEJAPC@MSTCIPH@				; `string'
PUBLIC	??_C@_08LMKCILHO@TINTLGNT@			; `string'
PUBLIC	??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@		; `string'
PUBLIC	??_C@_0N@EMABPIGL@QQPINYIN?4IME@		; `string'
PUBLIC	??_C@_0M@IPABOCGB@SOGOUPY?4IME@			; `string'
PUBLIC	??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@		; `string'
PUBLIC	??_C@_0BB@EOIFCLLM@GetReadingString@		; `string'
PUBLIC	??_C@_0BC@MEELNKEC@ShowReadingWindow@		; `string'
PUBLIC	__GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c
PUBLIC	__GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
PUBLIC	__GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
PUBLIC	__GUID_743abd5f_f26d_48df_8cc5_238492419b64
PUBLIC	__GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_ea1ea135_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca
PUBLIC	__GUID_71c6e74c_0f28_11d8_a82a_00065b84435c
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R0?AUIUnknown@@@8				; IUnknown `RTTI Type Descriptor'
PUBLIC	??_R3IUnknown@@8				; IUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IUnknown@@8				; IUnknown::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CIME@@6B@					; CIME::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCIME@@@8				; CIME `RTTI Type Descriptor'
PUBLIC	??_R3CIME@@8					; CIME::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CIME@@8					; CIME::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CIME@@8				; CIME::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUITfCompartmentEventSink@@@8		; ITfCompartmentEventSink `RTTI Type Descriptor'
PUBLIC	??_R3ITfCompartmentEventSink@@8			; ITfCompartmentEventSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITfCompartmentEventSink@@8			; ITfCompartmentEventSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITfCompartmentEventSink@@8	; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUITfInputProcessorProfileActivationSink@@@8 ; ITfInputProcessorProfileActivationSink `RTTI Type Descriptor'
PUBLIC	??_R3ITfInputProcessorProfileActivationSink@@8	; ITfInputProcessorProfileActivationSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITfInputProcessorProfileActivationSink@@8	; ITfInputProcessorProfileActivationSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUITfUIElementSink@@@8			; ITfUIElementSink `RTTI Type Descriptor'
PUBLIC	??_R3ITfUIElementSink@@8			; ITfUIElementSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITfUIElementSink@@8			; ITfUIElementSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITfUIElementSink@@8		; ITfUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCUIElementSink@CTsfUiLessMode@@@8	; CTsfUiLessMode::CUIElementSink `RTTI Type Descriptor'
PUBLIC	??_R3CUIElementSink@CTsfUiLessMode@@8		; CTsfUiLessMode::CUIElementSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CUIElementSink@CTsfUiLessMode@@8		; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8	; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
PUBLIC	??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R13?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
PUBLIC	??_R17?0A@EA@ITfCompartmentEventSink@@8		; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R17?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (8,-1,0,66)'
PUBLIC	??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
PUBLIC	??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_iswdigit:PROC
EXTRN	_towlower:PROC
EXTRN	__stricmp:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GlobalUnlock@4:PROC
EXTRN	__imp__GlobalLock@4:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	__imp__GetKeyboardLayoutNameA@4:PROC
EXTRN	__imp__GetKeyboardLayout@4:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__OpenClipboard@4:PROC
EXTRN	__imp__CloseClipboard@0:PROC
EXTRN	__imp__GetClipboardData@4:PROC
EXTRN	__imp__CharNextW@4:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__CompareStringA@24:PROC
EXTRN	__imp__GetLocaleInfoA@16:PROC
EXTRN	_GetFileVersionInfoSizeA@8:PROC
EXTRN	_GetFileVersionInfoA@16:PROC
EXTRN	_VerQueryValueA@16:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	_ImmGetIMEFileNameA@12:PROC
EXTRN	_ImmIsIME@4:PROC
EXTRN	_ImmGetContext@4:PROC
EXTRN	_ImmReleaseContext@8:PROC
EXTRN	_ImmAssociateContext@8:PROC
EXTRN	_ImmGetCompositionStringW@16:PROC
EXTRN	_ImmSetCompositionStringW@24:PROC
EXTRN	_ImmGetCandidateListW@16:PROC
EXTRN	_ImmGetConversionStatus@12:PROC
EXTRN	_ImmSetConversionStatus@12:PROC
EXTRN	_ImmGetOpenStatus@4:PROC
EXTRN	_ImmNotifyIME@16:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitializeEx@8:PROC
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_find_trivial_2@12:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_ECIME@@UAEPAXI@Z:PROC			; CIME::`vector deleting destructor'
EXTRN	?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z:PROC ; GetTextTagOutputString
EXTRN	?GetTextTagOutputLen@@YAHPB_WH@Z:PROC		; GetTextTagOutputLen
EXTRN	?FindColorTagEndPosition@@YAHPB_WH@Z:PROC	; FindColorTagEndPosition
EXTRN	?FindColorTagStartPosition@@YAHPB_WH@Z:PROC	; FindColorTagStartPosition
EXTRN	?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z:PROC ; GetTextTagInternalPosFromRenderPos
EXTRN	?MIN@@YAHHH@Z:PROC				; MIN
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	__imp__VariantClear@4:PROC
EXTRN	?GetDefaultCodePage@@YAKXZ:PROC			; GetDefaultCodePage
EXTRN	?ReadToken@@YAHPBD@Z:PROC			; ReadToken
EXTRN	?FindToken@@YAPBDPBD0@Z:PROC			; FindToken
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_IID_IUnknown:BYTE
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_CLSID_TF_ThreadMgr:BYTE
EXTRN	_CLSID_TF_InputProcessorProfiles:BYTE
EXTRN	_GUID_COMPARTMENT_KEYBOARD_OPENCLOSE:BYTE
EXTRN	_GUID_TFCAT_TIP_KEYBOARD:BYTE
EXTRN	_IID_ITfCompartmentEventSink:BYTE
EXTRN	_IID_ITfCompartmentMgr:BYTE
EXTRN	_IID_ITfSource:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A DB 0cH DUP (?) ; CIME::ms_wstrReading
	ALIGN	8

?g_disableCicero@@3VCDisableCicero@@A DQ 01H DUP (?)	; g_disableCicero
_BSS	ENDS
;	COMDAT ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
_BSS	SEGMENT
?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA DB 010H DUP (?) ; `CIME::GetCodePageText'::`2'::szCodePage
_BSS	ENDS
;	COMDAT ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA
_BSS	SEGMENT
?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA DB 01H DUP (?) ; `CIME::FinalizeString'::`2'::s_bProcessing
_BSS	ENDS
;	COMDAT ?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A
_BSS	SEGMENT
?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A DD 01H DUP (?) ; `CIME::GetImeId'::`2'::hklPrev
_BSS	ENDS
;	COMDAT ?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A
_BSS	SEGMENT
?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A DD 01H DUP (?) ; `CIME::CheckInputLocale'::`2'::s_hklPrev
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_wstrReading$initializer$@CIME@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ; ??ms_wstrReading$initializer$@CIME@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT ??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@
rdata$r	SEGMENT
??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ DD 00H ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
rdata$r	SEGMENT
??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ DD 00H ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R17?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (8,-1,0,66)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R17?0A@EA@ITfCompartmentEventSink@@8 DD FLAT:??_R0?AUITfCompartmentEventSink@@@8 ; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	01H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfCompartmentEventSink@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R13?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8 DD FLAT:??_R0?AUITfInputProcessorProfileActivationSink@@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	01H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfInputProcessorProfileActivationSink@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8 DD FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8 ; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R2CUIElementSink@CTsfUiLessMode@@8
rdata$r	SEGMENT
??_R2CUIElementSink@CTsfUiLessMode@@8 DD FLAT:??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8 ; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ITfUIElementSink@@8
	DD	FLAT:??_R1A@?0A@EC@IUnknown@@8
	DD	FLAT:??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8
	DD	FLAT:??_R13?0A@EC@IUnknown@@8
	DD	FLAT:??_R17?0A@EA@ITfCompartmentEventSink@@8
	DD	FLAT:??_R17?0A@EC@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	SEGMENT
??_R3CUIElementSink@CTsfUiLessMode@@8 DD 00H		; CTsfUiLessMode::CUIElementSink::`RTTI Class Hierarchy Descriptor'
	DD	05H
	DD	07H
	DD	FLAT:??_R2CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
data$rs	SEGMENT
??_R0?AVCUIElementSink@CTsfUiLessMode@@@8 DD FLAT:??_7type_info@@6B@ ; CTsfUiLessMode::CUIElementSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCUIElementSink@CTsfUiLessMode@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@
rdata$r	SEGMENT
??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ DD 00H ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ITfUIElementSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITfUIElementSink@@8 DD FLAT:??_R0?AUITfUIElementSink@@@8 ; ITfUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfUIElementSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITfUIElementSink@@8
rdata$r	SEGMENT
??_R2ITfUIElementSink@@8 DD FLAT:??_R1A@?0A@EA@ITfUIElementSink@@8 ; ITfUIElementSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ITfUIElementSink@@8
rdata$r	SEGMENT
??_R3ITfUIElementSink@@8 DD 00H				; ITfUIElementSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITfUIElementSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITfUIElementSink@@@8
data$rs	SEGMENT
??_R0?AUITfUIElementSink@@@8 DD FLAT:??_7type_info@@6B@	; ITfUIElementSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITfUIElementSink@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8 DD FLAT:??_R0?AUITfInputProcessorProfileActivationSink@@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfInputProcessorProfileActivationSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R2ITfInputProcessorProfileActivationSink@@8 DD FLAT:??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R3ITfInputProcessorProfileActivationSink@@8 DD 00H	; ITfInputProcessorProfileActivationSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITfInputProcessorProfileActivationSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITfInputProcessorProfileActivationSink@@@8
data$rs	SEGMENT
??_R0?AUITfInputProcessorProfileActivationSink@@@8 DD FLAT:??_7type_info@@6B@ ; ITfInputProcessorProfileActivationSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITfInputProcessorProfileActivationSink@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITfCompartmentEventSink@@8 DD FLAT:??_R0?AUITfCompartmentEventSink@@@8 ; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfCompartmentEventSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R2ITfCompartmentEventSink@@8 DD FLAT:??_R1A@?0A@EA@ITfCompartmentEventSink@@8 ; ITfCompartmentEventSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R3ITfCompartmentEventSink@@8 DD 00H			; ITfCompartmentEventSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITfCompartmentEventSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITfCompartmentEventSink@@@8
data$rs	SEGMENT
??_R0?AUITfCompartmentEventSink@@@8 DD FLAT:??_7type_info@@6B@ ; ITfCompartmentEventSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITfCompartmentEventSink@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CIME@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CIME@@8 DD FLAT:??_R0?AVCIME@@@8		; CIME::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CIME@@8
rdata$r	ENDS
;	COMDAT ??_R2CIME@@8
rdata$r	SEGMENT
??_R2CIME@@8 DD	FLAT:??_R1A@?0A@EA@CIME@@8		; CIME::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CIME@@8
rdata$r	SEGMENT
??_R3CIME@@8 DD	00H					; CIME::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CIME@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCIME@@@8
data$rs	SEGMENT
??_R0?AVCIME@@@8 DD FLAT:??_7type_info@@6B@		; CIME `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCIME@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CIME@@6B@
rdata$r	SEGMENT
??_R4CIME@@6B@ DD 00H					; CIME::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCIME@@@8
	DD	FLAT:??_R3CIME@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2IUnknown@@8
rdata$r	SEGMENT
??_R2IUnknown@@8 DD FLAT:??_R1A@?0A@EA@IUnknown@@8	; IUnknown::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IUnknown@@8
rdata$r	SEGMENT
??_R3IUnknown@@8 DD 00H					; IUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
data$rs	SEGMENT
??_R0?AUIUnknown@@@8 DD FLAT:??_7type_info@@6B@		; IUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknown@@', 00H
data$rs	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION@?1??GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z@4U_GUID@@A
_DATA	SEGMENT
?_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION@?1??GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z@4U_GUID@@A DD 0ccf05dd8H ; `CTsfUiLessMode::GetCompartments'::`2'::_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION
	DW	04a87H
	DW	011d7H
	DB	0a6H
	DB	0e2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
_DATA	ENDS
;	COMDAT __GUID_71c6e74c_0f28_11d8_a82a_00065b84435c
CONST	SEGMENT
__GUID_71c6e74c_0f28_11d8_a82a_00065b84435c DD 071c6e74cH
	DW	0f28H
	DW	011d8H
	DB	0a8H
	DB	02aH
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca
CONST	SEGMENT
__GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca DD 01f02b6c5H
	DW	07842H
	DW	04ee6H
	DB	08aH
	DB	0bH
	DB	09aH
	DB	024H
	DB	018H
	DB	03aH
	DB	095H
	DB	0caH
CONST	ENDS
;	COMDAT __GUID_ea1ea135_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea135_19df_11d7_a6d2_00065b84435c DD 0ea1ea135H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT ?TF_PROFILE_DAYI@?1??OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z@4U4@A
_DATA	SEGMENT
?TF_PROFILE_DAYI@?1??OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z@4U4@A DD 037b2c25H ; `CTsfUiLessMode::CUIElementSink::OnActivated'::`2'::TF_PROFILE_DAYI
	DW	0480cH
	DW	04d7fH
	DB	0b0H
	DB	027H
	DB	0d6H
	DB	0caH
	DB	06bH
	DB	069H
	DB	078H
	DB	08aH
_DATA	ENDS
;	COMDAT __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea138_19df_11d7_a6d2_00065b84435c DD 0ea1ea138H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea139_19df_11d7_a6d2_00065b84435c DD 0ea1ea139H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_743abd5f_f26d_48df_8cc5_238492419b64
CONST	SEGMENT
__GUID_743abd5f_f26d_48df_8cc5_238492419b64 DD 0743abd5fH
	DW	0f26dH
	DW	048dfH
	DB	08cH
	DB	0c5H
	DB	023H
	DB	084H
	DB	092H
	DB	041H
	DB	09bH
	DB	064H
CONST	ENDS
;	COMDAT __GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
CONST	SEGMENT
__GUID_71c6e74e_0f28_11d8_a82a_00065b84435c DD 071c6e74eH
	DW	0f28H
	DW	011d8H
	DB	0a8H
	DB	02aH
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea136_19df_11d7_a6d2_00065b84435c DD 0ea1ea136H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
CONST	SEGMENT
__GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7 DD 04ea48a35H
	DW	060aeH
	DW	0446fH
	DB	08fH
	DB	0d6H
	DB	0e6H
	DB	0a8H
	DB	0d8H
	DB	024H
	DB	059H
	DB	0f7H
CONST	ENDS
;	COMDAT __GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c
CONST	SEGMENT
__GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c DD 03e90ade3H
	DW	07594H
	DW	04cb0H
	DB	0bbH
	DB	058H
	DB	069H
	DB	062H
	DB	08fH
	DB	05fH
	DB	045H
	DB	08cH
CONST	ENDS
;	COMDAT ?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA
_DATA	SEGMENT
?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA DD 0ffffH ; `CIME::CheckInputLocale'::`2'::s_uPrevCodePage
_DATA	ENDS
;	COMDAT ??_C@_0BC@MEELNKEC@ShowReadingWindow@
CONST	SEGMENT
??_C@_0BC@MEELNKEC@ShowReadingWindow@ DB 'ShowReadingWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EOIFCLLM@GetReadingString@
CONST	SEGMENT
??_C@_0BB@EOIFCLLM@GetReadingString@ DB 'GetReadingString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@
CONST	SEGMENT
??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@ DB 'GOOGLEPINYIN2.IME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IPABOCGB@SOGOUPY?4IME@
CONST	SEGMENT
??_C@_0M@IPABOCGB@SOGOUPY?4IME@ DB 'SOGOUPY.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EMABPIGL@QQPINYIN?4IME@
CONST	SEGMENT
??_C@_0N@EMABPIGL@QQPINYIN?4IME@ DB 'QQPINYIN.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@
CONST	SEGMENT
??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@ DB 'Keyboard Mapping', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LMKCILHO@TINTLGNT@
CONST	SEGMENT
??_C@_08LMKCILHO@TINTLGNT@ DB 'TINTLGNT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DEJAPC@MSTCIPH@
CONST	SEGMENT
??_C@_07DEJAPC@MSTCIPH@ DB 'MSTCIPH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@
CONST	SEGMENT
??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@ DB 'software\micro'
	DB	'soft\windows\currentversion\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@
CONST	SEGMENT
??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@ DB 'MSSCIPYA.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JFHOELJF@PINTLGNT?4IME@
CONST	SEGMENT
??_C@_0N@JFHOELJF@PINTLGNT?4IME@ DB 'PINTLGNT.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FHDFFBN@MSTCIPHA?4IME@
CONST	SEGMENT
??_C@_0N@FHDFFBN@MSTCIPHA?4IME@ DB 'MSTCIPHA.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JMLDIBIB@CINTLGNT?4IME@
CONST	SEGMENT
??_C@_0N@JMLDIBIB@CINTLGNT?4IME@ DB 'CINTLGNT.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FFMHCBAD@TINTLGNT?4IME@
CONST	SEGMENT
??_C@_0N@FFMHCBAD@TINTLGNT?4IME@ DB 'TINTLGNT.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05EFEJGKEJ@?$EA9999@
CONST	SEGMENT
??_C@_05EFEJGKEJ@?$EA9999@ DB '@9999', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKJMOPAK@?$EA?$CF04d@
CONST	SEGMENT
??_C@_05JKJMOPAK@?$EA?$CF04d@ DB '@%04d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@
CONST	SEGMENT
??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@ DB 'ImmDisableTextFrameSer'
	DB	'vice', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKKOACL@ImmUnlockIMCC@
CONST	SEGMENT
??_C@_0O@GKKOACL@ImmUnlockIMCC@ DB 'ImmUnlockIMCC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OKKMJOGM@ImmLockIMCC@
CONST	SEGMENT
??_C@_0M@OKKMJOGM@ImmLockIMCC@ DB 'ImmLockIMCC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDIACEGP@ImmUnlockIMC@
CONST	SEGMENT
??_C@_0N@PDIACEGP@ImmUnlockIMC@ DB 'ImmUnlockIMC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JGAMEFKO@ImmLockIMC@
CONST	SEGMENT
??_C@_0L@JGAMEFKO@ImmLockIMC@ DB 'ImmLockIMC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LPOFADGE@?2imm32?4dll@
CONST	SEGMENT
??_C@_0L@LPOFADGE@?2imm32?4dll@ DB '\imm32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT __GUID_aa80e801_2021_11d2_93e0_0060b067b86e
CONST	SEGMENT
__GUID_aa80e801_2021_11d2_93e0_0060b067b86e DD 0aa80e801H
	DW	02021H
	DW	011d2H
	DB	093H
	DB	0e0H
	DB	00H
	DB	060H
	DB	0b0H
	DB	067H
	DB	0b8H
	DB	06eH
CONST	ENDS
;	COMDAT ??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@
CONST	SEGMENT
??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ DD FLAT:??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
	DD	FLAT:?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
	DD	FLAT:?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
	DD	FLAT:?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z
CONST	ENDS
;	COMDAT ??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
CONST	SEGMENT
??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ DD FLAT:??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
	DD	FLAT:?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
	DD	FLAT:?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
	DD	FLAT:?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z
CONST	ENDS
;	COMDAT ??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@
CONST	SEGMENT
??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ DD FLAT:??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
	DD	FLAT:?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ
	DD	FLAT:?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ
	DD	FLAT:?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z
	DD	FLAT:?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
	DD	FLAT:?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
CONST	ENDS
;	COMDAT ??_7CIME@@6B@
CONST	SEGMENT
??_7CIME@@6B@ DD FLAT:??_R4CIME@@6B@			; CIME::`vftable'
	DD	FLAT:??_ECIME@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Fg_disableCicero@@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__Fg_disableCicero@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Fg_disableCicero@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CDisableCicero@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsMax@CIME@@IAE_NPB_WH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsMax@CIME@@IAE_NPB_WH@Z$0
__ehfuncinfo$?IsMax@CIME@@IAE_NPB_WH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsMax@CIME@@IAE_NPB_WH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z$0
__ehfuncinfo$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PasteTextFromClipBoard@CIME@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PasteTextFromClipBoard@CIME@@QAEXXZ$0
__ehfuncinfo$?PasteTextFromClipBoard@CIME@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PasteTextFromClipBoard@CIME@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_disableCicero$initializer$@@3P6AXXZA DD FLAT:??__Eg_disableCicero@@YAXXZ ; g_disableCicero$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
_TEXT	SEGMENT
?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{8}', COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::Release
?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{8}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
_TEXT	SEGMENT
?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{8}', COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::AddRef
?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{8}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{8}', COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ; CTsfUiLessMode::CUIElementSink::QueryInterface
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{8}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
_TEXT	SEGMENT
?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{4}', COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::Release
?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{4}', COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::AddRef
?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{4}', COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ; CTsfUiLessMode::CUIElementSink::QueryInterface
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAE@std@@YAPAEQBDQAEII@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAE@std@@YAPAEQBDQAEII@Z PROC	; std::_Copy_memmove_tail<unsigned char *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAE@std@@YAPAEQBDQAEII@Z ENDP	; std::_Copy_memmove_tail<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z PROC	; std::_Copy_memmove<wchar_t *,wchar_t *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	d1 f8		 sar	 eax, 1

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  0000f	50		 push	 eax
  00010	51		 push	 ecx
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PA_W@std@@YAPA_WQBDQA_WII@Z ; std::_Copy_memmove_tail<wchar_t *>
  0001a	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ENDP	; std::_Copy_memmove<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b c1		 sub	 eax, ecx

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  0000b	50		 push	 eax
  0000c	50		 push	 eax
  0000d	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAE@std@@YAPAEQBDQAEII@Z ; std::_Copy_memmove_tail<unsigned char *>
  00016	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PA_W@std@@YAPA_WQBDQA_WII@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PA_W@std@@YAPA_WQBDQA_WII@Z PROC	; std::_Copy_memmove_tail<wchar_t *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PA_W@std@@YAPA_WQBDQA_WII@Z ENDP	; std::_Copy_memmove_tail<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z PROC		; std::_Zero_range<wchar_t *>, COMDAT

; 2032 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2033 :     char* const _First_ch = reinterpret_cast<char*>(_STD _To_address(_First));
; 2034 :     char* const _Last_ch  = reinterpret_cast<char*>(_STD _To_address(_Last));
; 2035 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 2036 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2037 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z ENDP		; std::_Zero_range<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 2032 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2033 :     char* const _First_ch = reinterpret_cast<char*>(_STD _To_address(_First));
; 2034 :     char* const _Last_ch  = reinterpret_cast<char*>(_STD _To_address(_Last));
; 2035 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 2036 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2037 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_n@PA_WPA_W@std@@YAPA_WPA_WI0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Object_count$ = 12					; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove_n@PA_WPA_W@std@@YAPA_WPA_WI0@Z PROC	; std::_Copy_memmove_n<wchar_t *,wchar_t *>, COMDAT

; 4790 : _OutCtgIt _Copy_memmove_n(_CtgIt _First, const size_t _Object_count, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4791 :     const auto _First_ptr  = _STD _To_address(_First);
; 4792 :     const auto _First_ch   = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4793 :     const auto _Byte_count = _Object_count * sizeof(*_First_ptr);
; 4794 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Object_count$[ebp]
  00006	50		 push	 eax
  00007	03 c0		 add	 eax, eax
  00009	50		 push	 eax
  0000a	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PA_W@std@@YAPA_WQBDQA_WII@Z ; std::_Copy_memmove_tail<wchar_t *>
  00015	83 c4 10	 add	 esp, 16			; 00000010H

; 4795 : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??$_Copy_memmove_n@PA_WPA_W@std@@YAPA_WPA_WI0@Z ENDP	; std::_Copy_memmove_n<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Find_vectorized@_W_W@std@@YAPA_WQA_W0_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 2
??$_Find_vectorized@_W_W@std@@YAPA_WQA_W0_W@Z PROC	; std::_Find_vectorized<wchar_t,wchar_t>, COMDAT

; 199  : _Ty* _Find_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  :     if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
; 201  : #ifdef _WIN64
; 202  :         return const_cast<_Ty*>(
; 203  :             static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val))));
; 204  : #else
; 205  :         return const_cast<_Ty*>(
; 206  :             static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, reinterpret_cast<uint32_t>(_Val))));
; 207  : #endif
; 208  :     } else if constexpr (sizeof(_Ty) == 1) {
; 209  :         return const_cast<_Ty*>(
; 210  :             static_cast<const _Ty*>(::__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 211  :     } else if constexpr (sizeof(_Ty) == 2) {
; 212  :         return const_cast<_Ty*>(

  00003	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ___std_find_trivial_2@12

; 213  :             static_cast<const _Ty*>(::__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 214  :     } else if constexpr (sizeof(_Ty) == 4) {
; 215  :         return const_cast<_Ty*>(
; 216  :             static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 217  :     } else if constexpr (sizeof(_Ty) == 8) {
; 218  :         return const_cast<_Ty*>(
; 219  :             static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 220  :     } else {
; 221  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 222  :     }
; 223  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Find_vectorized@_W_W@std@@YAPA_WQA_W0_W@Z ENDP	; std::_Find_vectorized<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Assign_counted_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_WI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Oldsize$1$ = 12					; size = 4
$T1 = 12						; size = 4
??$_Assign_counted_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_WI@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_counted_range<wchar_t *>, COMDAT
; _this$ = ecx

; 1405 :     _CONSTEXPR20 void _Assign_counted_range(_Iter _First, const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1406 :         // assign elements from counted range _First + [0, _Newsize)
; 1407 :         auto& _Al         = _Getal();
; 1408 :         auto& _My_data    = _Mypair._Myval2;
; 1409 :         pointer& _Myfirst = _My_data._Myfirst;
; 1410 :         pointer& _Mylast  = _My_data._Mylast;
; 1411 :         pointer& _Myend   = _My_data._Myend;
; 1412 : 
; 1413 :         constexpr bool _Nothrow_construct = conjunction_v<is_nothrow_constructible<_Ty, _Iter_ref_t<_Iter>>,
; 1414 :             _Uses_default_construct<_Alloc, _Ty*, _Iter_ref_t<_Iter>>>;
; 1415 : 
; 1416 :         _My_data._Orphan_all();
; 1417 :         const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1418 :         if (_Newsize > _Oldcapacity) {

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0000e	8b 37		 mov	 esi, DWORD PTR [edi]
  00010	2b ce		 sub	 ecx, esi
  00012	d1 f9		 sar	 ecx, 1
  00014	3b d9		 cmp	 ebx, ecx
  00016	0f 86 c6 00 00
	00		 jbe	 $LN5@Assign_cou

; 1688 :         if (_Newsize > max_size()) {

  0001c	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00022	0f 87 f6 00 00
	00		 ja	 $LN105@Assign_cou

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00028	8b d1		 mov	 edx, ecx
  0002a	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0002f	d1 ea		 shr	 edx, 1
  00031	2b c2		 sub	 eax, edx
  00033	3b c8		 cmp	 ecx, eax
  00035	76 09		 jbe	 SHORT $LN15@Assign_cou

; 1997 :             return _Max; // geometric growth would overflow

  00037	c7 45 0c ff ff
	ff 7f		 mov	 DWORD PTR $T1[ebp], 2147483647 ; 7fffffffH
  0003e	eb 0b		 jmp	 SHORT $LN16@Assign_cou
$LN15@Assign_cou:

; 1998 :         }
; 1999 : 
; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00040	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00043	3b c3		 cmp	 eax, ebx
  00045	0f 42 c3	 cmovb	 eax, ebx
  00048	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
$LN16@Assign_cou:

; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  0004b	85 f6		 test	 esi, esi
  0004d	74 3e		 je	 SHORT $LN12@Assign_cou
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0004f	03 c9		 add	 ecx, ecx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00051	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00057	72 16		 jb	 SHORT $LN37@Assign_cou

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00059	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  0005c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0005f	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00061	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00064	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00067	0f 87 bb 00 00
	00		 ja	 $LN34@Assign_cou

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0006d	8b f2		 mov	 esi, edx
$LN37@Assign_cou:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0006f	51		 push	 ecx
  00070	56		 push	 esi
  00071	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1699 :             _Myfirst = nullptr;

  00076	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007c	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1700 :             _Mylast  = nullptr;

  0007f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1701 :             _Myend   = nullptr;

  00086	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN12@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0008d	8b 75 0c	 mov	 esi, DWORD PTR $T1[ebp]
  00090	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00096	0f 87 87 00 00
	00		 ja	 $LN106@Assign_cou

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0009c	03 f6		 add	 esi, esi

; 227  :     if (_Bytes == 0) {

  0009e	74 1a		 je	 SHORT $LN51@Assign_cou
$LN52@Assign_cou:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000a0	56		 push	 esi
  000a1	81 fe 00 10 00
	00		 cmp	 esi, 4096		; 00001000H
  000a7	72 07		 jb	 SHORT $LN53@Assign_cou

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a9	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ae	eb 05		 jmp	 SHORT $LN102@Assign_cou
$LN53@Assign_cou:

; 136  :         return ::operator new(_Bytes);

  000b0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN102@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2020 :         _Myfirst              = _Newvec;

  000b5	8b f0		 mov	 esi, eax
  000b7	83 c4 04	 add	 esp, 4
$LN51@Assign_cou:

; 2021 :         _Mylast               = _Newvec;
; 2022 :         _Myend                = _Newvec + _Newcapacity;

  000ba	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
  000bd	89 37		 mov	 DWORD PTR [edi], esi
  000bf	89 77 04	 mov	 DWORD PTR [edi+4], esi
  000c2	8d 04 46	 lea	 eax, DWORD PTR [esi+eax*2]
  000c5	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN6@Assign_cou:

; 1465 :     }

  000c8	56		 push	 esi
  000c9	53		 push	 ebx
  000ca	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000cd	e8 00 00 00 00	 call	 ??$_Copy_memmove_n@PA_WPA_W@std@@YAPA_WPA_WI0@Z ; std::_Copy_memmove_n<wchar_t *,wchar_t *>
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d5	8d 04 5e	 lea	 eax, DWORD PTR [esi+ebx*2]
  000d8	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5b		 pop	 ebx
  000de	5d		 pop	 ebp
  000df	c2 08 00	 ret	 8
$LN5@Assign_cou:

; 1419 :             _Clear_and_reserve_geometric(_Newsize);
; 1420 :             if constexpr (_Nothrow_construct) {
; 1421 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1422 :                 _ASAN_VECTOR_CREATE;
; 1423 :             } else {
; 1424 :                 _ASAN_VECTOR_CREATE_GUARD;
; 1425 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize, _Myfirst, _Al);
; 1426 :             }
; 1427 :             return;
; 1428 :         }
; 1429 : 
; 1430 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  000e2	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000e5	2b c6		 sub	 eax, esi
  000e7	d1 f8		 sar	 eax, 1
  000e9	89 45 0c	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1431 :         if (_Newsize > _Oldsize) {

  000ec	3b d8		 cmp	 ebx, eax
  000ee	76 d8		 jbe	 SHORT $LN6@Assign_cou

; 1432 :             bool _Copied = false;
; 1433 :             if constexpr (_Iter_copy_cat<_Iter, pointer>::_Bitcopy_assignable) {
; 1434 : #if _HAS_CXX20
; 1435 :                 if (!_STD is_constant_evaluated())
; 1436 : #endif // _HAS_CXX20
; 1437 :                 {
; 1438 :                     _Copy_memmove_n(_First, static_cast<size_t>(_Oldsize), _Myfirst);

  000f0	56		 push	 esi
  000f1	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  000f4	50		 push	 eax
  000f5	56		 push	 esi
  000f6	e8 00 00 00 00	 call	 ??$_Copy_memmove_n@PA_WPA_W@std@@YAPA_WPA_WI0@Z ; std::_Copy_memmove_n<wchar_t *,wchar_t *>

; 1439 :                     _First += _Oldsize;

  000fb	8b 4d 0c	 mov	 ecx, DWORD PTR __Oldsize$1$[ebp]

; 1440 :                     _Copied = true;
; 1441 :                 }
; 1442 :             }
; 1443 : 
; 1444 :             if (!_Copied) {
; 1445 :                 for (auto _Mid = _Myfirst; _Mid != _Mylast; ++_Mid, (void) ++_First) {
; 1446 :                     *_Mid = *_First;
; 1447 :                 }
; 1448 :             }
; 1449 : 
; 1450 :             if constexpr (_Nothrow_construct) {
; 1451 :                 _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1452 :                 _Mylast = _STD _Uninitialized_copy_n(_STD move(_First), _Newsize - _Oldsize, _Mylast, _Al);

  000fe	2b d9		 sub	 ebx, ecx
  00100	8d 04 4e	 lea	 eax, DWORD PTR [esi+ecx*2]
  00103	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1893 :             _STD _Copy_memmove_n(_UFirst, _Count, _STD _Unfancy(_Dest));

  00106	56		 push	 esi
  00107	53		 push	 ebx
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 ??$_Copy_memmove_n@PA_WPA_W@std@@YAPA_WPA_WI0@Z ; std::_Copy_memmove_n<wchar_t *,wchar_t *>
  0010e	83 c4 18	 add	 esp, 24			; 00000018H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1465 :     }

  00111	8d 04 5e	 lea	 eax, DWORD PTR [esi+ebx*2]
  00114	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	5d		 pop	 ebp
  0011b	c2 08 00	 ret	 8
$LN105@Assign_cou:

; 1689 :             _Xlength();

  0011e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN106@Assign_cou:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00123	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN34@Assign_cou:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00128	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN101@Assign_cou:
  0012d	cc		 int	 3
??$_Assign_counted_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_WI@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_counted_range<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?_strtoul@@YAKPBDPAPADH@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?_strtoul@@YAKPBDPAPADH@Z PROC				; _strtoul, COMDAT

; 1421 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1422 : 	if ( !psz )

  00004	8b 75 08	 mov	 esi, DWORD PTR _psz$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 05		 jne	 SHORT $LN6@strtoul

; 1423 : 		return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 1452 : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN6@strtoul:

; 1424 : 
; 1425 : 	ULONG ulRet = 0;
; 1426 : 	if ( psz[0] == '0' && ( psz[1] == 'x' || psz[1] == 'X' ) )

  00010	8a 0e		 mov	 cl, BYTE PTR [esi]
  00012	33 d2		 xor	 edx, edx
  00014	80 f9 30	 cmp	 cl, 48			; 00000030H
  00017	75 58		 jne	 SHORT $LN18@strtoul
  00019	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  0001c	3c 78		 cmp	 al, 120			; 00000078H
  0001e	74 04		 je	 SHORT $LN9@strtoul
  00020	3c 58		 cmp	 al, 88			; 00000058H
  00022	75 51		 jne	 SHORT $LN26@strtoul
$LN9@strtoul:

; 1427 : 	{
; 1428 : 		psz += 2;
; 1429 : 		ULONG ul = 0;
; 1430 : 		while ( *psz )

  00024	8a 46 02	 mov	 al, BYTE PTR [esi+2]
  00027	83 c6 02	 add	 esi, 2
  0002a	84 c0		 test	 al, al
  0002c	74 67		 je	 SHORT $LN27@strtoul
  0002e	8a c8		 mov	 cl, al
$LL2@strtoul:

; 1431 : 		{
; 1432 : 			if ( '0' <= *psz && *psz <= '9' )

  00030	3c 30		 cmp	 al, 48			; 00000030H
  00032	7c 0d		 jl	 SHORT $LN23@strtoul
  00034	80 f9 39	 cmp	 cl, 57			; 00000039H
  00037	7f 08		 jg	 SHORT $LN23@strtoul

; 1433 : 				ul = *psz - '0';

  00039	0f be c1	 movsx	 eax, cl
  0003c	83 e8 30	 sub	 eax, 48			; 00000030H
  0003f	eb 1c		 jmp	 SHORT $LN15@strtoul
$LN23@strtoul:

; 1434 : 			else if ( 'A' <= *psz && *psz <= 'F' )

  00041	8d 41 bf	 lea	 eax, DWORD PTR [ecx-65]
  00044	3c 05		 cmp	 al, 5
  00046	77 08		 ja	 SHORT $LN12@strtoul

; 1435 : 				ul = *psz - 'A' + 10;

  00048	0f be c1	 movsx	 eax, cl
  0004b	83 e8 37	 sub	 eax, 55			; 00000037H
  0004e	eb 0d		 jmp	 SHORT $LN15@strtoul
$LN12@strtoul:

; 1436 : 			else if ( 'a' <= *psz && *psz <= 'f' )

  00050	8d 41 9f	 lea	 eax, DWORD PTR [ecx-97]
  00053	3c 05		 cmp	 al, 5
  00055	77 3e		 ja	 SHORT $LN27@strtoul

; 1437 : 				ul = *psz - 'a' + 10;

  00057	0f be c1	 movsx	 eax, cl
  0005a	83 e8 57	 sub	 eax, 87			; 00000057H
$LN15@strtoul:

; 1438 : 			else
; 1439 : 				break;
; 1440 : 			ulRet = ulRet * 16 + ul;
; 1441 : 			psz++;

  0005d	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  00060	46		 inc	 esi
  00061	c1 e2 04	 shl	 edx, 4
  00064	03 d0		 add	 edx, eax
  00066	8a c1		 mov	 al, cl
  00068	84 c9		 test	 cl, cl
  0006a	75 c4		 jne	 SHORT $LL2@strtoul

; 1449 : 		}
; 1450 : 	}
; 1451 : 	return ulRet;

  0006c	8b c2		 mov	 eax, edx
  0006e	5e		 pop	 esi

; 1452 : }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN18@strtoul:

; 1442 : 		}
; 1443 : 	}
; 1444 : 	else {
; 1445 : 		while ( *psz && ( '0' <= *psz && *psz <= '9' ) )

  00071	84 c9		 test	 cl, cl
  00073	74 20		 je	 SHORT $LN27@strtoul
$LN26@strtoul:
  00075	8a c1		 mov	 al, cl
$LL4@strtoul:
  00077	80 f9 30	 cmp	 cl, 48			; 00000030H
  0007a	7c 19		 jl	 SHORT $LN27@strtoul
  0007c	3c 39		 cmp	 al, 57			; 00000039H
  0007e	7f 15		 jg	 SHORT $LN27@strtoul

; 1446 : 		{
; 1447 : 			ulRet = ulRet * 10 + ( *psz - '0' );

  00080	0f be c0	 movsx	 eax, al
  00083	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]

; 1448 : 			psz++;

  00086	46		 inc	 esi
  00087	8d 52 e8	 lea	 edx, DWORD PTR [edx-24]
  0008a	8d 14 50	 lea	 edx, DWORD PTR [eax+edx*2]
  0008d	8a 06		 mov	 al, BYTE PTR [esi]
  0008f	8a c8		 mov	 cl, al
  00091	84 c0		 test	 al, al
  00093	75 e2		 jne	 SHORT $LL4@strtoul
$LN27@strtoul:

; 1449 : 		}
; 1450 : 	}
; 1451 : 	return ulRet;

  00095	8b c2		 mov	 eax, edx
  00097	5e		 pop	 esi

; 1452 : }

  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?_strtoul@@YAKPBDPAPADH@Z ENDP				; _strtoul
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 3d		 je	 SHORT $LN5@vector

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 22		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0002f	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00035	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00038	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  0003f	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00046	5e		 pop	 esi

; 820  :     }

  00047	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00048	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  0004d	cc		 int	 3
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ??__Fg_disableCicero@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Fg_disableCicero@@YAXXZ PROC			; `dynamic atexit destructor for 'g_disableCicero'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??__Fg_disableCicero@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 244  : 		if ( m_ptim )

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_disableCicero@@3VCDisableCicero@@A

; 221  : 	{

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 244  : 		if ( m_ptim )

  0002f	85 c9		 test	 ecx, ecx
  00031	74 10		 je	 SHORT $LN9@dynamic

; 245  : 		{
; 246  : 			m_ptim->Release();

  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	51		 push	 ecx
  00036	ff 50 08	 call	 DWORD PTR [eax+8]

; 247  : 			m_ptim = NULL;

  00039	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_disableCicero@@3VCDisableCicero@@A, 0
$LN9@dynamic:

; 248  : 		}
; 249  : 		if ( m_bComInit )

  00043	80 3d 04 00 00
	00 00		 cmp	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0
  0004a	74 06		 je	 SHORT $LN12@dynamic

; 250  : 			CoUninitialize();

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
$LN12@dynamic:

; 251  : 		m_bComInit = false;

  00052	c6 05 04 00 00
	00 00		 mov	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
  0006c	cc		 int	 3
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__Fg_disableCicero@@YAXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__Fg_disableCicero@@YAXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__Fg_disableCicero@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_disableCicero''
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ??__Eg_disableCicero@@YAXXZ
text$di	SEGMENT
??__Eg_disableCicero@@YAXXZ PROC			; `dynamic initializer for 'g_disableCicero'', COMDAT

; 272  : static CDisableCicero g_disableCicero;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fg_disableCicero@@YAXXZ ; `dynamic atexit destructor for 'g_disableCicero''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Eg_disableCicero@@YAXXZ ENDP			; `dynamic initializer for 'g_disableCicero''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z
_TEXT	SEGMENT
_srcTm$ = -4						; size = 4
_bEnable$ = 8						; size = 1
?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z PROC		; CTsfUiLessMode::EnableUiUpdates, COMDAT

; 2020 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2021 : 	if ( m_tm == NULL ||
; 2022 : 		 ( bEnable && m_dwUIElementSinkCookie != TF_INVALID_COOKIE )  ||

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0000a	85 c9		 test	 ecx, ecx
  0000c	74 7e		 je	 SHORT $LN3@EnableUiUp
  0000e	53		 push	 ebx
  0000f	8a 5d 08	 mov	 bl, BYTE PTR _bEnable$[ebp]
  00012	84 db		 test	 bl, bl
  00014	74 0b		 je	 SHORT $LN9@EnableUiUp
  00016	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwUIElementSinkCookie
  0001d	75 6c		 jne	 SHORT $LN14@EnableUiUp
  0001f	eb 09		 jmp	 SHORT $LN2@EnableUiUp
$LN9@EnableUiUp:
  00021	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwUIElementSinkCookie
  00028	74 61		 je	 SHORT $LN14@EnableUiUp
$LN2@EnableUiUp:

; 2023 : 		 ( !bEnable && m_dwUIElementSinkCookie == TF_INVALID_COOKIE ) )
; 2024 : 	{
; 2025 : 		return;
; 2026 : 	}
; 2027 : 	ITfSource *srcTm = NULL;
; 2028 : 	HRESULT hr = E_FAIL;
; 2029 : 	if (SUCCEEDED(hr = m_tm->QueryInterface(__uuidof(ITfSource), (void **)&srcTm)))

  0002a	8d 55 fc	 lea	 edx, DWORD PTR _srcTm$[ebp]
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _srcTm$[ebp], 0
  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	52		 push	 edx
  00037	68 00 00 00 00	 push	 OFFSET __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
  0003c	51		 push	 ecx
  0003d	ff 10		 call	 DWORD PTR [eax]
  0003f	85 c0		 test	 eax, eax
  00041	78 48		 js	 SHORT $LN14@EnableUiUp

; 2030 : 	{
; 2031 : 		if ( bEnable )

  00043	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$[ebp]
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	84 db		 test	 bl, bl
  0004a	74 22		 je	 SHORT $LN6@EnableUiUp

; 2032 : 		{
; 2033 : 			hr = srcTm->AdviseSink(__uuidof(ITfUIElementSink), (ITfUIElementSink*)m_TsfSink, &m_dwUIElementSinkCookie);

  0004c	68 00 00 00 00	 push	 OFFSET ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  00051	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  00057	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
  0005c	50		 push	 eax
  0005d	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 2038 : 			m_dwUIElementSinkCookie = TF_INVALID_COOKIE;
; 2039 : 		}
; 2040 : 		srcTm->Release();

  00060	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$[ebp]
  00063	50		 push	 eax
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	ff 51 08	 call	 DWORD PTR [ecx+8]
  00069	5b		 pop	 ebx

; 2041 : 	}
; 2042 : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN6@EnableUiUp:

; 2034 : 		}
; 2035 : 		else
; 2036 : 		{
; 2037 : 			hr = srcTm->UnadviseSink(m_dwUIElementSinkCookie);

  0006e	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  00074	50		 push	 eax
  00075	ff 51 10	 call	 DWORD PTR [ecx+16]

; 2038 : 			m_dwUIElementSinkCookie = TF_INVALID_COOKIE;
; 2039 : 		}
; 2040 : 		srcTm->Release();

  00078	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$[ebp]
  0007b	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwUIElementSinkCookie
  00085	50		 push	 eax
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN14@EnableUiUp:
  0008b	5b		 pop	 ebx
$LN3@EnableUiUp:

; 2041 : 	}
; 2042 : }

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z ENDP		; CTsfUiLessMode::EnableUiUpdates
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?UpdateImeState@CTsfUiLessMode@@SAXH@Z
_TEXT	SEGMENT
_valConvMode$1 = -44					; size = 16
_valOpenMode$2 = -28					; size = 16
_pcm$ = -12						; size = 4
_pTfConvMode$ = -8					; size = 4
_pTfOpenMode$ = -4					; size = 4
_bResetCompartmentEventSink$ = 8			; size = 4
?UpdateImeState@CTsfUiLessMode@@SAXH@Z PROC		; CTsfUiLessMode::UpdateImeState, COMDAT

; 1805 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 1806 : 	ITfCompartmentMgr* pcm;
; 1807 : 	ITfCompartment* pTfOpenMode = NULL;
; 1808 : 	ITfCompartment* pTfConvMode = NULL;
; 1809 : 	if ( GetCompartments( &pcm, &pTfOpenMode, &pTfConvMode ) )

  00006	8d 45 f8	 lea	 eax, DWORD PTR _pTfConvMode$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pTfOpenMode$[ebp], 0
  00010	50		 push	 eax
  00011	8d 45 fc	 lea	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pTfConvMode$[ebp], 0
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR _pcm$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ; CTsfUiLessMode::GetCompartments
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8e 00 00
	00		 je	 $LN2@UpdateImeS

; 1810 : 	{
; 1811 : 		VARIANT valOpenMode;
; 1812 : 		VARIANT valConvMode;
; 1813 : 		pTfOpenMode->GetValue( &valOpenMode );

  00030	53		 push	 ebx
  00031	57		 push	 edi
  00032	8b 7d fc	 mov	 edi, DWORD PTR _pTfOpenMode$[ebp]
  00035	8d 4d e4	 lea	 ecx, DWORD PTR _valOpenMode$2[ebp]
  00038	51		 push	 ecx
  00039	57		 push	 edi
  0003a	8b 07		 mov	 eax, DWORD PTR [edi]
  0003c	ff 50 10	 call	 DWORD PTR [eax+16]

; 1814 : 		pTfConvMode->GetValue( &valConvMode );

  0003f	8b 5d f8	 mov	 ebx, DWORD PTR _pTfConvMode$[ebp]
  00042	8d 4d d4	 lea	 ecx, DWORD PTR _valConvMode$1[ebp]
  00045	51		 push	 ecx
  00046	53		 push	 ebx
  00047	8b 03		 mov	 eax, DWORD PTR [ebx]
  00049	ff 50 10	 call	 DWORD PTR [eax+16]

; 1815 : 		if ( valOpenMode.vt == VT_I4 )

  0004c	66 83 7d e4 03	 cmp	 WORD PTR _valOpenMode$2[ebp], 3
  00051	75 2e		 jne	 SHORT $LN5@UpdateImeS

; 1816 : 		{
; 1817 : 			if ( CIME::ms_bChineseIME )

  00053	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, 0 ; CIME::ms_bChineseIME
  0005a	74 18		 je	 SHORT $LN4@UpdateImeS

; 1818 : 			{
; 1819 : 				CIME::ms_dwImeState = valOpenMode.lVal != 0 && valConvMode.lVal != 0 ? IMEUI_STATE_ON : IMEUI_STATE_ENGLISH;

  0005c	83 7d ec 00	 cmp	 DWORD PTR _valOpenMode$2[ebp+8], 0
  00060	74 0b		 je	 SHORT $LN8@UpdateImeS
  00062	83 7d dc 00	 cmp	 DWORD PTR _valConvMode$1[ebp+8], 0
  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	75 0f		 jne	 SHORT $LN9@UpdateImeS
$LN8@UpdateImeS:
  0006d	b8 02 00 00 00	 mov	 eax, 2

; 1820 : 			}

  00072	eb 08		 jmp	 SHORT $LN9@UpdateImeS
$LN4@UpdateImeS:

; 1821 : 			else
; 1822 : 			{
; 1823 : 				CIME::ms_dwImeState = valOpenMode.lVal != 0 ? IMEUI_STATE_ON : IMEUI_STATE_OFF;

  00074	33 c0		 xor	 eax, eax
  00076	39 45 ec	 cmp	 DWORD PTR _valOpenMode$2[ebp+8], eax
  00079	0f 95 c0	 setne	 al
$LN9@UpdateImeS:

; 1824 : 			}
; 1825 : 		}
; 1826 : 		VariantClear( &valOpenMode );

  0007c	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, eax ; CIME::ms_dwImeState
$LN5@UpdateImeS:
  00081	8d 45 e4	 lea	 eax, DWORD PTR _valOpenMode$2[ebp]
  00084	50		 push	 eax
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 1827 : 		VariantClear( &valConvMode );

  0008b	8d 45 d4	 lea	 eax, DWORD PTR _valConvMode$1[ebp]
  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 1828 : 
; 1829 : 		if ( bResetCompartmentEventSink )

  00095	83 7d 08 00	 cmp	 DWORD PTR _bResetCompartmentEventSink$[ebp], 0
  00099	74 0c		 je	 SHORT $LN6@UpdateImeS

; 1830 : 		{
; 1831 : 			SetupCompartmentSinks( FALSE, pTfOpenMode, pTfConvMode );	// Reset compartment sinks

  0009b	53		 push	 ebx
  0009c	57		 push	 edi
  0009d	6a 00		 push	 0
  0009f	e8 00 00 00 00	 call	 ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@UpdateImeS:

; 1832 : 		}
; 1833 : 		pTfOpenMode->Release();

  000a7	8b 07		 mov	 eax, DWORD PTR [edi]
  000a9	57		 push	 edi
  000aa	ff 50 08	 call	 DWORD PTR [eax+8]

; 1834 : 		pTfConvMode->Release();

  000ad	8b 03		 mov	 eax, DWORD PTR [ebx]
  000af	53		 push	 ebx
  000b0	ff 50 08	 call	 DWORD PTR [eax+8]

; 1835 : 		pcm->Release();

  000b3	8b 45 f4	 mov	 eax, DWORD PTR _pcm$[ebp]
  000b6	50		 push	 eax
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	ff 51 08	 call	 DWORD PTR [ecx+8]
  000bc	5f		 pop	 edi
  000bd	5b		 pop	 ebx
$LN2@UpdateImeS:

; 1836 : 	}
; 1837 : }

  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?UpdateImeState@CTsfUiLessMode@@SAXH@Z ENDP		; CTsfUiLessMode::UpdateImeState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ
_TEXT	SEGMENT
_pProfiles$ = -84					; size = 4
_pProfileMgr$1 = -80					; size = 4
_tip$2 = -76						; size = 72
__$ArrayPad$ = -4					; size = 4
?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ PROC	; CTsfUiLessMode::CurrentInputLocaleIsIme, COMDAT

; 1991 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 1992 : 	BOOL ret = FALSE;
; 1993 : 	HRESULT hr;
; 1994 : 
; 1995 : 	ITfInputProcessorProfiles *pProfiles;
; 1996 : 	hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, __uuidof(ITfInputProcessorProfiles), (LPVOID*)&pProfiles);

  00011	8d 45 ac	 lea	 eax, DWORD PTR _pProfiles$[ebp]
  00014	33 f6		 xor	 esi, esi
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET __GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca
  0001c	6a 01		 push	 1
  0001e	56		 push	 esi
  0001f	68 00 00 00 00	 push	 OFFSET _CLSID_TF_InputProcessorProfiles
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 1997 : 	if (SUCCEEDED(hr))

  0002a	85 c0		 test	 eax, eax
  0002c	78 43		 js	 SHORT $LN6@CurrentInp

; 1998 : 	{
; 1999 : 		ITfInputProcessorProfileMgr *pProfileMgr;
; 2000 : 		hr = pProfiles->QueryInterface(__uuidof(ITfInputProcessorProfileMgr), (LPVOID*)&pProfileMgr);

  0002e	8b 4d ac	 mov	 ecx, DWORD PTR _pProfiles$[ebp]
  00031	8d 55 b0	 lea	 edx, DWORD PTR _pProfileMgr$1[ebp]
  00034	52		 push	 edx
  00035	68 00 00 00 00	 push	 OFFSET __GUID_71c6e74c_0f28_11d8_a82a_00065b84435c
  0003a	51		 push	 ecx
  0003b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0003d	ff 10		 call	 DWORD PTR [eax]

; 2001 : 		if (SUCCEEDED(hr))

  0003f	85 c0		 test	 eax, eax
  00041	78 25		 js	 SHORT $LN3@CurrentInp

; 2002 : 		{
; 2003 : 			TF_INPUTPROCESSORPROFILE tip;
; 2004 : 			hr = pProfileMgr->GetActiveProfile( GUID_TFCAT_TIP_KEYBOARD, &tip );

  00043	8b 4d b0	 mov	 ecx, DWORD PTR _pProfileMgr$1[ebp]
  00046	8d 55 b4	 lea	 edx, DWORD PTR _tip$2[ebp]
  00049	52		 push	 edx
  0004a	68 00 00 00 00	 push	 OFFSET _GUID_TFCAT_TIP_KEYBOARD
  0004f	51		 push	 ecx
  00050	8b 01		 mov	 eax, DWORD PTR [ecx]
  00052	ff 50 28	 call	 DWORD PTR [eax+40]

; 2005 : 			if (SUCCEEDED(hr))

  00055	85 c0		 test	 eax, eax
  00057	78 06		 js	 SHORT $LN4@CurrentInp

; 2006 : 			{
; 2007 : 				ret = ( tip.dwProfileType & TF_PROFILETYPE_INPUTPROCESSOR ) != 0;

  00059	8b 75 b4	 mov	 esi, DWORD PTR _tip$2[ebp]
  0005c	83 e6 01	 and	 esi, 1
$LN4@CurrentInp:

; 2008 : 			}
; 2009 : 			pProfileMgr->Release();

  0005f	8b 45 b0	 mov	 eax, DWORD PTR _pProfileMgr$1[ebp]
  00062	50		 push	 eax
  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
  00065	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN3@CurrentInp:

; 2010 : 		}
; 2011 : 		pProfiles->Release();

  00068	8b 4d ac	 mov	 ecx, DWORD PTR _pProfiles$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	ff 52 08	 call	 DWORD PTR [edx+8]
$LN6@CurrentInp:

; 2012 : 	}
; 2013 : 	return ret;
; 2014 : }

  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	8b c6		 mov	 eax, esi
  00076	33 cd		 xor	 ecx, ebp
  00078	5e		 pop	 esi
  00079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ ENDP	; CTsfUiLessMode::CurrentInputLocaleIsIme
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?ReleaseSinks@CTsfUiLessMode@@SAXXZ
_TEXT	SEGMENT
_source$ = -4						; size = 4
?ReleaseSinks@CTsfUiLessMode@@SAXXZ PROC		; CTsfUiLessMode::ReleaseSinks, COMDAT

; 1625 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1626 : 	HRESULT hr;
; 1627 : 	ITfSource *source;
; 1628 : 
; 1629 : 	// Remove all sinks
; 1630 : 	if ( m_tm && SUCCEEDED(m_tm->QueryInterface(__uuidof(ITfSource), (void **)&source)))

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0000a	85 c9		 test	 ecx, ecx
  0000c	0f 84 86 00 00
	00		 je	 $LN4@ReleaseSin
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	8d 55 fc	 lea	 edx, DWORD PTR _source$[ebp]
  00017	52		 push	 edx
  00018	68 00 00 00 00	 push	 OFFSET __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
  0001d	51		 push	 ecx
  0001e	ff 10		 call	 DWORD PTR [eax]
  00020	85 c0		 test	 eax, eax
  00022	78 74		 js	 SHORT $LN4@ReleaseSin

; 1631 : 	{
; 1632 :         hr = source->UnadviseSink(m_dwUIElementSinkCookie);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _source$[ebp]
  00027	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  0002d	50		 push	 eax
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	ff 51 10	 call	 DWORD PTR [ecx+16]

; 1633 : 		hr = source->UnadviseSink(m_dwAlpnSinkCookie);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _source$[ebp]
  00036	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwAlpnSinkCookie
  0003c	50		 push	 eax
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	ff 51 10	 call	 DWORD PTR [ecx+16]

; 1634 :         source->Release();

  00042	8b 45 fc	 mov	 eax, DWORD PTR _source$[ebp]
  00045	50		 push	 eax
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1635 : 		SetupCompartmentSinks(TRUE);	// Remove all compartment sinks

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 01		 push	 1
  00051	e8 00 00 00 00	 call	 ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks

; 1636 : 		m_tm->Deactivate();

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	50		 push	 eax
  00061	ff 51 10	 call	 DWORD PTR [ecx+16]

; 1637 : 		SAFE_RELEASE(m_tm);

  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 10		 je	 SHORT $LN3@ReleaseSin
  0006e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00070	51		 push	 ecx
  00071	ff 50 08	 call	 DWORD PTR [eax+8]
  00074	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A, 0 ; CTsfUiLessMode::m_tm
$LN3@ReleaseSin:

; 1638 : 		SAFE_RELEASE(m_TsfSink);

  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  00084	85 c9		 test	 ecx, ecx
  00086	74 10		 je	 SHORT $LN4@ReleaseSin
  00088	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008a	51		 push	 ecx
  0008b	ff 50 08	 call	 DWORD PTR [eax+8]
  0008e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, 0 ; CTsfUiLessMode::m_TsfSink
$LN4@ReleaseSin:

; 1639 : 	}
; 1640 : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?ReleaseSinks@CTsfUiLessMode@@SAXXZ ENDP		; CTsfUiLessMode::ReleaseSinks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetupSinks@CTsfUiLessMode@@SAHXZ
_TEXT	SEGMENT
_cid$ = -8						; size = 4
$T1 = -4						; size = 4
_srcTm$2 = -4						; size = 4
?SetupSinks@CTsfUiLessMode@@SAHXZ PROC			; CTsfUiLessMode::SetupSinks, COMDAT

; 1577 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1578 : 	// ITfThreadMgrEx is available on Vista or later.
; 1579 : 	HRESULT hr;
; 1580 :     hr = CoCreateInstance(CLSID_TF_ThreadMgr,

  00006	68 00 00 00 00	 push	 OFFSET ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0000b	68 00 00 00 00	 push	 OFFSET __GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c
  00010	6a 01		 push	 1
  00012	6a 00		 push	 0
  00014	68 00 00 00 00	 push	 OFFSET _CLSID_TF_ThreadMgr
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 1581 :                           NULL,
; 1582 :                           CLSCTX_INPROC_SERVER,
; 1583 :                           __uuidof(ITfThreadMgrEx),
; 1584 :                           (void**)&m_tm);
; 1585 : 
; 1586 :     if (hr != S_OK)

  0001f	85 c0		 test	 eax, eax
  00021	0f 85 da 00 00
	00		 jne	 $LN15@SetupSinks

; 1587 :     {
; 1588 :         return FALSE;
; 1589 :     }
; 1590 : 
; 1591 :     // ready to start interacting
; 1592 : 	TfClientId cid;	// not used
; 1593 :     if (FAILED(m_tm->ActivateEx(&cid, TF_TMAE_UIELEMENTENABLEDONLY)))

  00027	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0002d	8d 55 f8	 lea	 edx, DWORD PTR _cid$[ebp]
  00030	6a 04		 push	 4
  00032	52		 push	 edx
  00033	51		 push	 ecx
  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	ff 50 38	 call	 DWORD PTR [eax+56]
  00039	85 c0		 test	 eax, eax
  0003b	0f 88 c0 00 00
	00		 js	 $LN15@SetupSinks

; 1596 :     }
; 1597 : 
; 1598 : 	// Setup sinks
; 1599 : 	BOOL bRc = FALSE;
; 1600 :     m_TsfSink = new CUIElementSink();

  00041	56		 push	 esi
  00042	6a 10		 push	 16			; 00000010H
  00044	33 f6		 xor	 esi, esi
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	83 c4 04	 add	 esp, 4
  0004e	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00051	85 c0		 test	 eax, eax
  00053	0f 84 9b 00 00
	00		 je	 $LN10@SetupSinks
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 ??0CUIElementSink@CTsfUiLessMode@@QAE@XZ ; CTsfUiLessMode::CUIElementSink::CUIElementSink
  00060	a3 00 00 00 00	 mov	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, eax ; CTsfUiLessMode::m_TsfSink
  00065	85 c0		 test	 eax, eax

; 1601 : 	if (m_TsfSink)

  00067	0f 84 8d 00 00
	00		 je	 $LN5@SetupSinks

; 1602 : 	{
; 1603 : 		ITfSource *srcTm;
; 1604 : 		if (SUCCEEDED(hr = m_tm->QueryInterface(__uuidof(ITfSource), (void **)&srcTm)))

  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00073	8d 55 fc	 lea	 edx, DWORD PTR _srcTm$2[ebp]
  00076	52		 push	 edx
  00077	68 00 00 00 00	 push	 OFFSET __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
  0007c	51		 push	 ecx
  0007d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007f	ff 10		 call	 DWORD PTR [eax]
  00081	85 c0		 test	 eax, eax
  00083	78 75		 js	 SHORT $LN5@SetupSinks

; 1605 : 		{
; 1606 : 			// Sink for reading window change
; 1607 : 			if (SUCCEEDED(hr = srcTm->AdviseSink(__uuidof(ITfUIElementSink), (ITfUIElementSink*)m_TsfSink, &m_dwUIElementSinkCookie)))

  00085	8b 4d fc	 mov	 ecx, DWORD PTR _srcTm$2[ebp]
  00088	68 00 00 00 00	 push	 OFFSET ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  0008d	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  00093	8b 01		 mov	 eax, DWORD PTR [ecx]
  00095	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
  0009a	51		 push	 ecx
  0009b	ff 50 0c	 call	 DWORD PTR [eax+12]
  0009e	85 c0		 test	 eax, eax
  000a0	78 42		 js	 SHORT $LN8@SetupSinks

; 1608 : 			{
; 1609 : 				// Sink for input locale change
; 1610 : 				if (SUCCEEDED(hr = srcTm->AdviseSink(__uuidof(ITfInputProcessorProfileActivationSink), (ITfInputProcessorProfileActivationSink*)m_TsfSink, &m_dwAlpnSinkCookie)))

  000a2	8b 4d fc	 mov	 ecx, DWORD PTR _srcTm$2[ebp]
  000a5	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a7	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  000af	85 c0		 test	 eax, eax
  000b1	74 05		 je	 SHORT $LN12@SetupSinks
  000b3	83 c0 04	 add	 eax, 4
  000b6	eb 02		 jmp	 SHORT $LN13@SetupSinks
$LN12@SetupSinks:
  000b8	33 c0		 xor	 eax, eax
$LN13@SetupSinks:
  000ba	68 00 00 00 00	 push	 OFFSET ?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwAlpnSinkCookie
  000bf	50		 push	 eax
  000c0	68 00 00 00 00	 push	 OFFSET __GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
  000c5	51		 push	 ecx
  000c6	ff d2		 call	 edx
  000c8	85 c0		 test	 eax, eax
  000ca	78 18		 js	 SHORT $LN8@SetupSinks

; 1611 : 				{
; 1612 : 					if (SetupCompartmentSinks())	// Setup compartment sinks for the first time

  000cc	6a 00		 push	 0
  000ce	6a 00		 push	 0
  000d0	6a 00		 push	 0
  000d2	e8 00 00 00 00	 call	 ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000da	b9 01 00 00 00	 mov	 ecx, 1
  000df	85 c0		 test	 eax, eax
  000e1	0f 45 f1	 cmovne	 esi, ecx
$LN8@SetupSinks:

; 1613 : 					{
; 1614 : 						bRc = TRUE;
; 1615 : 					}
; 1616 : 				}
; 1617 : 			}
; 1618 : 			srcTm->Release();

  000e4	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$2[ebp]
  000e7	50		 push	 eax
  000e8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ea	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1619 : 		}
; 1620 : 	}
; 1621 : 	return bRc;

  000ed	8b c6		 mov	 eax, esi
  000ef	5e		 pop	 esi

; 1622 : }

  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
$LN10@SetupSinks:

; 1596 :     }
; 1597 : 
; 1598 : 	// Setup sinks
; 1599 : 	BOOL bRc = FALSE;
; 1600 :     m_TsfSink = new CUIElementSink();

  000f4	89 35 00 00 00
	00		 mov	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, esi ; CTsfUiLessMode::m_TsfSink
$LN5@SetupSinks:

; 1619 : 		}
; 1620 : 	}
; 1621 : 	return bRc;

  000fa	8b c6		 mov	 eax, esi
  000fc	5e		 pop	 esi

; 1622 : }

  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c3		 ret	 0
$LN15@SetupSinks:

; 1594 :     {
; 1595 :         return FALSE;

  00101	33 c0		 xor	 eax, eax

; 1622 : }

  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
?SetupSinks@CTsfUiLessMode@@SAHXZ ENDP			; CTsfUiLessMode::SetupSinks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z
_TEXT	SEGMENT
_bRc$1$ = -16						; size = 4
_pcm$ = -12						; size = 4
_srcOpenMode$ = -8					; size = 4
_bLocalCompartments$1$ = -1				; size = 1
_bRemoveOnly$ = 8					; size = 4
_pTfOpenMode$ = 12					; size = 4
_srcConvMode$1 = 12					; size = 4
_pTfConvMode$ = 16					; size = 4
?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z PROC ; CTsfUiLessMode::SetupCompartmentSinks, COMDAT

; 2078 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2079 : 	bool bLocalCompartments = false;
; 2080 : 	ITfCompartmentMgr* pcm = NULL;
; 2081 : 	BOOL bRc = FALSE;
; 2082 : 	HRESULT hr = E_FAIL;
; 2083 : 
; 2084 : 	if ( !pTfOpenMode && !pTfConvMode )

  00008	8b 75 0c	 mov	 esi, DWORD PTR _pTfOpenMode$[ebp]
  0000b	57		 push	 edi
  0000c	33 ff		 xor	 edi, edi
  0000e	c6 45 ff 00	 mov	 BYTE PTR _bLocalCompartments$1$[ebp], 0
  00012	89 7d f4	 mov	 DWORD PTR _pcm$[ebp], edi
  00015	89 7d f0	 mov	 DWORD PTR _bRc$1$[ebp], edi
  00018	85 f6		 test	 esi, esi
  0001a	75 2f		 jne	 SHORT $LN19@SetupCompa
  0001c	39 7d 10	 cmp	 DWORD PTR _pTfConvMode$[ebp], edi
  0001f	0f 85 40 01 00
	00		 jne	 $LN4@SetupCompa

; 2085 : 	{
; 2086 : 		bLocalCompartments = true;
; 2087 : 		GetCompartments( &pcm, &pTfOpenMode, &pTfConvMode );

  00025	8d 45 10	 lea	 eax, DWORD PTR _pTfConvMode$[ebp]
  00028	c6 45 ff 01	 mov	 BYTE PTR _bLocalCompartments$1$[ebp], 1
  0002c	50		 push	 eax
  0002d	8d 45 0c	 lea	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR _pcm$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ; CTsfUiLessMode::GetCompartments

; 2088 : 	}
; 2089 : 	if ( !( pTfOpenMode && pTfConvMode ) )

  0003a	8b 75 0c	 mov	 esi, DWORD PTR _pTfOpenMode$[ebp]
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	85 f6		 test	 esi, esi
  00042	0f 84 1d 01 00
	00		 je	 $LN4@SetupCompa
  00048	8b 7d f4	 mov	 edi, DWORD PTR _pcm$[ebp]
$LN19@SetupCompa:
  0004b	8b 5d 10	 mov	 ebx, DWORD PTR _pTfConvMode$[ebp]
  0004e	85 db		 test	 ebx, ebx
  00050	0f 84 0f 01 00
	00		 je	 $LN4@SetupCompa

; 2090 : 	{
; 2091 : 		// Invalid parameters or GetCompartments() has failed.
; 2092 : 		return FALSE;
; 2093 : 	}
; 2094 : 	ITfSource *srcOpenMode = NULL;
; 2095 : 	if (SUCCEEDED(hr = pTfOpenMode->QueryInterface( IID_ITfSource, (void**)&srcOpenMode )))

  00056	8d 4d f8	 lea	 ecx, DWORD PTR _srcOpenMode$[ebp]
  00059	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _srcOpenMode$[ebp], 0
  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	51		 push	 ecx
  00063	68 00 00 00 00	 push	 OFFSET _IID_ITfSource
  00068	56		 push	 esi
  00069	ff 10		 call	 DWORD PTR [eax]
  0006b	85 c0		 test	 eax, eax
  0006d	0f 88 d0 00 00
	00		 js	 $LN5@SetupCompa

; 2096 : 	{
; 2097 : 		// Remove existing sink for open mode
; 2098 : 		if ( m_dwOpenModeSinkCookie != TF_INVALID_COOKIE )

  00073	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwOpenModeSinkCookie
  00079	83 fa ff	 cmp	 edx, -1
  0007c	74 14		 je	 SHORT $LN6@SetupCompa

; 2099 : 		{
; 2100 : 			srcOpenMode->UnadviseSink( m_dwOpenModeSinkCookie );

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _srcOpenMode$[ebp]
  00081	52		 push	 edx
  00082	50		 push	 eax
  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	ff 51 10	 call	 DWORD PTR [ecx+16]

; 2101 : 			m_dwOpenModeSinkCookie = TF_INVALID_COOKIE;

  00088	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwOpenModeSinkCookie
$LN6@SetupCompa:

; 2102 : 		}
; 2103 : 		// Setup sink for open mode (toggle state) change
; 2104 : 		if ( bRemoveOnly || SUCCEEDED(hr = srcOpenMode->AdviseSink( IID_ITfCompartmentEventSink, (ITfCompartmentEventSink*)m_TsfSink, &m_dwOpenModeSinkCookie )))

  00092	83 7d 08 00	 cmp	 DWORD PTR _bRemoveOnly$[ebp], 0
  00096	75 2a		 jne	 SHORT $LN8@SetupCompa
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _srcOpenMode$[ebp]
  0009b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009d	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  000a5	85 c0		 test	 eax, eax
  000a7	74 05		 je	 SHORT $LN15@SetupCompa
  000a9	83 c0 08	 add	 eax, 8
  000ac	eb 02		 jmp	 SHORT $LN16@SetupCompa
$LN15@SetupCompa:
  000ae	33 c0		 xor	 eax, eax
$LN16@SetupCompa:
  000b0	68 00 00 00 00	 push	 OFFSET ?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwOpenModeSinkCookie
  000b5	50		 push	 eax
  000b6	68 00 00 00 00	 push	 OFFSET _IID_ITfCompartmentEventSink
  000bb	51		 push	 ecx
  000bc	ff d2		 call	 edx
  000be	85 c0		 test	 eax, eax
  000c0	78 78		 js	 SHORT $LN9@SetupCompa
$LN8@SetupCompa:

; 2105 : 		{
; 2106 : 			ITfSource *srcConvMode = NULL;
; 2107 : 			if (SUCCEEDED(hr = pTfConvMode->QueryInterface( IID_ITfSource, (void**)&srcConvMode )))

  000c2	8d 4d 0c	 lea	 ecx, DWORD PTR _srcConvMode$1[ebp]
  000c5	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _srcConvMode$1[ebp], 0
  000cc	8b 03		 mov	 eax, DWORD PTR [ebx]
  000ce	51		 push	 ecx
  000cf	68 00 00 00 00	 push	 OFFSET _IID_ITfSource
  000d4	53		 push	 ebx
  000d5	ff 10		 call	 DWORD PTR [eax]
  000d7	85 c0		 test	 eax, eax
  000d9	78 5f		 js	 SHORT $LN9@SetupCompa

; 2108 : 			{
; 2109 : 				// Remove existing sink for open mode
; 2110 : 				if ( m_dwConvModeSinkCookie != TF_INVALID_COOKIE )

  000db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwConvModeSinkCookie
  000e1	83 fa ff	 cmp	 edx, -1
  000e4	74 14		 je	 SHORT $LN10@SetupCompa

; 2111 : 				{
; 2112 : 					srcConvMode->UnadviseSink( m_dwConvModeSinkCookie );

  000e6	8b 45 0c	 mov	 eax, DWORD PTR _srcConvMode$1[ebp]
  000e9	52		 push	 edx
  000ea	50		 push	 eax
  000eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ed	ff 51 10	 call	 DWORD PTR [ecx+16]

; 2113 : 					m_dwConvModeSinkCookie = TF_INVALID_COOKIE;

  000f0	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwConvModeSinkCookie
$LN10@SetupCompa:

; 2114 : 				}
; 2115 : 				// Setup sink for open mode (toggle state) change
; 2116 : 				if ( bRemoveOnly || SUCCEEDED(hr = srcConvMode->AdviseSink( IID_ITfCompartmentEventSink, (ITfCompartmentEventSink*)m_TsfSink, &m_dwConvModeSinkCookie )))

  000fa	83 7d 08 00	 cmp	 DWORD PTR _bRemoveOnly$[ebp], 0
  000fe	75 2a		 jne	 SHORT $LN12@SetupCompa
  00100	8b 4d 0c	 mov	 ecx, DWORD PTR _srcConvMode$1[ebp]
  00103	8b 01		 mov	 eax, DWORD PTR [ecx]
  00105	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00108	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  0010d	85 c0		 test	 eax, eax
  0010f	74 05		 je	 SHORT $LN17@SetupCompa
  00111	83 c0 08	 add	 eax, 8
  00114	eb 02		 jmp	 SHORT $LN18@SetupCompa
$LN17@SetupCompa:
  00116	33 c0		 xor	 eax, eax
$LN18@SetupCompa:
  00118	68 00 00 00 00	 push	 OFFSET ?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwConvModeSinkCookie
  0011d	50		 push	 eax
  0011e	68 00 00 00 00	 push	 OFFSET _IID_ITfCompartmentEventSink
  00123	51		 push	 ecx
  00124	ff d2		 call	 edx
  00126	85 c0		 test	 eax, eax
  00128	78 07		 js	 SHORT $LN11@SetupCompa
$LN12@SetupCompa:

; 2117 : 				{
; 2118 : 					bRc = TRUE;

  0012a	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bRc$1$[ebp], 1
$LN11@SetupCompa:

; 2119 : 				}
; 2120 : 				srcConvMode->Release();

  00131	8b 45 0c	 mov	 eax, DWORD PTR _srcConvMode$1[ebp]
  00134	50		 push	 eax
  00135	8b 08		 mov	 ecx, DWORD PTR [eax]
  00137	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN9@SetupCompa:

; 2121 : 			}
; 2122 : 		}
; 2123 : 		srcOpenMode->Release();

  0013a	8b 45 f8	 mov	 eax, DWORD PTR _srcOpenMode$[ebp]
  0013d	50		 push	 eax
  0013e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00140	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN5@SetupCompa:

; 2124 : 	}
; 2125 : 	if ( bLocalCompartments )

  00143	80 7d ff 00	 cmp	 BYTE PTR _bLocalCompartments$1$[ebp], 0
  00147	74 12		 je	 SHORT $LN13@SetupCompa

; 2126 : 	{
; 2127 : 		pTfOpenMode->Release();

  00149	8b 06		 mov	 eax, DWORD PTR [esi]
  0014b	56		 push	 esi
  0014c	ff 50 08	 call	 DWORD PTR [eax+8]

; 2128 : 		pTfConvMode->Release();

  0014f	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00151	53		 push	 ebx
  00152	ff 51 08	 call	 DWORD PTR [ecx+8]

; 2129 : 		pcm->Release();

  00155	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00157	57		 push	 edi
  00158	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN13@SetupCompa:

; 2130 : 	}
; 2131 : 	return bRc;

  0015b	8b 45 f0	 mov	 eax, DWORD PTR _bRc$1$[ebp]
  0015e	5f		 pop	 edi

; 2132 : }

  0015f	5e		 pop	 esi
  00160	5b		 pop	 ebx
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c3		 ret	 0
$LN4@SetupCompa:
  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	33 c0		 xor	 eax, eax
  00169	5b		 pop	 ebx
  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	c3		 ret	 0
?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ENDP ; CTsfUiLessMode::SetupCompartmentSinks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z
_TEXT	SEGMENT
_pTfConvMode$ = -12					; size = 4
_pTfOpenMode$ = -8					; size = 4
_pcm$ = -4						; size = 4
_ppcm$ = 8						; size = 4
_ppTfOpenMode$ = 12					; size = 4
_ppTfConvMode$ = 16					; size = 4
?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z PROC ; CTsfUiLessMode::GetCompartments, COMDAT

; 2047 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2048 : 	ITfCompartmentMgr* pcm = NULL;
; 2049 : 	ITfCompartment* pTfOpenMode = NULL;
; 2050 : 	ITfCompartment* pTfConvMode = NULL;
; 2051 : 
; 2052 : 	static GUID _GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION = { 0xCCF05DD8, 0x4A87, 0x11D7, 0xA6, 0xE2, 0x00, 0x06, 0x5B, 0x84, 0x43, 0x5C };
; 2053 : 
; 2054 : 	HRESULT hr;
; 2055 : 	if (SUCCEEDED(hr = m_tm->QueryInterface( IID_ITfCompartmentMgr, (void**)&pcm )))

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0000c	8d 55 fc	 lea	 edx, DWORD PTR _pcm$[ebp]
  0000f	52		 push	 edx
  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pcm$[ebp], 0
  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pTfOpenMode$[ebp], 0
  0001e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pTfConvMode$[ebp], 0
  00025	8b 01		 mov	 eax, DWORD PTR [ecx]
  00027	68 00 00 00 00	 push	 OFFSET _IID_ITfCompartmentMgr
  0002c	51		 push	 ecx
  0002d	ff 10		 call	 DWORD PTR [eax]
  0002f	85 c0		 test	 eax, eax
  00031	78 5f		 js	 SHORT $LN2@GetCompart

; 2056 : 	{
; 2057 : 		if (SUCCEEDED(hr = pcm->GetCompartment( GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, &pTfOpenMode )))

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _pcm$[ebp]
  00036	8d 55 f8	 lea	 edx, DWORD PTR _pTfOpenMode$[ebp]
  00039	52		 push	 edx
  0003a	68 00 00 00 00	 push	 OFFSET _GUID_COMPARTMENT_KEYBOARD_OPENCLOSE
  0003f	51		 push	 ecx
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	ff 50 0c	 call	 DWORD PTR [eax+12]
  00045	85 c0		 test	 eax, eax
  00047	78 40		 js	 SHORT $LN3@GetCompart

; 2058 : 		{
; 2059 : 			if (SUCCEEDED(hr = pcm->GetCompartment( _GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION, &pTfConvMode )))

  00049	8b 4d fc	 mov	 ecx, DWORD PTR _pcm$[ebp]
  0004c	8d 55 f4	 lea	 edx, DWORD PTR _pTfConvMode$[ebp]
  0004f	52		 push	 edx
  00050	68 00 00 00 00	 push	 OFFSET ?_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION@?1??GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z@4U_GUID@@A
  00055	51		 push	 ecx
  00056	8b 01		 mov	 eax, DWORD PTR [ecx]
  00058	ff 50 0c	 call	 DWORD PTR [eax+12]
  0005b	85 c0		 test	 eax, eax
  0005d	78 21		 js	 SHORT $LN4@GetCompart

; 2060 : 			{
; 2061 : 				*ppcm = pcm;

  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _ppcm$[ebp]
  00062	8b 45 fc	 mov	 eax, DWORD PTR _pcm$[ebp]
  00065	89 01		 mov	 DWORD PTR [ecx], eax

; 2062 : 				*ppTfOpenMode = pTfOpenMode;

  00067	8b 4d 0c	 mov	 ecx, DWORD PTR _ppTfOpenMode$[ebp]
  0006a	8b 45 f8	 mov	 eax, DWORD PTR _pTfOpenMode$[ebp]
  0006d	89 01		 mov	 DWORD PTR [ecx], eax

; 2063 : 				*ppTfConvMode = pTfConvMode;

  0006f	8b 4d 10	 mov	 ecx, DWORD PTR _ppTfConvMode$[ebp]
  00072	8b 45 f4	 mov	 eax, DWORD PTR _pTfConvMode$[ebp]
  00075	89 01		 mov	 DWORD PTR [ecx], eax

; 2064 : 				return TRUE;

  00077	b8 01 00 00 00	 mov	 eax, 1

; 2071 : }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
$LN4@GetCompart:

; 2065 : 			}
; 2066 : 			pTfOpenMode->Release();

  00080	8b 45 f8	 mov	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00083	50		 push	 eax
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN3@GetCompart:

; 2067 : 		}
; 2068 : 		pcm->Release();

  00089	8b 45 fc	 mov	 eax, DWORD PTR _pcm$[ebp]
  0008c	50		 push	 eax
  0008d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008f	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN2@GetCompart:

; 2069 : 	}
; 2070 : 	return FALSE;

  00092	33 c0		 xor	 eax, eax

; 2071 : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ENDP ; CTsfUiLessMode::GetCompartments
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z
_TEXT	SEGMENT
_puiem$ = -8						; size = 4
_pElement$ = -4						; size = 4
_dwUIElementId$ = 8					; size = 4
?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z PROC ; CTsfUiLessMode::GetUIElement, COMDAT

; 1977 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1978 :     ITfUIElementMgr *puiem;
; 1979 :     ITfUIElement *pElement = NULL;
; 1980 : 
; 1981 :     if (SUCCEEDED(m_tm->QueryInterface(__uuidof(ITfUIElementMgr), (void **)&puiem)))

  00006	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0000c	8d 55 f8	 lea	 edx, DWORD PTR _puiem$[ebp]
  0000f	52		 push	 edx
  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pElement$[ebp], 0
  00017	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea135_19df_11d7_a6d2_00065b84435c
  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001e	51		 push	 ecx
  0001f	ff 10		 call	 DWORD PTR [eax]
  00021	85 c0		 test	 eax, eax
  00023	78 19		 js	 SHORT $LN4@GetUIEleme

; 1982 :     {
; 1983 :         puiem->GetUIElement(dwUIElementId, &pElement);

  00025	8b 45 f8	 mov	 eax, DWORD PTR _puiem$[ebp]
  00028	8d 55 fc	 lea	 edx, DWORD PTR _pElement$[ebp]
  0002b	52		 push	 edx
  0002c	ff 75 08	 push	 DWORD PTR _dwUIElementId$[ebp]
  0002f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00031	50		 push	 eax
  00032	ff 51 18	 call	 DWORD PTR [ecx+24]

; 1984 :         puiem->Release();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _puiem$[ebp]
  00038	50		 push	 eax
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN4@GetUIEleme:

; 1985 :     }
; 1986 : 
; 1987 :     return pElement;
; 1988 : }

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ENDP ; CTsfUiLessMode::GetUIElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z
_TEXT	SEGMENT
_bstr$ = -28						; size = 4
_uCurrentPage$ = -24					; size = 4
_uIndex$ = -20						; size = 4
_IndexList$1$ = -16					; size = 4
tv313 = -12						; size = 4
_uCount$ = -8						; size = 4
_uPageCnt$ = -4						; size = 4
_pcandidate$ = 8					; size = 4
?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z PROC ; CTsfUiLessMode::MakeCandidateStrings, COMDAT

; 1917 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1918 : 	UINT uIndex = 0;
; 1919 : 	UINT uCount = 0;
; 1920 : 	UINT uCurrentPage = 0;
; 1921 : 	UINT *IndexList = NULL;
; 1922 : 	UINT uPageCnt = 0;
; 1923 : 	DWORD dwPageStart = 0;
; 1924 : 	DWORD dwPageSize = 0;
; 1925 : 	BSTR bstr;
; 1926 : 
; 1927 : 	pcandidate->GetSelection(&uIndex);

  00009	8b 7d 08	 mov	 edi, DWORD PTR _pcandidate$[ebp]
  0000c	8d 4d ec	 lea	 ecx, DWORD PTR _uIndex$[ebp]
  0000f	33 c0		 xor	 eax, eax
  00011	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _uIndex$[ebp], 0
  00018	89 45 f0	 mov	 DWORD PTR _IndexList$1$[ebp], eax
  0001b	33 f6		 xor	 esi, esi
  0001d	89 45 fc	 mov	 DWORD PTR _uPageCnt$[ebp], eax
  00020	33 db		 xor	 ebx, ebx
  00022	8b 07		 mov	 eax, DWORD PTR [edi]
  00024	51		 push	 ecx
  00025	57		 push	 edi
  00026	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _uCount$[ebp], 0
  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _uCurrentPage$[ebp], 0
  00034	ff 50 28	 call	 DWORD PTR [eax+40]

; 1928 : 	pcandidate->GetCount(&uCount);

  00037	8b 07		 mov	 eax, DWORD PTR [edi]
  00039	8d 4d f8	 lea	 ecx, DWORD PTR _uCount$[ebp]
  0003c	51		 push	 ecx
  0003d	57		 push	 edi
  0003e	ff 50 24	 call	 DWORD PTR [eax+36]

; 1929 : 	pcandidate->GetCurrentPage(&uCurrentPage);

  00041	8b 07		 mov	 eax, DWORD PTR [edi]
  00043	8d 4d e8	 lea	 ecx, DWORD PTR _uCurrentPage$[ebp]
  00046	51		 push	 ecx
  00047	57		 push	 edi
  00048	ff 50 38	 call	 DWORD PTR [eax+56]

; 1930 : 	CIME::ms_dwCandidateSelection = (DWORD)uIndex;

  0004b	8b 45 ec	 mov	 eax, DWORD PTR _uIndex$[ebp]

; 1931 : 	CIME::ms_dwCandidateCount = (DWORD)uCount;
; 1932 : 	CIME::ms_bCandidateList = true;
; 1933 : 
; 1934 : 	pcandidate->GetPageIndex(NULL, 0, &uPageCnt);

  0004e	8d 4d fc	 lea	 ecx, DWORD PTR _uPageCnt$[ebp]
  00051	51		 push	 ecx
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection
  00057	8b 45 f8	 mov	 eax, DWORD PTR _uCount$[ebp]
  0005a	53		 push	 ebx
  0005b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, eax ; CIME::ms_dwCandidateCount
  00060	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 1 ; CIME::ms_bCandidateList
  00067	8b 07		 mov	 eax, DWORD PTR [edi]
  00069	53		 push	 ebx
  0006a	57		 push	 edi
  0006b	ff 50 30	 call	 DWORD PTR [eax+48]

; 1935 : 	if(uPageCnt > 0)

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _uPageCnt$[ebp]
  00071	85 c0		 test	 eax, eax
  00073	74 46		 je	 SHORT $LN15@MakeCandid

; 1936 : 	{
; 1937 : 		IndexList = (UINT *) malloc(sizeof(UINT)*uPageCnt);

  00075	c1 e0 02	 shl	 eax, 2
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _malloc
  0007e	83 c4 04	 add	 esp, 4
  00081	89 45 f0	 mov	 DWORD PTR _IndexList$1$[ebp], eax

; 1938 : 		if(IndexList)

  00084	85 c0		 test	 eax, eax
  00086	74 33		 je	 SHORT $LN15@MakeCandid

; 1939 : 		{
; 1940 : 			pcandidate->GetPageIndex(IndexList, uPageCnt, &uPageCnt);

  00088	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0008a	8d 55 fc	 lea	 edx, DWORD PTR _uPageCnt$[ebp]
  0008d	52		 push	 edx
  0008e	ff 75 fc	 push	 DWORD PTR _uPageCnt$[ebp]
  00091	50		 push	 eax
  00092	57		 push	 edi
  00093	ff 51 30	 call	 DWORD PTR [ecx+48]

; 1941 : 			dwPageStart = IndexList[uCurrentPage];

  00096	8b 4d e8	 mov	 ecx, DWORD PTR _uCurrentPage$[ebp]
  00099	8b 45 f0	 mov	 eax, DWORD PTR _IndexList$1$[ebp]
  0009c	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]
  0009f	8d 1c 88	 lea	 ebx, DWORD PTR [eax+ecx*4]

; 1942 : 			dwPageSize = (uCurrentPage < uPageCnt-1) ?

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _uPageCnt$[ebp]
  000a5	48		 dec	 eax
  000a6	3b c8		 cmp	 ecx, eax
  000a8	73 0c		 jae	 SHORT $LN14@MakeCandid
  000aa	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  000ad	39 5d f8	 cmp	 DWORD PTR _uCount$[ebp], ebx
  000b0	0f 42 5d f8	 cmovb	 ebx, DWORD PTR _uCount$[ebp]
  000b4	eb 03		 jmp	 SHORT $LN40@MakeCandid
$LN14@MakeCandid:
  000b6	8b 5d f8	 mov	 ebx, DWORD PTR _uCount$[ebp]
$LN40@MakeCandid:

; 1943 : 				min(uCount, IndexList[uCurrentPage+1]) - dwPageStart:
; 1944 : 				uCount - dwPageStart;
; 1945 : 		}
; 1946 : 	}
; 1947 : 
; 1948 : 	CIME::ms_dwCandidatePageSize = min(dwPageSize, CIME::MAX_CANDLIST);

  000b9	2b de		 sub	 ebx, esi
$LN15@MakeCandid:
  000bb	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH

; 1949 : 	CIME::ms_dwCandidateSelection = CIME::ms_dwCandidateSelection - dwPageStart;
; 1950 : 
; 1951 : 	memset(&CIME::ms_wszCandidate, 0, sizeof(CIME::ms_wszCandidate));

  000c0	68 00 14 00 00	 push	 5120			; 00001400H
  000c5	3b df		 cmp	 ebx, edi
  000c7	6a 00		 push	 0
  000c9	0f 42 fb	 cmovb	 edi, ebx
  000cc	29 35 00 00 00
	00		 sub	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, esi ; CIME::ms_dwCandidateSelection
  000d2	68 00 00 00 00	 push	 OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  000d7	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, edi ; CIME::ms_dwCandidatePageSize
  000dd	e8 00 00 00 00	 call	 _memset
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1952 : 	for (UINT i = dwPageStart, j = 0; (DWORD)i < CIME::ms_dwCandidateCount && j < CIME::ms_dwCandidatePageSize; i++, j++)

  000e5	33 db		 xor	 ebx, ebx
  000e7	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount
  000ed	73 61		 jae	 SHORT $LN28@MakeCandid

; 1943 : 				min(uCount, IndexList[uCurrentPage+1]) - dwPageStart:
; 1944 : 				uCount - dwPageStart;
; 1945 : 		}
; 1946 : 	}
; 1947 : 
; 1948 : 	CIME::ms_dwCandidatePageSize = min(dwPageSize, CIME::MAX_CANDLIST);

  000ef	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv313[ebp], OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
$LL4@MakeCandid:

; 1952 : 	for (UINT i = dwPageStart, j = 0; (DWORD)i < CIME::ms_dwCandidateCount && j < CIME::ms_dwCandidatePageSize; i++, j++)

  000f6	3b df		 cmp	 ebx, edi
  000f8	73 56		 jae	 SHORT $LN28@MakeCandid

; 1953 : 	{
; 1954 : 		if (SUCCEEDED(pcandidate->GetString( i, &bstr )))

  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _pcandidate$[ebp]
  000fd	8d 55 e4	 lea	 edx, DWORD PTR _bstr$[ebp]
  00100	52		 push	 edx
  00101	56		 push	 esi
  00102	51		 push	 ecx
  00103	8b 01		 mov	 eax, DWORD PTR [ecx]
  00105	ff 50 2c	 call	 DWORD PTR [eax+44]
  00108	85 c0		 test	 eax, eax
  0010a	78 2b		 js	 SHORT $LN2@MakeCandid

; 1955 : 		{
; 1956 : 			if(bstr)

  0010c	8b 7d e4	 mov	 edi, DWORD PTR _bstr$[ebp]
  0010f	85 ff		 test	 edi, edi
  00111	74 24		 je	 SHORT $LN2@MakeCandid

; 1957 : 			{
; 1958 : 				wcscpy( CIME::ms_wszCandidate[j], bstr );

  00113	8b 55 f4	 mov	 edx, DWORD PTR tv313[ebp]
  00116	8b c7		 mov	 eax, edi
  00118	2b d0		 sub	 edx, eax
  0011a	66 0f 1f 44 00
	00		 npad	 6
$LL16@MakeCandid:
  00120	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00123	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00126	66 89 4c 10 fe	 mov	 WORD PTR [eax+edx-2], cx
  0012b	66 85 c9	 test	 cx, cx
  0012e	75 f0		 jne	 SHORT $LL16@MakeCandid

; 1959 : 				SysFreeString(bstr);

  00130	57		 push	 edi
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN2@MakeCandid:

; 1952 : 	for (UINT i = dwPageStart, j = 0; (DWORD)i < CIME::ms_dwCandidateCount && j < CIME::ms_dwCandidatePageSize; i++, j++)

  00137	81 45 f4 00 02
	00 00		 add	 DWORD PTR tv313[ebp], 512 ; 00000200H
  0013e	46		 inc	 esi
  0013f	43		 inc	 ebx
  00140	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount
  00146	73 08		 jae	 SHORT $LN28@MakeCandid
  00148	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA ; CIME::ms_dwCandidatePageSize
  0014e	eb a6		 jmp	 SHORT $LL4@MakeCandid
$LN28@MakeCandid:

; 1960 : 			}
; 1961 : 		}
; 1962 : 	}
; 1963 : 	//OutputDebugStringW( L"\n" );
; 1964 : 
; 1965 : 	if (GETPRIMLANG() == LANG_KOREAN)

  00150	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00155	5f		 pop	 edi
  00156	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx
  0015d	83 f8 12	 cmp	 eax, 18			; 00000012H
  00160	75 0a		 jne	 SHORT $LN9@MakeCandid

; 1966 : 	{
; 1967 : 		CIME::ms_dwCandidateSelection = (DWORD)-1;

  00162	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, -1 ; CIME::ms_dwCandidateSelection
$LN9@MakeCandid:

; 1968 : 	}
; 1969 : 
; 1970 : 	if(IndexList)

  0016c	8b 45 f0	 mov	 eax, DWORD PTR _IndexList$1$[ebp]
  0016f	85 c0		 test	 eax, eax
  00171	74 09		 je	 SHORT $LN10@MakeCandid

; 1971 : 	{
; 1972 : 		free(IndexList);

  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 _free
  00179	83 c4 04	 add	 esp, 4
$LN10@MakeCandid:

; 1973 : 	}
; 1974 : }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	c3		 ret	 0
?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ENDP ; CTsfUiLessMode::MakeCandidateStrings
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z
_TEXT	SEGMENT
_dwFlags$ = -24						; size = 4
_cchMax$ = -20						; size = 4
_i$1$ = -16						; size = 4
_fVertical$ = -12					; size = 4
_uErrorIndex$ = -8					; size = 4
_bstr$ = -4						; size = 4
_preading$ = 8						; size = 4
_pszSource$1$ = 8					; size = 4
?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z PROC ; CTsfUiLessMode::MakeReadingInformationString, COMDAT

; 1865 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi

; 1866 : 	UINT cchMax;
; 1867 : 	UINT uErrorIndex = 0;
; 1868 : 	BOOL fVertical;
; 1869 : 	DWORD dwFlags;
; 1870 : 
; 1871 : 	CIME::ms_wstrReading.resize(0);

  00007	6a 00		 push	 0
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  0000e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _uErrorIndex$[ebp], 0
  00015	e8 00 00 00 00	 call	 ?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::resize

; 1872 : 	preading->GetUpdatedFlags(&dwFlags);

  0001a	8b 75 08	 mov	 esi, DWORD PTR _preading$[ebp]
  0001d	8d 4d e8	 lea	 ecx, DWORD PTR _dwFlags$[ebp]
  00020	51		 push	 ecx
  00021	56		 push	 esi
  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1873 : 	preading->GetMaxReadingStringLength(&cchMax);

  00027	8b 06		 mov	 eax, DWORD PTR [esi]
  00029	8d 4d ec	 lea	 ecx, DWORD PTR _cchMax$[ebp]
  0002c	51		 push	 ecx
  0002d	56		 push	 esi
  0002e	ff 50 28	 call	 DWORD PTR [eax+40]

; 1874 : 	preading->GetErrorIndex(&uErrorIndex);	// errorIndex is zero-based

  00031	8b 06		 mov	 eax, DWORD PTR [esi]
  00033	8d 4d f8	 lea	 ecx, DWORD PTR _uErrorIndex$[ebp]
  00036	51		 push	 ecx
  00037	56		 push	 esi
  00038	ff 50 2c	 call	 DWORD PTR [eax+44]

; 1875 : 	preading->IsVerticalOrderPreferred(&fVertical);

  0003b	8b 06		 mov	 eax, DWORD PTR [esi]
  0003d	8d 4d f4	 lea	 ecx, DWORD PTR _fVertical$[ebp]
  00040	51		 push	 ecx
  00041	56		 push	 esi
  00042	ff 50 30	 call	 DWORD PTR [eax+48]

; 1876 : 	CIME::ms_iReadingError = (int)uErrorIndex;
; 1877 : 	CIME::ms_bHorizontalReading = !fVertical;

  00045	83 7d f4 00	 cmp	 DWORD PTR _fVertical$[ebp], 0

; 1878 : 	CIME::ms_bReadingInformation = true;
; 1879 : 	BSTR bstr;
; 1880 : 	if (SUCCEEDED(preading->GetString(&bstr)))

  00049	8d 4d fc	 lea	 ecx, DWORD PTR _bstr$[ebp]
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _uErrorIndex$[ebp]
  0004f	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iReadingError@CIME@@2HA, eax ; CIME::ms_iReadingError
  00054	0f 94 05 00 00
	00 00		 sete	 BYTE PTR ?ms_bHorizontalReading@CIME@@2_NA ; CIME::ms_bHorizontalReading
  0005b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 1 ; CIME::ms_bReadingInformation
  00062	8b 06		 mov	 eax, DWORD PTR [esi]
  00064	51		 push	 ecx
  00065	56		 push	 esi
  00066	ff 50 24	 call	 DWORD PTR [eax+36]
  00069	85 c0		 test	 eax, eax
  0006b	0f 88 bc 00 00
	00		 js	 $LN6@MakeReadin

; 1881 : 	{
; 1882 : 		if (bstr)

  00071	8b 45 fc	 mov	 eax, DWORD PTR _bstr$[ebp]
  00074	85 c0		 test	 eax, eax
  00076	0f 84 b1 00 00
	00		 je	 $LN6@MakeReadin

; 1884 : 			CIME::ms_wstrReading.assign( (wchar_t *) bstr, (wchar_t *) bstr+lstrlenW(bstr) );

  0007c	50		 push	 eax
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00083	8b 55 fc	 mov	 edx, DWORD PTR _bstr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1476 :             _Assign_counted_range(_UFirst, _Count);

  00086	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1884 : 			CIME::ms_wstrReading.assign( (wchar_t *) bstr, (wchar_t *) bstr+lstrlenW(bstr) );

  0008b	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 1692 :         return _Last - _First; // assume the iterator will do debug checking

  0008e	2b c2		 sub	 eax, edx
  00090	d1 f8		 sar	 eax, 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1476 :             _Assign_counted_range(_UFirst, _Count);

  00092	50		 push	 eax
  00093	52		 push	 edx
  00094	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_WI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_counted_range<wchar_t *>
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1886 : 			if ( fVertical )

  00099	83 7d f4 00	 cmp	 DWORD PTR _fVertical$[ebp], 0
  0009d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A
  000a3	89 4d 08	 mov	 DWORD PTR _pszSource$1$[ebp], ecx
  000a6	74 7c		 je	 SHORT $LN3@MakeReadin

; 1887 : 			{
; 1888 : 				CIME::ms_dwCandidatePageSize = CIME::MAX_CANDLIST;
; 1889 : 				// ms_iReadingError is used only in horizontal window, and has to be -1 if there's no error.
; 1890 : 				CIME::ms_dwCandidateSelection = CIME::ms_iReadingError ? CIME::ms_iReadingError - 1 : (DWORD)-1;

  000a8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_iReadingError@CIME@@2HA ; CIME::ms_iReadingError
  000ad	c7 05 00 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, 10 ; CIME::ms_dwCandidatePageSize, 0000000aH
  000b7	85 c0		 test	 eax, eax
  000b9	74 03		 je	 SHORT $LN10@MakeReadin
  000bb	48		 dec	 eax
  000bc	eb 03		 jmp	 SHORT $LN11@MakeReadin
$LN10@MakeReadin:
  000be	83 c8 ff	 or	 eax, -1
$LN11@MakeReadin:

; 1891 : 				CIME::ms_dwCandidateCount = cchMax;

  000c1	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection

; 1892 : 				// for vertical reading window, copy each character to g_szCandidate array.
; 1893 : 				for ( UINT i = 0; i < cchMax; i++ )

  000c6	33 d2		 xor	 edx, edx
  000c8	8b 45 ec	 mov	 eax, DWORD PTR _cchMax$[ebp]
  000cb	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, eax ; CIME::ms_dwCandidateCount
  000d0	89 55 f0	 mov	 DWORD PTR _i$1$[ebp], edx
  000d3	85 c0		 test	 eax, eax
  000d5	74 4d		 je	 SHORT $LN3@MakeReadin

; 1891 : 				CIME::ms_dwCandidateCount = cchMax;

  000d7	53		 push	 ebx
  000d8	be 00 00 00 00	 mov	 esi, OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  000dd	57		 push	 edi
  000de	66 90		 npad	 2
$LL4@MakeReadin:

; 1894 : 				{
; 1895 : 					LPWSTR pszDest = CIME::ms_wszCandidate[i];
; 1896 : 					if ( *pszSource )

  000e0	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  000e4	8b c6		 mov	 eax, esi
  000e6	74 26		 je	 SHORT $LN8@MakeReadin

; 1897 : 					{
; 1898 : 						LPWSTR pszNextSrc = CharNextW(pszSource);

  000e8	51		 push	 ecx
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  000ef	8b f8		 mov	 edi, eax

; 1899 : 						SIZE_T size = (LPSTR)pszNextSrc - (LPSTR)pszSource;

  000f1	8b 45 08	 mov	 eax, DWORD PTR _pszSource$1$[ebp]
  000f4	8b df		 mov	 ebx, edi
  000f6	2b d8		 sub	 ebx, eax

; 1900 : 						CopyMemory( pszDest, pszSource, size );

  000f8	53		 push	 ebx
  000f9	50		 push	 eax
  000fa	56		 push	 esi
  000fb	e8 00 00 00 00	 call	 _memcpy
  00100	8b 55 f0	 mov	 edx, DWORD PTR _i$1$[ebp]

; 1901 : 						pszSource = pszNextSrc;
; 1902 : 						pszDest += size;

  00103	8d 04 5e	 lea	 eax, DWORD PTR [esi+ebx*2]
  00106	8b cf		 mov	 ecx, edi
  00108	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010b	89 4d 08	 mov	 DWORD PTR _pszSource$1$[ebp], ecx
$LN8@MakeReadin:

; 1903 : 					}
; 1904 : 					*pszDest = 0;

  0010e	33 ff		 xor	 edi, edi
  00110	42		 inc	 edx
  00111	66 89 38	 mov	 WORD PTR [eax], di
  00114	81 c6 00 02 00
	00		 add	 esi, 512		; 00000200H
  0011a	89 55 f0	 mov	 DWORD PTR _i$1$[ebp], edx
  0011d	3b 55 ec	 cmp	 edx, DWORD PTR _cchMax$[ebp]
  00120	72 be		 jb	 SHORT $LL4@MakeReadin

; 1892 : 				// for vertical reading window, copy each character to g_szCandidate array.
; 1893 : 				for ( UINT i = 0; i < cchMax; i++ )

  00122	5f		 pop	 edi
  00123	5b		 pop	 ebx
$LN3@MakeReadin:

; 1905 : 				}
; 1906 : 			}
; 1907 : 			//else
; 1908 : 			//{
; 1909 : 			//	CIME::ms_wszCandidate[0][0] = L' ';	// hack to make rendering happen
; 1910 : 			//}
; 1911 : 			SysFreeString(bstr);

  00124	ff 75 fc	 push	 DWORD PTR _bstr$[ebp]
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN6@MakeReadin:
  0012d	5e		 pop	 esi

; 1912 : 		}
; 1913 : 	}
; 1914 : }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c3		 ret	 0
?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ENDP ; CTsfUiLessMode::MakeReadingInformationString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_rguid$ = 12						; size = 4
?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z PROC ; CTsfUiLessMode::CUIElementSink::OnChange, COMDAT

; 1860 : 	UpdateImeState();

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  00007	83 c4 04	 add	 esp, 4

; 1861 :     return S_OK;

  0000a	33 c0		 xor	 eax, eax

; 1862 : }

  0000c	c2 08 00	 ret	 8
?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z ENDP ; CTsfUiLessMode::CUIElementSink::OnChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwProfileType$ = 12					; size = 4
_langid$ = 16						; size = 2
_clsid$ = 20						; size = 4
_catid$ = 24						; size = 4
_guidProfile$ = 28					; size = 4
_hkl$ = 32						; size = 4
_dwFlags$ = 36						; size = 4
?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z PROC ; CTsfUiLessMode::CUIElementSink::OnActivated, COMDAT

; 1841 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00003	8b 55 1c	 mov	 edx, DWORD PTR _guidProfile$[ebp]
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?TF_PROFILE_DAYI@?1??OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z@4U4@A
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1841 : {

  0000b	56		 push	 esi
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  0000c	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
$LL15@OnActivate:
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	3b 02		 cmp	 eax, DWORD PTR [edx]
  00015	75 0f		 jne	 SHORT $LN14@OnActivate
  00017	83 c1 04	 add	 ecx, 4
  0001a	83 c2 04	 add	 edx, 4
  0001d	83 ee 04	 sub	 esi, 4
  00020	73 ef		 jae	 SHORT $LL15@OnActivate
  00022	33 c0		 xor	 eax, eax
  00024	eb 05		 jmp	 SHORT $LN16@OnActivate
$LN14@OnActivate:
  00026	b8 01 00 00 00	 mov	 eax, 1
$LN16@OnActivate:
  0002b	8b 4d 18	 mov	 ecx, DWORD PTR _catid$[ebp]
  0002e	ba 00 00 00 00	 mov	 edx, OFFSET _GUID_TFCAT_TIP_KEYBOARD
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1843 : 	CIME::ms_iCandListIndexBase = IsEqualGUID( TF_PROFILE_DAYI, guidProfile ) ? 0 : 1;

  00033	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iCandListIndexBase@CIME@@2HA, eax ; CIME::ms_iCandListIndexBase
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00038	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  0003d	0f 1f 00	 npad	 3
$LL18@OnActivate:
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	3b 02		 cmp	 eax, DWORD PTR [edx]
  00044	75 71		 jne	 SHORT $LN20@OnActivate
  00046	83 c1 04	 add	 ecx, 4
  00049	83 c2 04	 add	 edx, 4
  0004c	83 ee 04	 sub	 esi, 4
  0004f	73 ef		 jae	 SHORT $LL18@OnActivate
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1844 : 	if ( IsEqualIID( catid, GUID_TFCAT_TIP_KEYBOARD ) && ( dwFlags & TF_IPSINK_FLAG_ACTIVE ) )

  00051	f6 45 24 01	 test	 BYTE PTR _dwFlags$[ebp], 1
  00055	74 60		 je	 SHORT $LN20@OnActivate

; 1845 : 	{
; 1846 : 		CIME::ms_bChineseIME = ( dwProfileType & TF_PROFILETYPE_INPUTPROCESSOR ) && langid == LANG_CHT;

  00057	8b 45 0c	 mov	 eax, DWORD PTR _dwProfileType$[ebp]
  0005a	83 e0 01	 and	 eax, 1
  0005d	74 28		 je	 SHORT $LN6@OnActivate
  0005f	b9 04 04 00 00	 mov	 ecx, 1028		; 00000404H
  00064	66 39 4d 10	 cmp	 WORD PTR _langid$[ebp], cx
  00068	75 1d		 jne	 SHORT $LN6@OnActivate

; 1848 : 		{
; 1849 : 			UpdateImeState(TRUE);

  0006a	6a 01		 push	 1
  0006c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, 1 ; CIME::ms_bChineseIME
  00073	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  00078	83 c4 04	 add	 esp, 4

; 1853 : 		CIME::ChangeInputLanguage();

  0007b	e8 00 00 00 00	 call	 ?ChangeInputLanguage@CIME@@SAXXZ ; CIME::ChangeInputLanguage

; 1854 : 	}
; 1855 :     return S_OK;
; 1856 : }

  00080	33 c0		 xor	 eax, eax
  00082	5e		 pop	 esi
  00083	5d		 pop	 ebp
  00084	c2 20 00	 ret	 32			; 00000020H
$LN6@OnActivate:

; 1847 : 		if ( dwProfileType & TF_PROFILETYPE_INPUTPROCESSOR )

  00087	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, 0 ; CIME::ms_bChineseIME
  0008e	85 c0		 test	 eax, eax
  00090	74 16		 je	 SHORT $LN3@OnActivate

; 1848 : 		{
; 1849 : 			UpdateImeState(TRUE);

  00092	6a 01		 push	 1
  00094	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  00099	83 c4 04	 add	 esp, 4

; 1853 : 		CIME::ChangeInputLanguage();

  0009c	e8 00 00 00 00	 call	 ?ChangeInputLanguage@CIME@@SAXXZ ; CIME::ChangeInputLanguage

; 1854 : 	}
; 1855 :     return S_OK;
; 1856 : }

  000a1	33 c0		 xor	 eax, eax
  000a3	5e		 pop	 esi
  000a4	5d		 pop	 ebp
  000a5	c2 20 00	 ret	 32			; 00000020H
$LN3@OnActivate:

; 1850 : 		}
; 1851 : 		else
; 1852 : 			CIME::ms_dwImeState = IMEUI_STATE_OFF;

  000a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, 0 ; CIME::ms_dwImeState

; 1853 : 		CIME::ChangeInputLanguage();

  000b2	e8 00 00 00 00	 call	 ?ChangeInputLanguage@CIME@@SAXXZ ; CIME::ChangeInputLanguage
$LN20@OnActivate:

; 1854 : 	}
; 1855 :     return S_OK;
; 1856 : }

  000b7	33 c0		 xor	 eax, eax
  000b9	5e		 pop	 esi
  000ba	5d		 pop	 ebp
  000bb	c2 20 00	 ret	 32			; 00000020H
?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z ENDP ; CTsfUiLessMode::CUIElementSink::OnActivated
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
_TEXT	SEGMENT
tv176 = -8						; size = 4
_pcandidate$ = -4					; size = 4
_this$ = 8						; size = 4
_dwUIElementId$ = 12					; size = 4
_preading$ = 12						; size = 4
?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z PROC ; CTsfUiLessMode::CUIElementSink::EndUIElement, COMDAT

; 1773 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 1774 :     ITfUIElement *pElement = GetUIElement(dwUIElementId);

  00007	ff 75 0c	 push	 DWORD PTR _dwUIElementId$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
  0000f	8b f0		 mov	 esi, eax
  00011	83 c4 04	 add	 esp, 4

; 1775 :     if (!pElement)

  00014	85 f6		 test	 esi, esi
  00016	75 0c		 jne	 SHORT $LN2@EndUIEleme

; 1776 :         return E_INVALIDARG;

  00018	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001d	5e		 pop	 esi

; 1802 : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
$LN2@EndUIEleme:

; 1777 : 
; 1778 : 	//BSTR bstrDesc;
; 1779 : 	//OutputDebugStringW(L"ENDUI: ");
; 1780 : 	//pElement->GetDescription(&bstrDesc);
; 1781 : 	//OutputDebugStringW(bstrDesc);
; 1782 : 	//OutputDebugStringW(L"\n");
; 1783 : 
; 1784 : 	ITfReadingInformationUIElement   *preading = NULL;
; 1785 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfReadingInformationUIElement), (void **)&preading)))

  00024	8d 4d 0c	 lea	 ecx, DWORD PTR _preading$[ebp]
  00027	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _preading$[ebp], 0
  0002e	8b 06		 mov	 eax, DWORD PTR [esi]
  00030	51		 push	 ecx
  00031	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
  00036	56		 push	 esi
  00037	ff 10		 call	 DWORD PTR [eax]
  00039	85 c0		 test	 eax, eax
  0003b	78 0e		 js	 SHORT $LN3@EndUIEleme

; 1786 :     {
; 1787 : 		CIME::CloseReadingInformation();

  0003d	e8 00 00 00 00	 call	 ?CloseReadingInformation@CIME@@SAXXZ ; CIME::CloseReadingInformation

; 1788 :         preading->Release();

  00042	8b 45 0c	 mov	 eax, DWORD PTR _preading$[ebp]
  00045	50		 push	 eax
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN3@EndUIEleme:

; 1789 :     }
; 1790 : 
; 1791 : 	ITfCandidateListUIElement   *pcandidate = NULL;
; 1792 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfCandidateListUIElement), (void **)&pcandidate)))

  0004b	8d 4d fc	 lea	 ecx, DWORD PTR _pcandidate$[ebp]
  0004e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pcandidate$[ebp], 0
  00055	8b 06		 mov	 eax, DWORD PTR [esi]
  00057	51		 push	 ecx
  00058	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
  0005d	56		 push	 esi
  0005e	ff 10		 call	 DWORD PTR [eax]
  00060	85 c0		 test	 eax, eax
  00062	78 1d		 js	 SHORT $LN4@EndUIEleme

; 1793 : 	{
; 1794 : 		m_nCandidateRefCount--;

  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nCandidateRefCount@CTsfUiLessMode@@1HA ; CTsfUiLessMode::m_nCandidateRefCount
  00069	83 e8 01	 sub	 eax, 1
  0006c	a3 00 00 00 00	 mov	 DWORD PTR ?m_nCandidateRefCount@CTsfUiLessMode@@1HA, eax ; CTsfUiLessMode::m_nCandidateRefCount

; 1795 : 		if (m_nCandidateRefCount == 0)

  00071	75 05		 jne	 SHORT $LN5@EndUIEleme

; 1796 : 			CIME::CloseCandidateList();

  00073	e8 00 00 00 00	 call	 ?CloseCandidateList@CIME@@SAXXZ ; CIME::CloseCandidateList
$LN5@EndUIEleme:

; 1797 : 		pcandidate->Release();

  00078	8b 45 fc	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  0007b	50		 push	 eax
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN4@EndUIEleme:

; 1798 : 	}
; 1799 : 
; 1800 :     pElement->Release();

  00081	8b 06		 mov	 eax, DWORD PTR [esi]
  00083	56		 push	 esi
  00084	ff 50 08	 call	 DWORD PTR [eax+8]

; 1801 :     return S_OK;

  00087	33 c0		 xor	 eax, eax
  00089	5e		 pop	 esi

; 1802 : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ENDP ; CTsfUiLessMode::CUIElementSink::EndUIElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
_TEXT	SEGMENT
_pcandidate$ = -4					; size = 4
_this$ = 8						; size = 4
_dwUIElementId$ = 12					; size = 4
_preading$ = 12						; size = 4
?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z PROC ; CTsfUiLessMode::CUIElementSink::UpdateUIElement, COMDAT

; 1739 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1740 :     ITfUIElement *pElement = GetUIElement(dwUIElementId);

  00005	ff 75 0c	 push	 DWORD PTR _dwUIElementId$[ebp]
  00008	e8 00 00 00 00	 call	 ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
  0000d	8b f0		 mov	 esi, eax
  0000f	83 c4 04	 add	 esp, 4

; 1741 :     if (!pElement)

  00012	85 f6		 test	 esi, esi
  00014	75 0c		 jne	 SHORT $LN2@UpdateUIEl

; 1742 :         return E_INVALIDARG;

  00016	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001b	5e		 pop	 esi

; 1770 : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
$LN2@UpdateUIEl:

; 1743 : 
; 1744 :     ITfReadingInformationUIElement   *preading = NULL;
; 1745 :     ITfCandidateListUIElement		*pcandidate = NULL;
; 1746 : 
; 1747 : 	//BSTR bstrDesc;
; 1748 : 	//pElement->GetDescription(&bstrDesc);
; 1749 : 	//OutputDebugStringW(L"UPDATEUI: ");
; 1750 : 	//OutputDebugStringW(bstrDesc);
; 1751 : 	//OutputDebugStringW(L"\n");
; 1752 : 
; 1753 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfReadingInformationUIElement), (void **)&preading)))

  00022	8d 4d 0c	 lea	 ecx, DWORD PTR _preading$[ebp]
  00025	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _preading$[ebp], 0
  0002c	51		 push	 ecx
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pcandidate$[ebp], 0
  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
  0003b	56		 push	 esi
  0003c	ff 10		 call	 DWORD PTR [eax]
  0003e	85 c0		 test	 eax, eax
  00040	78 1f		 js	 SHORT $LN3@UpdateUIEl

; 1754 :     {
; 1755 : 		MakeReadingInformationString(preading);

  00042	ff 75 0c	 push	 DWORD PTR _preading$[ebp]
  00045	e8 00 00 00 00	 call	 ?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ; CTsfUiLessMode::MakeReadingInformationString

; 1756 : 		if(CIME::ms_pEvent)

  0004a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00050	83 c4 04	 add	 esp, 4
  00053	85 c9		 test	 ecx, ecx
  00055	74 05		 je	 SHORT $LN5@UpdateUIEl

; 1757 : 			CIME::ms_pEvent->OnOpenReadingWnd();

  00057	8b 01		 mov	 eax, DWORD PTR [ecx]
  00059	ff 50 14	 call	 DWORD PTR [eax+20]
$LN5@UpdateUIEl:

; 1758 :         preading->Release();

  0005c	8b 45 0c	 mov	 eax, DWORD PTR _preading$[ebp]

; 1759 :     }

  0005f	eb 2f		 jmp	 SHORT $LN14@UpdateUIEl
$LN3@UpdateUIEl:

; 1760 : 	else if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfCandidateListUIElement), (void **)&pcandidate)))

  00061	8b 06		 mov	 eax, DWORD PTR [esi]
  00063	8d 4d fc	 lea	 ecx, DWORD PTR _pcandidate$[ebp]
  00066	51		 push	 ecx
  00067	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
  0006c	56		 push	 esi
  0006d	ff 10		 call	 DWORD PTR [eax]
  0006f	85 c0		 test	 eax, eax
  00071	78 23		 js	 SHORT $LN6@UpdateUIEl

; 1761 : 	{
; 1762 : 		MakeCandidateStrings(pcandidate);

  00073	ff 75 fc	 push	 DWORD PTR _pcandidate$[ebp]
  00076	e8 00 00 00 00	 call	 ?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ; CTsfUiLessMode::MakeCandidateStrings

; 1763 : 		if(CIME::ms_pEvent)

  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00081	83 c4 04	 add	 esp, 4
  00084	85 c9		 test	 ecx, ecx
  00086	74 05		 je	 SHORT $LN7@UpdateUIEl

; 1764 : 			CIME::ms_pEvent->OnOpenCandidateList();

  00088	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008a	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN7@UpdateUIEl:

; 1765 : 		pcandidate->Release();

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _pcandidate$[ebp]
$LN14@UpdateUIEl:

; 1766 :     }
; 1767 : 
; 1768 :     pElement->Release();

  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	50		 push	 eax
  00093	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN6@UpdateUIEl:
  00096	8b 06		 mov	 eax, DWORD PTR [esi]
  00098	56		 push	 esi
  00099	ff 50 08	 call	 DWORD PTR [eax+8]

; 1769 :     return S_OK;

  0009c	33 c0		 xor	 eax, eax
  0009e	5e		 pop	 esi

; 1770 : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 08 00	 ret	 8
?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ENDP ; CTsfUiLessMode::CUIElementSink::UpdateUIElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z
_TEXT	SEGMENT
_pcandidate$ = -4					; size = 4
_this$ = 8						; size = 4
_dwUIElementId$ = 12					; size = 4
_preading$ = 12						; size = 4
_pbShow$ = 16						; size = 4
?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z PROC ; CTsfUiLessMode::CUIElementSink::BeginUIElement, COMDAT

; 1703 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1704 :     ITfUIElement *pElement = GetUIElement(dwUIElementId);

  00005	ff 75 0c	 push	 DWORD PTR _dwUIElementId$[ebp]
  00008	e8 00 00 00 00	 call	 ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
  0000d	8b f0		 mov	 esi, eax
  0000f	83 c4 04	 add	 esp, 4

; 1705 :     if (!pElement)

  00012	85 f6		 test	 esi, esi
  00014	75 0c		 jne	 SHORT $LN2@BeginUIEle

; 1706 :         return E_INVALIDARG;

  00016	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001b	5e		 pop	 esi

; 1736 : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@BeginUIEle:

; 1707 : 
; 1708 :     ITfReadingInformationUIElement   *preading = NULL;
; 1709 : 	ITfCandidateListUIElement		*pcandidate = NULL;
; 1710 : 	*pbShow = FALSE;

  00022	8b 45 10	 mov	 eax, DWORD PTR _pbShow$[ebp]

; 1711 : 
; 1712 : 	//BSTR bstrDesc;
; 1713 : 	//OutputDebugStringW(L"BEGINUI: ");
; 1714 : 	//pElement->GetDescription(&bstrDesc);
; 1715 : 	//OutputDebugStringW(bstrDesc);
; 1716 : 	//OutputDebugStringW(L"\n");
; 1717 : 
; 1718 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfReadingInformationUIElement), (void **)&preading)))

  00025	8d 4d 0c	 lea	 ecx, DWORD PTR _preading$[ebp]
  00028	51		 push	 ecx
  00029	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _preading$[ebp], 0
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pcandidate$[ebp], 0
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0003d	8b 06		 mov	 eax, DWORD PTR [esi]
  0003f	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
  00044	56		 push	 esi
  00045	ff 10		 call	 DWORD PTR [eax]
  00047	85 c0		 test	 eax, eax
  00049	78 1f		 js	 SHORT $LN3@BeginUIEle

; 1719 :     {
; 1720 : 		MakeReadingInformationString(preading);

  0004b	ff 75 0c	 push	 DWORD PTR _preading$[ebp]
  0004e	e8 00 00 00 00	 call	 ?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ; CTsfUiLessMode::MakeReadingInformationString

; 1721 : 		if(CIME::ms_pEvent)

  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00059	83 c4 04	 add	 esp, 4
  0005c	85 c9		 test	 ecx, ecx
  0005e	74 05		 je	 SHORT $LN5@BeginUIEle

; 1722 : 			CIME::ms_pEvent->OnOpenReadingWnd();

  00060	8b 01		 mov	 eax, DWORD PTR [ecx]
  00062	ff 50 14	 call	 DWORD PTR [eax+20]
$LN5@BeginUIEle:

; 1723 :         preading->Release();

  00065	8b 45 0c	 mov	 eax, DWORD PTR _preading$[ebp]

; 1724 :     }

  00068	eb 35		 jmp	 SHORT $LN14@BeginUIEle
$LN3@BeginUIEle:

; 1725 : 	else if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfCandidateListUIElement), (void **)&pcandidate)))

  0006a	8b 06		 mov	 eax, DWORD PTR [esi]
  0006c	8d 4d fc	 lea	 ecx, DWORD PTR _pcandidate$[ebp]
  0006f	51		 push	 ecx
  00070	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
  00075	56		 push	 esi
  00076	ff 10		 call	 DWORD PTR [eax]
  00078	85 c0		 test	 eax, eax
  0007a	78 29		 js	 SHORT $LN6@BeginUIEle

; 1726 : 	{
; 1727 : 		m_nCandidateRefCount++;
; 1728 : 		MakeCandidateStrings(pcandidate);

  0007c	ff 75 fc	 push	 DWORD PTR _pcandidate$[ebp]
  0007f	ff 05 00 00 00
	00		 inc	 DWORD PTR ?m_nCandidateRefCount@CTsfUiLessMode@@1HA ; CTsfUiLessMode::m_nCandidateRefCount
  00085	e8 00 00 00 00	 call	 ?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ; CTsfUiLessMode::MakeCandidateStrings

; 1729 : 		if(CIME::ms_pEvent)

  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00090	83 c4 04	 add	 esp, 4
  00093	85 c9		 test	 ecx, ecx
  00095	74 05		 je	 SHORT $LN7@BeginUIEle

; 1730 : 			CIME::ms_pEvent->OnOpenCandidateList();

  00097	8b 01		 mov	 eax, DWORD PTR [ecx]
  00099	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN7@BeginUIEle:

; 1731 : 		pcandidate->Release();

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _pcandidate$[ebp]
$LN14@BeginUIEle:

; 1732 :     }
; 1733 : 
; 1734 :     pElement->Release();

  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	50		 push	 eax
  000a2	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN6@BeginUIEle:
  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	56		 push	 esi
  000a8	ff 50 08	 call	 DWORD PTR [eax+8]

; 1735 :     return S_OK;

  000ab	33 c0		 xor	 eax, eax
  000ad	5e		 pop	 esi

; 1736 : }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 0c 00	 ret	 12			; 0000000cH
?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z ENDP ; CTsfUiLessMode::CUIElementSink::BeginUIElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ PROC	; CTsfUiLessMode::CUIElementSink::Release, COMDAT

; 1691 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1692 :     LONG cr = --_cRef;

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	57		 push	 edi
  00008	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  0000c	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]

; 1693 : 
; 1694 :     if (_cRef == 0)

  0000f	75 12		 jne	 SHORT $LN10@Release
  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 ??1CUIElementSink@CTsfUiLessMode@@QAE@XZ ; CTsfUiLessMode::CUIElementSink::~CUIElementSink
  00018	6a 10		 push	 16			; 00000010H
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00020	83 c4 08	 add	 esp, 8
$LN10@Release:

; 1695 :     {
; 1696 :         delete this;
; 1697 :     }
; 1698 : 
; 1699 :     return cr;
; 1700 : }

  00023	8b c7		 mov	 eax, edi
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ ENDP	; CTsfUiLessMode::CUIElementSink::Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ PROC	; CTsfUiLessMode::CUIElementSink::AddRef, COMDAT

; 1686 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1687 :     return ++_cRef;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00009	40		 inc	 eax
  0000a	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1688 : }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ ENDP	; CTsfUiLessMode::CUIElementSink::AddRef
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppvObj$ = 16						; size = 4
?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z PROC ; CTsfUiLessMode::CUIElementSink::QueryInterface, COMDAT

; 1653 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1654 :     if (ppvObj == NULL)

  00003	8b 45 10	 mov	 eax, DWORD PTR _ppvObj$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 08	 mov	 ebx, DWORD PTR _this$[ebp]
  0000a	85 c0		 test	 eax, eax
  0000c	75 0a		 jne	 SHORT $LN2@QueryInter

; 1655 :         return E_INVALIDARG;

  0000e	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00013	5b		 pop	 ebx

; 1683 : }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN2@QueryInter:
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00018	8b 55 0c	 mov	 edx, DWORD PTR _riid$[ebp]
  0001b	8b ca		 mov	 ecx, edx
  0001d	56		 push	 esi
  0001e	57		 push	 edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1657 :     *ppvObj = NULL;

  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00025	be 00 00 00 00	 mov	 esi, OFFSET _IID_IUnknown
  0002a	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH
  0002f	90		 npad	 1
$LL25@QueryInter:
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	3b 06		 cmp	 eax, DWORD PTR [esi]
  00034	75 11		 jne	 SHORT $LN3@QueryInter
  00036	83 c1 04	 add	 ecx, 4
  00039	83 c6 04	 add	 esi, 4
  0003c	83 ef 04	 sub	 edi, 4
  0003f	73 ef		 jae	 SHORT $LL25@QueryInter
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1661 :         *ppvObj = reinterpret_cast<IUnknown *>(this);

  00041	8b cb		 mov	 ecx, ebx
  00043	8b d3		 mov	 edx, ebx

; 1662 : 	}

  00045	eb 6d		 jmp	 SHORT $LN44@QueryInter
$LN3@QueryInter:
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00047	8b ca		 mov	 ecx, edx
  00049	be 00 00 00 00	 mov	 esi, OFFSET __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
  0004e	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH
$LL27@QueryInter:
  00053	8b 01		 mov	 eax, DWORD PTR [ecx]
  00055	3b 06		 cmp	 eax, DWORD PTR [esi]
  00057	75 11		 jne	 SHORT $LN5@QueryInter
  00059	83 c1 04	 add	 ecx, 4
  0005c	83 c6 04	 add	 esi, 4
  0005f	83 ef 04	 sub	 edi, 4
  00062	73 ef		 jae	 SHORT $LL27@QueryInter
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1665 :         *ppvObj = (ITfUIElementSink *)this;

  00064	8b cb		 mov	 ecx, ebx
  00066	8b d3		 mov	 edx, ebx

; 1666 :     }

  00068	eb 4a		 jmp	 SHORT $LN44@QueryInter
$LN5@QueryInter:
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  0006a	8b ca		 mov	 ecx, edx
  0006c	be 00 00 00 00	 mov	 esi, OFFSET __GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
  00071	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH
$LL29@QueryInter:
  00076	8b 01		 mov	 eax, DWORD PTR [ecx]
  00078	3b 06		 cmp	 eax, DWORD PTR [esi]
  0007a	75 10		 jne	 SHORT $LN7@QueryInter
  0007c	83 c1 04	 add	 ecx, 4
  0007f	83 c6 04	 add	 esi, 4
  00082	83 ef 04	 sub	 edi, 4
  00085	73 ef		 jae	 SHORT $LL29@QueryInter
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1670 : 	}

  00087	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  0008a	eb 1e		 jmp	 SHORT $LN45@QueryInter
$LN7@QueryInter:
; File D:\Windows Kits\10\Include\10.0.26100.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  0008c	b9 00 00 00 00	 mov	 ecx, OFFSET __GUID_743abd5f_f26d_48df_8cc5_238492419b64
  00091	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
$LL31@QueryInter:
  00096	8b 02		 mov	 eax, DWORD PTR [edx]
  00098	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0009a	75 30		 jne	 SHORT $LN10@QueryInter
  0009c	83 c2 04	 add	 edx, 4
  0009f	83 c1 04	 add	 ecx, 4
  000a2	83 ee 04	 sub	 esi, 4
  000a5	73 ef		 jae	 SHORT $LL31@QueryInter
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1673 : 		*ppvObj = (ITfCompartmentEventSink*)this;

  000a7	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
$LN45@QueryInter:

; 1674 : 	}
; 1675 : 
; 1676 :     if (*ppvObj)

  000aa	8b cb		 mov	 ecx, ebx
  000ac	f7 d9		 neg	 ecx
  000ae	1b c9		 sbb	 ecx, ecx
  000b0	23 c8		 and	 ecx, eax
  000b2	8b d1		 mov	 edx, ecx
$LN44@QueryInter:
  000b4	8b 45 10	 mov	 eax, DWORD PTR _ppvObj$[ebp]
  000b7	89 10		 mov	 DWORD PTR [eax], edx
  000b9	85 c9		 test	 ecx, ecx
  000bb	74 0f		 je	 SHORT $LN10@QueryInter

; 1677 :     {
; 1678 :         AddRef();

  000bd	8b 03		 mov	 eax, DWORD PTR [ebx]
  000bf	53		 push	 ebx
  000c0	ff 50 04	 call	 DWORD PTR [eax+4]
  000c3	5f		 pop	 edi
  000c4	5e		 pop	 esi

; 1679 :         return S_OK;

  000c5	33 c0		 xor	 eax, eax
  000c7	5b		 pop	 ebx

; 1683 : }

  000c8	5d		 pop	 ebp
  000c9	c2 0c 00	 ret	 12			; 0000000cH
$LN10@QueryInter:
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi

; 1680 :     }
; 1681 : 
; 1682 :     return E_NOINTERFACE;

  000ce	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  000d3	5b		 pop	 ebx

; 1683 : }

  000d4	5d		 pop	 ebp
  000d5	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ENDP ; CTsfUiLessMode::CUIElementSink::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ??1CUIElementSink@CTsfUiLessMode@@QAE@XZ
_TEXT	SEGMENT
??1CUIElementSink@CTsfUiLessMode@@QAE@XZ PROC		; CTsfUiLessMode::CUIElementSink::~CUIElementSink, COMDAT
; _this$ = ecx

; 1649 : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@
  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
  0000d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@

; 1650 : }

  00014	c3		 ret	 0
??1CUIElementSink@CTsfUiLessMode@@QAE@XZ ENDP		; CTsfUiLessMode::CUIElementSink::~CUIElementSink
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ??0CUIElementSink@CTsfUiLessMode@@QAE@XZ
_TEXT	SEGMENT
??0CUIElementSink@CTsfUiLessMode@@QAE@XZ PROC		; CTsfUiLessMode::CUIElementSink::CUIElementSink, COMDAT
; _this$ = ecx

; 1643 : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@

; 1644 :     _cRef = 1;
; 1645 : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@
  00016	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [ecx+12], 1
  0001d	c3		 ret	 0
??0CUIElementSink@CTsfUiLessMode@@QAE@XZ ENDP		; CTsfUiLessMode::CUIElementSink::CUIElementSink
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CIME::ms_wstrReading'', COMDAT
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A
  00005	85 c0		 test	 eax, eax
  00007	74 4d		 je	 SHORT $LN7@ms_wstrRea

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+8
  0000f	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e1 fe	 and	 ecx, -2			; fffffffeH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN26@ms_wstrRea

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 2b		 ja	 SHORT $LN23@ms_wstrRea

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN26@ms_wstrRea:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00038	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A, 0

; 2081 :             _Mylast  = nullptr;

  00042	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+4, 0

; 2082 :             _Myend   = nullptr;

  0004c	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+8, 0
$LN7@ms_wstrRea:
  00056	c3		 ret	 0
$LN23@ms_wstrRea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00057	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CIME::ms_wstrReading''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'CIME::ms_wstrReading'', COMDAT

; 120  : std::vector<wchar_t>	CIME::ms_wstrReading;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'CIME::ms_wstrReading''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'CIME::ms_wstrReading''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCIME@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCIME@@UAEPAXI@Z PROC				; CIME::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CIME@@UAE@XZ		; CIME::~CIME
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN5@scalar
  00011	68 24 08 00 00	 push	 2084			; 00000824H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCIME@@UAEPAXI@Z ENDP				; CIME::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array, COMDAT
; _this$ = ecx

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();
; 2047 :         auto& _My_data    = _Mypair._Myval2;
; 2048 :         pointer& _Myfirst = _My_data._Myfirst;
; 2049 :         pointer& _Mylast  = _My_data._Mylast;
; 2050 :         pointer& _Myend   = _My_data._Myend;
; 2051 : 
; 2052 :         _My_data._Orphan_all();
; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN10@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000f	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e1 fe	 and	 ecx, -2			; fffffffeH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN21@Change_arr

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN18@Change_arr

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN21@Change_arr:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN10@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2060 :         _Myfirst = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 2064 :     }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN18@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Newsize$ = 8						; size = 4
$T1 = 8							; size = 4
?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::resize, COMDAT
; _this$ = ecx

; 1613 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 1581 :         if (_Newsize < _Oldsize) { // trim

  00006	8b 75 08	 mov	 esi, DWORD PTR __Newsize$[ebp]

; 1613 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	89 7d fc	 mov	 DWORD PTR _this$1$[ebp], edi

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0000f	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00012	8b da		 mov	 ebx, edx
  00014	8b 07		 mov	 eax, DWORD PTR [edi]
  00016	2b d8		 sub	 ebx, eax
  00018	d1 fb		 sar	 ebx, 1

; 1581 :         if (_Newsize < _Oldsize) { // trim

  0001a	3b f3		 cmp	 esi, ebx
  0001c	73 0f		 jae	 SHORT $LN4@resize

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  0001e	8d 04 70	 lea	 eax, DWORD PTR [eax+esi*2]

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1585 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1586 :             _Mylast = _Newlast;

  00021	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00024	5f		 pop	 edi

; 1616 :     }

  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
$LN4@resize:

; 1590 :         if (_Newsize > _Oldsize) { // append

  0002d	0f 86 be 00 00
	00		 jbe	 $LN5@resize

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00033	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00036	2b c8		 sub	 ecx, eax
  00038	d1 f9		 sar	 ecx, 1

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  0003a	3b f1		 cmp	 esi, ecx
  0003c	0f 86 9d 00 00
	00		 jbe	 $LN6@resize

; 1538 :         if (_Newsize > max_size()) {

  00042	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00048	0f 87 ac 00 00
	00		 ja	 $LN111@resize

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004e	8b d1		 mov	 edx, ecx
  00050	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00055	d1 ea		 shr	 edx, 1
  00057	2b c2		 sub	 eax, edx
  00059	3b c8		 cmp	 ecx, eax
  0005b	76 12		 jbe	 SHORT $LN13@resize

; 1997 :             return _Max; // geometric growth would overflow

  0005d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00062	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006d	eb 31		 jmp	 SHORT $LN109@resize
$LN13@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006f	8d 3c 0a	 lea	 edi, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00072	3b fe		 cmp	 edi, esi
  00074	73 0b		 jae	 SHORT $LN14@resize

; 2003 :             return _Newsize; // geometric growth would be insufficient

  00076	8b fe		 mov	 edi, esi
$LN24@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  00078	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]

; 227  :     if (_Bytes == 0) {

  0007b	85 c0		 test	 eax, eax
  0007d	75 0c		 jne	 SHORT $LN28@resize

; 228  :         return nullptr;

  0007f	eb 22		 jmp	 SHORT $LN108@resize
$LN14@resize:

; 117  :         if (_Count > _Max_possible) {

  00081	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00087	77 76		 ja	 SHORT $LN112@resize
  00089	eb ed		 jmp	 SHORT $LN24@resize
$LN28@resize:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0008b	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00090	72 08		 jb	 SHORT $LN29@resize

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00098	eb 06		 jmp	 SHORT $LN109@resize
$LN29@resize:

; 136  :         return ::operator new(_Bytes);

  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN109@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000a0	83 c4 04	 add	 esp, 4
$LN108@resize:
  000a3	8d 0c 58	 lea	 ecx, DWORD PTR [eax+ebx*2]
  000a6	89 45 08	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  000a9	8b c6		 mov	 eax, esi
  000ab	2b c3		 sub	 eax, ebx
  000ad	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000b0	50		 push	 eax
  000b1	51		 push	 ecx
  000b2	e8 00 00 00 00	 call	 ??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z ; std::_Zero_range<wchar_t *>

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b 5d fc	 mov	 ebx, DWORD PTR _this$1$[ebp]
  000ba	ff 75 08	 push	 DWORD PTR $T1[ebp]
  000bd	ff 73 04	 push	 DWORD PTR [ebx+4]
  000c0	ff 33		 push	 DWORD PTR [ebx]
  000c2	e8 00 00 00 00	 call	 ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ; std::_Copy_memmove<wchar_t *,wchar_t *>
  000c7	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1570 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000ca	8b cb		 mov	 ecx, ebx
  000cc	57		 push	 edi
  000cd	56		 push	 esi
  000ce	ff 75 08	 push	 DWORD PTR $T1[ebp]
  000d1	e8 00 00 00 00	 call	 ?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
  000d6	5f		 pop	 edi

; 1616 :     }

  000d7	5e		 pop	 esi
  000d8	5b		 pop	 ebx
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c2 04 00	 ret	 4
$LN6@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  000df	2b f3		 sub	 esi, ebx
  000e1	8d 34 72	 lea	 esi, DWORD PTR [edx+esi*2]
  000e4	56		 push	 esi
  000e5	52		 push	 edx
  000e6	e8 00 00 00 00	 call	 ??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z ; std::_Zero_range<wchar_t *>
  000eb	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  000ee	89 77 04	 mov	 DWORD PTR [edi+4], esi
$LN5@resize:
  000f1	5f		 pop	 edi

; 1616 :     }

  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c2 04 00	 ret	 4
$LN111@resize:

; 1539 :             _Xlength();

  000fa	e8 00 00 00 00	 call	 ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN112@resize:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  000ff	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN107@resize:
  00104	cc		 int	 3
?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetupImeApi@CIME@@KAXXZ
_TEXT	SEGMENT
_szImeFile$ = -268					; size = 261
__$ArrayPad$ = -4					; size = 4
?SetupImeApi@CIME@@KAXXZ PROC				; CIME::SetupImeApi, COMDAT

; 1390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1391 :     char szImeFile[MAX_PATH + 1];
; 1392 : 
; 1393 : 	_GetReadingString = NULL;
; 1394 :     _ShowReadingWindow = NULL;
; 1395 : 	ms_bUseIMMCandidate = false;
; 1396 : 
; 1397 : 	if(ImmGetIMEFileNameA(ms_hklCurrent, szImeFile, COUNTOF(szImeFile) - 1) == 0)

  00013	68 04 01 00 00	 push	 260			; 00000104H
  00018	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szImeFile$[ebp]
  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, 0 ; CIME::_GetReadingString
  00028	50		 push	 eax
  00029	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0002f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA, 0 ; CIME::_ShowReadingWindow
  00039	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA, 0 ; CIME::ms_bUseIMMCandidate
  00040	e8 00 00 00 00	 call	 _ImmGetIMEFileNameA@12
  00045	85 c0		 test	 eax, eax
  00047	0f 84 dd 00 00
	00		 je	 $LN9@SetupImeAp

; 1398 : 		return;
; 1399 : 	if(stricmp(szImeFile, CHS_IMEFILENAME_QQPINYIN) == 0 || stricmp(szImeFile, CHS_IMEFILENAME_SOGOUPY) == 0 || stricmp(szImeFile, CHS_IMEFILENAME_GOOGLEPINYIN2) == 0)

  0004d	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szImeFile$[ebp]
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EMABPIGL@QQPINYIN?4IME@
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 __stricmp
  0005e	83 c4 08	 add	 esp, 8
  00061	85 c0		 test	 eax, eax
  00063	74 30		 je	 SHORT $LN4@SetupImeAp
  00065	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szImeFile$[ebp]
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IPABOCGB@SOGOUPY?4IME@
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 __stricmp
  00076	83 c4 08	 add	 esp, 8
  00079	85 c0		 test	 eax, eax
  0007b	74 18		 je	 SHORT $LN4@SetupImeAp
  0007d	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szImeFile$[ebp]
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 __stricmp
  0008e	83 c4 08	 add	 esp, 8
  00091	85 c0		 test	 eax, eax
  00093	75 07		 jne	 SHORT $LN3@SetupImeAp
$LN4@SetupImeAp:

; 1400 : 		ms_bUseIMMCandidate = true;

  00095	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA, 1 ; CIME::ms_bUseIMMCandidate
$LN3@SetupImeAp:

; 1401 : 	if (ms_bUILessMode)

  0009c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  000a3	0f 85 81 00 00
	00		 jne	 $LN9@SetupImeAp

; 1402 : 		return;
; 1403 : 	SAFE_FREE_LIBRARY(ms_hCurrentImeDll);

  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  000ae	85 c0		 test	 eax, eax
  000b0	74 11		 je	 SHORT $LN6@SetupImeAp
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  000b9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
$LN6@SetupImeAp:

; 1404 : 	ms_hCurrentImeDll = LoadLibraryA(szImeFile);

  000c3	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szImeFile$[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  000d0	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, eax ; CIME::ms_hCurrentImeDll
  000d5	85 c0		 test	 eax, eax

; 1405 : 
; 1406 : 	if (ms_hCurrentImeDll) {

  000d7	74 51		 je	 SHORT $LN9@SetupImeAp

; 1407 : 		_GetReadingString = (UINT (WINAPI*)(HIMC, UINT, LPWSTR, PINT, BOOL*, PUINT)) (GetProcAddress(ms_hCurrentImeDll, "GetReadingString"));

  000d9	56		 push	 esi
  000da	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetProcAddress@8
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EOIFCLLM@GetReadingString@
  000e5	50		 push	 eax
  000e6	ff d6		 call	 esi

; 1408 : 		_ShowReadingWindow =(BOOL (WINAPI*)(HIMC, BOOL)) (GetProcAddress(ms_hCurrentImeDll, "ShowReadingWindow"));

  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MEELNKEC@ShowReadingWindow@
  000ed	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  000f3	a3 00 00 00 00	 mov	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, eax ; CIME::_GetReadingString
  000f8	ff d6		 call	 esi
  000fa	a3 00 00 00 00	 mov	 DWORD PTR ?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA, eax ; CIME::_ShowReadingWindow
  000ff	85 c0		 test	 eax, eax

; 1409 : 
; 1410 : 		if(_ShowReadingWindow) {

  00101	74 26		 je	 SHORT $LN19@SetupImeAp

; 1411 : 			HIMC hImc = ImmGetContext(ms_hWnd);

  00103	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00109	e8 00 00 00 00	 call	 _ImmGetContext@4
  0010e	8b f0		 mov	 esi, eax

; 1412 : 			if(hImc) {

  00110	85 f6		 test	 esi, esi
  00112	74 15		 je	 SHORT $LN19@SetupImeAp

; 1413 : 				_ShowReadingWindow(hImc, false);

  00114	6a 00		 push	 0
  00116	56		 push	 esi
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA ; CIME::_ShowReadingWindow

; 1414 : 				ImmReleaseContext(ms_hWnd, hImc);

  0011d	56		 push	 esi
  0011e	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00124	e8 00 00 00 00	 call	 _ImmReleaseContext@8
$LN19@SetupImeAp:
  00129	5e		 pop	 esi
$LN9@SetupImeAp:

; 1415 : 			}
; 1416 : 		}
; 1417 : 	}
; 1418 : }

  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
?SetupImeApi@CIME@@KAXXZ ENDP				; CIME::SetupImeApi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetReadingWindowOrientation@CIME@@IAE_NXZ
_TEXT	SEGMENT
_dwType$1 = -284					; size = 4
_dwMapping$2 = -280					; size = 4
_dwSize$3 = -276					; size = 4
_hKey$4 = -272						; size = 4
_bHorizontalReading$1$ = -265				; size = 1
_szRegPath$5 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
?GetReadingWindowOrientation@CIME@@IAE_NXZ PROC		; CIME::GetReadingWindowOrientation, COMDAT
; _this$ = ecx

; 1356 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1357 :     bool bHorizontalReading = (ms_hklCurrent == _CHS_HKL) || (ms_hklCurrent == _CHT_HKL_NEW_CHANG_JIE) || (ms_adwId[0] == 0);

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00018	53		 push	 ebx
  00019	3d 04 08 0e e0	 cmp	 eax, -535951356		; e00e0804H
  0001e	0f 84 aa 01 00
	00		 je	 $LN10@GetReading
  00024	3d 04 04 09 e0	 cmp	 eax, -536280060		; e0090404H
  00029	0f 84 9f 01 00
	00		 je	 $LN10@GetReading
  0002f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?ms_adwId@CIME@@2PAKA
  00035	85 db		 test	 ebx, ebx
  00037	0f 84 91 01 00
	00		 je	 $LN10@GetReading
  0003d	32 c9		 xor	 cl, cl

; 1358 :     if(!bHorizontalReading && (GETLANG() == LANG_CHT))

  0003f	ba 04 04 00 00	 mov	 edx, 1028		; 00000404H
  00044	88 8d f7 fe ff
	ff		 mov	 BYTE PTR _bHorizontalReading$1$[ebp], cl
  0004a	66 3b c2	 cmp	 ax, dx
  0004d	0f 85 6a 01 00
	00		 jne	 $LN16@GetReading

; 1359 :     {
; 1360 :         char szRegPath[MAX_PATH];
; 1361 :         HKEY hKey;
; 1362 :         DWORD dwVer = ms_adwId[0] & 0xFFFF0000;
; 1363 :         strcpy(szRegPath, "software\\microsoft\\windows\\currentversion\\");

  00053	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@
  0005a	66 a1 28 00 00
	00		 mov	 ax, WORD PTR ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@+40
  00060	81 e3 00 00 ff
	ff		 and	 ebx, -65536		; ffff0000H
  00066	66 89 85 20 ff
	ff ff		 mov	 WORD PTR _szRegPath$5[ebp+40], ax

; 1364 :         strcat(szRegPath, (dwVer >= MAKEIMEVERSION(5, 1)) ? "MSTCIPH" : "TINTLGNT");

  0006d	81 fb 00 00 01
	05		 cmp	 ebx, 83951616		; 05010000H
  00073	a0 2a 00 00 00	 mov	 al, BYTE PTR ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@+42
  00078	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07DEJAPC@MSTCIPH@
  0007d	0f 11 85 f8 fe
	ff ff		 movups	 XMMWORD PTR _szRegPath$5[ebp], xmm0
  00084	88 85 22 ff ff
	ff		 mov	 BYTE PTR _szRegPath$5[ebp+42], al
  0008a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LMKCILHO@TINTLGNT@
  0008f	0f 10 05 10 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@+16
  00096	56		 push	 esi
  00097	0f 42 d0	 cmovb	 edx, eax
  0009a	0f 11 85 08 ff
	ff ff		 movups	 XMMWORD PTR _szRegPath$5[ebp+16], xmm0
  000a1	8b f2		 mov	 esi, edx
  000a3	f3 0f 7e 05 20
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@+32
  000ab	57		 push	 edi
  000ac	66 0f d6 85 18
	ff ff ff	 movq	 QWORD PTR _szRegPath$5[ebp+32], xmm0
$LL13@GetReading:
  000b4	8a 02		 mov	 al, BYTE PTR [edx]
  000b6	42		 inc	 edx
  000b7	84 c0		 test	 al, al
  000b9	75 f9		 jne	 SHORT $LL13@GetReading
  000bb	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _szRegPath$5[ebp]
  000c1	2b d6		 sub	 edx, esi
  000c3	4f		 dec	 edi
$LL14@GetReading:
  000c4	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000c7	47		 inc	 edi
  000c8	84 c0		 test	 al, al
  000ca	75 f8		 jne	 SHORT $LL14@GetReading
  000cc	8b ca		 mov	 ecx, edx

; 1365 :         LONG lRc = RegOpenKeyExA(HKEY_CURRENT_USER, szRegPath, 0, KEY_READ, &hKey);

  000ce	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _hKey$4[ebp]
  000d4	c1 e9 02	 shr	 ecx, 2
  000d7	f3 a5		 rep movsd
  000d9	50		 push	 eax
  000da	68 19 00 02 00	 push	 131097			; 00020019H
  000df	6a 00		 push	 0
  000e1	8b ca		 mov	 ecx, edx
  000e3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szRegPath$5[ebp]
  000e9	83 e1 03	 and	 ecx, 3
  000ec	50		 push	 eax
  000ed	f3 a4		 rep movsb
  000ef	68 01 00 00 80	 push	 -2147483647		; 80000001H
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi

; 1366 :         if (lRc == ERROR_SUCCESS)

  000fc	85 c0		 test	 eax, eax
  000fe	0f 85 a4 00 00
	00		 jne	 $LN15@GetReading

; 1367 :         {
; 1368 :             DWORD dwSize = sizeof(DWORD), dwMapping, dwType;
; 1369 :             lRc = RegQueryValueExA(hKey, "Keyboard Mapping", NULL, &dwType, (PBYTE)&dwMapping, &dwSize);

  00104	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _dwSize$3[ebp]
  0010a	c7 85 ec fe ff
	ff 04 00 00 00	 mov	 DWORD PTR _dwSize$3[ebp], 4
  00114	50		 push	 eax
  00115	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _dwMapping$2[ebp]
  0011b	50		 push	 eax
  0011c	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _dwType$1[ebp]
  00122	50		 push	 eax
  00123	6a 00		 push	 0
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@
  0012a	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _hKey$4[ebp]
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24

; 1370 :             if (lRc == ERROR_SUCCESS)

  00136	85 c0		 test	 eax, eax
  00138	75 4b		 jne	 SHORT $LN19@GetReading

; 1371 :             {
; 1372 :                 if ((dwVer <= MAKEIMEVERSION(5, 0) &&
; 1373 :                        ((BYTE)dwMapping == 0x22 || (BYTE)dwMapping == 0x23))
; 1374 :                      ||

  0013a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _dwMapping$2[ebp]
  00140	81 fb 00 00 00
	05		 cmp	 ebx, 83886080		; 05000000H
  00146	77 08		 ja	 SHORT $LN7@GetReading
  00148	3c 22		 cmp	 al, 34			; 00000022H
  0014a	74 1a		 je	 SHORT $LN6@GetReading
  0014c	3c 23		 cmp	 al, 35			; 00000023H
  0014e	74 16		 je	 SHORT $LN6@GetReading
$LN7@GetReading:
  00150	81 fb 00 00 01
	05		 cmp	 ebx, 83951616		; 05010000H
  00156	74 08		 je	 SHORT $LN8@GetReading
  00158	81 fb 00 00 02
	05		 cmp	 ebx, 84017152		; 05020000H
  0015e	75 25		 jne	 SHORT $LN19@GetReading
$LN8@GetReading:
  00160	2c 22		 sub	 al, 34			; 00000022H
  00162	3c 02		 cmp	 al, 2
  00164	77 1f		 ja	 SHORT $LN19@GetReading
$LN6@GetReading:

; 1375 :                      ((dwVer == MAKEIMEVERSION(5, 1) || dwVer == MAKEIMEVERSION(5, 2)) &&
; 1376 :                        (BYTE)dwMapping >= 0x22 && (BYTE)dwMapping <= 0x24)
; 1377 :                   )
; 1378 :                 {
; 1379 :                     bHorizontalReading = true;
; 1380 :                 }
; 1381 :             }
; 1382 :             RegCloseKey(hKey);

  00166	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _hKey$4[ebp]
  0016c	b3 01		 mov	 bl, 1
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 1383 :         }
; 1384 :     }
; 1385 : 
; 1386 : 	return bHorizontalReading;

  00174	8a c3		 mov	 al, bl
  00176	5b		 pop	 ebx

; 1387 : }

  00177	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017a	33 cd		 xor	 ecx, ebp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c3		 ret	 0
$LN19@GetReading:

; 1375 :                      ((dwVer == MAKEIMEVERSION(5, 1) || dwVer == MAKEIMEVERSION(5, 2)) &&
; 1376 :                        (BYTE)dwMapping >= 0x22 && (BYTE)dwMapping <= 0x24)
; 1377 :                   )
; 1378 :                 {
; 1379 :                     bHorizontalReading = true;
; 1380 :                 }
; 1381 :             }
; 1382 :             RegCloseKey(hKey);

  00185	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _hKey$4[ebp]
  0018b	8a 9d f7 fe ff
	ff		 mov	 bl, BYTE PTR _bHorizontalReading$1$[ebp]
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 1383 :         }
; 1384 :     }
; 1385 : 
; 1386 : 	return bHorizontalReading;

  00197	8a c3		 mov	 al, bl
  00199	5b		 pop	 ebx

; 1387 : }

  0019a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019d	33 cd		 xor	 ecx, ebp
  0019f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
$LN15@GetReading:

; 1383 :         }
; 1384 :     }
; 1385 : 
; 1386 : 	return bHorizontalReading;

  001a8	8a 85 f7 fe ff
	ff		 mov	 al, BYTE PTR _bHorizontalReading$1$[ebp]
  001ae	5b		 pop	 ebx

; 1387 : }

  001af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b2	33 cd		 xor	 ecx, ebp
  001b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c3		 ret	 0
$LN16@GetReading:

; 1383 :         }
; 1384 :     }
; 1385 : 
; 1386 : 	return bHorizontalReading;

  001bd	8a c1		 mov	 al, cl
  001bf	5b		 pop	 ebx

; 1387 : }

  001c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c3	33 cd		 xor	 ecx, ebp
  001c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
$LN10@GetReading:
  001ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d1	b0 01		 mov	 al, 1
  001d3	33 cd		 xor	 ecx, ebp
  001d5	5b		 pop	 ebx
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	8b e5		 mov	 esp, ebp
  001dd	5d		 pop	 ebp
  001de	c3		 ret	 0
?GetReadingWindowOrientation@CIME@@IAE_NXZ ENDP		; CIME::GetReadingWindowOrientation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetImeId@CIME@@IAEKI@Z
_TEXT	SEGMENT
_cbVerData$1 = -1044					; size = 4
_lpVerData$2 = -1040					; size = 4
_lpVerBuffer$1$ = -1036					; size = 4
_dwVerHandle$ = -1032					; size = 4
_szTmp$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_uIndex$ = 8						; size = 4
?GetImeId@CIME@@IAEKI@Z PROC				; CIME::GetImeId, COMDAT
; _this$ = ecx

; 1267 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1268 : 	static HKL hklPrev = 0;
; 1269 :     char szTmp[1024];
; 1270 : 
; 1271 : 	if (uIndex >= COUNTOF(ms_adwId))

  00016	8b 7d 08	 mov	 edi, DWORD PTR _uIndex$[ebp]
  00019	83 ff 02	 cmp	 edi, 2
  0001c	0f 83 2b 02 00
	00		 jae	 $LN20@GetImeId

; 1272 : 		return 0;
; 1273 : 	HKL hkl = ms_hklCurrent;

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent

; 1274 : 	if(hklPrev == hkl)

  00028	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A, ecx
  0002e	0f 84 67 02 00
	00		 je	 $LN21@GetImeId

; 1275 : 		return ms_adwId[uIndex];
; 1276 : 	hklPrev = hkl;
; 1277 : 
; 1278 : 	DWORD dwLang = ((DWORD)hkl & 0xffff);
; 1279 : 
; 1280 : 	if ( ms_bUILessMode && GETLANG() == LANG_CHT ) {

  00034	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  0003b	b8 04 04 00 00	 mov	 eax, 1028		; 00000404H
  00040	89 0d 00 00 00
	00		 mov	 DWORD PTR ?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A, ecx
  00046	74 23		 je	 SHORT $LN4@GetImeId
  00048	66 3b c8	 cmp	 cx, ax
  0004b	75 1e		 jne	 SHORT $LN4@GetImeId

; 1281 : 		// In case of Vista, artifitial value is returned so that it's not considered as older IME.
; 1282 : 		ms_adwId[0] = IMEID_CHT_VER_VISTA;

  0004d	c7 05 00 00 00
	00 04 04 00 07	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA, 117441540 ; 07000404H

; 1283 : 		ms_adwId[1] = 0;
; 1284 : 		return ms_adwId[0];

  00057	b8 04 04 00 07	 mov	 eax, 117441540		; 07000404H
  0005c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA+4, 0
  00066	e9 e4 01 00 00	 jmp	 $LN1@GetImeId
$LN4@GetImeId:

; 1285 : 	}
; 1286 : 
; 1287 : 	if (!((ms_hklCurrent == _CHT_HKL_NEW_PHONETIC) || (ms_hklCurrent == _CHT_HKL_NEW_CHANG_JIE) || (ms_hklCurrent == _CHT_HKL_NEW_QUICK) || (ms_hklCurrent == _CHT_HKL_HK_CANTONESE) || (ms_hklCurrent == _CHS_HKL))) {

  0006b	81 f9 04 04 08
	e0		 cmp	 ecx, -536345596		; e0080404H
  00071	74 24		 je	 SHORT $LN5@GetImeId
  00073	81 f9 04 04 09
	e0		 cmp	 ecx, -536280060		; e0090404H
  00079	74 1c		 je	 SHORT $LN5@GetImeId
  0007b	81 f9 04 04 0a
	e0		 cmp	 ecx, -536214524		; e00a0404H
  00081	74 14		 je	 SHORT $LN5@GetImeId
  00083	81 f9 04 04 0b
	e0		 cmp	 ecx, -536148988		; e00b0404H
  00089	74 0c		 je	 SHORT $LN5@GetImeId
  0008b	81 f9 04 08 0e
	e0		 cmp	 ecx, -535951356		; e00e0804H
  00091	0f 85 a2 01 00
	00		 jne	 $LN12@GetImeId
$LN5@GetImeId:

; 1288 : 		ms_adwId[0] = ms_adwId[1] = 0;
; 1289 :         return 0;
; 1290 : 	}
; 1291 : 
; 1292 : 	if (!ImmGetIMEFileNameA(ms_hklCurrent, szTmp, (sizeof(szTmp) / sizeof(szTmp[0])) - 1)) {

  00097	68 ff 03 00 00	 push	 1023			; 000003ffH
  0009c	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  000a2	50		 push	 eax
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 _ImmGetIMEFileNameA@12
  000a9	85 c0		 test	 eax, eax
  000ab	0f 84 88 01 00
	00		 je	 $LN12@GetImeId

; 1293 : 		ms_adwId[0] = ms_adwId[1] = 0;
; 1294 :         return 0;
; 1295 : 	}
; 1296 : 
; 1297 :     if (!_GetReadingString)

  000b1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, 0 ; CIME::_GetReadingString
  000b8	0f 85 a0 00 00
	00		 jne	 $LN8@GetImeId

; 1298 : 	{
; 1299 :         if ((CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME1, -1) != CSTR_EQUAL) &&
; 1300 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME2, -1) != CSTR_EQUAL) &&
; 1301 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME3, -1) != CSTR_EQUAL) &&
; 1302 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHS_IMEFILENAME1, -1) != CSTR_EQUAL) &&

  000be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CompareStringA@24
  000c4	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  000ca	6a ff		 push	 -1
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FFMHCBAD@TINTLGNT?4IME@
  000d1	6a ff		 push	 -1
  000d3	50		 push	 eax
  000d4	6a 01		 push	 1
  000d6	68 09 04 00 00	 push	 1033			; 00000409H
  000db	ff d6		 call	 esi
  000dd	83 f8 02	 cmp	 eax, 2
  000e0	74 7c		 je	 SHORT $LN8@GetImeId
  000e2	6a ff		 push	 -1
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JMLDIBIB@CINTLGNT?4IME@
  000e9	6a ff		 push	 -1
  000eb	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  000f1	50		 push	 eax
  000f2	6a 01		 push	 1
  000f4	68 09 04 00 00	 push	 1033			; 00000409H
  000f9	ff d6		 call	 esi
  000fb	83 f8 02	 cmp	 eax, 2
  000fe	74 5e		 je	 SHORT $LN8@GetImeId
  00100	6a ff		 push	 -1
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FHDFFBN@MSTCIPHA?4IME@
  00107	6a ff		 push	 -1
  00109	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0010f	50		 push	 eax
  00110	6a 01		 push	 1
  00112	68 09 04 00 00	 push	 1033			; 00000409H
  00117	ff d6		 call	 esi
  00119	83 f8 02	 cmp	 eax, 2
  0011c	74 40		 je	 SHORT $LN8@GetImeId
  0011e	6a ff		 push	 -1
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JFHOELJF@PINTLGNT?4IME@
  00125	6a ff		 push	 -1
  00127	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0012d	50		 push	 eax
  0012e	6a 01		 push	 1
  00130	68 09 04 00 00	 push	 1033			; 00000409H
  00135	ff d6		 call	 esi
  00137	83 f8 02	 cmp	 eax, 2
  0013a	74 22		 je	 SHORT $LN8@GetImeId
  0013c	6a ff		 push	 -1
  0013e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@
  00143	6a ff		 push	 -1
  00145	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0014b	50		 push	 eax
  0014c	6a 01		 push	 1
  0014e	68 09 04 00 00	 push	 1033			; 00000409H
  00153	ff d6		 call	 esi
  00155	83 f8 02	 cmp	 eax, 2
  00158	0f 85 db 00 00
	00		 jne	 $LN12@GetImeId
$LN8@GetImeId:

; 1303 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHS_IMEFILENAME2, -1) != CSTR_EQUAL))
; 1304 : 		{
; 1305 : 			ms_adwId[0] = ms_adwId[1] = 0;
; 1306 : 	        return 0;
; 1307 :         }
; 1308 :     }
; 1309 : 
; 1310 :     DWORD   dwVerHandle;
; 1311 :     DWORD   dwVerSize = GetFileVersionInfoSize(szTmp, &dwVerHandle);

  0015e	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dwVerHandle$[ebp]
  00164	50		 push	 eax
  00165	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _GetFileVersionInfoSizeA@8

; 1312 : 	LANGID	langId = LOWORD(ms_hklCurrent);

  00171	0f b7 35 00 00
	00 00		 movzx	 esi, WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A
  00178	8b d8		 mov	 ebx, eax

; 1313 : 
; 1314 :     if (dwVerSize)

  0017a	85 db		 test	 ebx, ebx
  0017c	0f 84 b7 00 00
	00		 je	 $LN12@GetImeId

; 1315 : 	{
; 1316 :         LPVOID lpVerBuffer = alloca(dwVerSize);

  00182	e8 00 00 00 00	 call	 __alloca_probe_16
  00187	8b c4		 mov	 eax, esp

; 1317 : 
; 1318 :         if (GetFileVersionInfo(szTmp, dwVerHandle, dwVerSize, lpVerBuffer))

  00189	50		 push	 eax
  0018a	53		 push	 ebx
  0018b	ff b5 f8 fb ff
	ff		 push	 DWORD PTR _dwVerHandle$[ebp]
  00191	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _lpVerBuffer$1$[ebp], eax
  00197	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 _GetFileVersionInfoA@16
  001a3	85 c0		 test	 eax, eax
  001a5	0f 84 8e 00 00
	00		 je	 $LN12@GetImeId

; 1319 : 		{
; 1320 : 			LPVOID  lpVerData;
; 1321 : 			UINT    cbVerData;
; 1322 : 
; 1323 :             if(VerQueryValue(lpVerBuffer, "\\", &lpVerData, &cbVerData))

  001ab	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _cbVerData$1[ebp]
  001b1	50		 push	 eax
  001b2	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _lpVerData$2[ebp]
  001b8	50		 push	 eax
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@
  001be	ff b5 f4 fb ff
	ff		 push	 DWORD PTR _lpVerBuffer$1$[ebp]
  001c4	e8 00 00 00 00	 call	 _VerQueryValueA@16
  001c9	85 c0		 test	 eax, eax
  001cb	74 6c		 je	 SHORT $LN12@GetImeId

; 1324 : 			{
; 1325 :                 DWORD dwVer = ((VS_FIXEDFILEINFO*) lpVerData)->dwFileVersionMS;

  001cd	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _lpVerData$2[ebp]
  001d3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 1326 :                 dwVer = (dwVer & 0x00ff0000) << 8 | (dwVer & 0x000000ff) << 16;

  001d6	0f b6 c8	 movzx	 ecx, al
  001d9	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  001de	c1 e1 08	 shl	 ecx, 8
  001e1	0b c8		 or	 ecx, eax
  001e3	c1 e1 08	 shl	 ecx, 8

; 1327 : 
; 1328 :                 if (_GetReadingString
; 1329 :                     ||
; 1330 :                     (langId == LANG_CHT &&
; 1331 :                         (dwVer == MAKEIMEVERSION(4, 2) ||
; 1332 :                         dwVer == MAKEIMEVERSION(4, 3) ||
; 1333 :                         dwVer == MAKEIMEVERSION(4, 4) ||
; 1334 :                         dwVer == MAKEIMEVERSION(5, 0) ||
; 1335 :                         dwVer == MAKEIMEVERSION(5, 1) ||
; 1336 :                         dwVer == MAKEIMEVERSION(5, 2) ||
; 1337 :                         dwVer == MAKEIMEVERSION(6, 0)))
; 1338 :                     ||

  001e6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, 0 ; CIME::_GetReadingString
  001ed	0f 85 97 00 00
	00		 jne	 $LN15@GetImeId
  001f3	b8 04 04 00 00	 mov	 eax, 1028		; 00000404H
  001f8	66 3b f0	 cmp	 si, ax
  001fb	75 6b		 jne	 SHORT $LN14@GetImeId
  001fd	81 f9 00 00 02
	04		 cmp	 ecx, 67239936		; 04020000H
  00203	0f 84 81 00 00
	00		 je	 $LN15@GetImeId
  00209	81 f9 00 00 03
	04		 cmp	 ecx, 67305472		; 04030000H
  0020f	74 79		 je	 SHORT $LN15@GetImeId
  00211	81 f9 00 00 04
	04		 cmp	 ecx, 67371008		; 04040000H
  00217	74 71		 je	 SHORT $LN15@GetImeId
  00219	81 f9 00 00 00
	05		 cmp	 ecx, 83886080		; 05000000H
  0021f	74 69		 je	 SHORT $LN15@GetImeId
  00221	81 f9 00 00 01
	05		 cmp	 ecx, 83951616		; 05010000H
  00227	74 61		 je	 SHORT $LN15@GetImeId
  00229	81 f9 00 00 02
	05		 cmp	 ecx, 84017152		; 05020000H
  0022f	74 59		 je	 SHORT $LN15@GetImeId
  00231	81 f9 00 00 00
	06		 cmp	 ecx, 100663296		; 06000000H
  00237	74 51		 je	 SHORT $LN15@GetImeId
$LN12@GetImeId:

; 1346 : 					return ms_adwId[uIndex];
; 1347 :                 }
; 1348 :             }
; 1349 :         }
; 1350 :     }
; 1351 : 	ms_adwId[0] = ms_adwId[1] = 0;

  00239	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA+4, 0
  00243	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA, 0
$LN20@GetImeId:

; 1352 : 	return ms_adwId[0];
; 1353 : }

  0024d	33 c0		 xor	 eax, eax
$LN1@GetImeId:
  0024f	8d a5 e0 fb ff
	ff		 lea	 esp, DWORD PTR [ebp-1056]
  00255	5f		 pop	 edi
  00256	5e		 pop	 esi
  00257	5b		 pop	 ebx
  00258	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025b	33 cd		 xor	 ecx, ebp
  0025d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00262	8b e5		 mov	 esp, ebp
  00264	5d		 pop	 ebp
  00265	c2 04 00	 ret	 4
$LN14@GetImeId:

; 1327 : 
; 1328 :                 if (_GetReadingString
; 1329 :                     ||
; 1330 :                     (langId == LANG_CHT &&
; 1331 :                         (dwVer == MAKEIMEVERSION(4, 2) ||
; 1332 :                         dwVer == MAKEIMEVERSION(4, 3) ||
; 1333 :                         dwVer == MAKEIMEVERSION(4, 4) ||
; 1334 :                         dwVer == MAKEIMEVERSION(5, 0) ||
; 1335 :                         dwVer == MAKEIMEVERSION(5, 1) ||
; 1336 :                         dwVer == MAKEIMEVERSION(5, 2) ||
; 1337 :                         dwVer == MAKEIMEVERSION(6, 0)))
; 1338 :                     ||

  00268	b8 04 08 00 00	 mov	 eax, 2052		; 00000804H
  0026d	66 3b f0	 cmp	 si, ax
  00270	75 c7		 jne	 SHORT $LN12@GetImeId
  00272	81 f9 00 00 01
	04		 cmp	 ecx, 67174400		; 04010000H
  00278	74 10		 je	 SHORT $LN15@GetImeId
  0027a	81 f9 00 00 02
	04		 cmp	 ecx, 67239936		; 04020000H
  00280	74 08		 je	 SHORT $LN15@GetImeId
  00282	81 f9 00 00 03
	05		 cmp	 ecx, 84082688		; 05030000H
  00288	75 af		 jne	 SHORT $LN12@GetImeId
$LN15@GetImeId:

; 1339 :                     (langId == LANG_CHS &&
; 1340 :                         (dwVer == MAKEIMEVERSION(4, 1) ||
; 1341 :                         dwVer == MAKEIMEVERSION(4, 2) ||
; 1342 :                         dwVer == MAKEIMEVERSION(5, 3))))
; 1343 : 				{
; 1344 :                     ms_adwId[0] = dwVer | langId;

  0028a	8b c6		 mov	 eax, esi
  0028c	0b c1		 or	 eax, ecx
  0028e	a3 00 00 00 00	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA, eax

; 1345 :                     ms_adwId[1] = ((VS_FIXEDFILEINFO*)lpVerData)->dwFileVersionLS;

  00293	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00296	a3 04 00 00 00	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA+4, eax
$LN21@GetImeId:

; 1352 : 	return ms_adwId[0];
; 1353 : }

  0029b	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR ?ms_adwId@CIME@@2PAKA[edi*4]
  002a2	eb ab		 jmp	 SHORT $LN1@GetImeId
?GetImeId@CIME@@IAEKI@Z ENDP				; CIME::GetImeId
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?IsMax@CIME@@IAE_NPB_WH@Z
_TEXT	SEGMENT
_wInput$GSCopy$1$ = -68					; size = 4
_str$2 = -64						; size = 24
_input$3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wInput$ = 8						; size = 4
_len$ = 12						; size = 4
?IsMax@CIME@@IAE_NPB_WH@Z PROC				; CIME::IsMax, COMDAT
; _this$ = ecx

; 1245 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?IsMax@CIME@@IAE_NPB_WH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	8b 7d 0c	 mov	 edi, DWORD PTR _len$[ebp]

; 1246 : 	if (ms_lastpos + len > IMESTR_MAXLEN)

  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00036	8b 45 08	 mov	 eax, DWORD PTR _wInput$[ebp]
  00039	89 45 bc	 mov	 DWORD PTR _wInput$GSCopy$1$[ebp], eax
  0003c	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0003f	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  00044	0f 8f ed 00 00
	00		 jg	 $LN29@IsMax

; 1247 : 		return true;
; 1248 : 
; 1249 : 	int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, m_wText, ms_lastpos, 0, 0, NULL, NULL);

  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	51		 push	 ecx
  00053	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  00058	6a 00		 push	 0
  0005a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 1250 : 	int inputLen = WideCharToMultiByte(ms_uOutputCodePage, 0, wInput, len, 0, 0, NULL, NULL);

  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	57		 push	 edi
  0006f	ff 75 bc	 push	 DWORD PTR _wInput$GSCopy$1$[ebp]
  00072	8b f0		 mov	 esi, eax
  00074	6a 00		 push	 0
  00076	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 1251 : 	//return textLen + inputLen > m_max;
; 1252 : 
; 1253 : 	if (textLen + inputLen > m_max)

  00082	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00085	03 c6		 add	 eax, esi
  00087	3b c1		 cmp	 eax, ecx
  00089	0f 8f a8 00 00
	00		 jg	 $LN29@IsMax

; 1255 : 	else if (m_userMax != 0 && m_max != m_userMax)

  0008f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00092	85 c0		 test	 eax, eax
  00094	0f 84 99 00 00
	00		 je	 $LN5@IsMax
  0009a	3b c8		 cmp	 ecx, eax
  0009c	0f 84 91 00 00
	00		 je	 $LN5@IsMax

; 1256 : 	{
; 1257 : 		std::wstring str = GetTextTagOutputString(m_wText, ms_lastpos);

  000a2	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  000a8	8d 45 c0	 lea	 eax, DWORD PTR _str$2[ebp]
  000ab	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z ; GetTextTagOutputString

; 1258 : 		std::wstring input = GetTextTagOutputString(wInput, len);

  000b6	57		 push	 edi
  000b7	ff 75 bc	 push	 DWORD PTR _wInput$GSCopy$1$[ebp]
  000ba	8d 45 d8	 lea	 eax, DWORD PTR _input$3[ebp]
  000bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z ; GetTextTagOutputString

; 1259 : 		int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, str.c_str(), str.length(), 0, 0, NULL, NULL);

  000ca	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WideCharToMultiByte@32
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  000d0	8d 45 c0	 lea	 eax, DWORD PTR _str$2[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1258 : 		std::wstring input = GetTextTagOutputString(wInput, len);

  000d3	83 c4 18	 add	 esp, 24			; 00000018H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000d6	83 7d d4 07	 cmp	 DWORD PTR _str$2[ebp+20], 7

; 426  :         if (_Large_mode_engaged()) {

  000da	0f 47 45 c0	 cmova	 eax, DWORD PTR _str$2[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1259 : 		int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, str.c_str(), str.length(), 0, 0, NULL, NULL);

  000de	6a 00		 push	 0
  000e0	6a 00		 push	 0
  000e2	6a 00		 push	 0
  000e4	6a 00		 push	 0
  000e6	ff 75 d0	 push	 DWORD PTR _str$2[ebp+16]
  000e9	50		 push	 eax
  000ea	6a 00		 push	 0
  000ec	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  000f2	ff d7		 call	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000f4	83 7d ec 07	 cmp	 DWORD PTR _input$3[ebp+20], 7

; 425  :         const value_type* _Result = _Bx._Buf;

  000f8	8d 4d d8	 lea	 ecx, DWORD PTR _input$3[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1260 : 		int inputLen = WideCharToMultiByte(ms_uOutputCodePage, 0, input.c_str(), input.length(), 0, 0, NULL, NULL);

  000fb	6a 00		 push	 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  000fd	0f 47 4d d8	 cmova	 ecx, DWORD PTR _input$3[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1259 : 		int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, str.c_str(), str.length(), 0, 0, NULL, NULL);

  00101	8b f0		 mov	 esi, eax

; 1260 : 		int inputLen = WideCharToMultiByte(ms_uOutputCodePage, 0, input.c_str(), input.length(), 0, 0, NULL, NULL);

  00103	6a 00		 push	 0
  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	ff 75 e8	 push	 DWORD PTR _input$3[ebp+16]
  0010c	51		 push	 ecx
  0010d	6a 00		 push	 0
  0010f	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00115	ff d7		 call	 edi

; 1261 : 		return textLen + inputLen > m_userMax;

  00117	03 c6		 add	 eax, esi
  00119	8d 4d d8	 lea	 ecx, DWORD PTR _input$3[ebp]
  0011c	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0011f	0f 9f c3	 setg	 bl
  00122	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00127	8d 4d c0	 lea	 ecx, DWORD PTR _str$2[ebp]
  0012a	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0012f	8a c3		 mov	 al, bl
  00131	eb 06		 jmp	 SHORT $LN1@IsMax
$LN5@IsMax:

; 1262 : 	}
; 1263 : 	return false;

  00133	32 c0		 xor	 al, al
  00135	eb 02		 jmp	 SHORT $LN1@IsMax
$LN29@IsMax:

; 1254 : 		return true;

  00137	b0 01		 mov	 al, 1
$LN1@IsMax:

; 1264 : }

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014a	33 cd		 xor	 ecx, ebp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsMax@CIME@@IAE_NPB_WH@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _str$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?IsMax@CIME@@IAE_NPB_WH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?IsMax@CIME@@IAE_NPB_WH@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?IsMax@CIME@@IAE_NPB_WH@Z ENDP				; CIME::IsMax
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_this$1$ = -180						; size = 4
_hImc$GSCopy$1$ = -176					; size = 4
_dwErr$ = -172						; size = 4
$T1 = -168						; size = 4
_uMaxUiLen$2 = -164					; size = 4
_tempLen$1$ = -164					; size = 4
_bUnicodeIme$1$ = -157					; size = 1
_bVertical$3 = -156					; size = 4
_temp$1$ = -156						; size = 4
_nTcharSize$1$ = -156					; size = 4
_osi$4 = -152						; size = 148
__$ArrayPad$ = -4					; size = 4
_hImc$ = 8						; size = 4
?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::ReadingProcess, COMDAT
; _this$ = ecx

; 1100 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b4 00 00
	00		 sub	 esp, 180		; 000000b4H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1101 :     if (!ms_adwId[0])

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_adwId@CIME@@2PAKA, 0
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _this$1$[ebp], ecx
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _hImc$[ebp]
  00025	57		 push	 edi
  00026	89 8d 50 ff ff
	ff		 mov	 DWORD PTR _hImc$GSCopy$1$[ebp], ecx
  0002c	0f 84 92 03 00
	00		 je	 $LN33@ReadingPro

; 1102 : 	{
; 1103 : 		return;
; 1104 :     }
; 1105 : 
; 1106 :     DWORD dwErr = 0;
; 1107 : 
; 1108 :     if (_GetReadingString)

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA ; CIME::_GetReadingString
  00037	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwErr$[ebp], 0
  00041	85 c0		 test	 eax, eax
  00043	0f 84 84 00 00
	00		 je	 $LN5@ReadingPro

; 1109 : 	{
; 1110 :         UINT uMaxUiLen;
; 1111 :         BOOL bVertical;
; 1112 :         // Obtain the reading string size
; 1113 :         int wstrLen = _GetReadingString(hImc, 0, NULL, (PINT)&dwErr, &bVertical, &uMaxUiLen);

  00049	8d 95 5c ff ff
	ff		 lea	 edx, DWORD PTR _uMaxUiLen$2[ebp]
  0004f	52		 push	 edx
  00050	8d 95 64 ff ff
	ff		 lea	 edx, DWORD PTR _bVertical$3[ebp]
  00056	52		 push	 edx
  00057	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR _dwErr$[ebp]
  0005d	52		 push	 edx
  0005e	6a 00		 push	 0
  00060	6a 00		 push	 0
  00062	51		 push	 ecx
  00063	ff d0		 call	 eax
  00065	8b d8		 mov	 ebx, eax

; 1114 : 
; 1115 : 		if(wstrLen == 0) {

  00067	85 db		 test	 ebx, ebx
  00069	75 19		 jne	 SHORT $LN7@ReadingPro

; 1116 : 			ms_wstrReading.resize(0);

  0006b	50		 push	 eax
  0006c	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  00071	e8 00 00 00 00	 call	 ?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::resize

; 1123 : 		ms_bHorizontalReading = (bVertical == 0);

  00076	39 9d 64 ff ff
	ff		 cmp	 DWORD PTR _bVertical$3[ebp], ebx
  0007c	0f 94 c0	 sete	 al

; 1124 : 
; 1125 :     } else {

  0007f	e9 c6 00 00 00	 jmp	 $LN6@ReadingPro
$LN7@ReadingPro:

; 1117 : 		} else {
; 1118 : 			wchar_t *wstr = (wchar_t*)alloca(sizeof(wchar_t) * wstrLen);

  00084	8d 3c 1b	 lea	 edi, DWORD PTR [ebx+ebx]
  00087	8b c7		 mov	 eax, edi
  00089	e8 00 00 00 00	 call	 __alloca_probe_16
  0008e	8b f4		 mov	 esi, esp

; 1119 :             _GetReadingString(hImc, wstrLen, wstr, (PINT)&dwErr, &bVertical, &uMaxUiLen);

  00090	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _uMaxUiLen$2[ebp]
  00096	50		 push	 eax
  00097	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _bVertical$3[ebp]
  0009d	50		 push	 eax
  0009e	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR _dwErr$[ebp]
  000a4	50		 push	 eax
  000a5	56		 push	 esi
  000a6	53		 push	 ebx
  000a7	ff b5 50 ff ff
	ff		 push	 DWORD PTR _hImc$GSCopy$1$[ebp]
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA ; CIME::_GetReadingString
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 1692 :         return _Last - _First; // assume the iterator will do debug checking

  000b3	d1 ff		 sar	 edi, 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1476 :             _Assign_counted_range(_UFirst, _Count);

  000b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  000ba	57		 push	 edi
  000bb	56		 push	 esi
  000bc	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_WI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_counted_range<wchar_t *>
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1123 : 		ms_bHorizontalReading = (bVertical == 0);

  000c1	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _bVertical$3[ebp], 0
  000c8	0f 94 c0	 sete	 al

; 1124 : 
; 1125 :     } else {

  000cb	eb 7d		 jmp	 SHORT $LN6@ReadingPro
$LN5@ReadingPro:

; 1126 : 
; 1127 :         // IMEs that doesn't implement Reading String API
; 1128 : 		wchar_t* temp = NULL;
; 1129 : 		DWORD tempLen = 0;
; 1130 : 	    bool bUnicodeIme = false;
; 1131 : 		INPUTCONTEXT *lpIC = _ImmLockIMC(hImc);

  000cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA ; CIME::_ImmLockIMC
  000d2	51		 push	 ecx
  000d3	ff d0		 call	 eax
  000d5	8b f8		 mov	 edi, eax

; 1132 : 
; 1133 : 		if (lpIC == NULL)

  000d7	85 ff		 test	 edi, edi
  000d9	74 3e		 je	 SHORT $LN54@ReadingPro

; 1134 : 		{
; 1135 : 			temp = NULL;
; 1136 : 			tempLen = 0;
; 1137 : 		}
; 1138 : 		else
; 1139 : 		{
; 1140 : 			LPBYTE p = 0;
; 1141 : 			switch(ms_adwId[0])

  000db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_adwId@CIME@@2PAKA
  000e1	81 f9 04 04 04
	04		 cmp	 ecx, 67372036		; 04040404H
  000e7	0f 87 a1 01 00
	00		 ja	 $LN36@ReadingPro
  000ed	0f 84 63 01 00
	00		 je	 $LN11@ReadingPro
  000f3	81 f9 04 08 02
	04		 cmp	 ecx, 67241988		; 04020804H
  000f9	0f 87 4b 01 00
	00		 ja	 $LN37@ReadingPro
  000ff	0f 84 d1 00 00
	00		 je	 $LN25@ReadingPro
  00105	81 f9 04 08 01
	04		 cmp	 ecx, 67176452		; 04010804H
  0010b	74 77		 je	 SHORT $LN23@ReadingPro
  0010d	81 f9 04 04 02
	04		 cmp	 ecx, 67240964		; 04020404H
  00113	0f 84 3d 01 00
	00		 je	 $LN11@ReadingPro
$LN54@ReadingPro:

; 1218 : 			ms_wstrReading.resize(0);

  00119	6a 00		 push	 0
  0011b	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  00120	e8 00 00 00 00	 call	 ?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::resize
  00125	8d 87 24 01 00
	00		 lea	 eax, DWORD PTR [edi+292]
$LN31@ReadingPro:

; 1226 : 				ms_wstrReading.assign(wstr, wstr+wstrLen);
; 1227 : 			}
; 1228 : 		}
; 1229 : 
; 1230 : 		_ImmUnlockIMCC(lpIC->hPrivate);

  0012b	ff 30		 push	 DWORD PTR [eax]
  0012d	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA ; CIME::_ImmUnlockIMCC

; 1231 : 		_ImmUnlockIMC(hImc);

  00133	ff b5 50 ff ff
	ff		 push	 DWORD PTR _hImc$GSCopy$1$[ebp]
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA ; CIME::_ImmUnlockIMC

; 1232 : 
; 1233 : 		ms_bHorizontalReading = GetReadingWindowOrientation();

  0013f	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$1$[ebp]
  00145	e8 00 00 00 00	 call	 ?GetReadingWindowOrientation@CIME@@IAE_NXZ ; CIME::GetReadingWindowOrientation
$LN6@ReadingPro:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0014a	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bHorizontalReading@CIME@@2_NA, al ; CIME::ms_bHorizontalReading
  0014f	a1 04 00 00 00	 mov	 eax, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+4
  00154	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1235 : 	if (ms_wstrReading.size()) {

  0015a	a9 fe ff ff ff	 test	 eax, -2			; fffffffeH
  0015f	0f 84 5a 02 00
	00		 je	 $LN32@ReadingPro

; 1236 : 		ms_bReadingInformation = true;
; 1237 : 		if(ms_pEvent)

  00165	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0016b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 1 ; CIME::ms_bReadingInformation
  00172	85 c9		 test	 ecx, ecx
  00174	0f 84 4a 02 00
	00		 je	 $LN33@ReadingPro

; 1238 : 			ms_pEvent->OnOpenReadingWnd();

  0017a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0017c	ff 50 14	 call	 DWORD PTR [eax+20]

; 1239 : 	} else {

  0017f	e9 40 02 00 00	 jmp	 $LN33@ReadingPro
$LN23@ReadingPro:

; 1176 : 					break;
; 1177 : 
; 1178 : 				// the code tested only with Win 98 SE (MSPY 1.5/ ver 4.1.0.21)
; 1179 : 				case IMEID_CHS_VER41:
; 1180 : 					{
; 1181 : 						int nOffset;
; 1182 : 						nOffset = (ms_adwId[1] >= 0x00000002) ? 8 : 7;

  00184	83 3d 04 00 00
	00 02		 cmp	 DWORD PTR ?ms_adwId@CIME@@2PAKA+4, 2

; 1183 : 
; 1184 : 						p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + nOffset * 4);

  0018b	8d 9f 24 01 00
	00		 lea	 ebx, DWORD PTR [edi+292]
  00191	ff 33		 push	 DWORD PTR [ebx]
  00193	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  00198	1b f6		 sbb	 esi, esi
  0019a	89 9d 58 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ebx
  001a0	ff d0		 call	 eax
  001a2	8b 5c b0 20	 mov	 ebx, DWORD PTR [eax+esi*4+32]

; 1185 : 						if(!p) break;

  001a6	85 db		 test	 ebx, ebx
  001a8	0f 84 6b ff ff
	ff		 je	 $LN54@ReadingPro

; 1186 : 						tempLen = *(DWORD *)(p + 7*4 + 16*2*4);
; 1187 : 						dwErr = *(DWORD *)(p + 8*4 + 16*2*4);

  001ae	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
  001b4	8b 8b 9c 00 00
	00		 mov	 ecx, DWORD PTR [ebx+156]

; 1188 : 						dwErr = min(dwErr, tempLen);
; 1189 : 						temp = (wchar_t *)(p + 6*4 + 16*2*1);

  001ba	83 c3 38	 add	 ebx, 56			; 00000038H
  001bd	3b c1		 cmp	 eax, ecx

; 1190 : 						bUnicodeIme = true;

  001bf	c6 85 63 ff ff
	ff 01		 mov	 BYTE PTR _bUnicodeIme$1$[ebp], 1
  001c6	8b d1		 mov	 edx, ecx
  001c8	0f 42 d0	 cmovb	 edx, eax

; 1191 : 					}
; 1192 : 					break;

  001cb	8a 85 63 ff ff
	ff		 mov	 al, BYTE PTR _bUnicodeIme$1$[ebp]
  001d1	e9 59 01 00 00	 jmp	 $LN55@ReadingPro
$LN25@ReadingPro:

; 1193 : 
; 1194 : 				case IMEID_CHS_VER42: // 4.2.x.x // SCIME98 or MSPY2 (w/Office2k, Win2k, WinME, etc)
; 1195 : 					{
; 1196 : 						OSVERSIONINFOA osi;
; 1197 : 						osi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
; 1198 : 						GetVersionExA(&osi);

  001d6	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _osi$4[ebp]
  001dc	c7 85 68 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _osi$4[ebp], 148 ; 00000094H
  001e6	50		 push	 eax
  001e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 1199 : 
; 1200 : 						int nTcharSize = (osi.dwPlatformId == VER_PLATFORM_WIN32_NT) ? sizeof(wchar_t) : sizeof(char);
; 1201 : 						p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 1*4 + 1*4 + 6*4);

  001ed	ff b7 24 01 00
	00		 push	 DWORD PTR [edi+292]
  001f3	33 c0		 xor	 eax, eax
  001f5	8d 9f 24 01 00
	00		 lea	 ebx, DWORD PTR [edi+292]
  001fb	83 bd 78 ff ff
	ff 02		 cmp	 DWORD PTR _osi$4[ebp+16], 2
  00202	89 9d 58 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ebx
  00208	0f 94 c0	 sete	 al
  0020b	40		 inc	 eax
  0020c	89 85 64 ff ff
	ff		 mov	 DWORD PTR _nTcharSize$1$[ebp], eax
  00212	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  00217	ff d0		 call	 eax
  00219	8b 70 20	 mov	 esi, DWORD PTR [eax+32]

; 1202 : 						if(!p) break;

  0021c	85 f6		 test	 esi, esi
  0021e	0f 84 f5 fe ff
	ff		 je	 $LN54@ReadingPro

; 1203 : 						tempLen = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * nTcharSize);

  00224	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR _nTcharSize$1$[ebp]

; 1204 : 						dwErr = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * nTcharSize + 1*4);
; 1205 : 						temp  = (wchar_t *) (p + 1*4 + (16*2+2*4) + 5*4);

  0022a	8d 5e 40	 lea	 ebx, DWORD PTR [esi+64]
  0022d	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  00230	03 c0		 add	 eax, eax

; 1206 : 						bUnicodeIme = (osi.dwPlatformId == VER_PLATFORM_WIN32_NT) ? true : false;

  00232	83 bd 78 ff ff
	ff 02		 cmp	 DWORD PTR _osi$4[ebp+16], 2
  00239	8b 0c c6	 mov	 ecx, DWORD PTR [esi+eax*8]
  0023c	0f 94 c0	 sete	 al
  0023f	03 d2		 add	 edx, edx
  00241	8b 54 d6 44	 mov	 edx, DWORD PTR [esi+edx*8+68]

; 1207 : 					}
; 1208 : 					break;

  00245	e9 e5 00 00 00	 jmp	 $LN55@ReadingPro
$LN37@ReadingPro:

; 1134 : 		{
; 1135 : 			temp = NULL;
; 1136 : 			tempLen = 0;
; 1137 : 		}
; 1138 : 		else
; 1139 : 		{
; 1140 : 			LPBYTE p = 0;
; 1141 : 			switch(ms_adwId[0])

  0024a	81 f9 04 04 03
	04		 cmp	 ecx, 67306500		; 04030404H
  00250	0f 85 c3 fe ff
	ff		 jne	 $LN54@ReadingPro
$LN11@ReadingPro:

; 1142 : 			{
; 1143 : 				case IMEID_CHT_VER42: // New(Phonetic/ChanJie)IME98  : 4.2.x.x // Win98
; 1144 : 				case IMEID_CHT_VER43: // New(Phonetic/ChanJie)IME98a : 4.3.x.x // WinMe, Win2k
; 1145 : 				case IMEID_CHT_VER44: // New ChanJie IME98b          : 4.4.x.x // WinXP
; 1146 : 					p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 24);

  00256	ff b7 24 01 00
	00		 push	 DWORD PTR [edi+292]
  0025c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  00261	8d 9f 24 01 00
	00		 lea	 ebx, DWORD PTR [edi+292]
  00267	89 9d 58 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ebx
  0026d	ff d0		 call	 eax
  0026f	8b 50 18	 mov	 edx, DWORD PTR [eax+24]

; 1147 : 					if (!p) break;

  00272	85 d2		 test	 edx, edx
  00274	0f 84 9f fe ff
	ff		 je	 $LN54@ReadingPro

; 1148 : 					tempLen = *(DWORD *)(p + 7 * 4 + 32 * 4);

  0027a	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [edx+156]

; 1149 : 					dwErr = *(DWORD *)(p + 8 * 4 + 32 * 4);
; 1150 : 					temp = (wchar_t *)(p + 56);

  00280	8d 5a 38	 lea	 ebx, DWORD PTR [edx+56]

; 1151 : 					bUnicodeIme = true;

  00283	8b 92 a0 00 00
	00		 mov	 edx, DWORD PTR [edx+160]

; 1152 : 					break;

  00289	e9 9f 00 00 00	 jmp	 $LN56@ReadingPro
$LN36@ReadingPro:

; 1134 : 		{
; 1135 : 			temp = NULL;
; 1136 : 			tempLen = 0;
; 1137 : 		}
; 1138 : 		else
; 1139 : 		{
; 1140 : 			LPBYTE p = 0;
; 1141 : 			switch(ms_adwId[0])

  0028e	81 f9 04 04 02
	05		 cmp	 ecx, 84018180		; 05020404H
  00294	77 53		 ja	 SHORT $LN38@ReadingPro
  00296	74 5d		 je	 SHORT $LN18@ReadingPro
  00298	81 f9 04 04 00
	05		 cmp	 ecx, 83887108		; 05000404H
  0029e	74 0d		 je	 SHORT $LN15@ReadingPro
  002a0	81 f9 04 04 01
	05		 cmp	 ecx, 83952644		; 05010404H
  002a6	74 4d		 je	 SHORT $LN18@ReadingPro
  002a8	e9 6c fe ff ff	 jmp	 $LN54@ReadingPro
$LN15@ReadingPro:

; 1153 : 
; 1154 : 				case IMEID_CHT_VER50: // 5.0.x.x // WinME
; 1155 : 					p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 3 * 4);

  002ad	ff b7 24 01 00
	00		 push	 DWORD PTR [edi+292]
  002b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  002b8	8d 9f 24 01 00
	00		 lea	 ebx, DWORD PTR [edi+292]
  002be	89 9d 58 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ebx
  002c4	ff d0		 call	 eax
  002c6	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]

; 1156 : 					if(!p) break;

  002c9	85 d2		 test	 edx, edx
  002cb	0f 84 48 fe ff
	ff		 je	 $LN54@ReadingPro

; 1157 : 					p = *(LPBYTE *)((LPBYTE)p + 1*4 + 5*4 + 4*2);

  002d1	8b 52 20	 mov	 edx, DWORD PTR [edx+32]

; 1158 : 					if(!p) break;

  002d4	85 d2		 test	 edx, edx
  002d6	0f 84 3d fe ff
	ff		 je	 $LN54@ReadingPro

; 1159 : 					tempLen = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16);

  002dc	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]

; 1160 : 					dwErr = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 + 1*4);
; 1161 : 					temp = (wchar_t *)(p + 1*4 + (16*2+2*4) + 5*4);

  002df	8d 5a 40	 lea	 ebx, DWORD PTR [edx+64]

; 1162 : 					bUnicodeIme = false;

  002e2	8b 52 54	 mov	 edx, DWORD PTR [edx+84]
  002e5	32 c0		 xor	 al, al

; 1163 : 					break;

  002e7	eb 46		 jmp	 SHORT $LN55@ReadingPro
$LN38@ReadingPro:

; 1134 : 		{
; 1135 : 			temp = NULL;
; 1136 : 			tempLen = 0;
; 1137 : 		}
; 1138 : 		else
; 1139 : 		{
; 1140 : 			LPBYTE p = 0;
; 1141 : 			switch(ms_adwId[0])

  002e9	81 f9 04 08 03
	05		 cmp	 ecx, 84084740		; 05030804H
  002ef	0f 85 24 fe ff
	ff		 jne	 $LN54@ReadingPro
$LN18@ReadingPro:

; 1164 : 
; 1165 : 				case IMEID_CHT_VER51: // 5.1.x.x // IME2002(w/OfficeXP)
; 1166 : 				case IMEID_CHT_VER52: // 5.2.x.x // (w/whistler)
; 1167 : 				case IMEID_CHS_VER53: // 5.3.x.x // SCIME2k or MSPY3 (w/OfficeXP and Whistler)
; 1168 : 					p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 4);

  002f5	ff b7 24 01 00
	00		 push	 DWORD PTR [edi+292]
  002fb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  00300	8d 8f 24 01 00
	00		 lea	 ecx, DWORD PTR [edi+292]
  00306	89 8d 58 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  0030c	ff d0		 call	 eax
  0030e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1169 : 					if(!p) break;

  00311	85 d2		 test	 edx, edx
  00313	0f 84 00 fe ff
	ff		 je	 $LN54@ReadingPro

; 1170 : 					p = *(LPBYTE *)((LPBYTE)p + 1*4 + 5*4);

  00319	8b 52 18	 mov	 edx, DWORD PTR [edx+24]

; 1171 : 					if(!p) break;

  0031c	85 d2		 test	 edx, edx
  0031e	0f 84 f5 fd ff
	ff		 je	 $LN54@ReadingPro

; 1172 : 					tempLen = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * 2);

  00324	8b 4a 60	 mov	 ecx, DWORD PTR [edx+96]

; 1173 : 					dwErr = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * 2 + 1*4);
; 1174 : 					temp  = (wchar_t *) (p + 1*4 + (16*2+2*4) + 5*4);

  00327	8d 5a 40	 lea	 ebx, DWORD PTR [edx+64]

; 1175 : 					bUnicodeIme = true;

  0032a	8b 52 64	 mov	 edx, DWORD PTR [edx+100]
$LN56@ReadingPro:

; 1209 : 
; 1210 : 				default:
; 1211 : 					temp = NULL;
; 1212 : 					tempLen = 0;
; 1213 : 					break;
; 1214 : 			}
; 1215 : 		}
; 1216 : 
; 1217 : 		if(tempLen == 0) {

  0032d	b0 01		 mov	 al, 1
$LN55@ReadingPro:
  0032f	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _tempLen$1$[ebp], ecx
  00335	89 9d 64 ff ff
	ff		 mov	 DWORD PTR _temp$1$[ebp], ebx
  0033b	89 95 54 ff ff
	ff		 mov	 DWORD PTR _dwErr$[ebp], edx
  00341	85 c9		 test	 ecx, ecx
  00343	0f 84 d0 fd ff
	ff		 je	 $LN54@ReadingPro

; 1219 : 		} else {
; 1220 : 			if(bUnicodeIme) {

  00349	84 c0		 test	 al, al
  0034b	74 1c		 je	 SHORT $LN30@ReadingPro

; 1221 : 				ms_wstrReading.assign(temp, temp+tempLen);

  0034d	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1476 :             _Assign_counted_range(_UFirst, _Count);

  00350	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 1692 :         return _Last - _First; // assume the iterator will do debug checking

  00355	d1 f8		 sar	 eax, 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1476 :             _Assign_counted_range(_UFirst, _Count);

  00357	50		 push	 eax
  00358	53		 push	 ebx
  00359	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_WI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_counted_range<wchar_t *>
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1222 : 			} else {

  0035e	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00364	e9 c2 fd ff ff	 jmp	 $LN31@ReadingPro
$LN30@ReadingPro:

; 1223 : 				int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, (char*)temp, tempLen, NULL, 0);

  00369	6a 00		 push	 0
  0036b	6a 00		 push	 0
  0036d	51		 push	 ecx
  0036e	53		 push	 ebx
  0036f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__MultiByteToWideChar@24
  00375	6a 00		 push	 0
  00377	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  0037d	ff d3		 call	 ebx
  0037f	8b f0		 mov	 esi, eax

; 1224 : 				wchar_t* wstr = (wchar_t*)alloca(sizeof(wchar_t)*wstrLen);

  00381	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
  00384	e8 00 00 00 00	 call	 __alloca_probe_16
  00389	8b fc		 mov	 edi, esp

; 1225 : 				MultiByteToWideChar(ms_uInputCodePage, 0, (char*)temp, tempLen, wstr, wstrLen);

  0038b	56		 push	 esi
  0038c	57		 push	 edi
  0038d	ff b5 5c ff ff
	ff		 push	 DWORD PTR _tempLen$1$[ebp]
  00393	ff b5 64 ff ff
	ff		 push	 DWORD PTR _temp$1$[ebp]
  00399	6a 00		 push	 0
  0039b	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  003a1	ff d3		 call	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 1692 :         return _Last - _First; // assume the iterator will do debug checking

  003a3	8d 04 36	 lea	 eax, DWORD PTR [esi+esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1476 :             _Assign_counted_range(_UFirst, _Count);

  003a6	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 1692 :         return _Last - _First; // assume the iterator will do debug checking

  003ab	d1 f8		 sar	 eax, 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1476 :             _Assign_counted_range(_UFirst, _Count);

  003ad	50		 push	 eax
  003ae	57		 push	 edi
  003af	e8 00 00 00 00	 call	 ??$_Assign_counted_range@PA_W@?$vector@_WV?$allocator@_W@std@@@std@@AAEXPA_WI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Assign_counted_range<wchar_t *>
  003b4	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  003ba	e9 6c fd ff ff	 jmp	 $LN31@ReadingPro
$LN32@ReadingPro:
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1240 : 		CloseReadingInformation();

  003bf	e8 00 00 00 00	 call	 ?CloseReadingInformation@CIME@@SAXXZ ; CIME::CloseReadingInformation
$LN33@ReadingPro:

; 1241 : 	}
; 1242 : }

  003c4	8d a5 40 ff ff
	ff		 lea	 esp, DWORD PTR [ebp-192]
  003ca	5f		 pop	 edi
  003cb	5e		 pop	 esi
  003cc	5b		 pop	 ebx
  003cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d0	33 cd		 xor	 ecx, ebp
  003d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003d7	8b e5		 mov	 esp, ebp
  003d9	5d		 pop	 ebp
  003da	c2 04 00	 ret	 4
?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::ReadingProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_abyCandidate$ = -36					; size = 12
_this$1$ = -24						; size = 4
tv1054 = -20						; size = 4
tv1069 = -20						; size = 4
_j$1$ = -16						; size = 4
__Oldsize$1$ = -16					; size = 4
tv1055 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hImc$ = 8						; size = 4
_cChars$1$ = 8						; size = 4
tv1051 = 8						; size = 4
?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::CandidateProcess, COMDAT
; _this$ = ecx

; 1042 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d e8	 mov	 DWORD PTR _this$1$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _abyCandidate$[ebp], 0
  00032	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _abyCandidate$[ebp+4], 0
  00039	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _abyCandidate$[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1044 : 	DWORD dwCandidateLen = ImmGetCandidateListW(hImc, 0, NULL, 0);

  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00049	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00050	e8 00 00 00 00	 call	 _ImmGetCandidateListW@16
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00055	8b 55 e0	 mov	 edx, DWORD PTR _abyCandidate$[ebp+4]
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1044 : 	DWORD dwCandidateLen = ImmGetCandidateListW(hImc, 0, NULL, 0);

  00058	8b f8		 mov	 edi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0005a	8b 75 dc	 mov	 esi, DWORD PTR _abyCandidate$[ebp]
  0005d	8b da		 mov	 ebx, edx
  0005f	2b de		 sub	 ebx, esi
  00061	89 5d f0	 mov	 DWORD PTR __Oldsize$1$[ebp], ebx

; 1581 :         if (_Newsize < _Oldsize) { // trim

  00064	3b fb		 cmp	 edi, ebx
  00066	73 0b		 jae	 SHORT $LN35@CandidateP

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  00068	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);
; 1585 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1586 :             _Mylast = _Newlast;

  0006b	89 4d e0	 mov	 DWORD PTR _abyCandidate$[ebp+4], ecx

; 1587 :             return;

  0006e	e9 e0 00 00 00	 jmp	 $LN193@CandidateP
$LN35@CandidateP:

; 1590 :         if (_Newsize > _Oldsize) { // append

  00073	0f 86 da 00 00
	00		 jbe	 $LN193@CandidateP

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00079	8b 4d e4	 mov	 ecx, DWORD PTR _abyCandidate$[ebp+8]
  0007c	2b ce		 sub	 ecx, esi

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  0007e	3b f9		 cmp	 edi, ecx
  00080	0f 86 b7 00 00
	00		 jbe	 $LN37@CandidateP

; 1538 :         if (_Newsize > max_size()) {

  00086	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  0008c	0f 87 9a 02 00
	00		 ja	 $LN203@CandidateP

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00092	8b d1		 mov	 edx, ecx
  00094	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00099	d1 ea		 shr	 edx, 1
  0009b	2b c2		 sub	 eax, edx
  0009d	3b c8		 cmp	 ecx, eax
  0009f	76 0d		 jbe	 SHORT $LN44@CandidateP

; 1997 :             return _Max; // geometric growth would overflow

  000a1	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a6	53		 push	 ebx
  000a7	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ac	eb 27		 jmp	 SHORT $LN201@CandidateP
$LN44@CandidateP:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000ae	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  000b1	3b df		 cmp	 ebx, edi
  000b3	0f 42 df	 cmovb	 ebx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  000b6	8b c3		 mov	 eax, ebx
  000b8	85 db		 test	 ebx, ebx
  000ba	75 04		 jne	 SHORT $LN55@CandidateP

; 228  :         return nullptr;

  000bc	33 f6		 xor	 esi, esi
  000be	eb 1a		 jmp	 SHORT $LN54@CandidateP
$LN55@CandidateP:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000c0	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000c5	72 08		 jb	 SHORT $LN56@CandidateP

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c7	53		 push	 ebx
  000c8	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000cd	eb 06		 jmp	 SHORT $LN201@CandidateP
$LN56@CandidateP:

; 136  :         return ::operator new(_Bytes);

  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN201@CandidateP:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000d5	8b f0		 mov	 esi, eax
  000d7	83 c4 04	 add	 esp, 4
$LN54@CandidateP:
  000da	8b 45 f0	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  000dd	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000e0	03 c6		 add	 eax, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  000e2	51		 push	 ecx
  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000e9	56		 push	 esi
  000ea	ff 75 e0	 push	 DWORD PTR _abyCandidate$[ebp+4]
  000ed	ff 75 dc	 push	 DWORD PTR _abyCandidate$[ebp]
  000f0	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ; std::_Copy_memmove<unsigned char *,unsigned char *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000f5	8b 55 dc	 mov	 edx, DWORD PTR _abyCandidate$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000f8	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000fb	85 d2		 test	 edx, edx
  000fd	74 2d		 je	 SHORT $LN93@CandidateP

; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000ff	8b 4d e4	 mov	 ecx, DWORD PTR _abyCandidate$[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00102	8b c2		 mov	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00104	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00106	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0010c	72 14		 jb	 SHORT $LN104@CandidateP

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0010e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00111	83 c1 23	 add	 ecx, 35			; 00000023H
  00114	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00116	83 c0 fc	 add	 eax, -4			; fffffffcH
  00119	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0011c	0f 87 0f 02 00
	00		 ja	 $LN172@CandidateP
$LN104@CandidateP:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00122	51		 push	 ecx
  00123	52		 push	 edx
  00124	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00129	83 c4 08	 add	 esp, 8
$LN93@CandidateP:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0012c	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0012f	89 75 dc	 mov	 DWORD PTR _abyCandidate$[ebp], esi
  00132	89 45 e0	 mov	 DWORD PTR _abyCandidate$[ebp+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00135	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00138	89 45 e4	 mov	 DWORD PTR _abyCandidate$[ebp+8], eax

; 1594 :                 return;

  0013b	eb 16		 jmp	 SHORT $LN193@CandidateP
$LN37@CandidateP:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  0013d	8b f2		 mov	 esi, edx
  0013f	2b f3		 sub	 esi, ebx
  00141	03 f7		 add	 esi, edi
  00143	56		 push	 esi
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  0014a	89 75 e0	 mov	 DWORD PTR _abyCandidate$[ebp+4], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);

  0014d	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1590 :         if (_Newsize > _Oldsize) { // append

  00150	8b 75 dc	 mov	 esi, DWORD PTR _abyCandidate$[ebp]
$LN193@CandidateP:
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1046 : 	if(dwCandidateLen > 0) {

  00153	85 ff		 test	 edi, edi
  00155	0f 84 90 01 00
	00		 je	 $LN14@CandidateP

; 1047 : 		ms_bCandidateList = true;
; 1048 : 
; 1049 : 		CANDIDATELIST* lpCandidateList = (CANDIDATELIST*)(&abyCandidate[0]);
; 1050 : 		dwCandidateLen = ImmGetCandidateListW(hImc, 0, lpCandidateList, dwCandidateLen);

  0015b	57		 push	 edi
  0015c	56		 push	 esi
  0015d	6a 00		 push	 0
  0015f	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00162	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 1 ; CIME::ms_bCandidateList
  00169	e8 00 00 00 00	 call	 _ImmGetCandidateListW@16

; 1051 : 
; 1052 : 		ms_dwCandidateSelection	= lpCandidateList->dwSelection;

  0016e	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 1053 : 		ms_dwCandidateCount		= lpCandidateList->dwCount;
; 1054 : 
; 1055 : 		int iStartOfPage = 0;

  00171	33 db		 xor	 ebx, ebx
  00173	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection

; 1056 : 
; 1057 : 		if( GETLANG() == LANG_CHS ) {

  00178	b8 04 08 00 00	 mov	 eax, 2052		; 00000804H
  0017d	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00180	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, ecx ; CIME::ms_dwCandidateCount
  00186	66 39 05 00 00
	00 00		 cmp	 WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, ax
  0018d	75 53		 jne	 SHORT $LN9@CandidateP

; 1058 : 			// MSPY (CHS IME) has variable number of candidates in candidate window find where current page starts, and the size of current page
; 1059 : 			const int maxCandChar = 18 * (3 - sizeof(TCHAR));
; 1060 : 			UINT cChars = 0;

  0018f	33 c0		 xor	 eax, eax

; 1061 : 			UINT i;
; 1062 : 			for (i = 0; i < ms_dwCandidateCount; i++)

  00191	33 ff		 xor	 edi, edi
  00193	89 45 08	 mov	 DWORD PTR _cChars$1$[ebp], eax
  00196	85 c9		 test	 ecx, ecx
  00198	74 3e		 je	 SHORT $LN194@CandidateP

; 1058 : 			// MSPY (CHS IME) has variable number of candidates in candidate window find where current page starts, and the size of current page
; 1059 : 			const int maxCandChar = 18 * (3 - sizeof(TCHAR));
; 1060 : 			UINT cChars = 0;

  0019a	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0019d	89 45 f0	 mov	 DWORD PTR tv1055[ebp], eax
$LL4@CandidateP:

; 1063 : 			{
; 1064 : 				UINT uLen = lstrlenW((LPWSTR)((DWORD)lpCandidateList + lpCandidateList->dwOffset[i])) + (3 - sizeof(WCHAR));

  001a0	8b 00		 mov	 eax, DWORD PTR [eax]
  001a2	03 c6		 add	 eax, esi
  001a4	50		 push	 eax
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4

; 1065 : 				if (uLen + cChars > maxCandChar)

  001ab	8b 4d 08	 mov	 ecx, DWORD PTR _cChars$1$[ebp]
  001ae	40		 inc	 eax
  001af	03 c8		 add	 ecx, eax
  001b1	89 4d 08	 mov	 DWORD PTR _cChars$1$[ebp], ecx
  001b4	83 f9 24	 cmp	 ecx, 36			; 00000024H
  001b7	76 0d		 jbe	 SHORT $LN2@CandidateP

; 1066 : 				{
; 1067 : 					if (i > ms_dwCandidateSelection)

  001b9	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection
  001bf	77 17		 ja	 SHORT $LN194@CandidateP

; 1068 : 					{
; 1069 : 						break;
; 1070 : 					}
; 1071 : 					iStartOfPage = i;

  001c1	8b df		 mov	 ebx, edi

; 1072 : 					cChars = uLen;

  001c3	89 45 08	 mov	 DWORD PTR _cChars$1$[ebp], eax
$LN2@CandidateP:

; 1061 : 			UINT i;
; 1062 : 			for (i = 0; i < ms_dwCandidateCount; i++)

  001c6	8b 45 f0	 mov	 eax, DWORD PTR tv1055[ebp]
  001c9	47		 inc	 edi
  001ca	83 c0 04	 add	 eax, 4
  001cd	89 45 f0	 mov	 DWORD PTR tv1055[ebp], eax
  001d0	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount
  001d6	72 c8		 jb	 SHORT $LL4@CandidateP
$LN194@CandidateP:

; 1073 : 				}
; 1074 : 				else
; 1075 : 				{
; 1076 : 					cChars += uLen;
; 1077 : 				}
; 1078 : 			}
; 1079 : 			ms_dwCandidatePageSize	= i - iStartOfPage;

  001d8	2b fb		 sub	 edi, ebx
  001da	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, edi ; CIME::ms_dwCandidatePageSize

; 1080 : 		} else {

  001e0	eb 32		 jmp	 SHORT $LN18@CandidateP
$LN9@CandidateP:

; 1081 : 			ms_dwCandidatePageSize	= MIN( lpCandidateList->dwPageSize, MAX_CANDLIST );

  001e2	6a 0a		 push	 10			; 0000000aH
  001e4	ff 76 14	 push	 DWORD PTR [esi+20]
  001e7	e8 00 00 00 00	 call	 ?MIN@@YAHHH@Z		; MIN
  001ec	83 c4 08	 add	 esp, 8
  001ef	8b f8		 mov	 edi, eax
  001f1	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, edi ; CIME::ms_dwCandidatePageSize

; 1082 : 			iStartOfPage = ms_bUILessMode ? lpCandidateList->dwPageStart : (ms_dwCandidateSelection / (MAX_CANDLIST - 1)) * (MAX_CANDLIST - 1);

  001f7	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, bl ; CIME::ms_bUILessMode
  001fd	74 05		 je	 SHORT $LN17@CandidateP
  001ff	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  00202	eb 10		 jmp	 SHORT $LN18@CandidateP
$LN17@CandidateP:
  00204	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  00209	f7 25 00 00 00
	00		 mul	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection
  0020f	d1 ea		 shr	 edx, 1
  00211	8d 1c d2	 lea	 ebx, DWORD PTR [edx+edx*8]
$LN18@CandidateP:

; 1083 : 		}
; 1084 : 
; 1085 : 		ms_dwCandidateSelection = ( GETLANG() == LANG_CHS && !GetImeId() ) ? (DWORD)-1 : ms_dwCandidateSelection - iStartOfPage;

  00214	b8 04 08 00 00	 mov	 eax, 2052		; 00000804H
  00219	66 39 05 00 00
	00 00		 cmp	 WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, ax
  00220	75 19		 jne	 SHORT $LN19@CandidateP
  00222	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00225	6a 00		 push	 0
  00227	e8 00 00 00 00	 call	 ?GetImeId@CIME@@IAEKI@Z	; CIME::GetImeId
  0022c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA ; CIME::ms_dwCandidatePageSize
  00232	85 c0		 test	 eax, eax
  00234	75 05		 jne	 SHORT $LN19@CandidateP
  00236	83 c8 ff	 or	 eax, -1
  00239	eb 07		 jmp	 SHORT $LN20@CandidateP
$LN19@CandidateP:
  0023b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection
  00240	2b c3		 sub	 eax, ebx
$LN20@CandidateP:

; 1086 : 
; 1087 : 		//printf( "SEL: %d, START: %d, PAGED: %d\n", ms_dwCandidateSelection, iStartOfPage, ms_dwCandidatePageSize );
; 1088 : 	    memset(&ms_wszCandidate, 0, sizeof(ms_wszCandidate));

  00242	68 00 14 00 00	 push	 5120			; 00001400H
  00247	6a 00		 push	 0
  00249	68 00 00 00 00	 push	 OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  0024e	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection
  00253	e8 00 00 00 00	 call	 _memset

; 1089 : 	    for(UINT i = iStartOfPage, j = 0; (DWORD)i < lpCandidateList->dwCount && j < ms_dwCandidatePageSize; i++, j++) {

  00258	33 c0		 xor	 eax, eax
  0025a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0025d	89 45 f0	 mov	 DWORD PTR _j$1$[ebp], eax
  00260	3b 5e 08	 cmp	 ebx, DWORD PTR [esi+8]
  00263	73 4e		 jae	 SHORT $LN6@CandidateP

; 1086 : 
; 1087 : 		//printf( "SEL: %d, START: %d, PAGED: %d\n", ms_dwCandidateSelection, iStartOfPage, ms_dwCandidatePageSize );
; 1088 : 	    memset(&ms_wszCandidate, 0, sizeof(ms_wszCandidate));

  00265	8d 4b 06	 lea	 ecx, DWORD PTR [ebx+6]
  00268	ba 00 00 00 00	 mov	 edx, OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  0026d	8d 0c 8e	 lea	 ecx, DWORD PTR [esi+ecx*4]
  00270	89 55 ec	 mov	 DWORD PTR tv1054[ebp], edx
  00273	89 4d 08	 mov	 DWORD PTR tv1051[ebp], ecx
$LL7@CandidateP:

; 1089 : 	    for(UINT i = iStartOfPage, j = 0; (DWORD)i < lpCandidateList->dwCount && j < ms_dwCandidatePageSize; i++, j++) {

  00276	3b c7		 cmp	 eax, edi
  00278	73 39		 jae	 SHORT $LN6@CandidateP

; 1090 : 			wcscpy( ms_wszCandidate[j], (LPWSTR)( (DWORD)lpCandidateList + lpCandidateList->dwOffset[i] ) );

  0027a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0027c	03 ce		 add	 ecx, esi
  0027e	66 90		 npad	 2
$LL21@CandidateP:
  00280	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00283	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00286	66 89 02	 mov	 WORD PTR [edx], ax
  00289	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  0028c	66 85 c0	 test	 ax, ax
  0028f	75 ef		 jne	 SHORT $LL21@CandidateP

; 1089 : 	    for(UINT i = iStartOfPage, j = 0; (DWORD)i < lpCandidateList->dwCount && j < ms_dwCandidatePageSize; i++, j++) {

  00291	8b 4d 08	 mov	 ecx, DWORD PTR tv1051[ebp]
  00294	43		 inc	 ebx
  00295	8b 45 f0	 mov	 eax, DWORD PTR _j$1$[ebp]
  00298	83 c1 04	 add	 ecx, 4
  0029b	8b 55 ec	 mov	 edx, DWORD PTR tv1054[ebp]
  0029e	40		 inc	 eax
  0029f	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  002a5	89 4d 08	 mov	 DWORD PTR tv1051[ebp], ecx
  002a8	89 45 f0	 mov	 DWORD PTR _j$1$[ebp], eax
  002ab	89 55 ec	 mov	 DWORD PTR tv1054[ebp], edx
  002ae	3b 5e 08	 cmp	 ebx, DWORD PTR [esi+8]
  002b1	72 c3		 jb	 SHORT $LL7@CandidateP
$LN6@CandidateP:

; 1091 : 	    }
; 1092 : 
; 1093 : 		// don't display selection in candidate list in case of Korean and old Chinese IME.
; 1094 : 		if ( GETPRIMLANG() == LANG_KOREAN || GETLANG() == LANG_CHT && !GetImeId() )

  002b3	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A
  002ba	8b c1		 mov	 eax, ecx
  002bc	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  002c1	83 f8 12	 cmp	 eax, 18			; 00000012H
  002c4	74 18		 je	 SHORT $LN15@CandidateP
  002c6	b8 04 04 00 00	 mov	 eax, 1028		; 00000404H
  002cb	66 3b c8	 cmp	 cx, ax
  002ce	75 18		 jne	 SHORT $LN196@CandidateP
  002d0	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  002d3	6a 00		 push	 0
  002d5	e8 00 00 00 00	 call	 ?GetImeId@CIME@@IAEKI@Z	; CIME::GetImeId
  002da	85 c0		 test	 eax, eax
  002dc	75 0a		 jne	 SHORT $LN196@CandidateP
$LN15@CandidateP:

; 1095 : 			ms_dwCandidateSelection = (DWORD) -1;

  002de	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, -1 ; CIME::ms_dwCandidateSelection
$LN196@CandidateP:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  002e8	8b 75 dc	 mov	 esi, DWORD PTR _abyCandidate$[ebp]
$LN14@CandidateP:
  002eb	85 f6		 test	 esi, esi
  002ed	74 29		 je	 SHORT $LN156@CandidateP

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  002ef	8b 4d e4	 mov	 ecx, DWORD PTR _abyCandidate$[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002f2	8b c6		 mov	 eax, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  002f4	2b ce		 sub	 ecx, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  002f6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  002fc	72 10		 jb	 SHORT $LN175@CandidateP

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002fe	8b 70 fc	 mov	 esi, DWORD PTR [eax-4]
  00301	83 c1 23	 add	 ecx, 35			; 00000023H
  00304	2b c6		 sub	 eax, esi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00306	83 c0 fc	 add	 eax, -4			; fffffffcH
  00309	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0030c	77 23		 ja	 SHORT $LN172@CandidateP
$LN175@CandidateP:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0030e	51		 push	 ecx
  0030f	56		 push	 esi
  00310	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00315	83 c4 08	 add	 esp, 8
$LN156@CandidateP:
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 1097 : }

  00318	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0031b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00322	59		 pop	 ecx
  00323	5f		 pop	 edi
  00324	5e		 pop	 esi
  00325	5b		 pop	 ebx
  00326	8b e5		 mov	 esp, ebp
  00328	5d		 pop	 ebp
  00329	c2 04 00	 ret	 4
$LN203@CandidateP:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1539 :             _Xlength();

  0032c	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN172@CandidateP:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00331	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN200@CandidateP:
  00336	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _abyCandidate$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::CandidateProcess
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_attribute$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_hImc$ = 8						; size = 4
?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::AttributeProcess, COMDAT
; _this$ = ecx

; 1029 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _hImc$[ebp]

; 1030 : 	BYTE	attribute[IMESTR_MAXLEN];
; 1031 : 	LONG	attributeLen = ImmGetCompositionStringW(hImc, GCS_COMPATTR, &attribute, sizeof(attribute)) / sizeof(BYTE);

  00016	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _attribute$[ebp]
  0001c	56		 push	 esi
  0001d	68 00 04 00 00	 push	 1024			; 00000400H
  00022	51		 push	 ecx
  00023	6a 10		 push	 16			; 00000010H
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  0002b	8b f0		 mov	 esi, eax

; 1032 : 
; 1033 : 	int start,end;
; 1034 : 	for(start=0; start<attributeLen; ++start) if(attribute[start]==ATTR_TARGET_CONVERTED || attribute[start]==ATTR_TARGET_NOTCONVERTED) break;

  0002d	33 c9		 xor	 ecx, ecx
  0002f	85 f6		 test	 esi, esi
  00031	7e 16		 jle	 SHORT $LN24@AttributeP
$LL4@AttributeP:
  00033	8a 94 0d fc fb
	ff ff		 mov	 dl, BYTE PTR _attribute$[ebp+ecx]
  0003a	80 fa 01	 cmp	 dl, 1
  0003d	74 0a		 je	 SHORT $LN24@AttributeP
  0003f	80 fa 03	 cmp	 dl, 3
  00042	74 05		 je	 SHORT $LN24@AttributeP
  00044	41		 inc	 ecx
  00045	3b ce		 cmp	 ecx, esi
  00047	7c ea		 jl	 SHORT $LL4@AttributeP
$LN24@AttributeP:

; 1035 : 	for(end=start; end<attributeLen; ++end) if(attribute[end]!=attribute[start]) break;

  00049	8b c1		 mov	 eax, ecx
  0004b	3b ce		 cmp	 ecx, esi
  0004d	7d 15		 jge	 SHORT $LN23@AttributeP
  0004f	8a 94 0d fc fb
	ff ff		 mov	 dl, BYTE PTR _attribute$[ebp+ecx]
$LL7@AttributeP:
  00056	38 94 05 fc fb
	ff ff		 cmp	 BYTE PTR _attribute$[ebp+eax], dl
  0005d	75 05		 jne	 SHORT $LN23@AttributeP
  0005f	40		 inc	 eax
  00060	3b c6		 cmp	 eax, esi
  00062	7c f2		 jl	 SHORT $LL7@AttributeP
$LN23@AttributeP:

; 1036 : 
; 1037 : 	ms_ulbegin = start;
; 1038 : 	ms_ulend = end;
; 1039 : }

  00064	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_ulbegin@CIME@@2HA, ecx ; CIME::ms_ulbegin
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?ms_ulend@CIME@@2HA, eax ; CIME::ms_ulend
  00074	5e		 pop	 esi
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::AttributeProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_hImc$ = 8						; size = 4
?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z PROC	; CIME::CompositionProcess, COMDAT
; _this$ = ecx

; 968  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 969  : 	ms_compLen = ImmGetCompositionStringW(hImc, GCS_COMPSTR, m_wszComposition, sizeof(m_wszComposition))/sizeof(wchar_t);

  00007	68 00 08 00 00	 push	 2048			; 00000800H
  0000c	8d 77 22	 lea	 esi, DWORD PTR [edi+34]
  0000f	56		 push	 esi
  00010	6a 08		 push	 8
  00012	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00015	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  0001a	d1 e8		 shr	 eax, 1

; 970  : 
; 971  : 	//OutputDebugStringW( L"Composition: " );
; 972  : 	//OutputDebugStringW( m_wszComposition );
; 973  : 	//for( int i=0; i < (int) ms_compLen * 2; i++ ) {
; 974  : 	//	LPBYTE pbyData = (LPBYTE) m_wszComposition;
; 975  : 	//	pbyData += i;
; 976  : 	//	WCHAR tszName[32];
; 977  : 
; 978  : 	//	swprintf_s( tszName, L"%02X ", (unsigned int) *pbyData );
; 979  : 	//	OutputDebugStringW( tszName );
; 980  : 	//}
; 981  : 	//OutputDebugStringW( L"\n" );
; 982  : 
; 983  : 	if (IsMax(m_wszComposition, ms_compLen))

  0001c	8b cf		 mov	 ecx, edi
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	a3 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, eax ; CIME::ms_compLen
  00025	e8 00 00 00 00	 call	 ?IsMax@CIME@@IAE_NPB_WH@Z ; CIME::IsMax
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	84 c0		 test	 al, al
  0002e	74 18		 je	 SHORT $LN2@Compositio

; 984  : 	{
; 985  : 		ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);

  00030	6a 00		 push	 0
  00032	6a 04		 push	 4
  00034	6a 15		 push	 21			; 00000015H
  00036	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00039	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 986  : 		ms_compLen = 0;

  0003e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen
$LN2@Compositio:

; 987  : 	}
; 988  : }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP	; CIME::CompositionProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_hImc$ = 8						; size = 4
?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z PROC ; CIME::CompositionProcessBuilding, COMDAT
; _this$ = ecx

; 991  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 992  : 	int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, m_wText, ms_lastpos, 0, 0, NULL, NULL);

  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00012	8b f1		 mov	 esi, ecx
  00014	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  00019	6a 00		 push	 0
  0001b	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 993  : 
; 994  : 	if (textLen >= m_max)

  00027	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0002a	7c 1d		 jl	 SHORT $LN2@Compositio

; 995  : 	{
; 996  : 		ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);

  0002c	6a 00		 push	 0
  0002e	6a 04		 push	 4
  00030	6a 15		 push	 21			; 00000015H
  00032	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00035	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 1002 : 
; 1003 : 	//OutputDebugStringW( L"Composition: " );
; 1004 : 	//OutputDebugStringW( m_wszComposition );
; 1005 : 	//for( int i=0; i < (int) ms_compLen * 2; i++ ) {
; 1006 : 	//	LPBYTE pbyData = (LPBYTE) m_wszComposition;
; 1007 : 	//	pbyData += i;
; 1008 : 	//	WCHAR tszName[32];
; 1009 : 
; 1010 : 	//	swprintf_s( tszName, L"%02X ", (unsigned int) *pbyData );
; 1011 : 	//	OutputDebugStringW( tszName );
; 1012 : 	//}
; 1013 : 	//OutputDebugStringW( L"\n" );
; 1014 : }

  0003a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen
  00044	5e		 pop	 esi
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN2@Compositio:

; 997  : 		ms_compLen = 0;
; 998  : 		return;
; 999  : 	}
; 1000 : 
; 1001 : 	ms_compLen = ImmGetCompositionStringW(hImc, GCS_COMPSTR, m_wszComposition, sizeof(m_wszComposition))/sizeof(wchar_t);

  00049	68 00 08 00 00	 push	 2048			; 00000800H
  0004e	8d 46 22	 lea	 eax, DWORD PTR [esi+34]
  00051	50		 push	 eax
  00052	6a 08		 push	 8
  00054	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00057	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  0005c	d1 e8		 shr	 eax, 1

; 1002 : 
; 1003 : 	//OutputDebugStringW( L"Composition: " );
; 1004 : 	//OutputDebugStringW( m_wszComposition );
; 1005 : 	//for( int i=0; i < (int) ms_compLen * 2; i++ ) {
; 1006 : 	//	LPBYTE pbyData = (LPBYTE) m_wszComposition;
; 1007 : 	//	pbyData += i;
; 1008 : 	//	WCHAR tszName[32];
; 1009 : 
; 1010 : 	//	swprintf_s( tszName, L"%02X ", (unsigned int) *pbyData );
; 1011 : 	//	OutputDebugStringW( tszName );
; 1012 : 	//}
; 1013 : 	//OutputDebugStringW( L"\n" );
; 1014 : }

  0005e	a3 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, eax ; CIME::ms_compLen
  00063	5e		 pop	 esi
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z ENDP ; CIME::CompositionProcessBuilding
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_temp$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_hImc$ = 8						; size = 4
?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::ResultProcess, COMDAT
; _this$ = ecx

; 1017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _hImc$[ebp]
  00016	56		 push	 esi

; 1018 : 	wchar_t temp[IMESTR_MAXLEN];
; 1019 : 
; 1020 : 	int len = ImmGetCompositionStringW(hImc, GCS_RESULTSTR, temp, sizeof(temp))/sizeof(wchar_t);

  00017	68 00 08 00 00	 push	 2048			; 00000800H
  0001c	8b f1		 mov	 esi, ecx
  0001e	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00024	51		 push	 ecx
  00025	68 00 08 00 00	 push	 2048			; 00000800H
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  00030	d1 e8		 shr	 eax, 1

; 1021 : 
; 1022 : 	if (len <= 0)

  00032	74 0f		 je	 SHORT $LN1@ResultProc

; 1023 : 		return;
; 1024 : 
; 1025 : 	InsertString(temp, len);

  00034	50		 push	 eax
  00035	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  0003b	8b ce		 mov	 ecx, esi
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString
$LN1@ResultProc:

; 1026 : }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	33 cd		 xor	 ecx, ebp
  00048	5e		 pop	 esi
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::ResultProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetCodePageFromLang@CIME@@IAEIG@Z
_TEXT	SEGMENT
_langid$ = 8						; size = 2
?GetCodePageFromLang@CIME@@IAEIG@Z PROC			; CIME::GetCodePageFromLang, COMDAT
; _this$ = ecx

; 894  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 895  : 	unsigned pri_langid = PRIMARYLANGID(langid);

  00003	0f b7 4d 08	 movzx	 ecx, WORD PTR _langid$[ebp]
  00007	8b c1		 mov	 eax, ecx
  00009	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH

; 896  : 	switch (pri_langid)

  0000e	48		 dec	 eax
  0000f	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00012	0f 87 93 00 00
	00		 ja	 $LN36@GetCodePag
  00018	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN38@GetCodePag[eax]
  0001f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN39@GetCodePag[eax*4]
$LN6@GetCodePag:

; 897  : 	{
; 898  : 		case LANG_JAPANESE:
; 899  : 			//setlocale(LC_ALL, ".932");
; 900  : 			return 932;

  00026	b8 a4 03 00 00	 mov	 eax, 932		; 000003a4H

; 964  : 	}
; 965  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN7@GetCodePag:

; 901  : 		case LANG_KOREAN:
; 902  : 			//setlocale(LC_ALL, ".949");
; 903  : 			return 949;

  0002f	b8 b5 03 00 00	 mov	 eax, 949		; 000003b5H

; 964  : 	}
; 965  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN8@GetCodePag:

; 904  : 		case LANG_CHINESE:
; 905  : 			{
; 906  : 				switch (SUBLANGID(langid))

  00038	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  0003b	49		 dec	 ecx
  0003c	83 f9 04	 cmp	 ecx, 4
  0003f	77 10		 ja	 SHORT $LN4@GetCodePag
  00041	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN40@GetCodePag[ecx*4]
$LN11@GetCodePag:

; 907  : 				{
; 908  : 					case SUBLANG_CHINESE_SIMPLIFIED:
; 909  : 					case SUBLANG_CHINESE_SINGAPORE:
; 910  : 						//setlocale(LC_ALL, ".936");
; 911  : 						return 936;
; 912  : 					case SUBLANG_CHINESE_TRADITIONAL:
; 913  : 					case SUBLANG_CHINESE_MACAU:
; 914  : 					case SUBLANG_CHINESE_HONGKONG:
; 915  : 						//setlocale(LC_ALL, ".950");
; 916  : 						return 950;

  00048	b8 b6 03 00 00	 mov	 eax, 950		; 000003b6H

; 964  : 	}
; 965  : }

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN4@GetCodePag:

; 917  : 				}
; 918  : 			}
; 919  : 			//setlocale(LC_ALL, ".936");
; 920  : 			return 936;

  00051	b8 a8 03 00 00	 mov	 eax, 936		; 000003a8H

; 964  : 	}
; 965  : }

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
$LN14@GetCodePag:

; 921  : 		case LANG_ARABIC:
; 922  : 			return 1256;

  0005a	b8 e8 04 00 00	 mov	 eax, 1256		; 000004e8H

; 964  : 	}
; 965  : }

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN15@GetCodePag:

; 923  : 		case LANG_GREEK:
; 924  : 			//setlocale(LC_ALL, ".1253");
; 925  : 			return 1253;

  00063	b8 e5 04 00 00	 mov	 eax, 1253		; 000004e5H

; 964  : 	}
; 965  : }

  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
$LN16@GetCodePag:

; 926  : 		case LANG_TURKISH:
; 927  : 			//setlocale(LC_ALL, ".1254");
; 928  : 			return 1254;

  0006c	b8 e6 04 00 00	 mov	 eax, 1254		; 000004e6H

; 964  : 	}
; 965  : }

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
$LN17@GetCodePag:

; 929  : 		case LANG_HEBREW:
; 930  : 			//setlocale(LC_ALL, ".1255");
; 931  : 			return 1255;

  00075	b8 e7 04 00 00	 mov	 eax, 1255		; 000004e7H

; 964  : 	}
; 965  : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
$LN18@GetCodePag:

; 932  : 		case LANG_ESTONIAN:
; 933  : 		case LANG_LATVIAN:
; 934  : 		case LANG_LITHUANIAN:
; 935  : 			//setlocale(LC_ALL, ".1257");
; 936  : 			return 1257;

  0007e	b8 e9 04 00 00	 mov	 eax, 1257		; 000004e9H

; 964  : 	}
; 965  : }

  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
$LN21@GetCodePag:

; 937  : 		case LANG_VIETNAMESE:
; 938  : 			return 1258;

  00087	b8 ea 04 00 00	 mov	 eax, 1258		; 000004eaH

; 964  : 	}
; 965  : }

  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN22@GetCodePag:

; 939  : 		case LANG_THAI:
; 940  : 			//setlocale(LC_ALL, ".874");
; 941  : 			return 874;

  00090	b8 6a 03 00 00	 mov	 eax, 874		; 0000036aH

; 964  : 	}
; 965  : }

  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
$LN23@GetCodePag:

; 942  : 		case LANG_CZECH:
; 943  : 		case LANG_HUNGARIAN:
; 944  : 		case LANG_POLISH:
; 945  : 		case LANG_CROATIAN:
; 946  : 		case LANG_MACEDONIAN:
; 947  : 		case LANG_ROMANIAN:
; 948  : 		case LANG_SLOVAK:
; 949  : 		case LANG_SLOVENIAN:
; 950  : 			//setlocale(LC_ALL, ".1250");
; 951  : 			return 1250;

  00099	b8 e2 04 00 00	 mov	 eax, 1250		; 000004e2H

; 964  : 	}
; 965  : }

  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
$LN31@GetCodePag:

; 952  : 		case LANG_RUSSIAN:
; 953  : 		case LANG_BELARUSIAN:
; 954  : 		case LANG_BULGARIAN:
; 955  : 		case LANG_UKRAINIAN:
; 956  : 			return 1251;

  000a2	b8 e3 04 00 00	 mov	 eax, 1251		; 000004e3H

; 964  : 	}
; 965  : }

  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
$LN36@GetCodePag:

; 957  : 		case LANG_GERMAN:
; 958  : 			//_wsetlocale(LC_ALL, ".1252");
; 959  : 			return 1252;
; 960  : 		default:
; 961  : 			//TraceError("UNKNOWN IME[%d]\n", langid);
; 962  : 			//setlocale(LC_ALL, ".949");
; 963  : 			return 1252;

  000ab	b8 e4 04 00 00	 mov	 eax, 1252		; 000004e4H

; 964  : 	}
; 965  : }

  000b0	5d		 pop	 ebp
  000b1	c2 04 00	 ret	 4
$LN39@GetCodePag:
  000b4	00 00 00 00	 DD	 $LN14@GetCodePag
  000b8	00 00 00 00	 DD	 $LN31@GetCodePag
  000bc	00 00 00 00	 DD	 $LN8@GetCodePag
  000c0	00 00 00 00	 DD	 $LN23@GetCodePag
  000c4	00 00 00 00	 DD	 $LN36@GetCodePag
  000c8	00 00 00 00	 DD	 $LN15@GetCodePag
  000cc	00 00 00 00	 DD	 $LN17@GetCodePag
  000d0	00 00 00 00	 DD	 $LN6@GetCodePag
  000d4	00 00 00 00	 DD	 $LN7@GetCodePag
  000d8	00 00 00 00	 DD	 $LN22@GetCodePag
  000dc	00 00 00 00	 DD	 $LN16@GetCodePag
  000e0	00 00 00 00	 DD	 $LN18@GetCodePag
  000e4	00 00 00 00	 DD	 $LN21@GetCodePag
  000e8	00 00 00 00	 DD	 $LN36@GetCodePag
$LN38@GetCodePag:
  000ec	00		 DB	 0
  000ed	01		 DB	 1
  000ee	0d		 DB	 13			; 0000000dH
  000ef	02		 DB	 2
  000f0	03		 DB	 3
  000f1	0d		 DB	 13			; 0000000dH
  000f2	04		 DB	 4
  000f3	05		 DB	 5
  000f4	0d		 DB	 13			; 0000000dH
  000f5	0d		 DB	 13			; 0000000dH
  000f6	0d		 DB	 13			; 0000000dH
  000f7	0d		 DB	 13			; 0000000dH
  000f8	06		 DB	 6
  000f9	03		 DB	 3
  000fa	0d		 DB	 13			; 0000000dH
  000fb	0d		 DB	 13			; 0000000dH
  000fc	07		 DB	 7
  000fd	08		 DB	 8
  000fe	0d		 DB	 13			; 0000000dH
  000ff	0d		 DB	 13			; 0000000dH
  00100	03		 DB	 3
  00101	0d		 DB	 13			; 0000000dH
  00102	0d		 DB	 13			; 0000000dH
  00103	03		 DB	 3
  00104	01		 DB	 1
  00105	03		 DB	 3
  00106	03		 DB	 3
  00107	0d		 DB	 13			; 0000000dH
  00108	0d		 DB	 13			; 0000000dH
  00109	09		 DB	 9
  0010a	0a		 DB	 10			; 0000000aH
  0010b	0d		 DB	 13			; 0000000dH
  0010c	0d		 DB	 13			; 0000000dH
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	03		 DB	 3
  00110	0b		 DB	 11			; 0000000bH
  00111	0b		 DB	 11			; 0000000bH
  00112	0b		 DB	 11			; 0000000bH
  00113	0d		 DB	 13			; 0000000dH
  00114	0d		 DB	 13			; 0000000dH
  00115	0c		 DB	 12			; 0000000cH
  00116	0d		 DB	 13			; 0000000dH
  00117	0d		 DB	 13			; 0000000dH
  00118	0d		 DB	 13			; 0000000dH
  00119	0d		 DB	 13			; 0000000dH
  0011a	03		 DB	 3
  0011b	90		 npad	 1
$LN40@GetCodePag:
  0011c	00 00 00 00	 DD	 $LN11@GetCodePag
  00120	00 00 00 00	 DD	 $LN4@GetCodePag
  00124	00 00 00 00	 DD	 $LN11@GetCodePag
  00128	00 00 00 00	 DD	 $LN4@GetCodePag
  0012c	00 00 00 00	 DD	 $LN11@GetCodePag
?GetCodePageFromLang@CIME@@IAEIG@Z ENDP			; CIME::GetCodePageFromLang
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?OnChar@CIME@@IAEX_W@Z
_TEXT	SEGMENT
_c$ = 8							; size = 2
?OnChar@CIME@@IAEX_W@Z PROC				; CIME::OnChar, COMDAT
; _this$ = ecx

; 879  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 880  : 	if (m_bOnlyNumberMode)

  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	74 0f		 je	 SHORT $LN3@OnChar

; 881  : 		if (!iswdigit(c))

  0000c	ff 75 08	 push	 DWORD PTR _c$[ebp]
  0000f	e8 00 00 00 00	 call	 _iswdigit
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 28		 je	 SHORT $LN1@OnChar
$LN3@OnChar:

; 882  : 			return;
; 883  : 
; 884  : 	if ((c >= 0x00 && c<=0x1f) || (c == 0x7f)) // @fixme011

  0001b	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
  0001e	66 83 f8 1f	 cmp	 ax, 31			; 0000001fH
  00022	76 1f		 jbe	 SHORT $LN1@OnChar
  00024	66 83 f8 7f	 cmp	 ax, 127			; 0000007fH
  00028	74 19		 je	 SHORT $LN1@OnChar

; 885  : 		return;
; 886  : 
; 887  : 	if (!__IsWritable(c))

  0002a	50		 push	 eax
  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 ?__IsWritable@CIME@@QAE_N_W@Z ; CIME::__IsWritable
  00032	84 c0		 test	 al, al
  00034	74 0d		 je	 SHORT $LN1@OnChar

; 888  : 		return;
; 889  : 
; 890  : 	InsertString(&c, 1);

  00036	6a 01		 push	 1
  00038	8d 45 08	 lea	 eax, DWORD PTR _c$[ebp]
  0003b	8b ce		 mov	 ecx, esi
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString
$LN1@OnChar:
  00043	5e		 pop	 esi

; 891  : }

  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
?OnChar@CIME@@IAEX_W@Z ENDP				; CIME::OnChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?InsertString@CIME@@IAEXPA_WH@Z
_TEXT	SEGMENT
_wString$ = 8						; size = 4
_iSize$ = 12						; size = 4
?InsertString@CIME@@IAEXPA_WH@Z PROC			; CIME::InsertString, COMDAT
; _this$ = ecx

; 865  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 866  : 	if (IsMax(wString, iSize))

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  00007	53		 push	 ebx
  00008	ff 75 08	 push	 DWORD PTR _wString$[ebp]
  0000b	e8 00 00 00 00	 call	 ?IsMax@CIME@@IAE_NPB_WH@Z ; CIME::IsMax
  00010	84 c0		 test	 al, al
  00012	75 5d		 jne	 SHORT $LN1@InsertStri

; 867  : 		return;
; 868  : 
; 869  : 	if (ms_curpos < ms_lastpos)

  00014	56		 push	 esi
  00015	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0001b	57		 push	 edi
  0001c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00022	3b f7		 cmp	 esi, edi
  00024	7d 22		 jge	 SHORT $LN3@InsertStri

; 870  : 		memmove(m_wText+ms_curpos+iSize, m_wText+ms_curpos, sizeof(wchar_t)*(ms_lastpos-ms_curpos));

  00026	8b c7		 mov	 eax, edi
  00028	2b c6		 sub	 eax, esi
  0002a	03 c0		 add	 eax, eax
  0002c	50		 push	 eax
  0002d	8d 04 75 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[esi*2]
  00034	50		 push	 eax
  00035	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00038	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _memmove
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@InsertStri:

; 871  : 
; 872  : 	memcpy(m_wText+ms_curpos, wString, sizeof(wchar_t)*iSize);

  00048	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  0004b	50		 push	 eax
  0004c	ff 75 08	 push	 DWORD PTR _wString$[ebp]
  0004f	8d 04 75 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[esi*2]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _memcpy
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 873  : 
; 874  : 	ms_curpos += iSize;

  0005f	03 f3		 add	 esi, ebx

; 875  : 	ms_lastpos += iSize;

  00061	03 fb		 add	 edi, ebx
  00063	89 35 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, esi ; CIME::ms_curpos
  00069	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, edi ; CIME::ms_lastpos
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
$LN1@InsertStri:
  00071	5b		 pop	 ebx

; 876  : }

  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
?InsertString@CIME@@IAEXPA_WH@Z ENDP			; CIME::InsertString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetSupportLevel@CIME@@KAXK@Z
_TEXT	SEGMENT
_dwImeLevel$ = 8					; size = 4
?SetSupportLevel@CIME@@KAXK@Z PROC			; CIME::SetSupportLevel, COMDAT

; 777  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 778  : 	if ( dwImeLevel < 2 || 3 < dwImeLevel )

  00003	8b 55 08	 mov	 edx, DWORD PTR _dwImeLevel$[ebp]
  00006	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]
  00009	83 f8 01	 cmp	 eax, 1
  0000c	77 28		 ja	 SHORT $LN3@SetSupport

; 779  : 		return;
; 780  : 	if ( GETPRIMLANG() == LANG_KOREAN )

  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent

; 781  : 	{
; 782  : 		dwImeLevel = 3;
; 783  : 	}
; 784  : 	ms_dwIMELevel = dwImeLevel;

  00013	b9 03 00 00 00	 mov	 ecx, 3
  00018	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0001d	83 f8 12	 cmp	 eax, 18			; 00000012H
  00020	0f 45 ca	 cmovne	 ecx, edx
  00023	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_dwIMELevel@CIME@@2KA, ecx ; CIME::ms_dwIMELevel

; 785  : 	// cancel current composition string.
; 786  : 	FinalizeString();

  00029	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _dwImeLevel$[ebp], 0

; 787  : 	//SetCompStringColor();
; 788  : }

  00030	5d		 pop	 ebp

; 785  : 	// cancel current composition string.
; 786  : 	FinalizeString();

  00031	e9 00 00 00 00	 jmp	 ?FinalizeString@CIME@@SAX_N@Z ; CIME::FinalizeString
$LN3@SetSupport:

; 787  : 	//SetCompStringColor();
; 788  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?SetSupportLevel@CIME@@KAXK@Z ENDP			; CIME::SetSupportLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?CheckToggleState@CIME@@KAXXZ
_TEXT	SEGMENT
_dwSentMode$1 = -8					; size = 4
_dwConvMode$2 = -4					; size = 4
?CheckToggleState@CIME@@KAXXZ PROC			; CIME::CheckToggleState, COMDAT

; 1534 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1535 : 	CheckInputLocale();

  00006	e8 00 00 00 00	 call	 ?CheckInputLocale@CIME@@KAXXZ ; CIME::CheckInputLocale

; 1536 : 
; 1537 : 	// In Vista, we have to use TSF since few IMM functions don't work as expected.
; 1538 : 	// WARNING: Because of timing, g_dwState and g_bChineseIME may not be updated
; 1539 : 	// immediately after the change on IME states by user.
; 1540 : 	if ( ms_bUILessMode )

  0000b	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  00012	0f 85 b2 00 00
	00		 jne	 $LN4@CheckToggl

; 1541 : 		return;
; 1542 : 
; 1543 : 	/* Check Toggle State */
; 1544 : 	bool bIme = ImmIsIME( ms_hklCurrent ) != 0

  00018	53		 push	 ebx
  00019	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0001f	e8 00 00 00 00	 call	 _ImmIsIME@4
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0002a	85 c0		 test	 eax, eax
  0002c	74 12		 je	 SHORT $LN8@CheckToggl
  0002e	8b c1		 mov	 eax, ecx
  00030	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  00035	3d 00 00 00 e0	 cmp	 eax, -536870912		; e0000000H
  0003a	75 04		 jne	 SHORT $LN8@CheckToggl
  0003c	b3 01		 mov	 bl, 1
  0003e	eb 02		 jmp	 SHORT $LN9@CheckToggl
$LN8@CheckToggl:
  00040	32 db		 xor	 bl, bl
$LN9@CheckToggl:

; 1545 : 		&& ( ( 0xF0000000 & (DWORD)ms_hklCurrent ) == 0xE0000000 ); // Hack to detect IME correctly. When IME is running as TIP, ImmIsIME() returns true for CHT US keyboard.
; 1546 : 	ms_bChineseIME = ( GETPRIMLANG() == LANG_CHINESE ) && bIme;

  00042	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00048	83 f9 04	 cmp	 ecx, 4
  0004b	75 08		 jne	 SHORT $LN10@CheckToggl
  0004d	84 db		 test	 bl, bl
  0004f	74 04		 je	 SHORT $LN10@CheckToggl
  00051	b0 01		 mov	 al, 1
  00053	eb 02		 jmp	 SHORT $LN11@CheckToggl
$LN10@CheckToggl:
  00055	32 c0		 xor	 al, al
$LN11@CheckToggl:
  00057	56		 push	 esi

; 1547 : 
; 1548 : 	HIMC himc;
; 1549 : 	if (NULL != (himc = ImmGetContext(ms_hWnd))) {

  00058	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0005e	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, al ; CIME::ms_bChineseIME
  00063	e8 00 00 00 00	 call	 _ImmGetContext@4
  00068	8b f0		 mov	 esi, eax
  0006a	85 f6		 test	 esi, esi
  0006c	74 50		 je	 SHORT $LN3@CheckToggl

; 1550 : 		if (ms_bChineseIME) {

  0006e	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, 0 ; CIME::ms_bChineseIME
  00075	74 19		 je	 SHORT $LN5@CheckToggl

; 1551 : 			DWORD dwConvMode, dwSentMode;
; 1552 : 			ImmGetConversionStatus(himc, &dwConvMode, &dwSentMode);

  00077	8d 45 f8	 lea	 eax, DWORD PTR _dwSentMode$1[ebp]
  0007a	50		 push	 eax
  0007b	8d 45 fc	 lea	 eax, DWORD PTR _dwConvMode$2[ebp]
  0007e	50		 push	 eax
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 _ImmGetConversionStatus@12

; 1553 : 			ms_dwImeState = ( dwConvMode & IME_CMODE_NATIVE ) ? IMEUI_STATE_ON : IMEUI_STATE_ENGLISH;

  00085	8b 45 fc	 mov	 eax, DWORD PTR _dwConvMode$2[ebp]
  00088	f7 d0		 not	 eax
  0008a	83 e0 01	 and	 eax, 1
  0008d	40		 inc	 eax

; 1554 : 		}

  0008e	eb 17		 jmp	 SHORT $LN13@CheckToggl
$LN5@CheckToggl:

; 1555 : 		else
; 1556 : 		{
; 1557 : 			ms_dwImeState = ( bIme && ImmGetOpenStatus( himc ) != 0 ) ? IMEUI_STATE_ON : IMEUI_STATE_OFF;

  00090	84 db		 test	 bl, bl
  00092	74 11		 je	 SHORT $LN12@CheckToggl
  00094	56		 push	 esi
  00095	e8 00 00 00 00	 call	 _ImmGetOpenStatus@4
  0009a	85 c0		 test	 eax, eax
  0009c	74 07		 je	 SHORT $LN12@CheckToggl
  0009e	b8 01 00 00 00	 mov	 eax, 1
  000a3	eb 02		 jmp	 SHORT $LN13@CheckToggl
$LN12@CheckToggl:
  000a5	33 c0		 xor	 eax, eax
$LN13@CheckToggl:

; 1558 : 		}
; 1559 : 		ImmReleaseContext(ms_hWnd, himc);

  000a7	56		 push	 esi
  000a8	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  000ae	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, eax ; CIME::ms_dwImeState
  000b3	e8 00 00 00 00	 call	 _ImmReleaseContext@8
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx

; 1563 : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN3@CheckToggl:
  000be	5e		 pop	 esi

; 1560 : 	}
; 1561 : 	else
; 1562 : 		ms_dwImeState = IMEUI_STATE_OFF;

  000bf	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, 0 ; CIME::ms_dwImeState
  000c9	5b		 pop	 ebx
$LN4@CheckToggl:

; 1563 : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
?CheckToggleState@CIME@@KAXXZ ENDP			; CIME::CheckToggleState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?CheckInputLocale@CIME@@KAXXZ
_TEXT	SEGMENT
_szCodePage$ = -24					; size = 8
_szLang$1 = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
?CheckInputLocale@CIME@@KAXXZ PROC			; CIME::CheckInputLocale, COMDAT

; 1455 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1456 : 	static UINT s_uPrevCodePage = 0xFFFF;
; 1457 : 	static HKL	s_hklPrev = NULL;
; 1458 : 
; 1459 : 	ms_hklCurrent = GetKeyboardLayout( 0 );

  00010	6a 00		 push	 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyboardLayout@4
  00018	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, eax ; CIME::ms_hklCurrent
  0001d	39 05 00 00 00
	00		 cmp	 DWORD PTR ?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A, eax

; 1460 : 	if ( s_hklPrev == ms_hklCurrent )

  00023	0f 84 25 01 00
	00		 je	 $LN19@CheckInput

; 1461 : 		return;
; 1462 : 	s_hklPrev = ms_hklCurrent;
; 1463 : 
; 1464 : 	char szCodePage[8];
; 1465 : 	int iRc = GetLocaleInfoA( MAKELCID( GETLANG(), SORT_DEFAULT ), LOCALE_IDEFAULTANSICODEPAGE, szCodePage, COUNTOF( szCodePage ) ); iRc;

  00029	6a 08		 push	 8
  0002b	8d 4d e8	 lea	 ecx, DWORD PTR _szCodePage$[ebp]
  0002e	a3 00 00 00 00	 mov	 DWORD PTR ?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A, eax
  00033	51		 push	 ecx
  00034	68 04 10 00 00	 push	 4100			; 00001004H
  00039	0f b7 c0	 movzx	 eax, ax
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16

; 1466 : 	ms_uInputCodePage = _strtoul( szCodePage, NULL, 0 );

  00043	6a 00		 push	 0
  00045	8d 45 e8	 lea	 eax, DWORD PTR _szCodePage$[ebp]
  00048	6a 00		 push	 0
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_strtoul@@YAKPBDPAPADH@Z ; _strtoul
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	a3 00 00 00 00	 mov	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA, eax ; CIME::ms_uInputCodePage
  00058	39 05 00 00 00
	00		 cmp	 DWORD PTR ?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA, eax

; 1467 : 	if ( s_uPrevCodePage == ms_uInputCodePage )

  0005e	0f 84 ea 00 00
	00		 je	 $LN19@CheckInput

; 1468 : 		return;
; 1469 : 	s_uPrevCodePage = ms_uInputCodePage;
; 1470 : 
; 1471 : 	GetKeyboardLayoutName(ms_szKeyboardLayout);

  00064	68 00 00 00 00	 push	 OFFSET ?ms_szKeyboardLayout@CIME@@2PADA ; CIME::ms_szKeyboardLayout
  00069	a3 00 00 00 00	 mov	 DWORD PTR ?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA, eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyboardLayoutNameA@4

; 1472 : 
; 1473 :     switch (GETPRIMLANG())

  00074	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A
  0007b	8b c1		 mov	 eax, ecx
  0007d	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00082	83 e8 04	 sub	 eax, 4
  00085	74 31		 je	 SHORT $LN10@CheckInput
  00087	83 e8 0d	 sub	 eax, 13			; 0000000dH
  0008a	74 19		 je	 SHORT $LN9@CheckInput
  0008c	83 e8 01	 sub	 eax, 1
  0008f	75 5f		 jne	 SHORT $LN16@CheckInput

; 1474 : 	{
; 1475 : 		case LANG_KOREAN:
; 1476 : 			ms_bVerticalCandidate = false;

  00091	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, al ; CIME::ms_bVerticalCandidate

; 1477 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_KOREAN];

  00096	c7 05 00 00 00
	00 12 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, OFFSET ?s_aszIndicator@@3PAY02_WA+18 ; CIME::ms_wszCurrentIndicator

; 1478 : 			break;

  000a0	e9 8e 00 00 00	 jmp	 $LN18@CheckInput
$LN9@CheckInput:

; 1479 : 
; 1480 : 		case LANG_JAPANESE:
; 1481 : 			ms_bVerticalCandidate = true;

  000a5	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, 1 ; CIME::ms_bVerticalCandidate

; 1482 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_JAPANESE];

  000ac	c7 05 00 00 00
	00 18 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, OFFSET ?s_aszIndicator@@3PAY02_WA+24 ; CIME::ms_wszCurrentIndicator

; 1483 : 			break;

  000b6	eb 7b		 jmp	 SHORT $LN18@CheckInput
$LN10@CheckInput:

; 1484 : 
; 1485 : 		case LANG_CHINESE:
; 1486 : 			ms_bVerticalCandidate = true;
; 1487 : 
; 1488 : 			switch(GETSUBLANG())

  000b8	8b c1		 mov	 eax, ecx
  000ba	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, 1 ; CIME::ms_bVerticalCandidate
  000c1	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  000c4	48		 dec	 eax
  000c5	83 f8 04	 cmp	 eax, 4
  000c8	77 26		 ja	 SHORT $LN16@CheckInput
  000ca	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN22@CheckInput[eax*4]
$LN11@CheckInput:

; 1489 : 			{
; 1490 : 				case SUBLANG_CHINESE_SIMPLIFIED:
; 1491 : 				case SUBLANG_CHINESE_SINGAPORE:
; 1492 : 					//ms_bVerticalCandidate = (GetImeId() == 0);
; 1493 : 					ms_bVerticalCandidate = false;

  000d1	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, 0 ; CIME::ms_bVerticalCandidate

; 1494 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_CHS];

  000d8	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, OFFSET ?s_aszIndicator@@3PAY02_WA+6 ; CIME::ms_wszCurrentIndicator

; 1495 : 					break;

  000e2	eb 4f		 jmp	 SHORT $LN18@CheckInput
$LN13@CheckInput:

; 1496 : 
; 1497 : 				case SUBLANG_CHINESE_TRADITIONAL:
; 1498 : 				case SUBLANG_CHINESE_HONGKONG:
; 1499 : 				case SUBLANG_CHINESE_MACAU:
; 1500 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_CHT];

  000e4	c7 05 00 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, OFFSET ?s_aszIndicator@@3PAY02_WA+12 ; CIME::ms_wszCurrentIndicator

; 1501 : 					break;

  000ee	eb 43		 jmp	 SHORT $LN18@CheckInput
$LN16@CheckInput:

; 1502 : 
; 1503 : 				default:	// unsupported sub-language
; 1504 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_NON_IME];
; 1505 : 					break;
; 1506 : 			}
; 1507 : 			break;
; 1508 : 
; 1509 : 		default:
; 1510 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_NON_IME];
; 1511 : 			break;
; 1512 :     }
; 1513 : 
; 1514 :     if (ms_wszCurrentIndicator == s_aszIndicator[INDICATOR_NON_IME])
; 1515 :     {
; 1516 :         char szLang[10];
; 1517 :         GetLocaleInfoA(MAKELCID(GETLANG(), SORT_DEFAULT), LOCALE_SABBREVLANGNAME, szLang, sizeof(szLang));

  000f0	6a 0a		 push	 10			; 0000000aH
  000f2	8d 45 f0	 lea	 eax, DWORD PTR _szLang$1[ebp]
  000f5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, OFFSET ?s_aszIndicator@@3PAY02_WA ; CIME::ms_wszCurrentIndicator, s_aszIndicator
  000ff	50		 push	 eax
  00100	6a 03		 push	 3
  00102	51		 push	 ecx
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16

; 1518 :         ms_wszCurrentIndicator[0] = szLang[0];

  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA ; CIME::ms_wszCurrentIndicator
  0010e	66 0f be 4d f0	 movsx	 cx, BYTE PTR _szLang$1[ebp]
  00113	66 89 08	 mov	 WORD PTR [eax], cx

; 1519 :         ms_wszCurrentIndicator[1] = towlower(szLang[1]);

  00116	66 0f be 45 f1	 movsx	 ax, BYTE PTR _szLang$1[ebp+1]
  0011b	0f b7 c0	 movzx	 eax, ax
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _towlower
  00124	0f b7 c8	 movzx	 ecx, ax
  00127	83 c4 04	 add	 esp, 4
  0012a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA ; CIME::ms_wszCurrentIndicator
  0012f	66 89 48 02	 mov	 WORD PTR [eax+2], cx
$LN18@CheckInput:

; 1520 :     }
; 1521 : 
; 1522 : 	if(ms_uOutputCodePage != 1256) {

  00133	81 3d 00 00 00
	00 e8 04 00 00	 cmp	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, 1256 ; CIME::ms_uOutputCodePage, 000004e8H
  0013d	74 0f		 je	 SHORT $LN19@CheckInput

; 1523 : 		ms_uOutputCodePage = ms_uInputCodePage;

  0013f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00144	a3 00 00 00 00	 mov	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, eax ; CIME::ms_uOutputCodePage

; 1524 : 		Clear();

  00149	e8 00 00 00 00	 call	 ?Clear@CIME@@SAXXZ	; CIME::Clear
$LN19@CheckInput:

; 1525 : 	}
; 1526 : 
; 1527 : 	//for ( int i = 0; i < 256; i++ )
; 1528 : 	//{
; 1529 : 	//	LeadByteTable[i] = (BYTE)IsDBCSLeadByteEx( g_uCodePage, (BYTE)i );
; 1530 : 	//}
; 1531 : }

  0014e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00151	33 cd		 xor	 ecx, ebp
  00153	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c3		 ret	 0
$LN22@CheckInput:
  0015c	00 00 00 00	 DD	 $LN13@CheckInput
  00160	00 00 00 00	 DD	 $LN11@CheckInput
  00164	00 00 00 00	 DD	 $LN13@CheckInput
  00168	00 00 00 00	 DD	 $LN11@CheckInput
  0016c	00 00 00 00	 DD	 $LN13@CheckInput
?CheckInputLocale@CIME@@KAXXZ ENDP			; CIME::CheckInputLocale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?DelCurPos@CIME@@IAEXXZ
_TEXT	SEGMENT
?DelCurPos@CIME@@IAEXXZ PROC				; CIME::DelCurPos, COMDAT
; _this$ = ecx

; 843  : 	if (ms_curpos < ms_lastpos)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0000b	3b c8		 cmp	 ecx, eax
  0000d	7d 5c		 jge	 SHORT $LN2@DelCurPos

; 844  : 	{
; 845  : 		int eraseCount = FindColorTagEndPosition(m_wText + ms_curpos, ms_lastpos - ms_curpos) + 1;

  0000f	56		 push	 esi
  00010	2b c1		 sub	 eax, ecx
  00012	57		 push	 edi
  00013	50		 push	 eax
  00014	8d 04 4d 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[ecx*2]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?FindColorTagEndPosition@@YAHPB_WH@Z ; FindColorTagEndPosition

; 846  : 		wcscpy(m_wText + ms_curpos, m_wText + ms_curpos + eraseCount);

  00021	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00027	83 c4 08	 add	 esp, 8
  0002a	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0002d	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00030	8d 0c 4d 00 00
	00 00		 lea	 ecx, DWORD PTR ?m_wText@CIME@@2PA_WA[ecx*2]
  00037	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  0003a	2b d1		 sub	 edx, ecx
  0003c	81 c2 00 00 00
	00		 add	 edx, OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
$LL4@DelCurPos:
  00042	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00045	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00048	66 89 44 0a fe	 mov	 WORD PTR [edx+ecx-2], ax
  0004d	66 85 c0	 test	 ax, ax
  00050	75 f0		 jne	 SHORT $LL4@DelCurPos

; 847  : 		ms_lastpos -= eraseCount;

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00057	2b c7		 sub	 eax, edi
  00059	3b c6		 cmp	 eax, esi
  0005b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, eax ; CIME::ms_lastpos

; 848  : 		ms_curpos = min(ms_lastpos, ms_curpos);

  00060	5f		 pop	 edi
  00061	0f 4c f0	 cmovl	 esi, eax
  00064	89 35 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, esi ; CIME::ms_curpos
  0006a	5e		 pop	 esi
$LN2@DelCurPos:

; 849  : 	}
; 850  : }

  0006b	c3		 ret	 0
?DelCurPos@CIME@@IAEXXZ ENDP				; CIME::DelCurPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetCurPos@CIME@@IAEXH@Z
_TEXT	SEGMENT
_offset$ = 8						; size = 4
?SetCurPos@CIME@@IAEXH@Z PROC				; CIME::SetCurPos, COMDAT
; _this$ = ecx

; 827  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 828  : //	if (offset < 0 || offset > ms_lastpos)
; 829  : 	if (offset < 0 || offset >= ms_lastpos) //fix input price cursor position

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _offset$[ebp]
  0000c	85 f6		 test	 esi, esi
  0000e	78 37		 js	 SHORT $LN4@SetCurPos
  00010	3b f0		 cmp	 esi, eax
  00012	7d 33		 jge	 SHORT $LN4@SetCurPos

; 830  : 	{
; 831  : 		ms_curpos = ms_lastpos;
; 832  : 		return;
; 833  : 	}
; 834  : 	else
; 835  : 	{
; 836  : 		//ms_curpos = min(ms_lastpos, offset);
; 837  : 		ms_curpos = min(ms_lastpos, GetTextTagInternalPosFromRenderPos(m_wText, ms_lastpos, offset));

  00014	56		 push	 esi
  00015	50		 push	 eax
  00016	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0001b	e8 00 00 00 00	 call	 ?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z ; GetTextTagInternalPosFromRenderPos
  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	3b c8		 cmp	 ecx, eax
  0002b	7d 0b		 jge	 SHORT $LN6@SetCurPos
  0002d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, ecx ; CIME::ms_curpos
  00033	5e		 pop	 esi

; 838  : 	}
; 839  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@SetCurPos:

; 830  : 	{
; 831  : 		ms_curpos = ms_lastpos;
; 832  : 		return;
; 833  : 	}
; 834  : 	else
; 835  : 	{
; 836  : 		//ms_curpos = min(ms_lastpos, offset);
; 837  : 		ms_curpos = min(ms_lastpos, GetTextTagInternalPosFromRenderPos(m_wText, ms_lastpos, offset));

  00038	56		 push	 esi
  00039	51		 push	 ecx
  0003a	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0003f	e8 00 00 00 00	 call	 ?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z ; GetTextTagInternalPosFromRenderPos
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SetCurPos:

; 838  : 	}
; 839  : }

  00047	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
?SetCurPos@CIME@@IAEXH@Z ENDP				; CIME::SetCurPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?DecCurPos@CIME@@IAEXXZ
_TEXT	SEGMENT
?DecCurPos@CIME@@IAEXXZ PROC				; CIME::DecCurPos, COMDAT
; _this$ = ecx

; 807  : 	if (ms_curpos > 0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00005	85 c0		 test	 eax, eax
  00007	7e 4a		 jle	 SHORT $LN4@DecCurPos

; 808  : 	{
; 809  : 		int pos = FindColorTagStartPosition(m_wText + ms_curpos - 1, ms_curpos);

  00009	50		 push	 eax
  0000a	8d 04 45 fe ff
	ff ff		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2-2]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?FindColorTagStartPosition@@YAHPB_WH@Z ; FindColorTagStartPosition
  00017	83 c4 08	 add	 esp, 8

; 810  : 
; 811  : 		if (pos > 0)

  0001a	85 c0		 test	 eax, eax
  0001c	7e 2f		 jle	 SHORT $LN3@DecCurPos

; 812  : 			ms_curpos = min(ms_lastpos, max(0, ms_curpos - (pos + 1)));

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0002a	2b c8		 sub	 ecx, eax
  0002c	33 c0		 xor	 eax, eax
  0002e	83 c1 ff	 add	 ecx, -1
  00031	0f 49 c1	 cmovns	 eax, ecx
  00034	3b d0		 cmp	 edx, eax
  00036	7d 07		 jge	 SHORT $LN10@DecCurPos
  00038	89 15 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, edx ; CIME::ms_curpos

; 815  : 		//--ms_curpos;
; 816  : 	}
; 817  : }

  0003e	c3		 ret	 0
$LN10@DecCurPos:

; 812  : 			ms_curpos = min(ms_lastpos, max(0, ms_curpos - (pos + 1)));

  0003f	33 c0		 xor	 eax, eax
  00041	85 c9		 test	 ecx, ecx
  00043	0f 48 c8	 cmovs	 ecx, eax
  00046	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, ecx ; CIME::ms_curpos

; 815  : 		//--ms_curpos;
; 816  : 	}
; 817  : }

  0004c	c3		 ret	 0
$LN3@DecCurPos:

; 813  : 		else
; 814  : 			--ms_curpos;

  0004d	ff 0d 00 00 00
	00		 dec	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
$LN4@DecCurPos:

; 815  : 		//--ms_curpos;
; 816  : 	}
; 817  : }

  00053	c3		 ret	 0
?DecCurPos@CIME@@IAEXXZ ENDP				; CIME::DecCurPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?IncCurPos@CIME@@IAEXXZ
_TEXT	SEGMENT
?IncCurPos@CIME@@IAEXXZ PROC				; CIME::IncCurPos, COMDAT
; _this$ = ecx

; 793  : 	if (ms_curpos < ms_lastpos)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0000b	3b c8		 cmp	 ecx, eax
  0000d	7d 4c		 jge	 SHORT $LN4@IncCurPos

; 794  : 	{
; 795  : 		int pos = FindColorTagEndPosition(m_wText + ms_curpos, ms_lastpos - ms_curpos);

  0000f	2b c1		 sub	 eax, ecx
  00011	50		 push	 eax
  00012	8d 04 4d 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[ecx*2]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?FindColorTagEndPosition@@YAHPB_WH@Z ; FindColorTagEndPosition
  0001f	83 c4 08	 add	 esp, 8

; 796  : 
; 797  : 		if (pos > 0)

  00022	85 c0		 test	 eax, eax
  00024	7e 2f		 jle	 SHORT $LN3@IncCurPos

; 798  : 			ms_curpos = min(ms_lastpos, max(0, ms_curpos + (pos + 1)));

  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0002c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00032	41		 inc	 ecx
  00033	03 c8		 add	 ecx, eax
  00035	33 c0		 xor	 eax, eax
  00037	85 c9		 test	 ecx, ecx
  00039	0f 49 c1	 cmovns	 eax, ecx
  0003c	3b d0		 cmp	 edx, eax
  0003e	7d 07		 jge	 SHORT $LN10@IncCurPos
  00040	89 15 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, edx ; CIME::ms_curpos

; 801  : 		//++ms_curpos;
; 802  : 	}
; 803  : }

  00046	c3		 ret	 0
$LN10@IncCurPos:

; 798  : 			ms_curpos = min(ms_lastpos, max(0, ms_curpos + (pos + 1)));

  00047	33 c0		 xor	 eax, eax
  00049	85 c9		 test	 ecx, ecx
  0004b	0f 48 c8	 cmovs	 ecx, eax
  0004e	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, ecx ; CIME::ms_curpos

; 801  : 		//++ms_curpos;
; 802  : 	}
; 803  : }

  00054	c3		 ret	 0
$LN3@IncCurPos:

; 799  : 		else
; 800  : 			++ms_curpos;

  00055	ff 05 00 00 00
	00		 inc	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
$LN4@IncCurPos:

; 801  : 		//++ms_curpos;
; 802  : 	}
; 803  : }

  0005b	c3		 ret	 0
?IncCurPos@CIME@@IAEXXZ ENDP				; CIME::IncCurPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_c$ = -25						; size = 1
_w$1 = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z PROC			; CIME::WMChar, COMDAT
; _this$ = ecx

; 2278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2279 : 	unsigned char c = unsigned char(wParam & 0xff);

  00010	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00013	88 55 e7	 mov	 BYTE PTR _c$[ebp], dl
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	80 fa 08	 cmp	 dl, 8

; 2280 : 
; 2281 : 	switch (c)

  0001c	74 57		 je	 SHORT $LN4@WMChar

; 2290 : 		}
; 2291 : 		if(ms_pEvent)
; 2292 : 			ms_pEvent->OnUpdate();
; 2293 : 		return 0;
; 2294 : 		break;
; 2295 : 
; 2296 : 	default:
; 2297 : 		if(ms_pEvent) {

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00024	85 c9		 test	 ecx, ecx
  00026	74 0e		 je	 SHORT $LN10@WMChar

; 2298 : 			if (ms_pEvent->OnWM_CHAR(wParam, lParam))

  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  0002d	52		 push	 edx
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	ff d0		 call	 eax
  00032	84 c0		 test	 al, al
  00034	75 6c		 jne	 SHORT $LN21@WMChar
$LN10@WMChar:

; 2299 : 				break;
; 2300 : 		}
; 2301 : 		if(ms_bCaptureInput == false)

  00036	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 0 ; CIME::ms_bCaptureInput
  0003d	74 63		 je	 SHORT $LN21@WMChar

; 2302 : 			return 0;
; 2303 : 		wchar_t w[10];
; 2304 : 		MultiByteToWideChar(ms_uInputCodePage, 0, (char*)&c, 1, w, 1);

  0003f	6a 01		 push	 1
  00041	8d 45 e8	 lea	 eax, DWORD PTR _w$1[ebp]
  00044	50		 push	 eax
  00045	6a 01		 push	 1
  00047	8d 45 e7	 lea	 eax, DWORD PTR _c$[ebp]
  0004a	50		 push	 eax
  0004b	6a 00		 push	 0
  0004d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 2305 : 
; 2306 : 		OnChar(w[0]);

  00059	ff 75 e8	 push	 DWORD PTR _w$1[ebp]
  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?OnChar@CIME@@IAEX_W@Z	; CIME::OnChar

; 2307 : 		if (w[0] == L'|')

  00063	66 83 7d e8 7c	 cmp	 WORD PTR _w$1[ebp], 124	; 0000007cH
  00068	75 29		 jne	 SHORT $LN6@WMChar

; 2308 : 			OnChar(w[0]);

  0006a	6a 7c		 push	 124			; 0000007cH
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?OnChar@CIME@@IAEX_W@Z	; CIME::OnChar
  00073	eb 1e		 jmp	 SHORT $LN6@WMChar
$LN4@WMChar:

; 2282 : 	{
; 2283 : 	case 8:
; 2284 : 		if(ms_bCaptureInput == false)

  00075	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 0 ; CIME::ms_bCaptureInput
  0007c	74 24		 je	 SHORT $LN21@WMChar

; 2285 : 			return 0;
; 2286 : 		if (ms_curpos > 0)

  0007e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_curpos@CIME@@2HA, 0 ; CIME::ms_curpos
  00085	7e 0c		 jle	 SHORT $LN6@WMChar

; 2287 : 		{
; 2288 : 			DecCurPos();

  00087	e8 00 00 00 00	 call	 ?DecCurPos@CIME@@IAEXXZ	; CIME::DecCurPos

; 2289 : 			DelCurPos();

  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?DelCurPos@CIME@@IAEXXZ	; CIME::DelCurPos
$LN6@WMChar:

; 2309 : 		if(ms_pEvent)
; 2310 : 			ms_pEvent->OnUpdate();
; 2311 : 		break;
; 2312 : 	}
; 2313 : 
; 2314 : 	return 0;
; 2315 : }

  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00099	85 c9		 test	 ecx, ecx
  0009b	74 05		 je	 SHORT $LN21@WMChar
  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	ff 50 04	 call	 DWORD PTR [eax+4]
$LN21@WMChar:
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 c0		 xor	 eax, eax
  000a7	33 cd		 xor	 ecx, ebp
  000a9	5e		 pop	 esi
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 10 00	 ret	 16			; 00000010H
?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP			; CIME::WMChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_result$1$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_uiMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z PROC		; CIME::WMNotify, COMDAT
; _this$ = ecx

; 2198 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2199 : 	LRESULT		result = 0;

  00005	33 db		 xor	 ebx, ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	89 5d fc	 mov	 DWORD PTR _result$1$[ebp], ebx

; 2200 : 
; 2201 : 	if(ms_bCaptureInput == false)

  0000d	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, bl ; CIME::ms_bCaptureInput
  00013	75 0a		 jne	 SHORT $LN6@WMNotify

; 2202 : 		return 0;

  00015	5e		 pop	 esi
  00016	33 c0		 xor	 eax, eax

; 2275 : }

  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
$LN6@WMNotify:

; 2203 : 	switch (wParam) {

  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00022	57		 push	 edi
  00023	8d 41 fd	 lea	 eax, DWORD PTR [ecx-3]
  00026	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00029	0f 87 1c 01 00
	00		 ja	 $LN2@WMNotify
  0002f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN43@WMNotify[eax]
  00036	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN44@WMNotify[eax*4]
$LN7@WMNotify:

; 2204 : 
; 2205 : 	case IMN_OPENCANDIDATE:
; 2206 : 	case IMN_CHANGECANDIDATE: {
; 2207 : 		if (ms_bUILessMode && !ms_bUseIMMCandidate)

  0003d	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, bl ; CIME::ms_bUILessMode
  00043	74 0c		 je	 SHORT $LN9@WMNotify
  00045	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA, bl ; CIME::ms_bUseIMMCandidate
  0004b	0f 84 fa 00 00
	00		 je	 $LN2@WMNotify
$LN9@WMNotify:

; 2208 : 			break;
; 2209 : 		HIMC hImc = ImmGetContext(hWnd);

  00051	8b 5d 08	 mov	 ebx, DWORD PTR _hWnd$[ebp]
  00054	53		 push	 ebx
  00055	e8 00 00 00 00	 call	 _ImmGetContext@4
  0005a	8b f8		 mov	 edi, eax

; 2210 : 		if (hImc == NULL)

  0005c	85 ff		 test	 edi, edi
  0005e	0f 84 e5 00 00
	00		 je	 $LN46@WMNotify

; 2211 : 			break;
; 2212 : 		CandidateProcess(hImc);

  00064	57		 push	 edi
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CandidateProcess

; 2213 : 		if (!m_bUseDefaultIME) {

  0006c	80 7e 21 00	 cmp	 BYTE PTR [esi+33], 0
  00070	75 1e		 jne	 SHORT $LN11@WMNotify

; 2214 : 			if(ms_pEvent)

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00078	85 c9		 test	 ecx, ecx
  0007a	74 27		 je	 SHORT $LN12@WMNotify

; 2215 : 				ms_pEvent->OnOpenCandidateList();

  0007c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007e	ff 50 0c	 call	 DWORD PTR [eax+12]

; 2218 : 		ImmReleaseContext(hWnd, hImc);

  00081	57		 push	 edi
  00082	53		 push	 ebx
  00083	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 2219 : 		break;

  00088	8b 5d fc	 mov	 ebx, DWORD PTR _result$1$[ebp]
  0008b	e9 bb 00 00 00	 jmp	 $LN2@WMNotify
$LN11@WMNotify:

; 2216 : 		} else
; 2217 : 			result = ::DefWindowProc(hWnd, uiMsg, wParam, lParam);

  00090	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00093	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00096	ff 75 0c	 push	 DWORD PTR _uiMsg$[ebp]
  00099	53		 push	 ebx
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  000a0	89 45 fc	 mov	 DWORD PTR _result$1$[ebp], eax
$LN12@WMNotify:

; 2218 : 		ImmReleaseContext(hWnd, hImc);

  000a3	57		 push	 edi
  000a4	53		 push	 ebx
  000a5	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 2219 : 		break;

  000aa	8b 5d fc	 mov	 ebx, DWORD PTR _result$1$[ebp]
  000ad	e9 99 00 00 00	 jmp	 $LN2@WMNotify
$LN14@WMNotify:

; 2220 : 		}
; 2221 : 	case IMN_CLOSECANDIDATE:
; 2222 : 		if (ms_bUILessMode && !ms_bUseIMMCandidate)

  000b2	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, bl ; CIME::ms_bUILessMode
  000b8	74 0c		 je	 SHORT $LN15@WMNotify
  000ba	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA, bl ; CIME::ms_bUseIMMCandidate
  000c0	0f 84 85 00 00
	00		 je	 $LN2@WMNotify
$LN15@WMNotify:

; 2223 : 			break;
; 2224 : 		if (!m_bUseDefaultIME)

  000c6	38 5e 21	 cmp	 BYTE PTR [esi+33], bl
  000c9	75 07		 jne	 SHORT $LN16@WMNotify

; 2225 : 			CloseCandidateList();

  000cb	e8 00 00 00 00	 call	 ?CloseCandidateList@CIME@@SAXXZ ; CIME::CloseCandidateList
  000d0	eb 79		 jmp	 SHORT $LN2@WMNotify
$LN16@WMNotify:

; 2226 : 		else
; 2227 : 			result = DefWindowProc(hWnd, uiMsg, wParam, lParam);

  000d2	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  000d5	51		 push	 ecx
  000d6	ff 75 0c	 push	 DWORD PTR _uiMsg$[ebp]
  000d9	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  000e2	8b d8		 mov	 ebx, eax

; 2228 : 		break;

  000e4	eb 65		 jmp	 SHORT $LN2@WMNotify
$LN18@WMNotify:

; 2229 : 
; 2230 : 	case IMN_SETCONVERSIONMODE:
; 2231 : 	case IMN_SETOPENSTATUS:
; 2232 : 		if (ms_bUILessMode)

  000e6	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, bl ; CIME::ms_bUILessMode
  000ec	75 5d		 jne	 SHORT $LN2@WMNotify

; 2233 : 			break;
; 2234 : 		CheckToggleState();

  000ee	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState

; 2235 : 		break;

  000f3	eb 56		 jmp	 SHORT $LN2@WMNotify
$LN21@WMNotify:

; 2236 : 
; 2237 : 	case IMN_PRIVATE: {
; 2238 : 		if (ms_bUILessMode)

  000f5	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, bl ; CIME::ms_bUILessMode
  000fb	75 4e		 jne	 SHORT $LN2@WMNotify

; 2239 : 			break;
; 2240 : 		HIMC hImc = ImmGetContext(hWnd);

  000fd	8b 5d 08	 mov	 ebx, DWORD PTR _hWnd$[ebp]
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _ImmGetContext@4
  00106	8b f8		 mov	 edi, eax

; 2241 : 		if (hImc == NULL)

  00108	85 ff		 test	 edi, edi
  0010a	74 3d		 je	 SHORT $LN46@WMNotify

; 2242 : 			break;
; 2243 :         ReadingProcess(hImc);

  0010c	57		 push	 edi
  0010d	8b ce		 mov	 ecx, esi
  0010f	e8 00 00 00 00	 call	 ?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::ReadingProcess

; 2244 : 
; 2245 : 		// Trap some messages to hide reading window
; 2246 :         switch(ms_adwId[0])

  00114	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_adwId@CIME@@2PAKA
  0011a	81 f9 04 04 00
	05		 cmp	 ecx, 83887108		; 05000404H
  00120	77 62		 ja	 SHORT $LN40@WMNotify
  00122	0f 84 80 00 00
	00		 je	 $LN31@WMNotify
  00128	81 f9 04 08 02
	04		 cmp	 ecx, 67241988		; 04020804H
  0012e	77 35		 ja	 SHORT $LN41@WMNotify
  00130	74 43		 je	 SHORT $LN24@WMNotify
  00132	81 f9 04 08 01
	04		 cmp	 ecx, 67176452		; 04010804H
  00138	74 3b		 je	 SHORT $LN24@WMNotify
  0013a	81 f9 04 04 02
	04		 cmp	 ecx, 67240964		; 04020404H
  00140	74 33		 je	 SHORT $LN24@WMNotify
$LN36@WMNotify:

; 2264 :                 break;
; 2265 :         }
; 2266 : 		ImmReleaseContext(hWnd, hImc);

  00142	57		 push	 edi
  00143	53		 push	 ebx
  00144	e8 00 00 00 00	 call	 _ImmReleaseContext@8
$LN46@WMNotify:

; 2267 : 		break;
; 2268 : 		}
; 2269 : 	}
; 2270 : 
; 2271 : 	if(ms_pEvent)

  00149	33 db		 xor	 ebx, ebx
$LN2@WMNotify:
  0014b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00151	85 c9		 test	 ecx, ecx
  00153	74 05		 je	 SHORT $LN38@WMNotify

; 2272 : 		ms_pEvent->OnUpdate();

  00155	8b 01		 mov	 eax, DWORD PTR [ecx]
  00157	ff 50 04	 call	 DWORD PTR [eax+4]
$LN38@WMNotify:

; 2273 : 
; 2274 : 	return result;

  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	8b c3		 mov	 eax, ebx

; 2275 : }

  0015e	5b		 pop	 ebx
  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 10 00	 ret	 16			; 00000010H
$LN41@WMNotify:

; 2244 : 
; 2245 : 		// Trap some messages to hide reading window
; 2246 :         switch(ms_adwId[0])

  00165	81 f9 04 04 03
	04		 cmp	 ecx, 67306500		; 04030404H
  0016b	74 08		 je	 SHORT $LN24@WMNotify
  0016d	81 f9 04 04 04
	04		 cmp	 ecx, 67372036		; 04040404H
  00173	75 cd		 jne	 SHORT $LN36@WMNotify
$LN24@WMNotify:

; 2247 :         {
; 2248 :             case IMEID_CHT_VER42:
; 2249 :             case IMEID_CHT_VER43:
; 2250 :             case IMEID_CHT_VER44:
; 2251 :             case IMEID_CHS_VER41:
; 2252 :             case IMEID_CHS_VER42:
; 2253 : 				if ((lParam == 1)||(lParam == 2))

  00175	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00178	83 f8 01	 cmp	 eax, 1
  0017b	74 4b		 je	 SHORT $LN37@WMNotify
  0017d	83 f8 02	 cmp	 eax, 2
  00180	74 46		 je	 SHORT $LN37@WMNotify
  00182	eb be		 jmp	 SHORT $LN36@WMNotify
$LN40@WMNotify:

; 2244 : 
; 2245 : 		// Trap some messages to hide reading window
; 2246 :         switch(ms_adwId[0])

  00184	81 f9 04 08 03
	05		 cmp	 ecx, 84084740		; 05030804H
  0018a	77 14		 ja	 SHORT $LN42@WMNotify
  0018c	74 1a		 je	 SHORT $LN31@WMNotify
  0018e	81 f9 04 04 01
	05		 cmp	 ecx, 83952644		; 05010404H
  00194	74 12		 je	 SHORT $LN31@WMNotify
  00196	81 f9 04 04 02
	05		 cmp	 ecx, 84018180		; 05020404H
  0019c	74 0a		 je	 SHORT $LN31@WMNotify
  0019e	eb a2		 jmp	 SHORT $LN36@WMNotify
$LN42@WMNotify:
  001a0	81 f9 04 04 00
	06		 cmp	 ecx, 100664324		; 06000404H
  001a6	75 9a		 jne	 SHORT $LN36@WMNotify
$LN31@WMNotify:

; 2254 : 					return true;
; 2255 :                 break;
; 2256 : 
; 2257 :             case IMEID_CHT_VER50:
; 2258 :             case IMEID_CHT_VER51:
; 2259 :             case IMEID_CHT_VER52:
; 2260 :             case IMEID_CHT_VER60:
; 2261 :             case IMEID_CHS_VER53:
; 2262 :                 if ((lParam == 16)||(lParam == 17)||(lParam == 26)||(lParam == 27)||(lParam == 28))

  001a8	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  001ab	83 f8 10	 cmp	 eax, 16			; 00000010H
  001ae	74 18		 je	 SHORT $LN37@WMNotify
  001b0	83 f8 11	 cmp	 eax, 17			; 00000011H
  001b3	74 13		 je	 SHORT $LN37@WMNotify
  001b5	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  001b8	74 0e		 je	 SHORT $LN37@WMNotify
  001ba	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  001bd	74 09		 je	 SHORT $LN37@WMNotify
  001bf	83 f8 1c	 cmp	 eax, 28			; 0000001cH
  001c2	0f 85 7a ff ff
	ff		 jne	 $LN36@WMNotify
$LN37@WMNotify:
  001c8	5f		 pop	 edi
  001c9	5e		 pop	 esi

; 2263 : 					return true;

  001ca	b8 01 00 00 00	 mov	 eax, 1

; 2275 : }

  001cf	5b		 pop	 ebx
  001d0	8b e5		 mov	 esp, ebp
  001d2	5d		 pop	 ebp
  001d3	c2 10 00	 ret	 16			; 00000010H
  001d6	66 90		 npad	 2
$LN44@WMNotify:
  001d8	00 00 00 00	 DD	 $LN7@WMNotify
  001dc	00 00 00 00	 DD	 $LN14@WMNotify
  001e0	00 00 00 00	 DD	 $LN18@WMNotify
  001e4	00 00 00 00	 DD	 $LN21@WMNotify
  001e8	00 00 00 00	 DD	 $LN2@WMNotify
$LN43@WMNotify:
  001ec	00		 DB	 0
  001ed	01		 DB	 1
  001ee	00		 DB	 0
  001ef	02		 DB	 2
  001f0	04		 DB	 4
  001f1	02		 DB	 2
  001f2	04		 DB	 4
  001f3	04		 DB	 4
  001f4	04		 DB	 4
  001f5	04		 DB	 4
  001f6	04		 DB	 4
  001f7	03		 DB	 3
?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP		; CIME::WMNotify
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z PROC	; CIME::WMEndComposition, COMDAT
; _this$ = ecx

; 2187 : 	ms_compLen = 0;
; 2188 : 	ms_ulbegin = 0;
; 2189 : 	ms_ulend = 0;
; 2190 : 
; 2191 : 	if(ms_pEvent)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen
  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulbegin@CIME@@2HA, 0 ; CIME::ms_ulbegin
  0001a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulend@CIME@@2HA, 0 ; CIME::ms_ulend
  00024	85 c9		 test	 ecx, ecx
  00026	74 05		 je	 SHORT $LN4@WMEndCompo

; 2192 : 		ms_pEvent->OnUpdate();

  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN4@WMEndCompo:

; 2193 : 
; 2194 : 	return 0L;
; 2195 : }

  0002d	33 c0		 xor	 eax, eax
  0002f	c2 10 00	 ret	 16			; 00000010H
?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP	; CIME::WMEndComposition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_lParam$ = 20						; size = 4
tv173 = 20						; size = 4
?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z PROC		; CIME::WMComposition, COMDAT
; _this$ = ecx

; 2147 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2148 : 	LRESULT		result = 0;
; 2149 : 
; 2150 : 	if(ms_bCaptureInput == false)

  00003	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 0 ; CIME::ms_bCaptureInput
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	74 7d		 je	 SHORT $LN16@WMComposit

; 2151 : 		return 0;
; 2152 : 
; 2153 : 	HIMC hImc = ImmGetContext(hWnd);

  0000f	56		 push	 esi
  00010	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00013	e8 00 00 00 00	 call	 _ImmGetContext@4
  00018	8b f0		 mov	 esi, eax

; 2154 : 
; 2155 : 	if(hImc == NULL)

  0001a	85 f6		 test	 esi, esi
  0001c	74 66		 je	 SHORT $LN17@WMComposit

; 2156 : 		return 0;
; 2157 : 
; 2158 : 	if(lParam&GCS_RESULTSTR)

  0001e	53		 push	 ebx
  0001f	8b 5d 14	 mov	 ebx, DWORD PTR _lParam$[ebp]
  00022	f7 c3 00 08 00
	00		 test	 ebx, 2048		; 00000800H
  00028	74 08		 je	 SHORT $LN4@WMComposit

; 2159 : 		ResultProcess(hImc);

  0002a	56		 push	 esi
  0002b	8b cf		 mov	 ecx, edi
  0002d	e8 00 00 00 00	 call	 ?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::ResultProcess
$LN4@WMComposit:

; 2160 : 	if(lParam&GCS_COMPATTR)

  00032	8b c3		 mov	 eax, ebx
  00034	83 e0 10	 and	 eax, 16			; 00000010H
  00037	89 45 14	 mov	 DWORD PTR tv173[ebp], eax
  0003a	74 0b		 je	 SHORT $LN5@WMComposit

; 2161 : 		AttributeProcess(hImc);

  0003c	56		 push	 esi
  0003d	8b cf		 mov	 ecx, edi
  0003f	e8 00 00 00 00	 call	 ?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::AttributeProcess
  00044	8b 45 14	 mov	 eax, DWORD PTR tv173[ebp]
$LN5@WMComposit:

; 2162 : 	if(lParam&GCS_COMPSTR)

  00047	f6 c3 08	 test	 bl, 8
  0004a	5b		 pop	 ebx
  0004b	74 1f		 je	 SHORT $LN8@WMComposit

; 2163 : 	{
; 2164 : 		if (ms_uOutputCodePage == 950)

  0004d	81 3d 00 00 00
	00 b6 03 00 00	 cmp	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, 950 ; CIME::ms_uOutputCodePage, 000003b6H
  00057	8b cf		 mov	 ecx, edi
  00059	56		 push	 esi
  0005a	75 0b		 jne	 SHORT $LN7@WMComposit

; 2165 : 		{
; 2166 : 			if (lParam&GCS_COMPATTR)

  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN7@WMComposit

; 2167 : 				CompositionProcessBuilding(hImc);

  00060	e8 00 00 00 00	 call	 ?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CompositionProcessBuilding
  00065	eb 05		 jmp	 SHORT $LN8@WMComposit
$LN7@WMComposit:

; 2168 : 			else
; 2169 : 				CompositionProcess(hImc);
; 2170 : 		}
; 2171 : 		else
; 2172 : 		{
; 2173 : 			CompositionProcess(hImc);
; 2174 : 		}
; 2175 : 	}
; 2176 : 
; 2177 : 	ImmReleaseContext(hWnd, hImc);

  00067	e8 00 00 00 00	 call	 ?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CompositionProcess
$LN8@WMComposit:
  0006c	56		 push	 esi
  0006d	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00070	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 2178 : 
; 2179 : 	if(ms_pEvent)

  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0007b	85 c9		 test	 ecx, ecx
  0007d	74 05		 je	 SHORT $LN17@WMComposit

; 2180 : 		ms_pEvent->OnUpdate();

  0007f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00081	ff 50 04	 call	 DWORD PTR [eax+4]
$LN17@WMComposit:

; 2181 : 
; 2182 : 	return (result);

  00084	5e		 pop	 esi
  00085	33 c0		 xor	 eax, eax
  00087	5f		 pop	 edi

; 2183 : }

  00088	5d		 pop	 ebp
  00089	c2 10 00	 ret	 16			; 00000010H
$LN16@WMComposit:

; 2181 : 
; 2182 : 	return (result);

  0008c	33 c0		 xor	 eax, eax
  0008e	5f		 pop	 edi

; 2183 : }

  0008f	5d		 pop	 ebp
  00090	c2 10 00	 ret	 16			; 00000010H
?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP		; CIME::WMComposition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z PROC	; CIME::WMStartComposition, COMDAT
; _this$ = ecx

; 2143 : 	return 1L;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 2144 : }

  00005	c2 10 00	 ret	 16			; 00000010H
?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP	; CIME::WMStartComposition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z PROC	; CIME::WMInputLanguage, COMDAT
; _this$ = ecx

; 2137 : 	ChangeInputLanguage();

  00000	e8 00 00 00 00	 call	 ?ChangeInputLanguage@CIME@@SAXXZ ; CIME::ChangeInputLanguage

; 2138 : 	return 0;

  00005	33 c0		 xor	 eax, eax

; 2139 : }

  00007	c2 10 00	 ret	 16			; 00000010H
?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP	; CIME::WMInputLanguage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?ChangeInputLanguageWorker@CIME@@SAXXZ
_TEXT	SEGMENT
?ChangeInputLanguageWorker@CIME@@SAXXZ PROC		; CIME::ChangeInputLanguageWorker, COMDAT

; 771  : 	if ( !ms_bUILessMode )

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  00007	75 14		 jne	 SHORT $LN2@ChangeInpu

; 772  : 		ms_iCandListIndexBase = ( ms_hklCurrent == _CHT_HKL_DAYI ) ? 0 : 1;

  00009	33 c0		 xor	 eax, eax
  0000b	81 3d 00 00 00
	00 04 04 06 e0	 cmp	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, -536476668 ; CIME::ms_hklCurrent, e0060404H
  00015	0f 95 c0	 setne	 al
  00018	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iCandListIndexBase@CIME@@2HA, eax ; CIME::ms_iCandListIndexBase
$LN2@ChangeInpu:

; 773  : 	SetupImeApi();

  0001d	e9 00 00 00 00	 jmp	 ?SetupImeApi@CIME@@KAXXZ ; CIME::SetupImeApi
?ChangeInputLanguageWorker@CIME@@SAXXZ ENDP		; CIME::ChangeInputLanguageWorker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?ChangeInputLanguage@CIME@@SAXXZ
_TEXT	SEGMENT
?ChangeInputLanguage@CIME@@SAXXZ PROC			; CIME::ChangeInputLanguage, COMDAT

; 746  : {

  00000	56		 push	 esi

; 747  : 	UINT uLanguage = (UINT) GETLANG();

  00001	0f b7 35 00 00
	00 00		 movzx	 esi, WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A

; 748  : 	CheckToggleState();

  00008	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState

; 749  : 	ChangeInputLanguageWorker();

  0000d	e8 00 00 00 00	 call	 ?ChangeInputLanguageWorker@CIME@@SAXXZ ; CIME::ChangeInputLanguageWorker

; 750  : 	if (uLanguage != GETLANG())

  00012	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A
  00019	66 3b f1	 cmp	 si, cx
  0001c	5e		 pop	 esi
  0001d	74 1f		 je	 SHORT $LN2@ChangeInpu

; 751  : 	{
; 752  : 		// Korean IME always uses level 3 support.
; 753  : 		// Other languages use the level that is specified by ImeUi_SetSupportLevel()
; 754  : 		SetSupportLevel( ( GETPRIMLANG() == LANG_KOREAN ) ? 3 : ms_dwIMELevelSaved );

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwIMELevelSaved@CIME@@2KA ; CIME::ms_dwIMELevelSaved
  00024	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0002a	83 f9 12	 cmp	 ecx, 18			; 00000012H
  0002d	ba 03 00 00 00	 mov	 edx, 3
  00032	0f 44 c2	 cmove	 eax, edx
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?SetSupportLevel@CIME@@KAXK@Z ; CIME::SetSupportLevel
  0003b	83 c4 04	 add	 esp, 4
$LN2@ChangeInpu:

; 755  : 	}
; 756  : 
; 757  : 	if(ms_pEvent)

  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00044	85 c9		 test	 ecx, ecx
  00046	74 05		 je	 SHORT $LN3@ChangeInpu

; 758  : 		ms_pEvent->OnChangeCodePage();

  00048	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004a	ff 60 08	 jmp	 DWORD PTR [eax+8]
$LN3@ChangeInpu:

; 759  : 
; 760  : 	//HWND hwndImeDef = ImmGetDefaultIMEWnd(ms_hWnd);
; 761  : 	//if ( hwndImeDef )
; 762  : 	//{
; 763  : 	//	// Fix for Zooty #3995: prevent CHT IME toobar from showing up
; 764  : 	//	SendMessageA(hwndImeDef, WM_IME_CONTROL, IMC_OPENSTATUSWINDOW, 0);
; 765  : 	//	SendMessageA(hwndImeDef, WM_IME_CONTROL, IMC_CLOSESTATUSWINDOW, 0);
; 766  : 	//}
; 767  : }

  0004d	c3		 ret	 0
?ChangeInputLanguage@CIME@@SAXXZ ENDP			; CIME::ChangeInputLanguage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?CloseReadingInformation@CIME@@SAXXZ
_TEXT	SEGMENT
?CloseReadingInformation@CIME@@SAXXZ PROC		; CIME::CloseReadingInformation, COMDAT

; 740  : 	CIME::ms_bReadingInformation = false;
; 741  : 	if(CIME::ms_pEvent)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00006	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 0 ; CIME::ms_bReadingInformation
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 05		 je	 SHORT $LN2@CloseReadi

; 742  : 		CIME::ms_pEvent->OnCloseReadingWnd();

  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	ff 60 18	 jmp	 DWORD PTR [eax+24]
$LN2@CloseReadi:

; 743  : }

  00016	c3		 ret	 0
?CloseReadingInformation@CIME@@SAXXZ ENDP		; CIME::CloseReadingInformation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?CloseCandidateList@CIME@@SAXXZ
_TEXT	SEGMENT
?CloseCandidateList@CIME@@SAXXZ PROC			; CIME::CloseCandidateList, COMDAT

; 731  : 	ms_bCandidateList = false;
; 732  : 	ms_dwCandidateCount = 0;
; 733  : 	memset(&ms_wszCandidate, 0, sizeof(ms_wszCandidate));

  00000	68 00 14 00 00	 push	 5120			; 00001400H
  00005	6a 00		 push	 0
  00007	68 00 00 00 00	 push	 OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  0000c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 0 ; CIME::ms_bCandidateList
  00013	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, 0 ; CIME::ms_dwCandidateCount
  0001d	e8 00 00 00 00	 call	 _memset

; 734  : 	if(ms_pEvent)

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	85 c9		 test	 ecx, ecx
  0002d	74 05		 je	 SHORT $LN2@CloseCandi

; 735  : 		ms_pEvent->OnCloseCandidateList();

  0002f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00031	ff 60 10	 jmp	 DWORD PTR [eax+16]
$LN2@CloseCandi:

; 736  : }

  00034	c3		 ret	 0
?CloseCandidateList@CIME@@SAXXZ ENDP			; CIME::CloseCandidateList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetULEnd@CIME@@SAHXZ
_TEXT	SEGMENT
?GetULEnd@CIME@@SAHXZ PROC				; CIME::GetULEnd, COMDAT

; 726  : 	return ms_ulend;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_ulend@CIME@@2HA ; CIME::ms_ulend

; 727  : }

  00005	c3		 ret	 0
?GetULEnd@CIME@@SAHXZ ENDP				; CIME::GetULEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetULBegin@CIME@@SAHXZ
_TEXT	SEGMENT
?GetULBegin@CIME@@SAHXZ PROC				; CIME::GetULBegin, COMDAT

; 721  : 	return ms_ulbegin;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_ulbegin@CIME@@2HA ; CIME::ms_ulbegin

; 722  : }

  00005	c3		 ret	 0
?GetULBegin@CIME@@SAHXZ ENDP				; CIME::GetULBegin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetCompLen@CIME@@SAHXZ
_TEXT	SEGMENT
?GetCompLen@CIME@@SAHXZ PROC				; CIME::GetCompLen, COMDAT

; 716  : 	return ms_compLen;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_compLen@CIME@@2HA ; CIME::ms_compLen

; 717  : }

  00005	c3		 ret	 0
?GetCompLen@CIME@@SAHXZ ENDP				; CIME::GetCompLen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetCurPos@CIME@@SAHXZ
_TEXT	SEGMENT
?GetCurPos@CIME@@SAHXZ PROC				; CIME::GetCurPos, COMDAT

; 821  : 	int pos = GetTextTagOutputLen(m_wText, ms_curpos);

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00006	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0000b	e8 00 00 00 00	 call	 ?GetTextTagOutputLen@@YAHPB_WH@Z ; GetTextTagOutputLen
  00010	83 c4 08	 add	 esp, 8

; 822  : 	return pos;
; 823  : 	//return ms_curpos;
; 824  : }

  00013	c3		 ret	 0
?GetCurPos@CIME@@SAHXZ ENDP				; CIME::GetCurPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?UseDefaultIME@CIME@@QAEXXZ
_TEXT	SEGMENT
?UseDefaultIME@CIME@@QAEXXZ PROC			; CIME::UseDefaultIME, COMDAT
; _this$ = ecx

; 377  : 	m_bUseDefaultIME = true;

  00000	c6 41 21 01	 mov	 BYTE PTR [ecx+33], 1

; 378  : }

  00004	c3		 ret	 0
?UseDefaultIME@CIME@@QAEXXZ ENDP			; CIME::UseDefaultIME
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?FinalizeString@CIME@@SAX_N@Z
_TEXT	SEGMENT
_bSend$ = 8						; size = 1
?FinalizeString@CIME@@SAX_N@Z PROC			; CIME::FinalizeString, COMDAT

; 677  : 	HIMC himc;
; 678  : 	static bool s_bProcessing = false; // to avoid infinite recursion
; 679  : 	if ( !ms_bInitialized || s_bProcessing || NULL == ( himc = ImmGetContext( ms_hWnd ) ) )

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
  00007	74 6c		 je	 SHORT $LN3@FinalizeSt
  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA, 0
  00010	75 63		 jne	 SHORT $LN3@FinalizeSt
  00012	56		 push	 esi
  00013	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00019	e8 00 00 00 00	 call	 _ImmGetContext@4
  0001e	8b f0		 mov	 esi, eax
  00020	85 f6		 test	 esi, esi
  00022	74 50		 je	 SHORT $LN11@FinalizeSt

; 680  : 		return;
; 681  : 	s_bProcessing = true;
; 682  : 
; 683  : 	if (ms_dwIMELevel == 2 && bSend)
; 684  : 	{
; 685  : 		//// Send composition string to app.
; 686  : 		//LONG lRet = lstrlenW( m_wszComposition );
; 687  : 		////assert( lRet >= 2);
; 688  : 		//// In case of CHT IME, don't send the trailing double byte space, if it exists.
; 689  : 		//if ( GETLANG() == LANG_CHT && (lRet >= 1)
; 690  : 		//	&& m_wszComposition[lRet - 1] == 0x3000 )
; 691  : 		//{
; 692  : 		//	lRet--;
; 693  : 		//}
; 694  : 		//SendCompString();
; 695  : 	}
; 696  : 
; 697  : 	//InitCompStringData();
; 698  : 	// clear composition string in IME
; 699  : 	ImmNotifyIME(himc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);

  00024	6a 00		 push	 0
  00026	6a 04		 push	 4
  00028	6a 15		 push	 21			; 00000015H
  0002a	56		 push	 esi
  0002b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA, 1
  00032	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 700  : 	if (ms_bUILessMode)

  00037	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  0003e	74 10		 je	 SHORT $LN5@FinalizeSt

; 701  : 	{
; 702  : 		// For some reason ImmNotifyIME doesn't work on DaYi and Array CHT IMEs. Cancel composition string by setting zero-length string.
; 703  : 		ImmSetCompositionStringW(himc, SCS_SETSTR, NULL, 0, NULL, 0);

  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	6a 00		 push	 0
  00048	6a 09		 push	 9
  0004a	56		 push	 esi
  0004b	e8 00 00 00 00	 call	 _ImmSetCompositionStringW@24
$LN5@FinalizeSt:

; 704  : 	}
; 705  : 	// the following line is necessary as Korean IME doesn't close cand list when comp string is cancelled.
; 706  : 	ImmNotifyIME( himc, NI_CLOSECANDIDATE, 0, 0 );

  00050	6a 00		 push	 0
  00052	6a 00		 push	 0
  00054	6a 11		 push	 17			; 00000011H
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 707  : 	ImmReleaseContext(ms_hWnd, himc);

  0005c	56		 push	 esi
  0005d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00063	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 708  : 	// Zooty2 RAID #4759: Sometimes application doesn't receive IMN_CLOSECANDIDATE on Alt+Tab
; 709  : 	// So the same code for IMN_CLOSECANDIDATE is replicated here.
; 710  : 	CloseCandidateList();

  00068	e8 00 00 00 00	 call	 ?CloseCandidateList@CIME@@SAXXZ ; CIME::CloseCandidateList

; 711  : 	s_bProcessing = false;

  0006d	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA, 0
$LN11@FinalizeSt:
  00074	5e		 pop	 esi
$LN3@FinalizeSt:

; 712  : }

  00075	c3		 ret	 0
?FinalizeString@CIME@@SAX_N@Z ENDP			; CIME::FinalizeString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?PasteString@CIME@@QAEXPBD@Z
_TEXT	SEGMENT
_m_wText$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
?PasteString@CIME@@QAEXPBD@Z PROC			; CIME::PasteString, COMDAT
; _this$ = ecx

; 853  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]

; 854  : 	const char * begin = str;
; 855  : 	const char * end = str + strlen(str);

  00016	8b c2		 mov	 eax, edx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b f1		 mov	 esi, ecx
  0001c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001f	90		 npad	 1
$LL4@PasteStrin:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL4@PasteStrin

; 856  : 	wchar_t m_wText[IMESTR_MAXLEN];
; 857  : 	int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, begin, end - begin, m_wText, IMESTR_MAXLEN);

  00027	68 00 04 00 00	 push	 1024			; 00000400H
  0002c	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _m_wText$[ebp]
  00032	2b c7		 sub	 eax, edi
  00034	51		 push	 ecx
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	6a 00		 push	 0
  00039	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 858  : 	InsertString(m_wText, wstrLen);

  00045	50		 push	 eax
  00046	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _m_wText$[ebp]
  0004c	8b ce		 mov	 ecx, esi
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString

; 859  : 	if(ms_pEvent)

  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	85 c9		 test	 ecx, ecx
  0005e	74 05		 je	 SHORT $LN2@PasteStrin

; 860  : 		ms_pEvent->OnUpdate();

  00060	8b 01		 mov	 eax, DWORD PTR [ecx]
  00062	ff 50 04	 call	 DWORD PTR [eax+4]
$LN2@PasteStrin:

; 861  : }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?PasteString@CIME@@QAEXPBD@Z ENDP			; CIME::PasteString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?EnablePaste@CIME@@QAEX_N@Z
_TEXT	SEGMENT
_bFlag$ = 8						; size = 1
?EnablePaste@CIME@@QAEX_N@Z PROC			; CIME::EnablePaste, COMDAT
; _this$ = ecx

; 631  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 	m_bEnablePaste = bFlag;

  00003	8a 45 08	 mov	 al, BYTE PTR _bFlag$[ebp]
  00006	88 41 20	 mov	 BYTE PTR [ecx+32], al

; 633  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?EnablePaste@CIME@@QAEX_N@Z ENDP			; CIME::EnablePaste
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?PasteTextFromClipBoard@CIME@@QAEXXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -2104					; size = 4
_handle$1$ = -2100					; size = 4
_buffer$1$ = -2096					; size = 4
$T2 = -2092						; size = 4
_strClipboard$ = -2088					; size = 24
_m_wText$ = -2064					; size = 2048
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PasteTextFromClipBoard@CIME@@QAEXXZ PROC		; CIME::PasteTextFromClipBoard, COMDAT
; _this$ = ecx

; 636  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?PasteTextFromClipBoard@CIME@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 2c 08 00
	00		 sub	 esp, 2092		; 0000082cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b c1		 mov	 eax, ecx
  0002f	89 85 c8 f7 ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], eax

; 637  : 	if (!m_bEnablePaste)

  00035	80 78 20 00	 cmp	 BYTE PTR [eax+32], 0
  00039	0f 84 e0 01 00
	00		 je	 $LN86@PasteTextF

; 638  : 		return;
; 639  : 
; 640  : 	if (!OpenClipboard(NULL))

  0003f	6a 00		 push	 0
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenClipboard@4
  00047	85 c0		 test	 eax, eax
  00049	0f 84 d0 01 00
	00		 je	 $LN86@PasteTextF

; 641  : 		return;
; 642  : 
; 643  : 	HANDLE handle = GetClipboardData(CF_TEXT);

  0004f	6a 01		 push	 1
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardData@4
  00057	8b f0		 mov	 esi, eax
  00059	89 b5 cc f7 ff
	ff		 mov	 DWORD PTR _handle$1$[ebp], esi

; 644  : 	if (!handle) // @fixme008

  0005f	85 f6		 test	 esi, esi
  00061	74 1a		 je	 SHORT $LN150@PasteTextF

; 645  : 	{
; 646  : 		CloseClipboard();
; 647  : 		return;
; 648  : 	}
; 649  : 	char * buffer = (char*)GlobalLock(handle);

  00063	56		 push	 esi
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  0006a	8b f8		 mov	 edi, eax
  0006c	89 bd d0 f7 ff
	ff		 mov	 DWORD PTR _buffer$1$[ebp], edi

; 650  : 	if (!buffer) // @fixme008

  00072	85 ff		 test	 edi, edi
  00074	75 12		 jne	 SHORT $LN5@PasteTextF

; 651  : 	{
; 652  : 		GlobalUnlock(handle);

  00076	56		 push	 esi
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4
$LN150@PasteTextF:

; 673  : }

  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseClipboard@0
  00083	e9 97 01 00 00	 jmp	 $LN86@PasteTextF
$LN5@PasteTextF:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  00088	8b f7		 mov	 esi, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 498  :     size_type _Mysize = 0; // current length of string (size)

  0008a	c7 85 e8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _strClipboard$[ebp+16], 0
  00094	0f 57 c0	 xorps	 xmm0, xmm0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00097	c7 85 ec f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _strClipboard$[ebp+20], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  000a1	0f 11 85 d8 f7
	ff ff		 movups	 XMMWORD PTR _strClipboard$[ebp], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  000a8	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  000ab	0f 1f 44 00 00	 npad	 5
$LL144@PasteTextF:
  000b0	8a 06		 mov	 al, BYTE PTR [esi]
  000b2	46		 inc	 esi
  000b3	84 c0		 test	 al, al
  000b5	75 f9		 jne	 SHORT $LL144@PasteTextF
  000b7	2b f1		 sub	 esi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 857  :         if (_Count > max_size()) {

  000b9	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  000bf	0f 87 75 01 00
	00		 ja	 $LN152@PasteTextF

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();
; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

  000c5	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  000c8	77 28		 ja	 SHORT $LN33@PasteTextF
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ca	56		 push	 esi
  000cb	8d 85 d8 f7 ff
	ff		 lea	 eax, DWORD PTR _strClipboard$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 866  :             _My_data._Mysize = _Count;

  000d1	89 b5 e8 f7 ff
	ff		 mov	 DWORD PTR _strClipboard$[ebp+16], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d7	57		 push	 edi
  000d8	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 867  :             _My_data._Myres  = _Small_string_capacity;

  000d9	c7 85 ec f7 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _strClipboard$[ebp+20], 15 ; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000e3	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  000e8	c6 84 35 d8 f7
	ff ff 00	 mov	 BYTE PTR _strClipboard$[ebp+esi], 0

; 875  :             } else { // _Strat == _Construct_strategy::_From_string
; 876  : #ifdef _INSERT_STRING_ANNOTATION
; 877  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 878  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 879  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 880  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 881  :             }
; 882  : 
; 883  :             _Proxy._Release();
; 884  :             return;

  000f0	eb 77		 jmp	 SHORT $LN147@PasteTextF
$LN33@PasteTextF:

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  000f2	8b fe		 mov	 edi, esi
  000f4	83 cf 0f	 or	 edi, 15			; 0000000fH
  000f7	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  000fd	76 12		 jbe	 SHORT $LN39@PasteTextF

; 2944 :             return _Max;

  000ff	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00104	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00109	50		 push	 eax
  0010a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0010f	eb 26		 jmp	 SHORT $LN149@PasteTextF
$LN39@PasteTextF:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00111	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00116	3b f8		 cmp	 edi, eax
  00118	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0011b	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  0011e	85 c0		 test	 eax, eax
  00120	74 18		 je	 SHORT $LN148@PasteTextF
$LN53@PasteTextF:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00122	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00127	72 08		 jb	 SHORT $LN54@PasteTextF

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0012f	eb 06		 jmp	 SHORT $LN149@PasteTextF
$LN54@PasteTextF:

; 136  :         return ::operator new(_Bytes);

  00131	50		 push	 eax
  00132	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN149@PasteTextF:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00137	83 c4 04	 add	 esp, 4
$LN148@PasteTextF:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0013a	56		 push	 esi
  0013b	ff b5 d0 f7 ff
	ff		 push	 DWORD PTR _buffer$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00141	89 85 d4 f7 ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00147	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00148	89 85 d8 f7 ff
	ff		 mov	 DWORD PTR _strClipboard$[ebp], eax

; 890  : 
; 891  :         _My_data._Mysize = _Count;

  0014e	89 b5 e8 f7 ff
	ff		 mov	 DWORD PTR _strClipboard$[ebp+16], esi

; 892  :         _My_data._Myres  = _New_capacity;

  00154	89 bd ec f7 ff
	ff		 mov	 DWORD PTR _strClipboard$[ebp+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0015a	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  0015f	8b 85 d4 f7 ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00165	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0
$LN147@PasteTextF:
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 656  : 	std::string strClipboard = buffer;

  00169	83 c4 0c	 add	 esp, 12			; 0000000cH

; 657  : 	GlobalUnlock(handle);

  0016c	ff b5 cc f7 ff
	ff		 push	 DWORD PTR _handle$1$[ebp]
  00172	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00179	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 658  : 	CloseClipboard();

  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseClipboard@0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2458 :         return _Mypair._Myval2._Mysize == 0;

  00185	8b 85 e8 f7 ff
	ff		 mov	 eax, DWORD PTR _strClipboard$[ebp+16]
  0018b	85 c0		 test	 eax, eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 660  : 	if (strClipboard.empty())

  0018d	74 5a		 je	 SHORT $LN8@PasteTextF
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0018f	83 bd ec f7 ff
	ff 0f		 cmp	 DWORD PTR _strClipboard$[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00196	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR _strClipboard$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 666  : 	int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, begin, end-begin, m_wText, IMESTR_MAXLEN);

  0019c	68 00 04 00 00	 push	 1024			; 00000400H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  001a1	0f 47 8d d8 f7
	ff ff		 cmova	 ecx, DWORD PTR _strClipboard$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 666  : 	int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, begin, end-begin, m_wText, IMESTR_MAXLEN);

  001a8	8d 95 f0 f7 ff
	ff		 lea	 edx, DWORD PTR _m_wText$[ebp]
  001ae	52		 push	 edx
  001af	03 c1		 add	 eax, ecx
  001b1	2b c1		 sub	 eax, ecx
  001b3	50		 push	 eax
  001b4	51		 push	 ecx
  001b5	6a 00		 push	 0
  001b7	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  001bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 667  : 	if (wstrLen <= 0) // @fixme008

  001c3	85 c0		 test	 eax, eax
  001c5	7e 22		 jle	 SHORT $LN8@PasteTextF

; 668  : 		return;
; 669  : 
; 670  : 	InsertString(m_wText, wstrLen);

  001c7	8b 8d c8 f7 ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  001cd	50		 push	 eax
  001ce	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _m_wText$[ebp]
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString

; 671  : 	if(ms_pEvent)

  001da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  001e0	85 c9		 test	 ecx, ecx
  001e2	74 05		 je	 SHORT $LN8@PasteTextF

; 672  : 		ms_pEvent->OnUpdate();

  001e4	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e6	ff 50 04	 call	 DWORD PTR [eax+4]
$LN8@PasteTextF:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  001e9	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _strClipboard$[ebp+20]
  001ef	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  001f2	76 2b		 jbe	 SHORT $LN86@PasteTextF
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001f4	8b 95 d8 f7 ff
	ff		 mov	 edx, DWORD PTR _strClipboard$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  001fa	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001fb	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001fd	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00203	72 10		 jb	 SHORT $LN97@PasteTextF

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00205	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00208	83 c1 23	 add	 ecx, 35			; 00000023H
  0020b	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0020d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00210	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00213	77 2a		 ja	 SHORT $LN153@PasteTextF
$LN97@PasteTextF:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00215	51		 push	 ecx
  00216	52		 push	 edx
  00217	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0021c	83 c4 08	 add	 esp, 8
$LN86@PasteTextF:
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 673  : }

  0021f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00222	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00229	59		 pop	 ecx
  0022a	5f		 pop	 edi
  0022b	5e		 pop	 esi
  0022c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022f	33 cd		 xor	 ecx, ebp
  00231	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00236	8b e5		 mov	 esp, ebp
  00238	5d		 pop	 ebp
  00239	c3		 ret	 0
$LN152@PasteTextF:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 858  :             _Xlen_string(); // result too long

  0023a	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN153@PasteTextF:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0023f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN146@PasteTextF:
  00244	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PasteTextFromClipBoard@CIME@@QAEXXZ$0:
  00000	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR _strClipboard$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?PasteTextFromClipBoard@CIME@@QAEXXZ:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a c8 f7 ff
	ff		 mov	 ecx, DWORD PTR [edx-2104]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PasteTextFromClipBoard@CIME@@QAEXXZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PasteTextFromClipBoard@CIME@@QAEXXZ ENDP		; CIME::PasteTextFromClipBoard
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?ClearExceptKey@CIME@@QAEXXZ
_TEXT	SEGMENT
?ClearExceptKey@CIME@@QAEXXZ PROC			; CIME::ClearExceptKey, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	3b 41 18	 cmp	 eax, DWORD PTR [ecx+24]
  00006	74 03		 je	 SHORT $LN3@ClearExcep

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00008	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN3@ClearExcep:
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 620  : }

  0000b	c3		 ret	 0
?ClearExceptKey@CIME@@QAEXXZ ENDP			; CIME::ClearExceptKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?AddExceptKey@CIME@@QAEX_W@Z
_TEXT	SEGMENT
__My_data$1$ = -16					; size = 4
__Oldsize$1$ = -12					; size = 4
tv606 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
$T1 = -4						; size = 4
_key$ = 8						; size = 2
?AddExceptKey@CIME@@QAEX_W@Z PROC			; CIME::AddExceptKey, COMDAT
; _this$ = ecx

; 613  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0000b	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 614  : 	m_exceptKey.push_back(key);

  0000e	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00011	8b 56 1c	 mov	 edx, DWORD PTR [esi+28]
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 614  : 	m_exceptKey.push_back(key);

  00014	89 45 f0	 mov	 DWORD PTR __My_data$1$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00017	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  0001a	3b ca		 cmp	 ecx, edx
  0001c	74 14		 je	 SHORT $LN6@AddExceptK

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  0001e	66 8b 45 08	 mov	 ax, WORD PTR _key$[ebp]
  00022	66 89 01	 mov	 WORD PTR [ecx], ax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00025	83 46 18 02	 add	 DWORD PTR [esi+24], 2
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 615  : }

  00029	5f		 pop	 edi
  0002a	5e		 pop	 esi
  0002b	5b		 pop	 ebx
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
$LN6@AddExceptK:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00032	8b 38		 mov	 edi, DWORD PTR [eax]
  00034	8b c1		 mov	 eax, ecx
  00036	2b c7		 sub	 eax, edi
  00038	d1 f8		 sar	 eax, 1
  0003a	89 45 f4	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);
; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0003d	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00042	0f 84 bd 00 00
	00		 je	 $LN109@AddExceptK

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00048	2b d7		 sub	 edx, edi

; 876  :         const size_type _Newsize = _Oldsize + 1;

  0004a	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0004d	d1 fa		 sar	 edx, 1

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00054	8b fa		 mov	 edi, edx

; 876  :         const size_type _Newsize = _Oldsize + 1;

  00056	89 5d f8	 mov	 DWORD PTR __Newsize$1$[ebp], ebx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00059	d1 ef		 shr	 edi, 1
  0005b	2b c7		 sub	 eax, edi
  0005d	3b d0		 cmp	 edx, eax
  0005f	76 12		 jbe	 SHORT $LN17@AddExceptK

; 1997 :             return _Max; // geometric growth would overflow

  00061	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00066	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00071	eb 34		 jmp	 SHORT $LN107@AddExceptK
$LN17@AddExceptK:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00073	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00076	3b c3		 cmp	 eax, ebx
  00078	0f 43 d8	 cmovae	 ebx, eax
  0007b	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00081	0f 87 83 00 00
	00		 ja	 $LN110@AddExceptK

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00087	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]

; 227  :     if (_Bytes == 0) {

  0008a	85 c0		 test	 eax, eax
  0008c	75 04		 jne	 SHORT $LN32@AddExceptK

; 228  :         return nullptr;

  0008e	33 ff		 xor	 edi, edi
  00090	eb 1d		 jmp	 SHORT $LN31@AddExceptK
$LN32@AddExceptK:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00092	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00097	72 08		 jb	 SHORT $LN33@AddExceptK

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009f	eb 06		 jmp	 SHORT $LN107@AddExceptK
$LN33@AddExceptK:

; 136  :         return ::operator new(_Bytes);

  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN107@AddExceptK:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  000aa	8b f8		 mov	 edi, eax
  000ac	83 c4 04	 add	 esp, 4
$LN31@AddExceptK:
  000af	8b 45 f4	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  000b2	8d 14 47	 lea	 edx, DWORD PTR [edi+eax*2]
  000b5	66 8b 45 08	 mov	 ax, WORD PTR _key$[ebp]
  000b9	66 89 02	 mov	 WORD PTR [edx], ax

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000bc	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000bf	89 55 f4	 mov	 DWORD PTR tv606[ebp], edx
  000c2	8b 56 14	 mov	 edx, DWORD PTR [esi+20]
  000c5	3b c8		 cmp	 ecx, eax
  000c7	75 04		 jne	 SHORT $LN12@AddExceptK
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000c9	8b cf		 mov	 ecx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000cb	eb 17		 jmp	 SHORT $LN61@AddExceptK
$LN12@AddExceptK:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cd	57		 push	 edi
  000ce	51		 push	 ecx
  000cf	52		 push	 edx
  000d0	e8 00 00 00 00	 call	 ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ; std::_Copy_memmove<wchar_t *,wchar_t *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR tv606[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000de	83 c1 02	 add	 ecx, 2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000e1	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
$LN61@AddExceptK:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 900  :         _Guard._New_begin = nullptr;

  000e4	51		 push	 ecx
  000e5	50		 push	 eax
  000e6	52		 push	 edx
  000e7	e8 00 00 00 00	 call	 ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ; std::_Copy_memmove<wchar_t *,wchar_t *>

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000ec	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$1$[ebp]
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	53		 push	 ebx
  000f3	ff 75 f8	 push	 DWORD PTR __Newsize$1$[ebp]
  000f6	57		 push	 edi
  000f7	e8 00 00 00 00	 call	 ?_Change_array@?$vector@_WV?$allocator@_W@std@@@std@@AAEXQA_WII@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Change_array
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 615  : }

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 04 00	 ret	 4
$LN109@AddExceptK:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00105	e8 00 00 00 00	 call	 ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN110@AddExceptK:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0010a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN106@AddExceptK:
  0010f	cc		 int	 3
?AddExceptKey@CIME@@QAEX_W@Z ENDP			; CIME::AddExceptKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?__IsWritable@CIME@@QAE_N_W@Z
_TEXT	SEGMENT
_key$ = 8						; size = 2
?__IsWritable@CIME@@QAE_N_W@Z PROC			; CIME::__IsWritable, COMDAT
; _this$ = ecx

; 623  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 6143 :             const auto _Result    = _STD _Find_vectorized(_First_ptr, _STD _To_address(_Last), _Val);

  00004	ff 75 08	 push	 DWORD PTR _key$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00007	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 6143 :             const auto _Result    = _STD _Find_vectorized(_First_ptr, _STD _To_address(_Last), _Val);

  0000a	56		 push	 esi
  0000b	ff 71 14	 push	 DWORD PTR [ecx+20]
  0000e	e8 00 00 00 00	 call	 ??$_Find_vectorized@_W_W@std@@YAPA_WQA_W0_W@Z ; std::_Find_vectorized<wchar_t,wchar_t>
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 166  :         return _Ptr == _Right._Ptr;

  00016	3b f0		 cmp	 esi, eax
  00018	0f 94 c0	 sete	 al
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 625  : 		return true;

  0001b	5e		 pop	 esi

; 626  : 	else
; 627  : 		return false;
; 628  : }

  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
?__IsWritable@CIME@@QAE_N_W@Z ENDP			; CIME::__IsWritable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetStringMode@CIME@@QAEXXZ
_TEXT	SEGMENT
?SetStringMode@CIME@@QAEXXZ PROC			; CIME::SetStringMode, COMDAT
; _this$ = ecx

; 609  : 	m_bOnlyNumberMode = FALSE;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 610  : }

  00007	c3		 ret	 0
?SetStringMode@CIME@@QAEXXZ ENDP			; CIME::SetStringMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetNumberMode@CIME@@QAEXXZ
_TEXT	SEGMENT
?SetNumberMode@CIME@@QAEXXZ PROC			; CIME::SetNumberMode, COMDAT
; _this$ = ecx

; 604  : 	m_bOnlyNumberMode = TRUE;

  00000	c7 41 10 01 00
	00 00		 mov	 DWORD PTR [ecx+16], 1

; 605  : }

  00007	c3		 ret	 0
?SetNumberMode@CIME@@QAEXXZ ENDP			; CIME::SetNumberMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?IsCaptureEnabled@CIME@@QAE_NXZ
_TEXT	SEGMENT
?IsCaptureEnabled@CIME@@QAE_NXZ PROC			; CIME::IsCaptureEnabled, COMDAT
; _this$ = ecx

; 415  : 	return ms_bCaptureInput;

  00000	a0 00 00 00 00	 mov	 al, BYTE PTR ?ms_bCaptureInput@CIME@@2_NA ; CIME::ms_bCaptureInput

; 416  : }

  00005	c3		 ret	 0
?IsCaptureEnabled@CIME@@QAE_NXZ ENDP			; CIME::IsCaptureEnabled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?DisableCaptureInput@CIME@@QAEXXZ
_TEXT	SEGMENT
?DisableCaptureInput@CIME@@QAEXXZ PROC			; CIME::DisableCaptureInput, COMDAT
; _this$ = ecx

; 410  : 	ms_bCaptureInput = false;

  00000	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 0 ; CIME::ms_bCaptureInput

; 411  : }

  00007	c3		 ret	 0
?DisableCaptureInput@CIME@@QAEXXZ ENDP			; CIME::DisableCaptureInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?EnableCaptureInput@CIME@@QAEXXZ
_TEXT	SEGMENT
?EnableCaptureInput@CIME@@QAEXXZ PROC			; CIME::EnableCaptureInput, COMDAT
; _this$ = ecx

; 405  : 	ms_bCaptureInput = true;

  00000	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 1 ; CIME::ms_bCaptureInput

; 406  : }

  00007	c3		 ret	 0
?EnableCaptureInput@CIME@@QAEXXZ ENDP			; CIME::EnableCaptureInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?DisableIME@CIME@@QAEXXZ
_TEXT	SEGMENT
?DisableIME@CIME@@QAEXXZ PROC				; CIME::DisableIME, COMDAT
; _this$ = ecx

; 400  : 	EnableIME(false);

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 ?EnableIME@CIME@@QAEX_N@Z ; CIME::EnableIME

; 401  : }

  00007	c3		 ret	 0
?DisableIME@CIME@@QAEXXZ ENDP				; CIME::DisableIME
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?EnableIME@CIME@@QAEX_N@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
?EnableIME@CIME@@QAEX_N@Z PROC				; CIME::EnableIME, COMDAT
; _this$ = ecx

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 387  : 	if (!ms_bInitialized || !ms_hWnd)

  00003	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
  0000a	53		 push	 ebx
  0000b	8a 5d 08	 mov	 bl, BYTE PTR _bEnable$[ebp]
  0000e	74 30		 je	 SHORT $LN3@EnableIME
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00015	85 c0		 test	 eax, eax
  00017	74 27		 je	 SHORT $LN3@EnableIME

; 388  : 		return;
; 389  : 	if (ms_bDisableIMECompletely)

  00019	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bDisableIMECompletely@CIME@@2_NA, 0 ; CIME::ms_bDisableIMECompletely
  00020	74 23		 je	 SHORT $LN4@EnableIME

; 390  : 		bEnable = false;

  00022	32 db		 xor	 bl, bl
  00024	88 5d 08	 mov	 BYTE PTR _bEnable$[ebp], bl
$LN7@EnableIME:

; 391  : 	ImmAssociateContext(ms_hWnd, bEnable ? m_hOrgIMC : NULL);

  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _ImmAssociateContext@8

; 395  : 	CTsfUiLessMode::EnableUiUpdates(bEnable);

  0002f	ff 75 08	 push	 DWORD PTR _bEnable$[ebp]
  00032	88 1d 00 00 00
	00		 mov	 BYTE PTR ?ms_bImeEnabled@CIME@@2_NA, bl ; CIME::ms_bImeEnabled
  00038	e8 00 00 00 00	 call	 ?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z ; CTsfUiLessMode::EnableUiUpdates
  0003d	83 c4 04	 add	 esp, 4
$LN3@EnableIME:
  00040	5b		 pop	 ebx

; 396  : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN4@EnableIME:

; 391  : 	ImmAssociateContext(ms_hWnd, bEnable ? m_hOrgIMC : NULL);

  00045	84 db		 test	 bl, bl
  00047	74 de		 je	 SHORT $LN7@EnableIME
  00049	ff 71 04	 push	 DWORD PTR [ecx+4]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _ImmAssociateContext@8
  00052	88 1d 00 00 00
	00		 mov	 BYTE PTR ?ms_bImeEnabled@CIME@@2_NA, bl ; CIME::ms_bImeEnabled

; 392  : 	ms_bImeEnabled = bEnable;
; 393  : 	if (bEnable)
; 394  : 		CheckToggleState();

  00058	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState
  0005d	88 5d 08	 mov	 BYTE PTR _bEnable$[ebp], bl

; 395  : 	CTsfUiLessMode::EnableUiUpdates(bEnable);

  00060	ff 75 08	 push	 DWORD PTR _bEnable$[ebp]
  00063	e8 00 00 00 00	 call	 ?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z ; CTsfUiLessMode::EnableUiUpdates
  00068	83 c4 04	 add	 esp, 4
  0006b	5b		 pop	 ebx

; 396  : }

  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
?EnableIME@CIME@@QAEX_N@Z ENDP				; CIME::EnableIME
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?IsIMEEnabled@CIME@@QAE_NXZ
_TEXT	SEGMENT
?IsIMEEnabled@CIME@@QAE_NXZ PROC			; CIME::IsIMEEnabled, COMDAT
; _this$ = ecx

; 382  : 	return ms_bImeEnabled;

  00000	a0 00 00 00 00	 mov	 al, BYTE PTR ?ms_bImeEnabled@CIME@@2_NA ; CIME::ms_bImeEnabled

; 383  : }

  00005	c3		 ret	 0
?IsIMEEnabled@CIME@@QAE_NXZ ENDP			; CIME::IsIMEEnabled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetInputMode@CIME@@QAEKXZ
_TEXT	SEGMENT
_dwSMode$ = -8						; size = 4
_dwCMode$ = -4						; size = 4
?GetInputMode@CIME@@QAEKXZ PROC				; CIME::GetInputMode, COMDAT
; _this$ = ecx

; 590  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 591  : 	DWORD dwCMode, dwSMode;
; 592  : 
; 593  : 	HIMC hImc = ImmGetContext(ms_hWnd);

  00007	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0000d	e8 00 00 00 00	 call	 _ImmGetContext@4
  00012	8b f0		 mov	 esi, eax

; 594  : 
; 595  : 	ImmGetConversionStatus(hImc, &dwCMode, &dwSMode);

  00014	8d 45 f8	 lea	 eax, DWORD PTR _dwSMode$[ebp]
  00017	50		 push	 eax
  00018	8d 45 fc	 lea	 eax, DWORD PTR _dwCMode$[ebp]
  0001b	50		 push	 eax
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _ImmGetConversionStatus@12

; 596  : 
; 597  : 	ImmReleaseContext(ms_hWnd, hImc);

  00022	56		 push	 esi
  00023	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00029	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 598  : 
; 599  : 	return dwCMode;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _dwCMode$[ebp]
  00031	5e		 pop	 esi

; 600  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GetInputMode@CIME@@QAEKXZ ENDP				; CIME::GetInputMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetInputMode@CIME@@QAEXK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?SetInputMode@CIME@@QAEXK@Z PROC			; CIME::SetInputMode, COMDAT
; _this$ = ecx

; 581  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 582  : 	HIMC hImc = ImmGetContext(ms_hWnd);

  00004	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0000a	e8 00 00 00 00	 call	 _ImmGetContext@4

; 583  : 
; 584  : 	ImmSetConversionStatus(hImc, dwMode, IME_SMODE_AUTOMATIC);

  0000f	6a 04		 push	 4
  00011	ff 75 08	 push	 DWORD PTR _dwMode$[ebp]
  00014	8b f0		 mov	 esi, eax
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 _ImmSetConversionStatus@12

; 585  : 
; 586  : 	ImmReleaseContext(ms_hWnd, hImc);

  0001c	56		 push	 esi
  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00023	e8 00 00 00 00	 call	 _ImmReleaseContext@8
  00028	5e		 pop	 esi

; 587  : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?SetInputMode@CIME@@QAEXK@Z ENDP			; CIME::SetInputMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetReadingError@CIME@@QAEHXZ
_TEXT	SEGMENT
?GetReadingError@CIME@@QAEHXZ PROC			; CIME::GetReadingError, COMDAT
; _this$ = ecx

; 444  : 	return ms_iReadingError;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_iReadingError@CIME@@2HA ; CIME::ms_iReadingError

; 445  : }

  00005	c3		 ret	 0
?GetReadingError@CIME@@QAEHXZ ENDP			; CIME::GetReadingError
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_reading$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_rstrText$ = 8						; size = 4
?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CIME::GetReading, COMDAT
; _this$ = ecx

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00013	a1 04 00 00 00	 mov	 eax, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+4
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 429  : {

  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _rstrText$[ebp]
  0001c	57		 push	 edi
  0001d	8b f9		 mov	 edi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A
  00025	2b c1		 sub	 eax, ecx
  00027	d1 f8		 sar	 eax, 1
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 432  : 	if(ms_wstrReading.size() == 0)

  00029	75 14		 jne	 SHORT $LN2@GetReading

; 433  : 		return 0;

  0002b	5f		 pop	 edi
  0002c	33 c0		 xor	 eax, eax

; 440  : }

  0002e	5e		 pop	 esi
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00032	33 cd		 xor	 ecx, ebp
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
$LN2@GetReading:
  0003f	53		 push	 ebx

; 434  : 	int readingLen = WideCharToMultiByte(ms_uOutputCodePage, 0, &ms_wstrReading[0], ms_wstrReading.size(), reading, sizeof(reading), NULL, NULL);

  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	68 80 00 00 00	 push	 128			; 00000080H
  00049	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _reading$[ebp]
  0004f	52		 push	 edx
  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	6a 00		 push	 0
  00054	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 435  : 
; 436  : 	rstrText.append(GetCodePageText());

  00060	8b cf		 mov	 ecx, edi
  00062	8b d8		 mov	 ebx, eax
  00064	e8 00 00 00 00	 call	 ?GetCodePageText@CIME@@QAEPBDXZ ; CIME::GetCodePageText
  00069	8b d0		 mov	 edx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  0006b	8b ca		 mov	 ecx, edx
  0006d	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL20@GetReading:
  00070	8a 01		 mov	 al, BYTE PTR [ecx]
  00072	41		 inc	 ecx
  00073	84 c0		 test	 al, al
  00075	75 f9		 jne	 SHORT $LL20@GetReading
  00077	2b cf		 sub	 ecx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1510 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00079	51		 push	 ecx
  0007a	52		 push	 edx
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1543 :             return append(_UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  00082	53		 push	 ebx
  00083	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _reading$[ebp]
  00089	8b ce		 mov	 ecx, esi
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 440  : }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00097	33 cd		 xor	 ecx, ebp
  00099	5b		 pop	 ebx
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CIME::GetReading
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetCandidateSelection@CIME@@QAEHXZ
_TEXT	SEGMENT
?GetCandidateSelection@CIME@@QAEHXZ PROC		; CIME::GetCandidateSelection, COMDAT
; _this$ = ecx

; 577  : 	return ms_dwCandidateSelection;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection

; 578  : }

  00005	c3		 ret	 0
?GetCandidateSelection@CIME@@QAEHXZ ENDP		; CIME::GetCandidateSelection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_text$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_index$ = 8						; size = 4
_rstrText$ = 12						; size = 4
?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CIME::GetCandidate, COMDAT
; _this$ = ecx

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _rstrText$[ebp]
  0001a	57		 push	 edi

; 555  : 	if(index >= MAX_CANDLIST)

  0001b	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0001e	73 75		 jae	 SHORT $LN13@GetCandida

; 556  : 		return 0;
; 557  : 
; 558  : 	LPCWSTR wszText = ms_wszCandidate[index];

  00020	c1 e1 09	 shl	 ecx, 9
  00023	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate

; 559  : 	if(wszText == NULL)

  00029	74 6a		 je	 SHORT $LN13@GetCandida

; 560  : 		return 0;
; 561  : 
; 562  : 	int wTextLen = wcslen(wszText);

  0002b	8b f9		 mov	 edi, ecx
  0002d	8d 57 02	 lea	 edx, DWORD PTR [edi+2]
$LL16@GetCandida:
  00030	66 8b 07	 mov	 ax, WORD PTR [edi]
  00033	83 c7 02	 add	 edi, 2
  00036	66 85 c0	 test	 ax, ax
  00039	75 f5		 jne	 SHORT $LL16@GetCandida
  0003b	2b fa		 sub	 edi, edx
  0003d	d1 ff		 sar	 edi, 1

; 563  : 	if(wTextLen == 0)

  0003f	74 54		 je	 SHORT $LN13@GetCandida

; 567  : 	int len = ::WideCharToMultiByte(CP_UTF8, 0, wszText, wTextLen, text, sizeof(text), 0, 0);

  00041	56		 push	 esi
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	68 00 04 00 00	 push	 1024			; 00000400H
  0004b	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  00051	50		 push	 eax
  00052	57		 push	 edi
  00053	51		 push	 ecx
  00054	6a 00		 push	 0
  00056	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1510 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00061	6a 05		 push	 5
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_05EFEJGKEJ@?$EA9999@
  00068	8b cb		 mov	 ecx, ebx
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 567  : 	int len = ::WideCharToMultiByte(CP_UTF8, 0, wszText, wTextLen, text, sizeof(text), 0, 0);

  0006a	8b f0		 mov	 esi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1510 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0006c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1543 :             return append(_UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  00071	56		 push	 esi
  00072	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  00078	8b cb		 mov	 ecx, ebx
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 572  : 	return wTextLen;

  00080	5e		 pop	 esi
  00081	8b c7		 mov	 eax, edi
  00083	5f		 pop	 edi

; 573  : }

  00084	5b		 pop	 ebx
  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 08 00	 ret	 8
$LN13@GetCandida:
  00095	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00098	33 c0		 xor	 eax, eax
  0009a	5f		 pop	 edi
  0009b	33 cd		 xor	 ecx, ebp
  0009d	5b		 pop	 ebx
  0009e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c2 08 00	 ret	 8
?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CIME::GetCandidate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetCandidatePageCount@CIME@@QAEHXZ
_TEXT	SEGMENT
?GetCandidatePageCount@CIME@@QAEHXZ PROC		; CIME::GetCandidatePageCount, COMDAT
; _this$ = ecx

; 545  : 	return ms_dwCandidatePageSize;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA ; CIME::ms_dwCandidatePageSize

; 546  : }

  00005	c3		 ret	 0
?GetCandidatePageCount@CIME@@QAEHXZ ENDP		; CIME::GetCandidatePageCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetCandidateCount@CIME@@QAEHXZ
_TEXT	SEGMENT
?GetCandidateCount@CIME@@QAEHXZ PROC			; CIME::GetCandidateCount, COMDAT
; _this$ = ecx

; 550  : 	return ms_dwCandidateCount;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount

; 551  : }

  00005	c3		 ret	 0
?GetCandidateCount@CIME@@QAEHXZ ENDP			; CIME::GetCandidateCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetCodePage@CIME@@QAEHXZ
_TEXT	SEGMENT
?GetCodePage@CIME@@QAEHXZ PROC				; CIME::GetCodePage, COMDAT
; _this$ = ecx

; 540  : 	return ms_uOutputCodePage;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage

; 541  : }

  00005	c3		 ret	 0
?GetCodePage@CIME@@QAEHXZ ENDP				; CIME::GetCodePage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetCodePageText@CIME@@QAEPBDXZ
_TEXT	SEGMENT
?GetCodePageText@CIME@@QAEPBDXZ PROC			; CIME::GetCodePageText, COMDAT
; _this$ = ecx

; 521  : 	static char szCodePage[16];
; 522  : 
; 523  : 	const int defCodePage = GetDefaultCodePage();

  00000	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage

; 524  : 	const int outCodePage = ms_uOutputCodePage;

  00005	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage

; 525  : 
; 526  : 	if (outCodePage != defCodePage)

  0000b	3b c8		 cmp	 ecx, eax
  0000d	74 19		 je	 SHORT $LN2@GetCodePag

; 527  : 	{
; 528  : 		sprintf(szCodePage, "@%04d", outCodePage);

  0000f	51		 push	 ecx
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_05JKJMOPAK@?$EA?$CF04d@
  00015	68 00 00 00 00	 push	 OFFSET ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
  0001a	e8 00 00 00 00	 call	 _sprintf
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 533  : 	}
; 534  : 
; 535  : 	return szCodePage;
; 536  : }

  00022	b8 00 00 00 00	 mov	 eax, OFFSET ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
  00027	c3		 ret	 0
$LN2@GetCodePag:

; 529  : 	}
; 530  : 	else
; 531  : 	{
; 532  : 		szCodePage[0] = 0;

  00028	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA, 0

; 533  : 	}
; 534  : 
; 535  : 	return szCodePage;
; 536  : }

  0002f	b8 00 00 00 00	 mov	 eax, OFFSET ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
  00034	c3		 ret	 0
?GetCodePageText@CIME@@QAEPBDXZ ENDP			; CIME::GetCodePageText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
_dataCodePage$1$ = -1040				; size = 4
_rstrText$GSCopy$1$ = -1036				; size = 4
$T1 = -1032						; size = 4
_text$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_rstrText$ = 8						; size = 4
_addCodePage$ = 12					; size = 1
?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; CIME::GetText, COMDAT
; _this$ = ecx

; 478  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 04 00
	00		 sub	 esp, 1040		; 00000410H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _rstrText$[ebp]

; 479  : 	int outCodePage = ms_uOutputCodePage;
; 480  : 	int dataCodePage;
; 481  : 	switch (outCodePage)

  00016	81 3d 00 00 00
	00 f4 04 00 00	 cmp	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, 1268 ; CIME::ms_uOutputCodePage, 000004f4H
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi

; 482  : 	{
; 483  : 		//case 1256: // ARABIC
; 484  : 		case 1268: // VIETNAM
; 485  : 			dataCodePage = CP_UTF8;
; 486  : 			break;
; 487  : 		default:
; 488  : 			dataCodePage = outCodePage;
; 489  : 	}
; 490  : 
; 491  : 	int len = 0;
; 492  : 	char text[IMESTR_MAXLEN];
; 493  : 
; 494  : 	len += WideCharToMultiByte(dataCodePage, 0, m_wText, ms_curpos, text, sizeof(text)-len, NULL, NULL);

  00023	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WideCharToMultiByte@32
  00029	8b d9		 mov	 ebx, ecx
  0002b	6a 00		 push	 0
  0002d	6a 00		 push	 0
  0002f	68 00 04 00 00	 push	 1024			; 00000400H
  00034	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _rstrText$GSCopy$1$[ebp], eax
  0003a	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  0003f	0f 45 0d 00 00
	00 00		 cmovne	 ecx, DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00046	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  0004c	50		 push	 eax
  0004d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00053	89 8d f0 fb ff
	ff		 mov	 DWORD PTR _dataCodePage$1$[ebp], ecx
  00059	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0005e	6a 00		 push	 0
  00060	51		 push	 ecx
  00061	ff d7		 call	 edi
  00063	8b c8		 mov	 ecx, eax

; 495  : 	len += WideCharToMultiByte(dataCodePage, 0, m_wszComposition, ms_compLen, text+len, sizeof(text)-len, NULL, NULL);

  00065	be 00 04 00 00	 mov	 esi, 1024		; 00000400H
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	8b c6		 mov	 eax, esi
  00070	89 8d f8 fb ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00076	2b c1		 sub	 eax, ecx
  00078	50		 push	 eax
  00079	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  0007f	03 c1		 add	 eax, ecx
  00081	50		 push	 eax
  00082	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_compLen@CIME@@2HA ; CIME::ms_compLen
  00088	8d 43 22	 lea	 eax, DWORD PTR [ebx+34]
  0008b	8b 9d f0 fb ff
	ff		 mov	 ebx, DWORD PTR _dataCodePage$1$[ebp]
  00091	50		 push	 eax
  00092	6a 00		 push	 0
  00094	53		 push	 ebx
  00095	ff d7		 call	 edi
  00097	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  0009d	03 c8		 add	 ecx, eax

; 496  : 	len += WideCharToMultiByte(dataCodePage, 0, m_wText+ms_curpos, ms_lastpos-ms_curpos, text+len, sizeof(text)-len, NULL, NULL);

  0009f	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  000a5	6a 00		 push	 0
  000a7	6a 00		 push	 0
  000a9	03 c1		 add	 eax, ecx
  000ab	89 8d f8 fb ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  000b1	2b f1		 sub	 esi, ecx
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  000b9	56		 push	 esi
  000ba	50		 push	 eax
  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  000c0	2b c1		 sub	 eax, ecx
  000c2	50		 push	 eax
  000c3	8d 04 4d 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[ecx*2]
  000ca	50		 push	 eax
  000cb	6a 00		 push	 0
  000cd	53		 push	 ebx
  000ce	ff d7		 call	 edi
  000d0	8b 9d f8 fb ff
	ff		 mov	 ebx, DWORD PTR $T1[ebp]

; 497  : 
; 498  : 	int i;
; 499  : 	for(i=0; i<len; ++i)

  000d6	33 f6		 xor	 esi, esi
  000d8	03 d8		 add	 ebx, eax
  000da	85 db		 test	 ebx, ebx
  000dc	7e 11		 jle	 SHORT $LN24@GetText
  000de	66 90		 npad	 2
$LL6@GetText:

; 500  : 		if((BYTE)text[i] > 0x7F) break;

  000e0	80 bc 35 fc fb
	ff ff 7f	 cmp	 BYTE PTR _text$[ebp+esi], 127 ; 0000007fH
  000e8	77 05		 ja	 SHORT $LN24@GetText

; 497  : 
; 498  : 	int i;
; 499  : 	for(i=0; i<len; ++i)

  000ea	46		 inc	 esi
  000eb	3b f3		 cmp	 esi, ebx
  000ed	7c f1		 jl	 SHORT $LL6@GetText
$LN24@GetText:

; 501  : 
; 502  : 	if(i == len)

  000ef	8b bd f4 fb ff
	ff		 mov	 edi, DWORD PTR _rstrText$GSCopy$1$[ebp]
  000f5	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  000fb	3b f3		 cmp	 esi, ebx
  000fd	74 1a		 je	 SHORT $LN11@GetText
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1543 :             return append(_UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  000ff	56		 push	 esi
  00100	50		 push	 eax
  00101	8b cf		 mov	 ecx, edi
  00103	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 513  : 		rstrText.append(text+i, text+len);

  00108	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  0010e	03 c6		 add	 eax, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1543 :             return append(_UFirst, _STD _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  00110	2b d8		 sub	 ebx, eax
  00112	8d 9c 1d fc fb
	ff ff		 lea	 ebx, DWORD PTR _text$[ebp+ebx]
$LN11@GetText:
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 516  : 	return rstrText.size();

  00119	53		 push	 ebx
  0011a	50		 push	 eax
  0011b	8b cf		 mov	 ecx, edi
  0011d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00122	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 517  : }

  00125	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00128	5f		 pop	 edi
  00129	5e		 pop	 esi
  0012a	33 cd		 xor	 ecx, ebp
  0012c	5b		 pop	 ebx
  0012d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 08 00	 ret	 8
?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; CIME::GetText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetText@CIME@@QAEXPBDH@Z
_TEXT	SEGMENT
_szText$ = 8						; size = 4
_len$ = 12						; size = 4
?SetText@CIME@@QAEXPBDH@Z PROC				; CIME::SetText, COMDAT
; _this$ = ecx

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 459  : 	ms_compLen = 0;
; 460  : 	ms_ulbegin = 0;
; 461  : 	ms_ulend = 0;
; 462  : 
; 463  : 	const char* begin = szText;
; 464  : 	const char* end = begin + len;

  00005	8b 75 08	 mov	 esi, DWORD PTR _szText$[ebp]
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR _len$[ebp]
  0000c	03 fe		 add	 edi, esi
  0000e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen

; 465  : 	const char* iter = FindToken(begin, end);

  00018	57		 push	 edi
  00019	56		 push	 esi
  0001a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulbegin@CIME@@2HA, 0 ; CIME::ms_ulbegin
  00024	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulend@CIME@@2HA, 0 ; CIME::ms_ulend
  0002e	e8 00 00 00 00	 call	 ?FindToken@@YAPBDPBD0@Z	; FindToken
  00033	83 c4 08	 add	 esp, 8
  00036	8b d8		 mov	 ebx, eax

; 466  : 
; 467  : 	int m_wTextLen = sizeof(m_wText)/sizeof(wchar_t);
; 468  : 
; 469  : 	ms_lastpos = MultiByteToWideChar(ms_uInputCodePage, 0, begin, iter-begin, m_wText, m_wTextLen);

  00038	8b cb		 mov	 ecx, ebx
  0003a	2b ce		 sub	 ecx, esi
  0003c	68 00 04 00 00	 push	 1024			; 00000400H
  00041	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  00046	51		 push	 ecx
  00047	56		 push	 esi
  00048	6a 00		 push	 0
  0004a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00056	8b f0		 mov	 esi, eax
  00058	89 35 00 00 00
	00		 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, esi ; CIME::ms_lastpos

; 470  : 
; 471  : 	if (iter < end)

  0005e	3b df		 cmp	 ebx, edi
  00060	73 3c		 jae	 SHORT $LN2@SetText

; 472  : 		ms_lastpos += MultiByteToWideChar(ReadToken(iter), 0, (iter+5), end-(iter+5), m_wText+ms_lastpos, m_wTextLen-ms_lastpos);

  00062	53		 push	 ebx
  00063	e8 00 00 00 00	 call	 ?ReadToken@@YAHPBD@Z	; ReadToken
  00068	83 c4 04	 add	 esp, 4
  0006b	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00070	2b ce		 sub	 ecx, esi
  00072	2b fb		 sub	 edi, ebx
  00074	8b d0		 mov	 edx, eax
  00076	83 ef 05	 sub	 edi, 5
  00079	8d 43 05	 lea	 eax, DWORD PTR [ebx+5]
  0007c	51		 push	 ecx
  0007d	8d 0c 75 00 00
	00 00		 lea	 ecx, DWORD PTR ?m_wText@CIME@@2PA_WA[esi*2]
  00084	51		 push	 ecx
  00085	57		 push	 edi
  00086	50		 push	 eax
  00087	6a 00		 push	 0
  00089	52		 push	 edx
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00090	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00096	03 f0		 add	 esi, eax
  00098	89 35 00 00 00
	00		 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, esi ; CIME::ms_lastpos
$LN2@SetText:

; 473  : 
; 474  : 	ms_curpos = min(ms_curpos, ms_lastpos);

  0009e	39 35 00 00 00
	00		 cmp	 DWORD PTR ?ms_curpos@CIME@@2HA, esi ; CIME::ms_curpos
  000a4	5f		 pop	 edi
  000a5	0f 4c 35 00 00
	00 00		 cmovl	 esi, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  000ac	89 35 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, esi ; CIME::ms_curpos
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx

; 475  : }

  000b4	5d		 pop	 ebp
  000b5	c2 08 00	 ret	 8
?SetText@CIME@@QAEXPBDH@Z ENDP				; CIME::SetText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetUserMax@CIME@@QAEXH@Z
_TEXT	SEGMENT
_iMax$ = 8						; size = 4
?SetUserMax@CIME@@QAEXH@Z PROC				; CIME::SetUserMax, COMDAT
; _this$ = ecx

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 454  : 	m_userMax = iMax;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMax$[ebp]
  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 455  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetUserMax@CIME@@QAEXH@Z ENDP				; CIME::SetUserMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?SetMax@CIME@@QAEXH@Z
_TEXT	SEGMENT
_iMax$ = 8						; size = 4
?SetMax@CIME@@QAEXH@Z PROC				; CIME::SetMax, COMDAT
; _this$ = ecx

; 448  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 449  : 	m_max = iMax;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMax$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 450  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetMax@CIME@@QAEXH@Z ENDP				; CIME::SetMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?Clear@CIME@@SAXXZ
_TEXT	SEGMENT
?Clear@CIME@@SAXXZ PROC					; CIME::Clear, COMDAT

; 420  : 	ms_lastpos = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, 0 ; CIME::ms_lastpos

; 421  : 	ms_curpos = 0;

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, 0 ; CIME::ms_curpos

; 422  : 
; 423  : 	ms_compLen = 0;

  00014	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen

; 424  : 	ms_ulbegin = 0;

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulbegin@CIME@@2HA, 0 ; CIME::ms_ulbegin

; 425  : 	ms_ulend = 0;

  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulend@CIME@@2HA, 0 ; CIME::ms_ulend

; 426  : }

  00032	c3		 ret	 0
?Clear@CIME@@SAXXZ ENDP					; CIME::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?Uninitialize@CIME@@QAEXXZ
_TEXT	SEGMENT
?Uninitialize@CIME@@QAEXXZ PROC				; CIME::Uninitialize, COMDAT
; _this$ = ecx

; 362  : 	if ( !ms_bInitialized )

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	0f 84 91 00 00
	00		 je	 $LN1@Uninitiali

; 363  : 		return;
; 364  : 	CTsfUiLessMode::ReleaseSinks();

  00010	e8 00 00 00 00	 call	 ?ReleaseSinks@CTsfUiLessMode@@SAXXZ ; CTsfUiLessMode::ReleaseSinks

; 365  : 	if ( ms_hWnd )

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0001a	85 c0		 test	 eax, eax
  0001c	74 09		 je	 SHORT $LN11@Uninitiali

; 366  : 		ImmAssociateContext(ms_hWnd, m_hOrgIMC);

  0001e	ff 76 04	 push	 DWORD PTR [esi+4]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _ImmAssociateContext@8
$LN11@Uninitiali:

; 367  : 	ms_hWnd = NULL;

  00027	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, 0 ; CIME::ms_hWnd

; 368  : 	m_hOrgIMC = NULL;

  00031	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 369  : 	SAFE_FREE_LIBRARY(ms_hCurrentImeDll);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  0003d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__FreeLibrary@4
  00043	85 c0		 test	 eax, eax
  00045	74 0d		 je	 SHORT $LN4@Uninitiali
  00047	50		 push	 eax
  00048	ff d6		 call	 esi
  0004a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
$LN4@Uninitiali:

; 370  : 	SAFE_FREE_LIBRARY(ms_hImm32Dll);

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  00059	85 c0		 test	 eax, eax
  0005b	74 0d		 je	 SHORT $LN5@Uninitiali
  0005d	50		 push	 eax
  0005e	ff d6		 call	 esi
  00060	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hImm32Dll
$LN5@Uninitiali:

; 244  : 		if ( m_ptim )

  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_disableCicero@@3VCDisableCicero@@A
  00070	85 c9		 test	 ecx, ecx
  00072	74 10		 je	 SHORT $LN8@Uninitiali

; 245  : 		{
; 246  : 			m_ptim->Release();

  00074	8b 01		 mov	 eax, DWORD PTR [ecx]
  00076	51		 push	 ecx
  00077	ff 50 08	 call	 DWORD PTR [eax+8]

; 247  : 			m_ptim = NULL;

  0007a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_disableCicero@@3VCDisableCicero@@A, 0
$LN8@Uninitiali:

; 248  : 		}
; 249  : 		if ( m_bComInit )

  00084	80 3d 04 00 00
	00 00		 cmp	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0
  0008b	74 06		 je	 SHORT $LN9@Uninitiali

; 250  : 			CoUninitialize();

  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
$LN9@Uninitiali:

; 251  : 		m_bComInit = false;

  00093	c6 05 04 00 00
	00 00		 mov	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0

; 371  : 	g_disableCicero.Uninitialize();
; 372  : 	ms_bInitialized = false;

  0009a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
$LN1@Uninitiali:

; 373  : }

  000a1	5e		 pop	 esi
  000a2	c3		 ret	 0
?Uninitialize@CIME@@QAEXXZ ENDP				; CIME::Uninitialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ?Initialize@CIME@@QAE_NPAUHWND__@@@Z
_TEXT	SEGMENT
_szPath$ = -268						; size = 261
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
?Initialize@CIME@@QAE_NPAUHWND__@@@Z PROC		; CIME::Initialize, COMDAT
; _this$ = ecx

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 302  : 	if(ms_bInitialized)

  00013	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
  0001a	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0001d	57		 push	 edi
  0001e	8b f9		 mov	 edi, ecx
  00020	0f 85 a2 01 00
	00		 jne	 $LN20@Initialize

; 226  : 		if ( m_bComInit )

  00026	80 3d 04 00 00
	00 00		 cmp	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0

; 303  : 		return true;
; 304  : 	ms_hWnd = hWnd;

  0002d	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, eax ; CIME::ms_hWnd

; 226  : 		if ( m_bComInit )

  00032	75 2e		 jne	 SHORT $LN15@Initialize

; 227  : 		{
; 228  : 			return;
; 229  : 		}
; 230  : 		HRESULT hr;
; 231  : 		hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

  00034	6a 02		 push	 2
  00036	6a 00		 push	 0
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitializeEx@8

; 232  : 	    if ( SUCCEEDED( hr ) )

  0003e	85 c0		 test	 eax, eax
  00040	78 20		 js	 SHORT $LN15@Initialize

; 233  : 		{
; 234  : 			m_bComInit = true;
; 235  : 			hr = CoCreateInstance( CLSID_TF_ThreadMgr,

  00042	68 00 00 00 00	 push	 OFFSET ?g_disableCicero@@3VCDisableCicero@@A
  00047	68 00 00 00 00	 push	 OFFSET __GUID_aa80e801_2021_11d2_93e0_0060b067b86e
  0004c	6a 01		 push	 1
  0004e	6a 00		 push	 0
  00050	68 00 00 00 00	 push	 OFFSET _CLSID_TF_ThreadMgr
  00055	c6 05 04 00 00
	00 01		 mov	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 1
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
$LN15@Initialize:

; 305  : 
; 306  : 	g_disableCicero.Initialize();
; 307  : 
; 308  : 	ms_stOSVI.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
; 309  : 	GetVersionExA(&ms_stOSVI);

  00062	68 00 00 00 00	 push	 OFFSET ?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A ; CIME::ms_stOSVI
  00067	c7 05 00 00 00
	00 94 00 00 00	 mov	 DWORD PTR ?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A, 148 ; 00000094H
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 310  : 
; 311  : 	bool bUnicodeImm = false;
; 312  : 	// IMM in NT or Win98 supports Unicode
; 313  : 	if ( ms_stOSVI.dwPlatformId == VER_PLATFORM_WIN32_NT ||
; 314  : 		( ms_stOSVI.dwMajorVersion > 4 ) ||
; 315  : 		( ms_stOSVI.dwMajorVersion == 4 ) && ( ms_stOSVI.dwMinorVersion > 0 ) ) {
; 316  : 		bUnicodeImm = true;
; 317  : 	}
; 318  : 
; 319  : 	// Load ImmLock/ImmUnlock Function Proc
; 320  :     CHAR szPath[MAX_PATH+1];
; 321  : 	ms_bDisableIMECompletely = false;
; 322  : 
; 323  : 	if(GetSystemDirectoryA(szPath, MAX_PATH+1)) {

  00077	68 05 01 00 00	 push	 261			; 00000105H
  0007c	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szPath$[ebp]
  00082	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bDisableIMECompletely@CIME@@2_NA, 0 ; CIME::ms_bDisableIMECompletely
  00089	50		 push	 eax
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemDirectoryA@8
  00090	85 c0		 test	 eax, eax
  00092	0f 84 b2 00 00
	00		 je	 $LN7@Initialize

; 324  : 		strcat(szPath, "\\imm32.dll");

  00098	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szPath$[ebp]
  0009e	49		 dec	 ecx
  0009f	90		 npad	 1
$LL18@Initialize:
  000a0	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000a3	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000a6	84 c0		 test	 al, al
  000a8	75 f6		 jne	 SHORT $LL18@Initialize
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@LPOFADGE@?2imm32?4dll@
  000af	89 01		 mov	 DWORD PTR [ecx], eax
  000b1	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@LPOFADGE@?2imm32?4dll@+4
  000b6	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000b9	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@LPOFADGE@?2imm32?4dll@+8
  000bf	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  000c3	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0L@LPOFADGE@?2imm32?4dll@+10
  000c8	88 41 0a	 mov	 BYTE PTR [ecx+10], al

; 325  : 		ms_hImm32Dll = LoadLibraryA(szPath);

  000cb	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szPath$[ebp]
  000d1	50		 push	 eax
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  000d8	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, eax ; CIME::ms_hImm32Dll
  000dd	85 c0		 test	 eax, eax

; 326  : 		if(ms_hImm32Dll)

  000df	74 62		 je	 SHORT $LN6@Initialize

; 327  : 		{
; 328  : 			_ImmLockIMC		= (INPUTCONTEXT*(WINAPI *)(HIMC))	GetProcAddress(ms_hImm32Dll, "ImmLockIMC");

  000e1	56		 push	 esi
  000e2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetProcAddress@8
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JGAMEFKO@ImmLockIMC@
  000ed	50		 push	 eax
  000ee	ff d6		 call	 esi

; 329  : 			_ImmUnlockIMC	= (BOOL(WINAPI *)(HIMC))			GetProcAddress(ms_hImm32Dll, "ImmUnlockIMC");

  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PDIACEGP@ImmUnlockIMC@
  000f5	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  000fb	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA, eax ; CIME::_ImmLockIMC
  00100	ff d6		 call	 esi

; 330  : 			_ImmLockIMCC	= (LPVOID(WINAPI *)(HIMCC))			GetProcAddress(ms_hImm32Dll, "ImmLockIMCC");

  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OKKMJOGM@ImmLockIMCC@
  00107	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  0010d	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA, eax ; CIME::_ImmUnlockIMC
  00112	ff d6		 call	 esi

; 331  : 			_ImmUnlockIMCC	= (BOOL(WINAPI *)(HIMCC))			GetProcAddress(ms_hImm32Dll, "ImmUnlockIMCC");

  00114	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GKKOACL@ImmUnlockIMCC@
  00119	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  0011f	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA, eax ; CIME::_ImmLockIMCC
  00124	ff d6		 call	 esi

; 332  : 			BOOL (WINAPI* _ImmDisableTextFrameService)(DWORD) = (BOOL (WINAPI*)(DWORD))GetProcAddress(ms_hImm32Dll, "ImmDisableTextFrameService");

  00126	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@
  0012b	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  00131	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA, eax ; CIME::_ImmUnlockIMCC
  00136	ff d6		 call	 esi
  00138	5e		 pop	 esi

; 333  : 			if ( _ImmDisableTextFrameService )

  00139	85 c0		 test	 eax, eax
  0013b	74 0d		 je	 SHORT $LN7@Initialize

; 334  : 				_ImmDisableTextFrameService( (DWORD)-1 );

  0013d	6a ff		 push	 -1
  0013f	ff d0		 call	 eax

; 335  : 		} else {

  00141	eb 07		 jmp	 SHORT $LN7@Initialize
$LN6@Initialize:

; 336  : 			ms_bDisableIMECompletely = true;

  00143	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bDisableIMECompletely@CIME@@2_NA, 1 ; CIME::ms_bDisableIMECompletely
$LN7@Initialize:

; 337  : 		}
; 338  : 	}
; 339  : 
; 340  : 	ms_bInitialized = true;
; 341  : 
; 342  : 	m_hOrgIMC = ImmGetContext( ms_hWnd );

  0014a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00150	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 1 ; CIME::ms_bInitialized
  00157	e8 00 00 00 00	 call	 _ImmGetContext@4

; 343  : 	ImmReleaseContext( ms_hWnd, m_hOrgIMC );

  0015c	50		 push	 eax
  0015d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00160	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00166	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 344  : 
; 345  : 	CheckInputLocale();

  0016b	e8 00 00 00 00	 call	 ?CheckInputLocale@CIME@@KAXXZ ; CIME::CheckInputLocale

; 346  : 	ChangeInputLanguageWorker();

  00170	e8 00 00 00 00	 call	 ?ChangeInputLanguageWorker@CIME@@SAXXZ ; CIME::ChangeInputLanguageWorker

; 347  : 	SetSupportLevel(2);

  00175	6a 02		 push	 2
  00177	e8 00 00 00 00	 call	 ?SetSupportLevel@CIME@@KAXK@Z ; CIME::SetSupportLevel
  0017c	83 c4 04	 add	 esp, 4

; 348  : 
; 349  : 	ms_bUILessMode = CTsfUiLessMode::SetupSinks() != FALSE;

  0017f	e8 00 00 00 00	 call	 ?SetupSinks@CTsfUiLessMode@@SAHXZ ; CTsfUiLessMode::SetupSinks
  00184	85 c0		 test	 eax, eax
  00186	0f 95 05 00 00
	00 00		 setne	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode

; 350  : 	CheckToggleState();

  0018d	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState

; 351  : 	if ( ms_bUILessMode )

  00192	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  00199	74 2d		 je	 SHORT $LN20@Initialize

; 352  : 	{
; 353  : 		ms_bChineseIME = ( GETPRIMLANG() == LANG_CHINESE ) && CTsfUiLessMode::CurrentInputLocaleIsIme();

  0019b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  001a0	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  001a5	83 f8 04	 cmp	 eax, 4
  001a8	75 0d		 jne	 SHORT $LN11@Initialize
  001aa	e8 00 00 00 00	 call	 ?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ ; CTsfUiLessMode::CurrentInputLocaleIsIme
  001af	85 c0		 test	 eax, eax
  001b1	74 04		 je	 SHORT $LN11@Initialize
  001b3	b0 01		 mov	 al, 1
  001b5	eb 02		 jmp	 SHORT $LN12@Initialize
$LN11@Initialize:
  001b7	32 c0		 xor	 al, al
$LN12@Initialize:

; 354  : 		CTsfUiLessMode::UpdateImeState();

  001b9	6a 00		 push	 0
  001bb	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, al ; CIME::ms_bChineseIME
  001c0	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  001c5	83 c4 04	 add	 esp, 4
$LN20@Initialize:

; 355  : 	}
; 356  : 
; 357  : 	return true;
; 358  : }

  001c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cb	b0 01		 mov	 al, 1
  001cd	33 cd		 xor	 ecx, ebp
  001cf	5f		 pop	 edi
  001d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d5	8b e5		 mov	 esp, ebp
  001d7	5d		 pop	 ebp
  001d8	c2 04 00	 ret	 4
?Initialize@CIME@@QAE_NPAUHWND__@@@Z ENDP		; CIME::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ??1CIME@@UAE@XZ
_TEXT	SEGMENT
??1CIME@@UAE@XZ PROC					; CIME::~CIME, COMDAT
; _this$ = ecx

; 295  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CIME@@6B@

; 296  : 	SAFE_FREE_LIBRARY(ms_hCurrentImeDll);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  0000e	85 c0		 test	 eax, eax
  00010	74 11		 je	 SHORT $LN2@CIME
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00019	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
$LN2@CIME:

; 297  : 	SAFE_FREE_LIBRARY(ms_hImm32Dll);

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  00028	85 c0		 test	 eax, eax
  0002a	74 11		 je	 SHORT $LN3@CIME
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00033	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hImm32Dll
$LN3@CIME:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0003d	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00040	85 c0		 test	 eax, eax
  00042	74 41		 je	 SHORT $LN10@CIME

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00044	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00047	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00049	83 e1 fe	 and	 ecx, -2			; fffffffeH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0004c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00052	72 12		 jb	 SHORT $LN29@CIME

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00054	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00057	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0005a	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0005f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00062	77 23		 ja	 SHORT $LN26@CIME

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00064	8b c2		 mov	 eax, edx
$LN29@CIME:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00066	51		 push	 ecx
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0006d	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00074	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00077	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 2082 :             _Myend   = nullptr;

  0007e	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN10@CIME:
  00085	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 298  : }

  00086	c3		 ret	 0
$LN26@CIME:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00087	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN40@CIME:
  0008c	cc		 int	 3
??1CIME@@UAE@XZ ENDP					; CIME::~CIME
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp
;	COMDAT ??0CIME@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CIME@@QAE@XZ PROC					; CIME::CIME, COMDAT
; _this$ = ecx

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CIME@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00010	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00017	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0001e	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\IME.cpp

; 277  : 	ms_hWnd = NULL;

  00025	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, 0 ; CIME::ms_hWnd

; 278  : 
; 279  : 	ms_bCandidateList = false;

  0002f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 0 ; CIME::ms_bCandidateList

; 280  : 	ms_bReadingInformation = false;

  00036	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 0 ; CIME::ms_bReadingInformation

; 281  : 
; 282  : 	Clear();

  0003d	e8 00 00 00 00	 call	 ?Clear@CIME@@SAXXZ	; CIME::Clear

; 283  : 
; 284  : 	m_max = 0;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 285  : 	m_userMax = 0;
; 286  : 
; 287  : 	m_bOnlyNumberMode = FALSE;
; 288  : 	m_hOrgIMC = NULL;
; 289  : 
; 290  : 	m_bEnablePaste = false;
; 291  : 	m_bUseDefaultIME = false;
; 292  : }

  00049	8b c6		 mov	 eax, esi
  0004b	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00052	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00059	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00060	66 c7 46 20 00
	00		 mov	 WORD PTR [esi+32], 0
  00066	5e		 pop	 esi
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
??0CIME@@QAE@XZ ENDP					; CIME::CIME
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 2d		 jbe	 SHORT $LN19@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN30@basic_stri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 21		 ja	 SHORT $LN27@basic_stri

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN30@basic_stri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN19@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00038	33 c0		 xor	 eax, eax
  0003a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	66 89 06	 mov	 WORD PTR [esi], ax
  0004b	5e		 pop	 esi

; 1366 :     }

  0004c	c3		 ret	 0
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@basic_stri:
  00052	cc		 int	 3
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__New_size$1$ = -16					; size = 4
tv520 = -16						; size = 4
__Old_size$1$ = -12					; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
tv510 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
tv505 = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1486 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 1487 :         // append [_Ptr, _Ptr + _Count)
; 1488 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 1489 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d f4	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 2e		 ja	 SHORT $LN2@append

; 1490 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1491 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 416  :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 434  :         return _Myres > _Small_string_capacity;

  0002a	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 417  :         if (_Large_mode_engaged()) {

  0002d	76 02		 jbe	 SHORT $LN5@append

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	53		 push	 ebx
  00032	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1493 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00035	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _memmove
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1494 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00041	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 1507 :     }

  00045	8b c7		 mov	 eax, edi
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN2@append:

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

  00050	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00055	2b c1		 sub	 eax, ecx
  00057	3b c3		 cmp	 eax, ebx
  00059	0f 82 1d 01 00
	00		 jb	 $LN98@append

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00062	8b f0		 mov	 esi, eax

; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

  00064	89 45 f0	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00067	83 ce 0f	 or	 esi, 15			; 0000000fH
  0006a	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00070	76 12		 jbe	 SHORT $LN23@append

; 2944 :             return _Max;

  00072	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00077	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00082	eb 4b		 jmp	 SHORT $LN96@append
$LN23@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00084	8b c2		 mov	 eax, edx
  00086	d1 e8		 shr	 eax, 1
  00088	89 45 fc	 mov	 DWORD PTR tv510[ebp], eax
  0008b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00090	2b 45 fc	 sub	 eax, DWORD PTR tv510[ebp]
  00093	3b d0		 cmp	 edx, eax
  00095	76 12		 jbe	 SHORT $LN24@append

; 2948 :             return _Max;

  00097	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009c	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a7	eb 26		 jmp	 SHORT $LN96@append
$LN24@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000a9	8b 45 fc	 mov	 eax, DWORD PTR tv510[ebp]
  000ac	03 c2		 add	 eax, edx
  000ae	3b f0		 cmp	 esi, eax
  000b0	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  000b3	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  000b6	85 c0		 test	 eax, eax
  000b8	74 1e		 je	 SHORT $LN95@append
$LN37@append:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000ba	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000bf	72 08		 jb	 SHORT $LN38@append

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000c7	eb 06		 jmp	 SHORT $LN96@append
$LN38@append:

; 136  :         return ::operator new(_Bytes);

  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN96@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3005 :         _My_data._Mysize      = _New_size;

  000cf	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  000d2	83 c4 04	 add	 esp, 4
  000d5	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
$LN95@append:
  000d8	8b 5d f0	 mov	 ebx, DWORD PTR __New_size$1$[ebp]
  000db	89 5f 10	 mov	 DWORD PTR [edi+16], ebx

; 3006 :         _My_data._Myres       = _New_capacity;
; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000de	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  000e1	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000e4	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  000e7	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  000ea	89 75 f0	 mov	 DWORD PTR tv520[ebp], esi
  000ed	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  000f0	89 45 0c	 mov	 DWORD PTR tv505[ebp], eax

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

  000f3	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  000f6	51		 push	 ecx
  000f7	83 fa 0f	 cmp	 edx, 15			; 0000000fH
  000fa	76 56		 jbe	 SHORT $LN16@append

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000fc	8b 37		 mov	 esi, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000fe	56		 push	 esi
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 _memcpy
  00105	53		 push	 ebx
  00106	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00109	ff 75 f0	 push	 DWORD PTR tv520[ebp]
  0010c	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00111	8b 45 0c	 mov	 eax, DWORD PTR tv505[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00114	83 c4 18	 add	 esp, 24			; 00000018H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00117	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0011a	41		 inc	 ecx

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0011b	c6 00 00	 mov	 BYTE PTR [eax], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0011e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00124	72 12		 jb	 SHORT $LN69@append

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00126	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00129	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0012c	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012e	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00131	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00134	77 4b		 ja	 SHORT $LN66@append

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00136	8b f2		 mov	 esi, edx
$LN69@append:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00138	51		 push	 ecx
  00139	56		 push	 esi
  0013a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1498 :         return _Reallocate_grow_by(

  0013f	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00142	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1498 :         return _Reallocate_grow_by(

  00145	89 07		 mov	 DWORD PTR [edi], eax

; 1507 :     }

  00147	8b c7		 mov	 eax, edi
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5b		 pop	 ebx
  0014c	8b e5		 mov	 esp, ebp
  0014e	5d		 pop	 ebp
  0014f	c2 08 00	 ret	 8
$LN16@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00152	57		 push	 edi
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _memcpy
  00159	53		 push	 ebx
  0015a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0015d	56		 push	 esi
  0015e	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00163	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00166	83 c4 18	 add	 esp, 24			; 00000018H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00169	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1498 :         return _Reallocate_grow_by(

  0016c	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  0016f	89 07		 mov	 DWORD PTR [edi], eax

; 1507 :     }

  00171	8b c7		 mov	 eax, edi
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5b		 pop	 ebx
  00176	8b e5		 mov	 esp, ebp
  00178	5d		 pop	 ebp
  00179	c2 08 00	 ret	 8
$LN98@append:

; 2994 :             _Xlen_string(); // result too long

  0017c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN66@append:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00181	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN93@append:
  00186	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 27		 jbe	 SHORT $LN19@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN30@basic_stri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN27@basic_stri

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN30@basic_stri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN19@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 1366 :     }

  00044	c3		 ret	 0
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 512  :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
