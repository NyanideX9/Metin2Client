; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\EterLib\Distribute\TextTag.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
PUBLIC	?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z ; GetTextTagOutputString
PUBLIC	?GetTextTagOutputLen@@YAHPB_WH@Z		; GetTextTagOutputLen
PUBLIC	?FindColorTagEndPosition@@YAHPB_WH@Z		; FindColorTagEndPosition
PUBLIC	?FindColorTagStartPosition@@YAHPB_WH@Z		; FindColorTagStartPosition
PUBLIC	?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z ; GetTextTagInternalPosFromRenderPos
PUBLIC	??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?GetDefaultCodePage@@YAKXZ:PROC			; GetDefaultCodePage
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z$1
__ehfuncinfo$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTextTagOutputLen@@YAHPB_WH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTextTagOutputLen@@YAHPB_WH@Z$0
__ehfuncinfo$?GetTextTagOutputLen@@YAHPB_WH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetTextTagOutputLen@@YAHPB_WH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z$1
__ehfuncinfo$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z
_TEXT	SEGMENT
__New_size$1$ = -8					; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
$T1 = 8							; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 2
??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>, COMDAT
; _this$ = ecx

; 2988 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2989 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2990 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2991 :         auto& _My_data            = _Mypair._Myval2;
; 2992 :         const size_type _Old_size = _My_data._Mysize;
; 2993 :         if (max_size() - _Old_size < _Size_increase) {

  00006	8b 55 08	 mov	 edx, DWORD PTR __Size_increase$[ebp]
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	b9 fe ff ff 7f	 mov	 ecx, 2147483646		; 7ffffffeH
  00012	8b c1		 mov	 eax, ecx
  00014	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  00017	2b c3		 sub	 eax, ebx
  00019	89 5d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ebx
  0001c	3b c2		 cmp	 eax, edx
  0001e	0f 82 02 01 00
	00		 jb	 $LN82@Reallocate

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

  00024	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

  00027	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
  0002a	56		 push	 esi

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  0002b	8b f0		 mov	 esi, eax

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	89 45 f8	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00030	83 ce 07	 or	 esi, 7

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

  00033	89 5d 08	 mov	 DWORD PTR $T1[ebp], ebx

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00036	3b f1		 cmp	 esi, ecx

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00038	76 18		 jbe	 SHORT $LN10@Reallocate

; 2944 :             return _Max;

  0003a	8b f1		 mov	 esi, ecx
$LN79@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0003c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00041	03 c0		 add	 eax, eax
$LN28@Reallocate:
  00043	50		 push	 eax
  00044	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00049	72 35		 jb	 SHORT $LN29@Reallocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00050	eb 33		 jmp	 SHORT $LN80@Reallocate
$LN10@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00052	8b c3		 mov	 eax, ebx
  00054	d1 e8		 shr	 eax, 1
  00056	2b c8		 sub	 ecx, eax
  00058	3b d9		 cmp	 ebx, ecx
  0005a	76 07		 jbe	 SHORT $LN11@Reallocate

; 2948 :             return _Max;

  0005c	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  00061	eb d9		 jmp	 SHORT $LN79@Reallocate
$LN11@Reallocate:

; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00063	03 c3		 add	 eax, ebx
  00065	3b f0		 cmp	 esi, eax
  00067	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0006a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0006d	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00072	0f 87 b3 00 00
	00		 ja	 $LN83@Reallocate

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00078	03 c0		 add	 eax, eax

; 227  :     if (_Bytes == 0) {

  0007a	75 c7		 jne	 SHORT $LN28@Reallocate

; 228  :         return nullptr;

  0007c	33 db		 xor	 ebx, ebx
  0007e	eb 0a		 jmp	 SHORT $LN27@Reallocate
$LN29@Reallocate:

; 136  :         return ::operator new(_Bytes);

  00080	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN80@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3005 :         _My_data._Mysize      = _New_size;

  00085	8b d8		 mov	 ebx, eax
  00087	83 c4 04	 add	 esp, 4
$LN27@Reallocate:

; 3006 :         _My_data._Myres       = _New_capacity;
; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3008 :         if (_Old_capacity > _Small_string_capacity) {

  0008a	83 7d 08 07	 cmp	 DWORD PTR $T1[ebp], 7
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  00091	8b 45 f8	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  00094	89 77 14	 mov	 DWORD PTR [edi+20], esi
  00097	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0009a	8d 34 09	 lea	 esi, DWORD PTR [ecx+ecx]
  0009d	76 60		 jbe	 SHORT $LN3@Reallocate

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009f	8b 37		 mov	 esi, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a1	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  000a4	50		 push	 eax
  000a5	56		 push	 esi
  000a6	53		 push	 ebx
  000a7	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2281 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  000ac	8b 55 fc	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000af	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2281 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  000b2	66 8b 45 10	 mov	 ax, WORD PTR _<_Args_0>$[ebp]
  000b6	8d 0c 12	 lea	 ecx, DWORD PTR [edx+edx]
  000b9	66 89 04 19	 mov	 WORD PTR [ecx+ebx], ax

; 2282 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  000bd	33 c0		 xor	 eax, eax
  000bf	66 89 44 19 02	 mov	 WORD PTR [ecx+ebx+2], ax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c4	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  000c7	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ce	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000d4	72 12		 jb	 SHORT $LN60@Reallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000d6	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000d9	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000dc	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000de	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  000e1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000e4	77 4a		 ja	 SHORT $LN57@Reallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000e6	8b f2		 mov	 esi, edx
$LN60@Reallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000e8	51		 push	 ecx
  000e9	56		 push	 esi
  000ea	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ef	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3019 :         return *this;

  000f2	89 1f		 mov	 DWORD PTR [edi], ebx
  000f4	8b c7		 mov	 eax, edi
  000f6	5e		 pop	 esi

; 3020 :     }

  000f7	5f		 pop	 edi
  000f8	5b		 pop	 ebx
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c2 0c 00	 ret	 12			; 0000000cH
$LN3@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ff	56		 push	 esi
  00100	57		 push	 edi
  00101	53		 push	 ebx
  00102	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2281 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  00107	66 8b 45 10	 mov	 ax, WORD PTR _<_Args_0>$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2281 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  0010e	66 89 04 1e	 mov	 WORD PTR [esi+ebx], ax

; 2282 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00112	33 c0		 xor	 eax, eax
  00114	66 89 44 1e 02	 mov	 WORD PTR [esi+ebx+2], ax

; 3019 :         return *this;

  00119	8b c7		 mov	 eax, edi
  0011b	89 1f		 mov	 DWORD PTR [edi], ebx
  0011d	5e		 pop	 esi

; 3020 :     }

  0011e	5f		 pop	 edi
  0011f	5b		 pop	 ebx
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 0c 00	 ret	 12			; 0000000cH
$LN82@Reallocate:

; 2994 :             _Xlen_string(); // result too long

  00126	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN83@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0012b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN57@Reallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00130	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN78@Reallocate:
  00135	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
;	COMDAT ?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z
_TEXT	SEGMENT
_len$ = -88						; size = 4
$T2 = -84						; size = 1
_src$GSCopy$1$ = -80					; size = 4
_output_len$1$ = -76					; size = 4
$T3 = -72						; size = 4
_color_tag$1$ = -65					; size = 1
_extraInfo$ = -64					; size = 24
_dst$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_src$ = 8						; size = 4
_src_len$ = 12						; size = 4
_offset$ = 16						; size = 4
?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z PROC	; GetTextTagInternalPosFromRenderPos, COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0002d	0f 57 c0	 xorps	 xmm0, xmm0
  00030	8b 55 0c	 mov	 edx, DWORD PTR _src_len$[ebp]
  00033	89 45 b0	 mov	 DWORD PTR _src$GSCopy$1$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00036	33 c0		 xor	 eax, eax

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00038	0f 11 45 d8	 movups	 XMMWORD PTR _dst$[ebp], xmm0

; 836  :         _My_data._Mysize = 0;

  0003c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _dst$[ebp+16], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00043	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR _dst$[ebp+20], 7

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004a	66 89 45 d8	 mov	 WORD PTR _dst$[ebp], ax

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0004e	b9 07 00 00 00	 mov	 ecx, 7
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 98   : 	std::wstring dst;

  00053	89 45 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00056	0f 11 45 c0	 movups	 XMMWORD PTR _extraInfo$[ebp], xmm0

; 836  :         _My_data._Mysize = 0;

  0005a	89 45 d0	 mov	 DWORD PTR _extraInfo$[ebp+16], eax

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0005d	89 4d d4	 mov	 DWORD PTR _extraInfo$[ebp+20], ecx

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00060	66 89 45 c0	 mov	 WORD PTR _extraInfo$[ebp], ax
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 101  :     int hyperlinkStep = 0;

  00064	33 ff		 xor	 edi, edi
  00066	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 102  : 	bool color_tag = false;
; 103  : 	int internal_offset = 0;
; 104  : 
; 105  :     for (int i = 0; i < src_len; )

  0006a	33 f6		 xor	 esi, esi
  0006c	89 45 b4	 mov	 DWORD PTR _output_len$1$[ebp], eax
  0006f	88 45 bf	 mov	 BYTE PTR _color_tag$1$[ebp], al
  00072	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
  00075	85 d2		 test	 edx, edx
  00077	0f 8e eb 00 00
	00		 jle	 $LN186@GetTextTag
  0007d	0f 1f 00	 npad	 3
$LL4@GetTextTag:

; 106  :     {
; 107  :         int tag = GetTextTag(&src[i], src_len - i, len, extraInfo);

  00080	8b 45 b0	 mov	 eax, DWORD PTR _src$GSCopy$1$[ebp]
  00083	2b d6		 sub	 edx, esi
  00085	8d 0c 70	 lea	 ecx, DWORD PTR [eax+esi*2]
  00088	8d 45 c0	 lea	 eax, DWORD PTR _extraInfo$[ebp]
  0008b	50		 push	 eax
  0008c	8d 45 a8	 lea	 eax, DWORD PTR _len$[ebp]
  0008f	50		 push	 eax
  00090	52		 push	 edx
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  00097	83 c4 10	 add	 esp, 16			; 00000010H

; 108  : 
; 109  :         if (tag == TEXT_TAG_COLOR)

  0009a	83 f8 02	 cmp	 eax, 2
  0009d	75 0e		 jne	 SHORT $LN5@GetTextTag

; 110  : 		{
; 111  : 			color_tag = true;
; 112  : 			internal_offset = i;

  0009f	8b c6		 mov	 eax, esi
  000a1	c6 45 bf 01	 mov	 BYTE PTR _color_tag$1$[ebp], 1
  000a5	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax

; 113  : 		}

  000a8	e9 aa 00 00 00	 jmp	 $LN98@GetTextTag
$LN5@GetTextTag:

; 114  : 		else if (tag == TEXT_TAG_RESTORE_COLOR)

  000ad	83 f8 05	 cmp	 eax, 5
  000b0	75 09		 jne	 SHORT $LN7@GetTextTag

; 115  : 		{
; 116  : 			color_tag = false;

  000b2	c6 45 bf 00	 mov	 BYTE PTR _color_tag$1$[ebp], 0

; 117  : 		}

  000b6	e9 99 00 00 00	 jmp	 $LN191@GetTextTag
$LN7@GetTextTag:

; 118  :         else if (tag == TEXT_TAG_PLAIN || tag == TEXT_TAG_TAG)

  000bb	85 c0		 test	 eax, eax
  000bd	74 28		 je	 SHORT $LN11@GetTextTag
  000bf	83 f8 01	 cmp	 eax, 1
  000c2	74 23		 je	 SHORT $LN11@GetTextTag

; 129  : 				dst += src[i];
; 130  : 			}
; 131  :         }
; 132  :         else if (tag == TEXT_TAG_HYPERLINK_START)

  000c4	83 f8 03	 cmp	 eax, 3
  000c7	0f 84 82 00 00
	00		 je	 $LN194@GetTextTag

; 133  :             hyperlinkStep = 1;
; 134  :         else if (tag == TEXT_TAG_HYPERLINK_END)

  000cd	83 f8 04	 cmp	 eax, 4
  000d0	75 04		 jne	 SHORT $LN17@GetTextTag

; 135  :             hyperlinkStep = 0;

  000d2	33 ff		 xor	 edi, edi
  000d4	eb 7e		 jmp	 SHORT $LN191@GetTextTag
$LN17@GetTextTag:

; 136  : #ifdef ENABLE_EMOJI_SYSTEM
; 137  : 		else if (tag == TEXT_TAG_EMOJI_START)

  000d6	83 f8 06	 cmp	 eax, 6
  000d9	74 74		 je	 SHORT $LN194@GetTextTag

; 139  : 		else if (tag == TEXT_TAG_EMOJI_END)

  000db	83 f8 07	 cmp	 eax, 7
  000de	8b 45 b8	 mov	 eax, DWORD PTR $T3[ebp]
  000e1	75 74		 jne	 SHORT $LN98@GetTextTag

; 140  : 			hyperlinkStep = 0;

  000e3	33 ff		 xor	 edi, edi
  000e5	eb 70		 jmp	 SHORT $LN98@GetTextTag
$LN11@GetTextTag:

; 119  :         {
; 120  :             if (hyperlinkStep == 0)

  000e7	85 ff		 test	 edi, edi
  000e9	75 69		 jne	 SHORT $LN191@GetTextTag

; 121  : 			{
; 122  : 				if (!color_tag)
; 123  : 					internal_offset = i;
; 124  : 
; 125  : 				if (offset <= output_len)

  000eb	80 7d bf 00	 cmp	 BYTE PTR _color_tag$1$[ebp], 0
  000ef	8b c6		 mov	 eax, esi
  000f1	0f 45 45 b8	 cmovne	 eax, DWORD PTR $T3[ebp]
  000f5	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
  000f8	8b 45 b4	 mov	 eax, DWORD PTR _output_len$1$[ebp]
  000fb	39 45 10	 cmp	 DWORD PTR _offset$[ebp], eax
  000fe	0f 8e c8 00 00
	00		 jle	 $LN184@GetTextTag
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2266 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00104	8b 4d e8	 mov	 ecx, DWORD PTR _dst$[ebp+16]
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 128  :                 ++output_len;

  00107	40		 inc	 eax
  00108	89 45 b4	 mov	 DWORD PTR _output_len$1$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1454 :         push_back(_Ch);

  0010b	8b 45 b0	 mov	 eax, DWORD PTR _src$GSCopy$1$[ebp]
  0010e	0f b7 14 70	 movzx	 edx, WORD PTR [eax+esi*2]

; 2266 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00112	3b 4d ec	 cmp	 ecx, DWORD PTR _dst$[ebp+20]

; 2267 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00115	73 1e		 jae	 SHORT $LN99@GetTextTag

; 434  :         return _Myres > _Small_string_capacity;

  00117	83 7d ec 07	 cmp	 DWORD PTR _dst$[ebp+20], 7

; 2269 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0011b	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0011e	89 45 e8	 mov	 DWORD PTR _dst$[ebp+16], eax

; 416  :         value_type* _Result = _Bx._Buf;

  00121	8d 45 d8	 lea	 eax, DWORD PTR _dst$[ebp]

; 417  :         if (_Large_mode_engaged()) {

  00124	0f 47 45 d8	 cmova	 eax, DWORD PTR _dst$[ebp]

; 2271 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00128	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 2272 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  0012c	33 d2		 xor	 edx, edx
  0012e	66 89 54 48 02	 mov	 WORD PTR [eax+ecx*2+2], dx

; 2273 :             return;

  00133	eb 1f		 jmp	 SHORT $LN191@GetTextTag
$LN99@GetTextTag:

; 2274 :         }
; 2275 : 
; 2276 :         _Reallocate_grow_by(

  00135	52		 push	 edx
  00136	c6 45 ac 00	 mov	 BYTE PTR $T2[ebp], 0
  0013a	8d 4d d8	 lea	 ecx, DWORD PTR _dst$[ebp]
  0013d	ff 75 ac	 push	 DWORD PTR $T2[ebp]
  00140	6a 01		 push	 1
  00142	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
  00147	8b 45 b8	 mov	 eax, DWORD PTR $T3[ebp]
  0014a	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 139  : 		else if (tag == TEXT_TAG_EMOJI_END)

  0014d	eb 08		 jmp	 SHORT $LN98@GetTextTag
$LN194@GetTextTag:

; 141  : #endif
; 142  : 
; 143  :         i += len;

  0014f	bf 01 00 00 00	 mov	 edi, 1
$LN191@GetTextTag:
  00154	8b 45 b8	 mov	 eax, DWORD PTR $T3[ebp]
$LN98@GetTextTag:
  00157	03 75 a8	 add	 esi, DWORD PTR _len$[ebp]
  0015a	8b 55 0c	 mov	 edx, DWORD PTR _src_len$[ebp]
  0015d	3b f2		 cmp	 esi, edx
  0015f	0f 8c 1b ff ff
	ff		 jl	 $LL4@GetTextTag

; 102  : 	bool color_tag = false;
; 103  : 	int internal_offset = 0;
; 104  : 
; 105  :     for (int i = 0; i < src_len; )

  00165	8b 4d d4	 mov	 ecx, DWORD PTR _extraInfo$[ebp+20]
$LN186@GetTextTag:

; 146  : 	return internal_offset;

  00168	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
$LN25@GetTextTag:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0016b	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0016e	76 2e		 jbe	 SHORT $LN128@GetTextTag
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00170	8b 55 c0	 mov	 edx, DWORD PTR _extraInfo$[ebp]
  00173	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  0017a	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0017c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00182	72 10		 jb	 SHORT $LN139@GetTextTag

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00184	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00187	83 c1 23	 add	 ecx, 35			; 00000023H
  0018a	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0018c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0018f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00192	77 65		 ja	 SHORT $LN174@GetTextTag
$LN139@GetTextTag:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00194	51		 push	 ecx
  00195	52		 push	 edx
  00196	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0019b	83 c4 08	 add	 esp, 8
$LN128@GetTextTag:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0019e	8b 45 ec	 mov	 eax, DWORD PTR _dst$[ebp+20]
  001a1	83 f8 07	 cmp	 eax, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  001a4	76 35		 jbe	 SHORT $LN166@GetTextTag
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001a6	8b 55 d8	 mov	 edx, DWORD PTR _dst$[ebp]
  001a9	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]
  001b0	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001b2	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001b8	72 17		 jb	 SHORT $LN177@GetTextTag

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001ba	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001bd	83 c1 23	 add	 ecx, 35			; 00000023H
  001c0	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001c2	83 c0 fc	 add	 eax, -4			; fffffffcH
  001c5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001c8	77 2f		 ja	 SHORT $LN174@GetTextTag
  001ca	eb 05		 jmp	 SHORT $LN177@GetTextTag
$LN184@GetTextTag:
  001cc	8b 4d d4	 mov	 ecx, DWORD PTR _extraInfo$[ebp+20]
  001cf	eb 9a		 jmp	 SHORT $LN25@GetTextTag
$LN177@GetTextTag:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001d1	51		 push	 ecx
  001d2	52		 push	 edx
  001d3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001d8	83 c4 08	 add	 esp, 8
$LN166@GetTextTag:
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 146  : 	return internal_offset;

  001db	8b 45 b8	 mov	 eax, DWORD PTR $T3[ebp]

; 147  : }

  001de	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001e1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e8	59		 pop	 ecx
  001e9	5f		 pop	 edi
  001ea	5e		 pop	 esi
  001eb	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ee	33 cd		 xor	 ecx, ebp
  001f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f5	8b e5		 mov	 esp, ebp
  001f7	5d		 pop	 ebp
  001f8	c3		 ret	 0
$LN174@GetTextTag:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001f9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN193@GetTextTag:
  001fe	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _dst$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z ENDP	; GetTextTagInternalPosFromRenderPos
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
;	COMDAT ?FindColorTagStartPosition@@YAHPB_WH@Z
_TEXT	SEGMENT
tv227 = -4						; size = 4
_src$ = 8						; size = 4
_src_len$ = 12						; size = 4
tv212 = 12						; size = 4
?FindColorTagStartPosition@@YAHPB_WH@Z PROC		; FindColorTagStartPosition, COMDAT

; 182  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 183  :     if (src_len < 2)

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR _src_len$[ebp]
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _src$[ebp]
  0000c	57		 push	 edi
  0000d	83 fb 02	 cmp	 ebx, 2
  00010	0f 8c a3 00 00
	00		 jl	 $LN10@FindColorT

; 184  :         return 0;
; 185  : 
; 186  :     const wchar_t * cur = src;
; 187  : 
; 188  : 	// @fixme012
; 189  : 	wchar_t wcStarts = L'c';
; 190  : 	wchar_t wcEnds = L'r';
; 191  : 	if (GetDefaultCodePage() == CP_ARABIC)

  00016	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage

; 192  : 	{
; 193  : 		wcStarts = L'h';
; 194  : 		wcEnds = L'h';
; 195  : 	}
; 196  : 
; 197  :     if (*cur == wcEnds && *(cur - 1) == L'|')

  0001b	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  00020	c7 45 0c 72 00
	00 00		 mov	 DWORD PTR tv212[ebp], 114 ; 00000072H
  00027	ba 68 00 00 00	 mov	 edx, 104		; 00000068H
  0002c	bf 63 00 00 00	 mov	 edi, 99			; 00000063H
  00031	8b c2		 mov	 eax, edx
  00033	0f 45 55 0c	 cmovne	 edx, DWORD PTR tv212[ebp]
  00037	0f 45 c7	 cmovne	 eax, edi
  0003a	0f b7 c0	 movzx	 eax, ax
  0003d	89 45 fc	 mov	 DWORD PTR tv227[ebp], eax
  00040	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00043	66 3b c2	 cmp	 ax, dx
  00046	75 5b		 jne	 SHORT $LN21@FindColorT
  00048	66 83 7e fe 7c	 cmp	 WORD PTR [esi-2], 124	; 0000007cH
  0004d	75 54		 jne	 SHORT $LN21@FindColorT

; 198  :     {
; 199  : 	    int len = src_len;
; 200  : 
; 201  :         if (len >= 2 && *(cur - 2) == L'|')

  0004f	0f b7 46 fc	 movzx	 eax, WORD PTR [esi-4]
  00053	8d 4e fc	 lea	 ecx, DWORD PTR [esi-4]
  00056	8b f8		 mov	 edi, eax
  00058	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  0005b	74 3a		 je	 SHORT $LN22@FindColorT

; 202  :             return 1;
; 203  : 
; 204  :         cur -= 2;
; 205  :         len -= 2;

  0005d	8d 53 fe	 lea	 edx, DWORD PTR [ebx-2]

; 206  : 
; 207  :         while (len > 1)

  00060	83 fa 01	 cmp	 edx, 1
  00063	7e 29		 jle	 SHORT $LN15@FindColorT
$LL2@FindColorT:

; 208  :         {
; 209  :             if (*cur == wcStarts && *(cur - 1) == L'|')

  00065	66 3b 7d fc	 cmp	 di, WORD PTR tv227[ebp]
  00069	75 07		 jne	 SHORT $LN20@FindColorT
  0006b	66 83 79 fe 7c	 cmp	 WORD PTR [ecx-2], 124	; 0000007cH
  00070	74 0e		 je	 SHORT $LN13@FindColorT
$LN20@FindColorT:

; 211  : 
; 212  :             --cur;
; 213  :             --len;

  00072	4a		 dec	 edx
  00073	83 c1 fe	 add	 ecx, -2			; fffffffeH
  00076	83 fa 01	 cmp	 edx, 1
  00079	7e 13		 jle	 SHORT $LN15@FindColorT

; 206  : 
; 207  :         while (len > 1)

  0007b	0f b7 39	 movzx	 edi, WORD PTR [ecx]
  0007e	eb e5		 jmp	 SHORT $LL2@FindColorT
$LN13@FindColorT:

; 210  :                 return (src - cur) + 1;

  00080	2b f1		 sub	 esi, ecx
  00082	d1 fe		 sar	 esi, 1
  00084	5f		 pop	 edi
  00085	8d 46 01	 lea	 eax, DWORD PTR [esi+1]

; 218  : 		return 1;
; 219  : 
; 220  :     return 0;
; 221  : }

  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
$LN15@FindColorT:
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	8b c3		 mov	 eax, ebx
  00092	5b		 pop	 ebx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
$LN22@FindColorT:
  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	5b		 pop	 ebx
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
$LN21@FindColorT:

; 214  :         }
; 215  :         return (src_len);
; 216  :     }
; 217  : 	else if (*cur == L'|' && *(cur - 1) == L'|')

  000a3	83 f8 7c	 cmp	 eax, 124		; 0000007cH
  000a6	75 11		 jne	 SHORT $LN10@FindColorT
  000a8	33 c0		 xor	 eax, eax
  000aa	66 83 7e fe 7c	 cmp	 WORD PTR [esi-2], 124	; 0000007cH
  000af	5f		 pop	 edi

; 218  : 		return 1;
; 219  : 
; 220  :     return 0;
; 221  : }

  000b0	5e		 pop	 esi
  000b1	0f 94 c0	 sete	 al
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
$LN10@FindColorT:
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	33 c0		 xor	 eax, eax
  000bd	5b		 pop	 ebx
  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?FindColorTagStartPosition@@YAHPB_WH@Z ENDP		; FindColorTagStartPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
;	COMDAT ?FindColorTagEndPosition@@YAHPB_WH@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_src_len$ = 12						; size = 4
?FindColorTagEndPosition@@YAHPB_WH@Z PROC		; FindColorTagEndPosition, COMDAT

; 224  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 225  : 	const wchar_t * cur = src;
; 226  : 
; 227  : 	// @fixme012
; 228  : 	wchar_t wcStarts = L'c';
; 229  : 	wchar_t wcEnds = L'r';
; 230  : 	if (GetDefaultCodePage() == CP_ARABIC)

  00005	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage

; 231  : 	{
; 232  : 		wcStarts = L'h';
; 233  : 		wcEnds = L'h';
; 234  : 	}
; 235  : 
; 236  : 	if (src_len >= 4 && *cur == L'|' && *(cur + 1) == wcStarts)

  0000a	ba 68 00 00 00	 mov	 edx, 104		; 00000068H
  0000f	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  00014	be 72 00 00 00	 mov	 esi, 114		; 00000072H
  00019	8b ca		 mov	 ecx, edx
  0001b	0f 45 ce	 cmovne	 ecx, esi
  0001e	8b 75 08	 mov	 esi, DWORD PTR _src$[ebp]
  00021	0f b7 f9	 movzx	 edi, cx
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR _src_len$[ebp]
  00027	83 f9 04	 cmp	 ecx, 4
  0002a	7c 48		 jl	 SHORT $LN5@FindColorT
  0002c	66 83 3e 7c	 cmp	 WORD PTR [esi], 124	; 0000007cH
  00030	75 33		 jne	 SHORT $LN8@FindColorT
  00032	53		 push	 ebx
  00033	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  00038	bb 63 00 00 00	 mov	 ebx, 99			; 00000063H
  0003d	0f 45 d3	 cmovne	 edx, ebx
  00040	5b		 pop	 ebx
  00041	66 39 56 02	 cmp	 WORD PTR [esi+2], dx
  00045	75 38		 jne	 SHORT $LN18@FindColorT

; 237  : 	{
; 238  : 		int left = src_len - 2;

  00047	8d 51 fe	 lea	 edx, DWORD PTR [ecx-2]

; 239  : 		cur += 2;

  0004a	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  0004d	0f 1f 00	 npad	 3
$LL2@FindColorT:

; 240  : 
; 241  : 		while (left > 1)
; 242  : 		{
; 243  : 			if (*cur == L'|' && *(cur + 1) == wcEnds)

  00050	66 83 38 7c	 cmp	 WORD PTR [eax], 124	; 0000007cH
  00054	75 06		 jne	 SHORT $LN16@FindColorT
  00056	66 39 78 02	 cmp	 WORD PTR [eax+2], di
  0005a	74 0f		 je	 SHORT $LN11@FindColorT
$LN16@FindColorT:

; 245  : 
; 246  : 			--left;

  0005c	4a		 dec	 edx

; 247  : 			++cur;

  0005d	83 c0 02	 add	 eax, 2
  00060	83 fa 01	 cmp	 edx, 1
  00063	7f eb		 jg	 SHORT $LL2@FindColorT
$LN8@FindColorT:
  00065	5f		 pop	 edi

; 251  : 		return 1;
; 252  : 
; 253  : 	return 0;

  00066	33 c0		 xor	 eax, eax

; 254  : }

  00068	5e		 pop	 esi
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN11@FindColorT:

; 244  : 				return (cur - src) + 1;

  0006b	2b c6		 sub	 eax, esi
  0006d	d1 f8		 sar	 eax, 1
  0006f	5f		 pop	 edi
  00070	40		 inc	 eax

; 254  : }

  00071	5e		 pop	 esi
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
$LN5@FindColorT:

; 248  : 		}
; 249  : 	}
; 250  : 	else if (src_len >= 2 && *cur == L'|' && *(cur + 1) == L'|')

  00074	83 f9 02	 cmp	 ecx, 2
  00077	7c ec		 jl	 SHORT $LN8@FindColorT
  00079	66 83 3e 7c	 cmp	 WORD PTR [esi], 124	; 0000007cH
  0007d	75 e6		 jne	 SHORT $LN8@FindColorT
$LN18@FindColorT:
  0007f	33 c0		 xor	 eax, eax
  00081	66 83 7e 02 7c	 cmp	 WORD PTR [esi+2], 124	; 0000007cH
  00086	5f		 pop	 edi
  00087	0f 94 c0	 sete	 al

; 254  : }

  0008a	5e		 pop	 esi
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?FindColorTagEndPosition@@YAHPB_WH@Z ENDP		; FindColorTagEndPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
;	COMDAT ?GetTextTagOutputLen@@YAHPB_WH@Z
_TEXT	SEGMENT
_src$GSCopy$1$ = -52					; size = 4
_len$ = -48						; size = 4
_output_len$1$ = -44					; size = 4
_extraInfo$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_src$ = 8						; size = 4
_src_len$ = 12						; size = 4
?GetTextTagOutputLen@@YAHPB_WH@Z PROC			; GetTextTagOutputLen, COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTextTagOutputLen@@YAHPB_WH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  0002d	0f 57 c0	 xorps	 xmm0, xmm0
  00030	8b 45 0c	 mov	 eax, DWORD PTR _src_len$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00033	b9 07 00 00 00	 mov	 ecx, 7

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00038	33 f6		 xor	 esi, esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 150  : {

  0003a	89 55 cc	 mov	 DWORD PTR _src$GSCopy$1$[ebp], edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0003d	0f 11 45 d8	 movups	 XMMWORD PTR _extraInfo$[ebp], xmm0

; 836  :         _My_data._Mysize = 0;

  00041	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _extraInfo$[ebp+16], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00048	89 4d ec	 mov	 DWORD PTR _extraInfo$[ebp+20], ecx

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004b	66 89 75 d8	 mov	 WORD PTR _extraInfo$[ebp], si
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 156  :     for (int i = 0; i < src_len; )

  0004f	33 ff		 xor	 edi, edi
  00051	89 75 fc	 mov	 DWORD PTR __$EHRec$[ebp+8], esi
  00054	89 75 d4	 mov	 DWORD PTR _output_len$1$[ebp], esi
  00057	85 c0		 test	 eax, eax
  00059	7e 62		 jle	 SHORT $LN3@GetTextTag
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@GetTextTag:

; 157  :     {
; 158  :         int tag = GetTextTag(&src[i], src_len - i, len, extraInfo);

  00060	8d 4d d8	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  00063	2b c7		 sub	 eax, edi
  00065	51		 push	 ecx
  00066	8d 4d d0	 lea	 ecx, DWORD PTR _len$[ebp]
  00069	51		 push	 ecx
  0006a	50		 push	 eax
  0006b	8d 04 7a	 lea	 eax, DWORD PTR [edx+edi*2]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  00074	83 c4 10	 add	 esp, 16			; 00000010H

; 159  : 
; 160  :         if (tag == TEXT_TAG_PLAIN || tag == TEXT_TAG_TAG)

  00077	85 c0		 test	 eax, eax
  00079	74 2b		 je	 SHORT $LN7@GetTextTag
  0007b	83 f8 01	 cmp	 eax, 1
  0007e	74 26		 je	 SHORT $LN7@GetTextTag

; 164  :         }
; 165  :         else if (tag == TEXT_TAG_HYPERLINK_START)

  00080	83 f8 03	 cmp	 eax, 3
  00083	75 05		 jne	 SHORT $LN9@GetTextTag

; 166  :             hyperlinkStep = 1;

  00085	8d 70 fe	 lea	 esi, DWORD PTR [eax-2]
  00088	eb 23		 jmp	 SHORT $LN8@GetTextTag
$LN9@GetTextTag:

; 167  :         else if (tag == TEXT_TAG_HYPERLINK_END)

  0008a	83 f8 04	 cmp	 eax, 4
  0008d	75 04		 jne	 SHORT $LN11@GetTextTag

; 168  :             hyperlinkStep = 0;

  0008f	33 f6		 xor	 esi, esi
  00091	eb 1a		 jmp	 SHORT $LN8@GetTextTag
$LN11@GetTextTag:

; 169  : #ifdef ENABLE_EMOJI_SYSTEM
; 170  : 		else if (tag == TEXT_TAG_EMOJI_START)

  00093	83 f8 06	 cmp	 eax, 6
  00096	75 05		 jne	 SHORT $LN13@GetTextTag

; 171  : 			hyperlinkStep = 1;

  00098	8d 70 fb	 lea	 esi, DWORD PTR [eax-5]
  0009b	eb 10		 jmp	 SHORT $LN8@GetTextTag
$LN13@GetTextTag:

; 172  : 		else if (tag == TEXT_TAG_EMOJI_END)

  0009d	83 f8 07	 cmp	 eax, 7
  000a0	75 0b		 jne	 SHORT $LN8@GetTextTag

; 173  : 			hyperlinkStep = 0;

  000a2	33 f6		 xor	 esi, esi
  000a4	eb 07		 jmp	 SHORT $LN8@GetTextTag
$LN7@GetTextTag:

; 161  :         {
; 162  :             if (hyperlinkStep == 0)

  000a6	85 f6		 test	 esi, esi
  000a8	75 03		 jne	 SHORT $LN8@GetTextTag

; 163  :                 ++output_len;

  000aa	ff 45 d4	 inc	 DWORD PTR _output_len$1$[ebp]
$LN8@GetTextTag:

; 174  : #endif
; 175  : 
; 176  :         i += len;

  000ad	03 7d d0	 add	 edi, DWORD PTR _len$[ebp]
  000b0	8b 45 0c	 mov	 eax, DWORD PTR _src_len$[ebp]
  000b3	8b 55 cc	 mov	 edx, DWORD PTR _src$GSCopy$1$[ebp]
  000b6	3b f8		 cmp	 edi, eax
  000b8	7c a6		 jl	 SHORT $LL4@GetTextTag
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _extraInfo$[ebp+20]
$LN3@GetTextTag:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000bd	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  000c0	76 2e		 jbe	 SHORT $LN58@GetTextTag
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c2	8b 55 d8	 mov	 edx, DWORD PTR _extraInfo$[ebp]
  000c5	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  000cc	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ce	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000d4	72 10		 jb	 SHORT $LN69@GetTextTag

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000d6	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000d9	83 c1 23	 add	 ecx, 35			; 00000023H
  000dc	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000de	83 c0 fc	 add	 eax, -4			; fffffffcH
  000e1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000e4	77 28		 ja	 SHORT $LN83@GetTextTag
$LN69@GetTextTag:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000e6	51		 push	 ecx
  000e7	52		 push	 edx
  000e8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ed	83 c4 08	 add	 esp, 8
$LN58@GetTextTag:
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 178  :     return output_len;

  000f0	8b 45 d4	 mov	 eax, DWORD PTR _output_len$1$[ebp]

; 179  : }

  000f3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fd	59		 pop	 ecx
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00103	33 cd		 xor	 ecx, ebp
  00105	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c3		 ret	 0
$LN83@GetTextTag:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN81@GetTextTag:
  00113	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTextTagOutputLen@@YAHPB_WH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?GetTextTagOutputLen@@YAHPB_WH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTextTagOutputLen@@YAHPB_WH@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTextTagOutputLen@@YAHPB_WH@Z ENDP			; GetTextTagOutputLen
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
;	COMDAT ?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z
_TEXT	SEGMENT
___$ReturnUdt$GSCopy$ = -68				; size = 4
_src$GSCopy$1$ = -64					; size = 4
_len$ = -60						; size = 4
$T2 = -56						; size = 1
$T3 = -52						; size = 4
_i$1$ = -48						; size = 4
tv507 = -44						; size = 4
__Ch$1$ = -44						; size = 4
_extraInfo$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_src$ = 12						; size = 4
_src_len$ = 16						; size = 4
?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z PROC ; GetTextTagOutputString, COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
  0002d	0f 57 c0	 xorps	 xmm0, xmm0
  00030	8b 55 0c	 mov	 edx, DWORD PTR _src$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00033	33 c0		 xor	 eax, eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 60   : {

  00035	89 75 bc	 mov	 DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
  00038	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0003f	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00042	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00049	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 836  :         _My_data._Mysize = 0;

  00050	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00057	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 60   : {

  0005e	89 55 c0	 mov	 DWORD PTR _src$GSCopy$1$[ebp], edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00061	66 89 06	 mov	 WORD PTR [esi], ax

; 836  :         _My_data._Mysize = 0;

  00064	89 45 e8	 mov	 DWORD PTR _extraInfo$[ebp+16], eax

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00067	33 c9		 xor	 ecx, ecx
  00069	b8 07 00 00 00	 mov	 eax, 7
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 62   : 	std::wstring dst;

  0006e	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR $T3[ebp], 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00075	0f 11 45 d8	 movups	 XMMWORD PTR _extraInfo$[ebp], xmm0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00079	89 45 ec	 mov	 DWORD PTR _extraInfo$[ebp+20], eax

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0007c	66 89 4d d8	 mov	 WORD PTR _extraInfo$[ebp], cx
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 65   :     int hyperlinkStep = 0;

  00080	33 ff		 xor	 edi, edi
  00082	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 66   : 
; 67   :     for (int i = 0; i < src_len; )

  00089	89 4d d0	 mov	 DWORD PTR _i$1$[ebp], ecx
  0008c	39 4d 10	 cmp	 DWORD PTR _src_len$[ebp], ecx
  0008f	0f 8e b0 00 00
	00		 jle	 $LN3@GetTextTag
  00095	8b 45 10	 mov	 eax, DWORD PTR _src_len$[ebp]
$LL4@GetTextTag:

; 68   :     {
; 69   :         int tag = GetTextTag(&src[i], src_len - i, len, extraInfo);

  00098	8d 14 4a	 lea	 edx, DWORD PTR [edx+ecx*2]
  0009b	2b c1		 sub	 eax, ecx
  0009d	89 55 d4	 mov	 DWORD PTR tv507[ebp], edx
  000a0	8d 55 d8	 lea	 edx, DWORD PTR _extraInfo$[ebp]
  000a3	52		 push	 edx
  000a4	8d 55 c4	 lea	 edx, DWORD PTR _len$[ebp]
  000a7	52		 push	 edx
  000a8	8b 55 d4	 mov	 edx, DWORD PTR tv507[ebp]
  000ab	50		 push	 eax
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  000b2	83 c4 10	 add	 esp, 16			; 00000010H

; 70   : 
; 71   :         if (tag == TEXT_TAG_PLAIN || tag == TEXT_TAG_TAG)

  000b5	85 c0		 test	 eax, eax
  000b7	74 2b		 je	 SHORT $LN7@GetTextTag
  000b9	83 f8 01	 cmp	 eax, 1
  000bc	74 26		 je	 SHORT $LN7@GetTextTag

; 74   : 			{
; 75   :                 ++output_len;
; 76   : 				dst += src[i];
; 77   : 			}
; 78   :         }
; 79   :         else if (tag == TEXT_TAG_HYPERLINK_START)

  000be	83 f8 03	 cmp	 eax, 3
  000c1	75 05		 jne	 SHORT $LN9@GetTextTag

; 80   :             hyperlinkStep = 1;

  000c3	8d 78 fe	 lea	 edi, DWORD PTR [eax-2]
  000c6	eb 63		 jmp	 SHORT $LN62@GetTextTag
$LN9@GetTextTag:

; 81   :         else if (tag == TEXT_TAG_HYPERLINK_END)

  000c8	83 f8 04	 cmp	 eax, 4
  000cb	75 04		 jne	 SHORT $LN11@GetTextTag

; 82   :             hyperlinkStep = 0;

  000cd	33 ff		 xor	 edi, edi
  000cf	eb 5a		 jmp	 SHORT $LN62@GetTextTag
$LN11@GetTextTag:

; 83   : #ifdef ENABLE_EMOJI_SYSTEM
; 84   : 		else if (tag == TEXT_TAG_EMOJI_START)

  000d1	83 f8 06	 cmp	 eax, 6
  000d4	75 05		 jne	 SHORT $LN13@GetTextTag

; 85   : 			hyperlinkStep = 1;

  000d6	8d 78 fb	 lea	 edi, DWORD PTR [eax-5]
  000d9	eb 50		 jmp	 SHORT $LN62@GetTextTag
$LN13@GetTextTag:

; 86   : 		else if (tag == TEXT_TAG_EMOJI_END)

  000db	83 f8 07	 cmp	 eax, 7
  000de	75 4b		 jne	 SHORT $LN62@GetTextTag

; 87   : 			hyperlinkStep = 0;

  000e0	33 ff		 xor	 edi, edi
  000e2	eb 47		 jmp	 SHORT $LN62@GetTextTag
$LN7@GetTextTag:

; 72   :         {
; 73   :             if (hyperlinkStep == 0)

  000e4	85 ff		 test	 edi, edi
  000e6	75 43		 jne	 SHORT $LN62@GetTextTag
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1454 :         push_back(_Ch);

  000e8	8b 45 d4	 mov	 eax, DWORD PTR tv507[ebp]

; 2266 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  000eb	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 2267 :         if (_Old_size < _Mypair._Myval2._Myres) {

  000ee	8b 56 14	 mov	 edx, DWORD PTR [esi+20]

; 1454 :         push_back(_Ch);

  000f1	0f b7 00	 movzx	 eax, WORD PTR [eax]
  000f4	89 45 d4	 mov	 DWORD PTR __Ch$1$[ebp], eax

; 2267 :         if (_Old_size < _Mypair._Myval2._Myres) {

  000f7	3b ca		 cmp	 ecx, edx
  000f9	73 1f		 jae	 SHORT $LN63@GetTextTag

; 2268 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2269 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  000fb	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000fe	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 416  :         value_type* _Result = _Bx._Buf;

  00101	8b c6		 mov	 eax, esi

; 434  :         return _Myres > _Small_string_capacity;

  00103	83 fa 07	 cmp	 edx, 7

; 417  :         if (_Large_mode_engaged()) {

  00106	76 02		 jbe	 SHORT $LN66@GetTextTag

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  00108	8b 06		 mov	 eax, DWORD PTR [esi]
$LN66@GetTextTag:

; 2271 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  0010a	8b 55 d4	 mov	 edx, DWORD PTR __Ch$1$[ebp]
  0010d	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx

; 2272 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00111	33 d2		 xor	 edx, edx
  00113	66 89 54 48 02	 mov	 WORD PTR [eax+ecx*2+2], dx

; 2273 :             return;

  00118	eb 11		 jmp	 SHORT $LN62@GetTextTag
$LN63@GetTextTag:

; 2274 :         }
; 2275 : 
; 2276 :         _Reallocate_grow_by(

  0011a	50		 push	 eax
  0011b	c6 45 c8 00	 mov	 BYTE PTR $T2[ebp], 0
  0011f	8b ce		 mov	 ecx, esi
  00121	ff 75 c8	 push	 DWORD PTR $T2[ebp]
  00124	6a 01		 push	 1
  00126	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
$LN62@GetTextTag:
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 90   :         i += len;

  0012b	8b 4d d0	 mov	 ecx, DWORD PTR _i$1$[ebp]
  0012e	03 4d c4	 add	 ecx, DWORD PTR _len$[ebp]
  00131	8b 45 10	 mov	 eax, DWORD PTR _src_len$[ebp]
  00134	8b 55 c0	 mov	 edx, DWORD PTR _src$GSCopy$1$[ebp]
  00137	89 4d d0	 mov	 DWORD PTR _i$1$[ebp], ecx
  0013a	3b c8		 cmp	 ecx, eax
  0013c	0f 8c 56 ff ff
	ff		 jl	 $LL4@GetTextTag
  00142	8b 45 ec	 mov	 eax, DWORD PTR _extraInfo$[ebp+20]
$LN3@GetTextTag:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00145	83 f8 07	 cmp	 eax, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00148	76 2e		 jbe	 SHORT $LN92@GetTextTag
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0014a	8b 55 d8	 mov	 edx, DWORD PTR _extraInfo$[ebp]
  0014d	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]
  00154	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00156	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0015c	72 10		 jb	 SHORT $LN103@GetTextTag

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0015e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00161	83 c1 23	 add	 ecx, 35			; 00000023H
  00164	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00166	83 c0 fc	 add	 eax, -4			; fffffffcH
  00169	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0016c	77 27		 ja	 SHORT $LN117@GetTextTag
$LN103@GetTextTag:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0016e	51		 push	 ecx
  0016f	52		 push	 edx
  00170	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00175	83 c4 08	 add	 esp, 8
$LN92@GetTextTag:
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp

; 92   : 	return dst;

  00178	8b c6		 mov	 eax, esi

; 93   : }

  0017a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00184	59		 pop	 ecx
  00185	5f		 pop	 edi
  00186	5e		 pop	 esi
  00187	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018a	33 cd		 xor	 ecx, ebp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	8b e5		 mov	 esp, ebp
  00193	5d		 pop	 ebp
  00194	c3		 ret	 0
$LN117@GetTextTag:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00195	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN115@GetTextTag:
  0019a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z$0:
  00000	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0c 00 00
	00		 je	 $LN18@GetTextTag
  0000c	83 65 cc fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00010	8b 4d bc	 mov	 ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN18@GetTextTag:
  00018	c3		 ret	 0
__unwindfunclet$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z$1:
  00019	8d 4d d8	 lea	 ecx, DWORD PTR _extraInfo$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z ENDP ; GetTextTagOutputString
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\TextTag.cpp
;	COMDAT ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_maxLen$ = 12						; size = 4
_tagLen$ = 16						; size = 4
_extraInfo$ = 20					; size = 4
?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z PROC ; GetTextTag, COMDAT

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7    :     tagLen = 1;
; 8    : 
; 9    :     if (maxLen < 2 || *src != L'|')

  00003	83 7d 0c 02	 cmp	 DWORD PTR _maxLen$[ebp], 2
  00007	8b 45 10	 mov	 eax, DWORD PTR _tagLen$[ebp]
  0000a	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  00010	0f 8c 99 00 00
	00		 jl	 $LN3@GetTextTag
  00016	8b 55 08	 mov	 edx, DWORD PTR _src$[ebp]
  00019	66 83 3a 7c	 cmp	 WORD PTR [edx], 124	; 0000007cH
  0001d	0f 85 8c 00 00
	00		 jne	 $LN3@GetTextTag

; 11   : 
; 12   :     const wchar_t * cur = ++src;
; 13   : 
; 14   :     if (*cur == L'c') // color

  00023	0f b7 4a 02	 movzx	 ecx, WORD PTR [edx+2]
  00027	83 f9 63	 cmp	 ecx, 99			; 00000063H
  0002a	75 21		 jne	 SHORT $LN4@GetTextTag

; 15   :     {
; 16   :         if (maxLen < 10)

  0002c	83 7d 0c 0a	 cmp	 DWORD PTR _maxLen$[ebp], 10 ; 0000000aH
  00030	7c 7d		 jl	 SHORT $LN3@GetTextTag

; 17   :             return TEXT_TAG_PLAIN;
; 18   : 
; 19   :         tagLen = 10;
; 20   :         extraInfo.assign(++cur, 8);

  00032	8b 4d 14	 mov	 ecx, DWORD PTR _extraInfo$[ebp]
  00035	c7 00 0a 00 00
	00		 mov	 DWORD PTR [eax], 10	; 0000000aH
  0003b	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  0003e	6a 08		 push	 8
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 21   :         return TEXT_TAG_COLOR;

  00046	b8 02 00 00 00	 mov	 eax, 2

; 53   : 	}
; 54   : #endif
; 55   : 
; 56   :     return TEXT_TAG_PLAIN;
; 57   : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
$LN4@GetTextTag:

; 22   :     }
; 23   :     else if (*cur == L'|')

  0004d	83 f9 7c	 cmp	 ecx, 124		; 0000007cH
  00050	75 0b		 jne	 SHORT $LN7@GetTextTag

; 24   :     {
; 25   :         tagLen = 2;

  00052	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 26   :         return TEXT_TAG_TAG;

  00058	8d 41 85	 lea	 eax, DWORD PTR [ecx-123]

; 53   : 	}
; 54   : #endif
; 55   : 
; 56   :     return TEXT_TAG_PLAIN;
; 57   : }

  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
$LN7@GetTextTag:

; 27   :     }
; 28   :     else if (*cur == L'r') // restore color

  0005d	83 f9 72	 cmp	 ecx, 114		; 00000072H
  00060	75 0b		 jne	 SHORT $LN9@GetTextTag

; 29   :     {
; 30   :         tagLen = 2;

  00062	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 31   :         return TEXT_TAG_RESTORE_COLOR;

  00068	8d 41 93	 lea	 eax, DWORD PTR [ecx-109]

; 53   : 	}
; 54   : #endif
; 55   : 
; 56   :     return TEXT_TAG_PLAIN;
; 57   : }

  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
$LN9@GetTextTag:

; 32   :     }
; 33   :     else if (*cur == L'H')

  0006d	83 f9 48	 cmp	 ecx, 72			; 00000048H
  00070	75 0b		 jne	 SHORT $LN11@GetTextTag

; 34   :     {
; 35   :         tagLen = 2;

  00072	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 36   :         return TEXT_TAG_HYPERLINK_START;

  00078	8d 41 bb	 lea	 eax, DWORD PTR [ecx-69]

; 53   : 	}
; 54   : #endif
; 55   : 
; 56   :     return TEXT_TAG_PLAIN;
; 57   : }

  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
$LN11@GetTextTag:

; 37   :     }
; 38   :     else if (*cur == L'h') // end of hyperlink

  0007d	83 f9 68	 cmp	 ecx, 104		; 00000068H
  00080	75 0b		 jne	 SHORT $LN13@GetTextTag

; 39   :     {
; 40   :         tagLen = 2;

  00082	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 41   :         return TEXT_TAG_HYPERLINK_END;

  00088	8d 41 9c	 lea	 eax, DWORD PTR [ecx-100]

; 53   : 	}
; 54   : #endif
; 55   : 
; 56   :     return TEXT_TAG_PLAIN;
; 57   : }

  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN13@GetTextTag:

; 42   :     }
; 43   : #ifdef ENABLE_EMOJI_SYSTEM
; 44   : 	else if (*cur == L'E') // emoji |Epath/emo|e

  0008d	83 f9 45	 cmp	 ecx, 69			; 00000045H
  00090	75 0b		 jne	 SHORT $LN15@GetTextTag

; 45   : 	{
; 46   : 		tagLen = 2;

  00092	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 47   : 		return TEXT_TAG_EMOJI_START;

  00098	8d 41 c1	 lea	 eax, DWORD PTR [ecx-63]

; 53   : 	}
; 54   : #endif
; 55   : 
; 56   :     return TEXT_TAG_PLAIN;
; 57   : }

  0009b	5d		 pop	 ebp
  0009c	c3		 ret	 0
$LN15@GetTextTag:

; 48   : 	}
; 49   : 	else if (*cur == L'e') // end of emoji

  0009d	83 f9 65	 cmp	 ecx, 101		; 00000065H
  000a0	75 0d		 jne	 SHORT $LN3@GetTextTag

; 50   : 	{
; 51   : 		tagLen = 2;

  000a2	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 52   : 		return TEXT_TAG_EMOJI_END;

  000a8	b8 07 00 00 00	 mov	 eax, 7

; 53   : 	}
; 54   : #endif
; 55   : 
; 56   :     return TEXT_TAG_PLAIN;
; 57   : }

  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
$LN3@GetTextTag:

; 10   :         return TEXT_TAG_PLAIN;

  000af	33 c0		 xor	 eax, eax

; 53   : 	}
; 54   : #endif
; 55   : 
; 56   :     return TEXT_TAG_PLAIN;
; 57   : }

  000b1	5d		 pop	 ebp
  000b2	c3		 ret	 0
?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ENDP ; GetTextTag
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Result$1$ = 12					; size = 4
$T2 = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1592 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1593 :         // assign [_Ptr, _Ptr + _Count)
; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0000f	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 36		 ja	 SHORT $LN2@assign

; 416  :         value_type* _Result = _Bx._Buf;

  00016	89 7d 0c	 mov	 DWORD PTR __Result$1$[ebp], edi
  00019	8b c7		 mov	 eax, edi

; 434  :         return _Myres > _Small_string_capacity;

  0001b	83 f9 07	 cmp	 ecx, 7

; 417  :         if (_Large_mode_engaged()) {

  0001e	76 05		 jbe	 SHORT $LN5@assign

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	89 45 0c	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN5@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00025	8d 34 1b	 lea	 esi, DWORD PTR [ebx+ebx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1597 :             _Mypair._Myval2._Mysize = _Count;

  00028	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0002b	56		 push	 esi
  0002c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _memmove
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00035	8b 45 0c	 mov	 eax, DWORD PTR __Result$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0003b	33 c9		 xor	 ecx, ecx
  0003d	66 89 0c 06	 mov	 WORD PTR [esi+eax], cx

; 1611 :     }

  00041	8b c7		 mov	 eax, edi
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN2@assign:

; 2962 :         if (_New_size > max_size()) {

  0004c	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  00052	0f 87 c4 00 00
	00		 ja	 $LN95@assign

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00058	8b f3		 mov	 esi, ebx
  0005a	83 ce 07	 or	 esi, 7
  0005d	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00063	77 2b		 ja	 SHORT $LN92@assign

; 2944 :             return _Max;
; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00065	8b d1		 mov	 edx, ecx
  00067	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  0006c	d1 ea		 shr	 edx, 1
  0006e	2b c2		 sub	 eax, edx
  00070	3b c8		 cmp	 ecx, eax
  00072	77 1c		 ja	 SHORT $LN92@assign

; 2948 :             return _Max;
; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00077	3b f0		 cmp	 esi, eax
  00079	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0007c	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0007f	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00084	0f 87 97 00 00
	00		 ja	 $LN96@assign

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0008a	03 c0		 add	 eax, eax

; 227  :     if (_Bytes == 0) {

  0008c	75 0e		 jne	 SHORT $LN41@assign

; 228  :         return nullptr;

  0008e	eb 23		 jmp	 SHORT $LN91@assign
$LN92@assign:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00095	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  0009a	03 c0		 add	 eax, eax
$LN41@assign:
  0009c	50		 push	 eax
  0009d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a2	72 07		 jb	 SHORT $LN42@assign

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a4	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a9	eb 05		 jmp	 SHORT $LN93@assign
$LN42@assign:

; 136  :         return ::operator new(_Bytes);

  000ab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN93@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000b0	83 c4 04	 add	 esp, 4
$LN91@assign:

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  000b3	89 77 14	 mov	 DWORD PTR [edi+20], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b6	8d 34 1b	 lea	 esi, DWORD PTR [ebx+ebx]
  000b9	56		 push	 esi
  000ba	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000bd	89 45 0c	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c0	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000c1	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c4	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000c9	8b 5d 0c	 mov	 ebx, DWORD PTR $T2[ebp]
  000cc	33 c0		 xor	 eax, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000d1	66 89 04 1e	 mov	 WORD PTR [esi+ebx], ax

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  000d5	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  000d8	83 f8 07	 cmp	 eax, 7
  000db	76 2d		 jbe	 SHORT $LN16@assign
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000dd	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]
  000e4	8b 07		 mov	 eax, DWORD PTR [edi]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000e6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ec	72 12		 jb	 SHORT $LN73@assign

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ee	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f1	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f4	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f6	83 c0 fc	 add	 eax, -4			; fffffffcH
  000f9	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fc	77 19		 ja	 SHORT $LN70@assign

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000fe	8b c2		 mov	 eax, edx
$LN73@assign:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00100	51		 push	 ecx
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00107	83 c4 08	 add	 esp, 8
$LN16@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1604 :         return _Reallocate_for(

  0010a	89 1f		 mov	 DWORD PTR [edi], ebx

; 1611 :     }

  0010c	8b c7		 mov	 eax, edi
  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5b		 pop	 ebx
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c2 08 00	 ret	 8
$LN70@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00117	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN95@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2963 :             _Xlen_string(); // result too long

  0011c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN96@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00121	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN89@assign:
  00126	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 2d		 jbe	 SHORT $LN19@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN30@basic_stri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 21		 ja	 SHORT $LN27@basic_stri

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN30@basic_stri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN19@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00038	33 c0		 xor	 eax, eax
  0003a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	66 89 06	 mov	 WORD PTR [esi], ax
  0004b	5e		 pop	 esi

; 1366 :     }

  0004c	c3		 ret	 0
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@basic_stri:
  00052	cc		 int	 3
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 512  :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
