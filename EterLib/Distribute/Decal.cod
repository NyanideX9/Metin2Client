; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\EterLib\Distribute\Decal.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0SPDTVertex@@QAE@XZ				; SPDTVertex::SPDTVertex
PUBLIC	??0CDecal@@QAE@XZ				; CDecal::CDecal
PUBLIC	??1CDecal@@UAE@XZ				; CDecal::~CDecal
PUBLIC	?Clear@CDecal@@QAEXXZ				; CDecal::Clear
PUBLIC	?Render@CDecal@@UAEXXZ				; CDecal::Render
PUBLIC	??1?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAE@XZ ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::~vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >
PUBLIC	?_Xlength@?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::_Xlength
PUBLIC	?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z	; CDecal::AddPolygon
PUBLIC	?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z	; CDecal::ClipMesh
PUBLIC	?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z ; CDecal::ClipPolygon
PUBLIC	?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
PUBLIC	??_GCDecal@@UAEPAXI@Z				; CDecal::`scalar deleting destructor'
PUBLIC	??$_Emplace_reallocate@ABUSTRIANGLEFANSTRUCT@CDecal@@@?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEPAUSTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::STRIANGLEFANSTRUCT const &>
PUBLIC	??$_Copy_memmove@PAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z ; std::_Copy_memmove<CDecal::STRIANGLEFANSTRUCT *,CDecal::STRIANGLEFANSTRUCT *>
PUBLIC	??$_Copy_memmove_tail@PAUSTRIANGLEFANSTRUCT@CDecal@@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@QBDQAU12@II@Z ; std::_Copy_memmove_tail<CDecal::STRIANGLEFANSTRUCT *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_7CDecal@@6B@					; CDecal::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CDecal@@6B@				; CDecal::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDecal@@@8				; CDecal `RTTI Type Descriptor'
PUBLIC	??_R3CDecal@@8					; CDecal::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDecal@@8					; CDecal::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDecal@@8				; CDecal::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f800000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_ECDecal@@UAEPAXI@Z:PROC			; CDecal::`vector deleting destructor'
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?DrawIndexedPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIIPBXW4_D3DFORMAT@@1I@Z:PROC ; CStateManager::DrawIndexedPrimitiveUP
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CDecal@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDecal@@8 DD FLAT:??_R0?AVCDecal@@@8	; CDecal::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDecal@@8
rdata$r	ENDS
;	COMDAT ??_R2CDecal@@8
rdata$r	SEGMENT
??_R2CDecal@@8 DD FLAT:??_R1A@?0A@EA@CDecal@@8		; CDecal::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDecal@@8
rdata$r	SEGMENT
??_R3CDecal@@8 DD 00H					; CDecal::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDecal@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDecal@@@8
data$rs	SEGMENT
??_R0?AVCDecal@@@8 DD FLAT:??_7type_info@@6B@		; CDecal `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDecal@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDecal@@6B@
rdata$r	SEGMENT
??_R4CDecal@@6B@ DD 00H					; CDecal::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDecal@@@8
	DD	FLAT:??_R3CDecal@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CDecal@@6B@
CONST	SEGMENT
??_7CDecal@@6B@ DD FLAT:??_R4CDecal@@6B@		; CDecal::`vftable'
	DD	FLAT:??_ECDecal@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?Render@CDecal@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CDecal@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CDecal@@QAE@XZ$0
__ehfuncinfo$??0CDecal@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CDecal@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAUSTRIANGLEFANSTRUCT@CDecal@@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@QBDQAU12@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAUSTRIANGLEFANSTRUCT@CDecal@@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@QBDQAU12@II@Z PROC ; std::_Copy_memmove_tail<CDecal::STRIANGLEFANSTRUCT *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAUSTRIANGLEFANSTRUCT@CDecal@@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@QBDQAU12@II@Z ENDP ; std::_Copy_memmove_tail<CDecal::STRIANGLEFANSTRUCT *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z PROC ; std::_Copy_memmove<CDecal::STRIANGLEFANSTRUCT *,CDecal::STRIANGLEFANSTRUCT *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 04	 sar	 eax, 4

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAUSTRIANGLEFANSTRUCT@CDecal@@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@QBDQAU12@II@Z ; std::_Copy_memmove_tail<CDecal::STRIANGLEFANSTRUCT *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z ENDP ; std::_Copy_memmove<CDecal::STRIANGLEFANSTRUCT *,CDecal::STRIANGLEFANSTRUCT *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSTRIANGLEFANSTRUCT@CDecal@@@?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEPAUSTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
$T1 = -8						; size = 4
tv710 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUSTRIANGLEFANSTRUCT@CDecal@@@?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEPAUSTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z PROC ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::STRIANGLEFANSTRUCT const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 f8 04	 sar	 eax, 4

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001a	3d ff ff ff 0f	 cmp	 eax, 268435455		; 0fffffffH
  0001f	0f 84 0e 01 00
	00		 je	 $LN131@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00025	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00028	8d 50 01	 lea	 edx, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002b	2b f9		 sub	 edi, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002d	89 55 f4	 mov	 DWORD PTR __Newsize$1$[ebp], edx

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00030	c1 ff 04	 sar	 edi, 4

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00033	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH
  00038	8b cf		 mov	 ecx, edi
  0003a	d1 e9		 shr	 ecx, 1
  0003c	2b c1		 sub	 eax, ecx
  0003e	3b f8		 cmp	 edi, eax
  00040	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00042	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  00047	c7 45 f8 f0 ff
	ff ff		 mov	 DWORD PTR $T1[ebp], -16	; fffffff0H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00054	eb 3b		 jmp	 SHORT $LN129@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00056	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00059	8b ca		 mov	 ecx, edx
  0005b	3b c2		 cmp	 eax, edx
  0005d	0f 43 c8	 cmovae	 ecx, eax
  00060	81 f9 ff ff ff
	0f		 cmp	 ecx, 268435455		; 0fffffffH
  00066	0f 87 cc 00 00
	00		 ja	 $LN132@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006c	c1 e1 04	 shl	 ecx, 4

; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0006f	8b c1		 mov	 eax, ecx

; 122  :     return _Count * _Ty_size;

  00071	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx

; 227  :     if (_Bytes == 0) {

  00074	85 c0		 test	 eax, eax
  00076	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  00078	33 ff		 xor	 edi, edi
  0007a	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0007c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00081	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00089	eb 06		 jmp	 SHORT $LN129@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN129@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00091	8b f8		 mov	 edi, eax
  00093	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00096	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00099	83 e3 f0	 and	 ebx, -16		; fffffff0H
  0009c	8d 0c 3b	 lea	 ecx, DWORD PTR [ebx+edi]

; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0009f	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a2	89 4d fc	 mov	 DWORD PTR tv710[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  000a5	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000a8	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000ab	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000ae	8b 06		 mov	 eax, DWORD PTR [esi]
  000b0	3b d9		 cmp	 ebx, ecx
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv710[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN58@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z ; std::_Copy_memmove<CDecal::STRIANGLEFANSTRUCT *,CDecal::STRIANGLEFANSTRUCT *>
  000c3	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000c6	8b c3		 mov	 eax, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv710[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 10	 lea	 edx, DWORD PTR [ebx+16]
$LN58@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	51		 push	 ecx
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUSTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z ; std::_Copy_memmove<CDecal::STRIANGLEFANSTRUCT *,CDecal::STRIANGLEFANSTRUCT *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN80@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 f0	 and	 ecx, -16		; fffffff0H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN91@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2c		 ja	 SHORT $LN88@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN91@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00111	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00114	c1 e0 04	 shl	 eax, 4
  00117	03 c7		 add	 eax, edi
  00119	89 3e		 mov	 DWORD PTR [esi], edi
  0011b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00124	8b c3		 mov	 eax, ebx

; 903  :     }

  00126	5e		 pop	 esi
  00127	5b		 pop	 ebx
  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c2 08 00	 ret	 8
$LN88@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN131@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00133	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::_Xlength
$LN132@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00138	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN128@Emplace_re:
  0013d	cc		 int	 3
??$_Emplace_reallocate@ABUSTRIANGLEFANSTRUCT@CDecal@@@?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEPAUSTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z ENDP ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::STRIANGLEFANSTRUCT const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCDecal@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDecal@@UAEPAXI@Z PROC				; CDecal::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDecal@@UAE@XZ	; CDecal::~CDecal
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN5@scalar
  00011	68 94 1a 00 00	 push	 6804			; 00001a94H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCDecal@@UAEPAXI@Z ENDP				; CDecal::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
;	COMDAT ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z
_TEXT	SEGMENT
tv2305 = -68						; size = 4
_c_rv4Plane$GSCopy$1$ = -64				; size = 4
tv2206 = -60						; size = 4
tv2242 = -60						; size = 4
_dwCurIndex$1$ = -56					; size = 4
_c_pv3Vertex$GSCopy$1$ = -52				; size = 4
tv2298 = -48						; size = 4
_c_pv3NewVertex$GSCopy$1$ = -48				; size = 4
_c_pv3Normal$GSCopy$1$ = -44				; size = 4
tv2243 = -40						; size = 4
tv2264 = -40						; size = 4
tv2240 = -36						; size = 4
tv2268 = -36						; size = 4
_dwCount$1$ = -32					; size = 4
_dwNegativeCount$1$ = -28				; size = 4
tv2301 = -28						; size = 4
tv2309 = -21						; size = 1
_ft$1$ = -20						; size = 4
_ft$1$ = -20						; size = 4
_bNegative$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_c_rv4Plane$ = 8					; size = 4
_dwVertexCount$ = 12					; size = 4
_c_pv3Vertex$ = 16					; size = 4
_c_pv3Normal$ = 20					; size = 4
_c_pv3NewVertex$ = 24					; size = 4
_c_pv3NewNormal$ = 28					; size = 4
?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z PROC ; CDecal::ClipPolygonAgainstPlane, COMDAT

; 153  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _c_pv3Vertex$[ebp]
  00013	8b 55 14	 mov	 edx, DWORD PTR _c_pv3Normal$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR _c_rv4Plane$[ebp]
  00019	53		 push	 ebx
  0001a	56		 push	 esi
  0001b	8b 75 18	 mov	 esi, DWORD PTR _c_pv3NewVertex$[ebp]
  0001e	33 db		 xor	 ebx, ebx
  00020	89 55 d4	 mov	 DWORD PTR _c_pv3Normal$GSCopy$1$[ebp], edx
  00023	8d 50 08	 lea	 edx, DWORD PTR [eax+8]
  00026	89 45 cc	 mov	 DWORD PTR _c_pv3Vertex$GSCopy$1$[ebp], eax

; 154  : 	bool bNegative[10];
; 155  : 
; 156  : 	// Classify vertices
; 157  : 	DWORD dwNegativeCount = 0;
; 158  : 	for (DWORD dwi = 0; dwi < dwVertexCount; ++dwi)

  00029	8b 45 0c	 mov	 eax, DWORD PTR _dwVertexCount$[ebp]
  0002c	89 4d c0	 mov	 DWORD PTR _c_rv4Plane$GSCopy$1$[ebp], ecx
  0002f	89 75 d0	 mov	 DWORD PTR _c_pv3NewVertex$GSCopy$1$[ebp], esi
  00032	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _dwNegativeCount$1$[ebp], 0
  00039	57		 push	 edi
  0003a	8b 7d 1c	 mov	 edi, DWORD PTR _c_pv3NewNormal$[ebp]
  0003d	85 c0		 test	 eax, eax
  0003f	74 60		 je	 SHORT $LN78@ClipPolygo
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00041	f3 0f 10 51 0c	 movss	 xmm2, DWORD PTR [ecx+12]
  00046	0f 57 f6	 xorps	 xmm6, xmm6
  00049	f3 0f 10 59 08	 movss	 xmm3, DWORD PTR [ecx+8]
  0004e	8b f0		 mov	 esi, eax
  00050	f3 0f 10 21	 movss	 xmm4, DWORD PTR [ecx]
  00054	f3 0f 10 69 04	 movss	 xmm5, DWORD PTR [ecx+4]
  00059	8b ca		 mov	 ecx, edx
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@ClipPolygo:
  00060	0f 28 c4	 movaps	 xmm0, xmm4
  00063	0f 28 cd	 movaps	 xmm1, xmm5
  00066	f3 0f 59 49 fc	 mulss	 xmm1, DWORD PTR [ecx-4]
  0006b	f3 0f 59 41 f8	 mulss	 xmm0, DWORD PTR [ecx-8]
  00070	f3 0f 58 c8	 addss	 xmm1, xmm0
  00074	0f 28 c3	 movaps	 xmm0, xmm3
  00077	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [ecx]
  0007b	f3 0f 58 c8	 addss	 xmm1, xmm0
  0007f	f3 0f 58 ca	 addss	 xmm1, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 160  : 		bool bNeg = (D3DXPlaneDotCoord(&c_rv4Plane, &c_pv3Vertex[dwi]) < 0.0F);

  00083	0f 2f f1	 comiss	 xmm6, xmm1
  00086	0f 97 c0	 seta	 al
  00089	83 c1 0c	 add	 ecx, 12			; 0000000cH

; 161  : 		bNegative[dwi] = bNeg;

  0008c	88 44 1d f0	 mov	 BYTE PTR _bNegative$[ebp+ebx], al
  00090	43		 inc	 ebx

; 162  : 		dwNegativeCount += bNeg;

  00091	0f b6 c0	 movzx	 eax, al
  00094	01 45 e4	 add	 DWORD PTR _dwNegativeCount$1$[ebp], eax
  00097	3b de		 cmp	 ebx, esi
  00099	72 c5		 jb	 SHORT $LL4@ClipPolygo
  0009b	8b 75 d0	 mov	 esi, DWORD PTR _c_pv3NewVertex$GSCopy$1$[ebp]
  0009e	8b 45 0c	 mov	 eax, DWORD PTR _dwVertexCount$[ebp]
$LN78@ClipPolygo:

; 163  : 	}
; 164  : 
; 165  : 	// Discard this polygon if it's completely culled
; 166  : 	if (dwNegativeCount == dwVertexCount)

  000a1	39 45 e4	 cmp	 DWORD PTR _dwNegativeCount$1$[ebp], eax
  000a4	75 13		 jne	 SHORT $LN8@ClipPolygo

; 210  : 			++dwCount;
; 211  : 		}
; 212  : 	}
; 213  : 
; 214  : 	// Return number of vertices in clipped polygon
; 215  : 	return dwCount;
; 216  : }

  000a6	5f		 pop	 edi
  000a7	5e		 pop	 esi
  000a8	33 c0		 xor	 eax, eax
  000aa	5b		 pop	 ebx
  000ab	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ae	33 cd		 xor	 ecx, ebp
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
$LN8@ClipPolygo:

; 167  : 		return 0;
; 168  : 
; 169  : 	DWORD dwCount = 0;

  000b9	33 db		 xor	 ebx, ebx
  000bb	33 c9		 xor	 ecx, ecx
  000bd	89 5d e0	 mov	 DWORD PTR _dwCount$1$[ebp], ebx
  000c0	89 4d c8	 mov	 DWORD PTR _dwCurIndex$1$[ebp], ecx

; 170  : 	for (DWORD dwCurIndex = 0; dwCurIndex < dwVertexCount; ++dwCurIndex)

  000c3	85 c0		 test	 eax, eax
  000c5	0f 84 40 03 00
	00		 je	 $LN6@ClipPolygo

; 167  : 		return 0;
; 168  : 
; 169  : 	DWORD dwCount = 0;

  000cb	48		 dec	 eax
  000cc	89 45 bc	 mov	 DWORD PTR tv2305[ebp], eax
  000cf	8b 45 d4	 mov	 eax, DWORD PTR _c_pv3Normal$GSCopy$1$[ebp]
  000d2	89 45 e4	 mov	 DWORD PTR tv2301[ebp], eax
  000d5	2b 45 cc	 sub	 eax, DWORD PTR _c_pv3Vertex$GSCopy$1$[ebp]
  000d8	89 45 d0	 mov	 DWORD PTR tv2298[ebp], eax
  000db	0f 1f 44 00 00	 npad	 5
$LL7@ClipPolygo:

; 171  : 	{
; 172  : 		// dwPrevIndex is the index of the previous vertex
; 173  : 		DWORD dwPrevIndex = (dwCurIndex != 0) ? dwCurIndex - 1 : dwVertexCount - 1;
; 174  : 
; 175  : 		if (bNegative[dwCurIndex])

  000e0	85 c9		 test	 ecx, ecx
  000e2	8d 41 ff	 lea	 eax, DWORD PTR [ecx-1]
  000e5	0f 44 45 bc	 cmove	 eax, DWORD PTR tv2305[ebp]
  000e9	80 7c 0d f0 00	 cmp	 BYTE PTR _bNegative$[ebp+ecx], 0
  000ee	8a 5c 05 f0	 mov	 bl, BYTE PTR _bNegative$[ebp+eax]
  000f2	88 5d eb	 mov	 BYTE PTR tv2309[ebp], bl
  000f5	8b 5d e4	 mov	 ebx, DWORD PTR tv2301[ebp]
  000f8	0f 84 67 01 00
	00		 je	 $LN9@ClipPolygo

; 176  : 		{
; 177  : 			if (!bNegative[dwPrevIndex])

  000fe	80 7d eb 00	 cmp	 BYTE PTR tv2309[ebp], 0
  00102	0f 85 ea 02 00
	00		 jne	 $LN5@ClipPolygo
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00108	8b 4d cc	 mov	 ecx, DWORD PTR _c_pv3Vertex$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 181  : 				const D3DXVECTOR3& v3_1 = c_pv3Vertex[dwPrevIndex];

  0010b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0010e	8b 5d c0	 mov	 ebx, DWORD PTR _c_rv4Plane$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 183  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00111	f3 0f 10 7a fc	 movss	 xmm7, DWORD PTR [edx-4]
  00116	f3 0f 10 6a f8	 movss	 xmm5, DWORD PTR [edx-8]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0011b	f3 0f 10 44 81
	04		 movss	 xmm0, DWORD PTR [ecx+eax*4+4]
  00121	f3 0f 10 34 81	 movss	 xmm6, DWORD PTR [ecx+eax*4]
  00126	f3 0f 10 4c 81
	08		 movss	 xmm1, DWORD PTR [ecx+eax*4+8]
  0012c	f3 0f 11 45 d8	 movss	 DWORD PTR tv2264[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 183  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00131	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00135	f3 0f 11 45 c4	 movss	 DWORD PTR tv2206[ebp], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0013a	f3 0f 10 03	 movss	 xmm0, DWORD PTR [ebx]
  0013e	f3 0f 59 c6	 mulss	 xmm0, xmm6

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00142	8b 4d d4	 mov	 ecx, DWORD PTR _c_pv3Normal$GSCopy$1$[ebp]

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00145	f3 0f 11 4d dc	 movss	 DWORD PTR tv2268[ebp], xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 183  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  0014a	f3 0f 10 55 c4	 movss	 xmm2, DWORD PTR tv2206[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0014f	f3 0f 11 45 ec	 movss	 DWORD PTR _ft$1$[ebp], xmm0
  00154	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR tv2264[ebp]
  00159	f3 0f 59 43 04	 mulss	 xmm0, DWORD PTR [ebx+4]
  0015e	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _ft$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 184  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00163	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f800000
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0016b	f3 0f 58 c8	 addss	 xmm1, xmm0
  0016f	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR tv2268[ebp]
  00174	f3 0f 59 43 08	 mulss	 xmm0, DWORD PTR [ebx+8]
  00179	f3 0f 11 4d ec	 movss	 DWORD PTR _ft$1$[ebp], xmm1
  0017e	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 183  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00182	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR tv2264[ebp]
  00187	f3 0f 5c c7	 subss	 xmm0, xmm7
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0018b	f3 0f 58 4b 0c	 addss	 xmm1, DWORD PTR [ebx+12]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 183  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00190	f3 0f 59 43 04	 mulss	 xmm0, DWORD PTR [ebx+4]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00195	f3 0f 11 4d ec	 movss	 DWORD PTR _ft$1$[ebp], xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 183  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  0019a	0f 28 ce	 movaps	 xmm1, xmm6
  0019d	f3 0f 5c cd	 subss	 xmm1, xmm5
  001a1	f3 0f 59 0b	 mulss	 xmm1, DWORD PTR [ebx]
  001a5	f3 0f 58 c8	 addss	 xmm1, xmm0
  001a9	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR tv2268[ebp]
  001ae	f3 0f 5c c2	 subss	 xmm0, xmm2
  001b2	f3 0f 59 43 08	 mulss	 xmm0, DWORD PTR [ebx+8]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  001b7	8b 5d e4	 mov	 ebx, DWORD PTR tv2301[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 183  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  001ba	f3 0f 58 c8	 addss	 xmm1, xmm0
  001be	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _ft$1$[ebp]
  001c3	f3 0f 5e c1	 divss	 xmm0, xmm1

; 184  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  001c7	f3 0f 5c e0	 subss	 xmm4, xmm0
  001cb	f3 0f 11 45 ec	 movss	 DWORD PTR _ft$1$[ebp], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  001d0	0f 28 c4	 movaps	 xmm0, xmm4
  001d3	0f 28 dc	 movaps	 xmm3, xmm4
  001d6	f3 0f 59 c6	 mulss	 xmm0, xmm6
  001da	f3 0f 10 75 ec	 movss	 xmm6, DWORD PTR _ft$1$[ebp]
  001df	f3 0f 59 ee	 mulss	 xmm5, xmm6
  001e3	0f 28 ce	 movaps	 xmm1, xmm6
  001e6	f3 0f 59 fe	 mulss	 xmm7, xmm6

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  001ea	f3 0f 58 c5	 addss	 xmm0, xmm5

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  001ee	f3 0f 59 d6	 mulss	 xmm2, xmm6
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 184  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  001f2	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  001f6	0f 28 c4	 movaps	 xmm0, xmm4
  001f9	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR tv2264[ebp]

; 180  :     x = fx;

  001fe	f3 0f 58 c7	 addss	 xmm0, xmm7
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 184  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00202	f3 0f 11 46 04	 movss	 DWORD PTR [esi+4], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00207	0f 28 c4	 movaps	 xmm0, xmm4
  0020a	f3 0f 59 45 dc	 mulss	 xmm0, DWORD PTR tv2268[ebp]

; 181  :     y = fy;

  0020f	f3 0f 58 c2	 addss	 xmm0, xmm2

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00213	0f 28 d4	 movaps	 xmm2, xmm4
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 184  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00216	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  0021b	0f 28 c6	 movaps	 xmm0, xmm6
  0021e	f3 0f 59 54 81
	04		 mulss	 xmm2, DWORD PTR [ecx+eax*4+4]
  00224	f3 0f 59 5c 81
	08		 mulss	 xmm3, DWORD PTR [ecx+eax*4+8]
  0022a	8b 4d d0	 mov	 ecx, DWORD PTR tv2298[ebp]
  0022d	f3 0f 59 33	 mulss	 xmm6, DWORD PTR [ebx]
  00231	f3 0f 59 43 04	 mulss	 xmm0, DWORD PTR [ebx+4]
  00236	f3 0f 59 0c 11	 mulss	 xmm1, DWORD PTR [ecx+edx]
  0023b	8b 4d d4	 mov	 ecx, DWORD PTR _c_pv3Normal$GSCopy$1$[ebp]

; 180  :     x = fx;

  0023e	f3 0f 58 c2	 addss	 xmm0, xmm2

; 181  :     y = fy;

  00242	f3 0f 58 cb	 addss	 xmm1, xmm3

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00246	f3 0f 59 24 81	 mulss	 xmm4, DWORD PTR [ecx+eax*4]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 188  : 				++dwCount;

  0024b	8b 4d c8	 mov	 ecx, DWORD PTR _dwCurIndex$1$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0024e	f3 0f 58 e6	 addss	 xmm4, xmm6
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 187  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  00252	f3 0f 11 27	 movss	 DWORD PTR [edi], xmm4
  00256	f3 0f 11 47 04	 movss	 DWORD PTR [edi+4], xmm0
  0025b	f3 0f 11 4f 08	 movss	 DWORD PTR [edi+8], xmm1

; 188  : 				++dwCount;

  00260	e9 84 01 00 00	 jmp	 $LN89@ClipPolygo
$LN9@ClipPolygo:

; 189  : 			}
; 190  : 		}
; 191  : 		else
; 192  : 		{
; 193  : 			if (bNegative[dwPrevIndex])

  00265	80 7d eb 00	 cmp	 BYTE PTR tv2309[ebp], 0
  00269	0f 84 5e 01 00
	00		 je	 $LN79@ClipPolygo
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0026f	f3 0f 10 42 fc	 movss	 xmm0, DWORD PTR [edx-4]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 198  : 				const D3DXVECTOR3& v3_2 = c_pv3Vertex[dwPrevIndex];

  00274	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]

; 199  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00277	8b 4d cc	 mov	 ecx, DWORD PTR _c_pv3Vertex$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0027a	8b 5d c0	 mov	 ebx, DWORD PTR _c_rv4Plane$GSCopy$1$[ebp]
  0027d	f3 0f 10 7a f8	 movss	 xmm7, DWORD PTR [edx-8]
  00282	f3 0f 11 45 dc	 movss	 DWORD PTR tv2240[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 199  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00287	f3 0f 10 44 81
	08		 movss	 xmm0, DWORD PTR [ecx+eax*4+8]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0028d	f3 0f 10 0a	 movss	 xmm1, DWORD PTR [edx]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 199  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00291	f3 0f 11 45 c4	 movss	 DWORD PTR tv2242[ebp], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00296	0f 28 c7	 movaps	 xmm0, xmm7
  00299	f3 0f 59 03	 mulss	 xmm0, DWORD PTR [ebx]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 204  : 				++dwCount;

  0029d	ff 45 e0	 inc	 DWORD PTR _dwCount$1$[ebp]
  002a0	f3 0f 10 2c 81	 movss	 xmm5, DWORD PTR [ecx+eax*4]
  002a5	f3 0f 10 74 81
	04		 movss	 xmm6, DWORD PTR [ecx+eax*4+4]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  002ab	f3 0f 11 45 ec	 movss	 DWORD PTR _ft$1$[ebp], xmm0
  002b0	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR tv2240[ebp]
  002b5	f3 0f 59 43 04	 mulss	 xmm0, DWORD PTR [ebx+4]

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  002ba	8b 4d d0	 mov	 ecx, DWORD PTR tv2298[ebp]

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  002bd	f3 0f 10 5d ec	 movss	 xmm3, DWORD PTR _ft$1$[ebp]
  002c2	f3 0f 11 4d d8	 movss	 DWORD PTR tv2243[ebp], xmm1
  002c7	f3 0f 58 d8	 addss	 xmm3, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 199  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  002cb	f3 0f 10 55 c4	 movss	 xmm2, DWORD PTR tv2242[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  002d0	f3 0f 10 43 08	 movss	 xmm0, DWORD PTR [ebx+8]
  002d5	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 200  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  002d9	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f800000
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  002e1	0f 28 cb	 movaps	 xmm1, xmm3
  002e4	f3 0f 11 5d ec	 movss	 DWORD PTR _ft$1$[ebp], xmm3
  002e9	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 199  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  002ed	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR tv2240[ebp]
  002f2	f3 0f 5c c6	 subss	 xmm0, xmm6
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  002f6	f3 0f 58 4b 0c	 addss	 xmm1, DWORD PTR [ebx+12]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 199  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  002fb	f3 0f 59 43 04	 mulss	 xmm0, DWORD PTR [ebx+4]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  00300	f3 0f 11 4d ec	 movss	 DWORD PTR _ft$1$[ebp], xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 199  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00305	0f 28 cf	 movaps	 xmm1, xmm7
  00308	f3 0f 5c cd	 subss	 xmm1, xmm5
  0030c	f3 0f 59 0b	 mulss	 xmm1, DWORD PTR [ebx]
  00310	f3 0f 58 c8	 addss	 xmm1, xmm0
  00314	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR tv2243[ebp]
  00319	f3 0f 5c c2	 subss	 xmm0, xmm2
  0031d	f3 0f 59 43 08	 mulss	 xmm0, DWORD PTR [ebx+8]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00322	8b 5d e4	 mov	 ebx, DWORD PTR tv2301[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 199  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00325	f3 0f 58 c8	 addss	 xmm1, xmm0
  00329	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _ft$1$[ebp]
  0032e	f3 0f 5e c1	 divss	 xmm0, xmm1

; 200  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00332	f3 0f 5c e0	 subss	 xmm4, xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00336	f3 0f 59 e8	 mulss	 xmm5, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 199  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  0033a	f3 0f 11 45 ec	 movss	 DWORD PTR _ft$1$[ebp], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  0033f	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR tv2240[ebp]
  00344	f3 0f 59 fc	 mulss	 xmm7, xmm4
  00348	0f 28 dc	 movaps	 xmm3, xmm4
  0034b	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0034f	f3 0f 58 fd	 addss	 xmm7, xmm5

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00353	f3 0f 10 6d ec	 movss	 xmm5, DWORD PTR _ft$1$[ebp]
  00358	f3 0f 59 f5	 mulss	 xmm6, xmm5
  0035c	0f 28 cd	 movaps	 xmm1, xmm5
  0035f	f3 0f 59 d5	 mulss	 xmm2, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 200  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00363	f3 0f 11 3e	 movss	 DWORD PTR [esi], xmm7
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00367	f3 0f 58 c6	 addss	 xmm0, xmm6
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 200  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  0036b	f3 0f 11 46 04	 movss	 DWORD PTR [esi+4], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00370	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR tv2243[ebp]
  00375	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 181  :     y = fy;

  00379	f3 0f 58 c2	 addss	 xmm0, xmm2

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  0037d	0f 28 d4	 movaps	 xmm2, xmm4
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 200  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00380	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00385	0f 28 c5	 movaps	 xmm0, xmm5
  00388	f3 0f 59 1c 11	 mulss	 xmm3, DWORD PTR [ecx+edx]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 204  : 				++dwCount;

  0038d	83 c6 0c	 add	 esi, 12			; 0000000cH
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00390	8b 4d d4	 mov	 ecx, DWORD PTR _c_pv3Normal$GSCopy$1$[ebp]
  00393	f3 0f 59 23	 mulss	 xmm4, DWORD PTR [ebx]
  00397	f3 0f 59 53 04	 mulss	 xmm2, DWORD PTR [ebx+4]
  0039c	f3 0f 59 2c 81	 mulss	 xmm5, DWORD PTR [ecx+eax*4]
  003a1	f3 0f 59 44 81
	04		 mulss	 xmm0, DWORD PTR [ecx+eax*4+4]
  003a7	f3 0f 59 4c 81
	08		 mulss	 xmm1, DWORD PTR [ecx+eax*4+8]

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  003ad	f3 0f 58 e5	 addss	 xmm4, xmm5
  003b1	8b 4d c8	 mov	 ecx, DWORD PTR _dwCurIndex$1$[ebp]

; 180  :     x = fx;

  003b4	f3 0f 58 c2	 addss	 xmm0, xmm2

; 181  :     y = fy;

  003b8	f3 0f 58 cb	 addss	 xmm1, xmm3
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 203  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  003bc	f3 0f 11 27	 movss	 DWORD PTR [edi], xmm4
  003c0	f3 0f 11 47 04	 movss	 DWORD PTR [edi+4], xmm0
  003c5	f3 0f 11 4f 08	 movss	 DWORD PTR [edi+8], xmm1

; 204  : 				++dwCount;

  003ca	83 c7 0c	 add	 edi, 12			; 0000000cH
$LN79@ClipPolygo:

; 205  : 			}
; 206  : 
; 207  : 			// Include current vertex
; 208  :  			c_pv3NewVertex[dwCount] = c_pv3Vertex[dwCurIndex];

  003cd	f3 0f 7e 42 f8	 movq	 xmm0, QWORD PTR [edx-8]
  003d2	66 0f d6 06	 movq	 QWORD PTR [esi], xmm0
  003d6	8b 02		 mov	 eax, DWORD PTR [edx]
  003d8	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 209  :  			c_pv3NewNormal[dwCount] = c_pv3Normal[dwCurIndex];

  003db	f3 0f 7e 03	 movq	 xmm0, QWORD PTR [ebx]
  003df	66 0f d6 07	 movq	 QWORD PTR [edi], xmm0
  003e3	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  003e6	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN89@ClipPolygo:

; 170  : 	for (DWORD dwCurIndex = 0; dwCurIndex < dwVertexCount; ++dwCurIndex)

  003e9	ff 45 e0	 inc	 DWORD PTR _dwCount$1$[ebp]
  003ec	83 c6 0c	 add	 esi, 12			; 0000000cH
  003ef	83 c7 0c	 add	 edi, 12			; 0000000cH
$LN5@ClipPolygo:
  003f2	41		 inc	 ecx
  003f3	83 c3 0c	 add	 ebx, 12			; 0000000cH
  003f6	83 c2 0c	 add	 edx, 12			; 0000000cH
  003f9	89 4d c8	 mov	 DWORD PTR _dwCurIndex$1$[ebp], ecx
  003fc	89 5d e4	 mov	 DWORD PTR tv2301[ebp], ebx
  003ff	3b 4d 0c	 cmp	 ecx, DWORD PTR _dwVertexCount$[ebp]
  00402	0f 82 d8 fc ff
	ff		 jb	 $LL7@ClipPolygo
  00408	8b 5d e0	 mov	 ebx, DWORD PTR _dwCount$1$[ebp]
$LN6@ClipPolygo:

; 210  : 			++dwCount;
; 211  : 		}
; 212  : 	}
; 213  : 
; 214  : 	// Return number of vertices in clipped polygon
; 215  : 	return dwCount;
; 216  : }

  0040b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040e	8b c3		 mov	 eax, ebx
  00410	5f		 pop	 edi
  00411	5e		 pop	 esi
  00412	33 cd		 xor	 ecx, ebp
  00414	5b		 pop	 ebx
  00415	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041a	8b e5		 mov	 esp, ebp
  0041c	5d		 pop	 ebp
  0041d	c3		 ret	 0
?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ENDP ; CDecal::ClipPolygonAgainstPlane
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
;	COMDAT ?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z
_TEXT	SEGMENT
_v3TempVertex$ = -220					; size = 108
_v3TempNormal$ = -112					; size = 108
__$ArrayPad$ = -4					; size = 4
_dwVertexCount$ = 8					; size = 4
_c_pv3Vertex$ = 12					; size = 4
_c_pv3Normal$ = 16					; size = 4
_c_pv3NewVertex$ = 20					; size = 4
_c_pv3NewNormal$ = 24					; size = 4
?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z PROC ; CDecal::ClipPolygon, COMDAT
; _this$ = ecx

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 10	 mov	 eax, DWORD PTR _c_pv3Normal$[ebp]
  00016	8b 55 0c	 mov	 edx, DWORD PTR _c_pv3Vertex$[ebp]
  00019	53		 push	 ebx
  0001a	8b 5d 18	 mov	 ebx, DWORD PTR _c_pv3NewNormal$[ebp]
  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	8b 7d 14	 mov	 edi, DWORD PTR _c_pv3NewVertex$[ebp]
  00022	8b f1		 mov	 esi, ecx

; 119  : 	D3DXVECTOR3		v3TempVertex[9];
; 120  : 	D3DXVECTOR3		v3TempNormal[9];
; 121  : 
; 122  : 	// Clip against all six planes
; 123  : 	DWORD dwCount = ClipPolygonAgainstPlane(m_v4LeftPlane, dwVertexCount, c_pv3Vertex, c_pv3Normal, v3TempVertex, v3TempNormal);

  00024	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  00027	51		 push	 ecx
  00028	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	52		 push	 edx
  00031	ff 75 08	 push	 DWORD PTR _dwVertexCount$[ebp]
  00034	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  0003d	83 c4 18	 add	 esp, 24			; 00000018H

; 124  : 	if (dwCount != 0)

  00040	85 c0		 test	 eax, eax
  00042	0f 84 92 00 00
	00		 je	 $LN6@ClipPolygo

; 125  : 	{
; 126  : 		dwCount = ClipPolygonAgainstPlane(m_v4RightPlane, dwCount, v3TempVertex, v3TempNormal, c_pv3NewVertex, c_pv3NewNormal);

  00048	53		 push	 ebx
  00049	57		 push	 edi
  0004a	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  0004d	51		 push	 ecx
  0004e	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  00054	51		 push	 ecx
  00055	50		 push	 eax
  00056	8d 46 2c	 lea	 eax, DWORD PTR [esi+44]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  0005f	83 c4 18	 add	 esp, 24			; 00000018H

; 127  : 		if (dwCount != 0)

  00062	85 c0		 test	 eax, eax
  00064	74 74		 je	 SHORT $LN6@ClipPolygo

; 128  : 		{
; 129  : 			dwCount = ClipPolygonAgainstPlane(m_v4BottomPlane, dwCount, c_pv3NewVertex, c_pv3NewNormal, v3TempVertex, v3TempNormal);

  00066	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  00069	51		 push	 ecx
  0006a	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  00070	51		 push	 ecx
  00071	53		 push	 ebx
  00072	57		 push	 edi
  00073	50		 push	 eax
  00074	8d 46 3c	 lea	 eax, DWORD PTR [esi+60]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  0007d	83 c4 18	 add	 esp, 24			; 00000018H

; 130  : 			if (dwCount != 0)

  00080	85 c0		 test	 eax, eax
  00082	74 56		 je	 SHORT $LN6@ClipPolygo

; 131  : 			{
; 132  : 				dwCount = ClipPolygonAgainstPlane(m_v4TopPlane, dwCount, v3TempVertex, v3TempNormal, c_pv3NewVertex, c_pv3NewNormal);

  00084	53		 push	 ebx
  00085	57		 push	 edi
  00086	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  00089	51		 push	 ecx
  0008a	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  00090	51		 push	 ecx
  00091	50		 push	 eax
  00092	8d 46 4c	 lea	 eax, DWORD PTR [esi+76]
  00095	50		 push	 eax
  00096	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  0009b	83 c4 18	 add	 esp, 24			; 00000018H

; 133  : 				if (dwCount != 0)

  0009e	85 c0		 test	 eax, eax
  000a0	74 38		 je	 SHORT $LN6@ClipPolygo

; 134  : 				{
; 135  : 					dwCount = ClipPolygonAgainstPlane(m_v4BackPlane, dwCount, c_pv3NewVertex, c_pv3NewNormal, v3TempVertex, v3TempNormal);

  000a2	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  000a5	51		 push	 ecx
  000a6	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  000ac	51		 push	 ecx
  000ad	53		 push	 ebx
  000ae	57		 push	 edi
  000af	50		 push	 eax
  000b0	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  000b9	83 c4 18	 add	 esp, 24			; 00000018H

; 136  : 					if (dwCount != 0)

  000bc	85 c0		 test	 eax, eax
  000be	74 1a		 je	 SHORT $LN6@ClipPolygo

; 137  : 					{
; 138  : 						dwCount = ClipPolygonAgainstPlane(m_v4FrontPlane, dwCount, v3TempVertex, v3TempNormal, c_pv3NewVertex, c_pv3NewNormal);

  000c0	53		 push	 ebx
  000c1	57		 push	 edi
  000c2	8d 4d 90	 lea	 ecx, DWORD PTR _v3TempNormal$[ebp]
  000c5	51		 push	 ecx
  000c6	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR _v3TempVertex$[ebp]
  000cc	51		 push	 ecx
  000cd	50		 push	 eax
  000ce	8d 46 5c	 lea	 eax, DWORD PTR [esi+92]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  000d7	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@ClipPolygo:

; 139  : 					}
; 140  : 				}
; 141  : 			}
; 142  : 		}
; 143  : 	}
; 144  : 	return dwCount;
; 145  : }

  000da	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	5f		 pop	 edi
  000de	5e		 pop	 esi
  000df	33 cd		 xor	 ecx, ebp
  000e1	5b		 pop	 ebx
  000e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c2 14 00	 ret	 20			; 00000014H
?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z ENDP ; CDecal::ClipPolygon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
;	COMDAT ?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -240					; size = 4
tv1122 = -236						; size = 4
tv1128 = -236						; size = 4
_v3NewNormal$ = -232					; size = 108
_v3NewVertex$ = -120					; size = 108
__$ArrayPad$ = -4					; size = 4
_dwPrimitiveCount$ = 8					; size = 4
_c_pv3Vertex$ = 12					; size = 4
_c_pv3Normal$ = 16					; size = 4
?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z PROC		; CDecal::ClipMesh, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  0000c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00011	33 c4		 xor	 eax, esp
  00013	89 84 24 f0 00
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+244], eax
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	8b 75 0c	 mov	 esi, DWORD PTR _c_pv3Vertex$[ebp]

; 46   : 	D3DXVECTOR3		v3NewVertex[9];
; 47   : 	D3DXVECTOR3		v3NewNormal[9];
; 48   : 
; 49   : 	// Clip one triangle at a time
; 50   : 	for (DWORD dwi = 0; dwi < dwPrimitiveCount; ++dwi)

  0001f	33 db		 xor	 ebx, ebx
  00021	57		 push	 edi
  00022	89 4c 24 10	 mov	 DWORD PTR _this$GSCopy$1$[esp+256], ecx
  00026	39 5d 08	 cmp	 DWORD PTR _dwPrimitiveCount$[ebp], ebx
  00029	0f 86 c5 01 00
	00		 jbe	 $LN53@ClipMesh
  0002f	8b 7d 10	 mov	 edi, DWORD PTR _c_pv3Normal$[ebp]
  00032	83 c7 18	 add	 edi, 24			; 00000018H
  00035	83 c6 14	 add	 esi, 20			; 00000014H
  00038	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@ClipMesh:
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00040	f3 0f 10 56 08	 movss	 xmm2, DWORD PTR [esi+8]
  00045	f3 0f 5c 56 f0	 subss	 xmm2, DWORD PTR [esi-16]
  0004a	f3 0f 10 4e 0c	 movss	 xmm1, DWORD PTR [esi+12]
  0004f	f3 0f 5c 4e f4	 subss	 xmm1, DWORD PTR [esi-12]
  00054	f3 0f 10 66 04	 movss	 xmm4, DWORD PTR [esi+4]
  00059	f3 0f 10 1e	 movss	 xmm3, DWORD PTR [esi]
  0005d	f3 0f 5c 5e f4	 subss	 xmm3, DWORD PTR [esi-12]
  00062	f3 0f 5c 66 ec	 subss	 xmm4, DWORD PTR [esi-20]
  00067	f3 0f 10 7e f8	 movss	 xmm7, DWORD PTR [esi-8]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0006c	0f 28 c2	 movaps	 xmm0, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0006f	f3 0f 10 76 fc	 movss	 xmm6, DWORD PTR [esi-4]

; 182  :     z = fz;

  00074	0f 28 e9	 movaps	 xmm5, xmm1

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00077	f3 0f 5c 7e ec	 subss	 xmm7, DWORD PTR [esi-20]
  0007c	f3 0f 5c 76 f0	 subss	 xmm6, DWORD PTR [esi-16]
  00081	f3 0f 11 54 24
	14		 movss	 DWORD PTR tv1122[esp+256], xmm2

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00087	0f 28 d4	 movaps	 xmm2, xmm4
  0008a	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0008e	f3 0f 59 d3	 mulss	 xmm2, xmm3

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00092	f3 0f 10 5c 24
	14		 movss	 xmm3, DWORD PTR tv1122[esp+256]
  00098	f3 0f 59 cf	 mulss	 xmm1, xmm7

; 182  :     z = fz;

  0009c	f3 0f 59 ee	 mulss	 xmm5, xmm6

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  000a0	f3 0f 5c d1	 subss	 xmm2, xmm1
  000a4	f3 0f 59 df	 mulss	 xmm3, xmm7
  000a8	f3 0f 5c e8	 subss	 xmm5, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  000ac	f3 0f 59 e6	 mulss	 xmm4, xmm6

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000b0	0f 28 ca	 movaps	 xmm1, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 60   : 		if (D3DXVec3Dot(&m_v3Normal, &v3Cross) > (m_cfDecalEpsilon) *D3DXVec3Length(&v3Cross))

  000b3	f3 0f 59 d2	 mulss	 xmm2, xmm2
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000b7	f3 0f 59 49 14	 mulss	 xmm1, DWORD PTR [ecx+20]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  000bc	f3 0f 5c dc	 subss	 xmm3, xmm4

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000c0	0f 28 c5	 movaps	 xmm0, xmm5

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000c3	f3 0f 59 ed	 mulss	 xmm5, xmm5

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000c7	f3 0f 59 41 10	 mulss	 xmm0, DWORD PTR [ecx+16]

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000cc	f3 0f 58 d5	 addss	 xmm2, xmm5

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000d0	f3 0f 58 c8	 addss	 xmm1, xmm0
  000d4	0f 28 c3	 movaps	 xmm0, xmm3
  000d7	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000dc	f3 0f 59 db	 mulss	 xmm3, xmm3

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000e0	f3 0f 58 c8	 addss	 xmm1, xmm0

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000e4	f3 0f 58 d3	 addss	 xmm2, xmm3

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000e8	f3 0f 11 4c 24
	14		 movss	 DWORD PTR tv1128[esp+256], xmm1
  000ee	0f 57 c9	 xorps	 xmm1, xmm1
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 808  :             return (float)sqrt(_X);

  000f1	0f 5a c2	 cvtps2pd xmm0, xmm2
  000f4	66 0f 2e c8	 ucomisd xmm1, xmm0
  000f8	77 06		 ja	 SHORT $LN55@ClipMesh
  000fa	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  000fe	eb 05		 jmp	 SHORT $LN56@ClipMesh
$LN55@ClipMesh:
  00100	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
$LN56@ClipMesh:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 60   : 		if (D3DXVec3Dot(&m_v3Normal, &v3Cross) > (m_cfDecalEpsilon) *D3DXVec3Length(&v3Cross))

  00105	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+256]
  00109	f3 0f 10 4c 24
	14		 movss	 xmm1, DWORD PTR tv1128[esp+256]
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 808  :             return (float)sqrt(_X);

  0010f	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 60   : 		if (D3DXVec3Dot(&m_v3Normal, &v3Cross) > (m_cfDecalEpsilon) *D3DXVec3Length(&v3Cross))

  00113	f3 0f 59 81 90
	1a 00 00	 mulss	 xmm0, DWORD PTR [ecx+6800]
  0011b	0f 2f c8	 comiss	 xmm1, xmm0
  0011e	0f 86 c0 00 00
	00		 jbe	 $LN2@ClipMesh

; 61   : 		{
; 62   : 			v3NewVertex[0] = v3_1;

  00124	8b 46 f4	 mov	 eax, DWORD PTR [esi-12]
  00127	f3 0f 7e 46 ec	 movq	 xmm0, QWORD PTR [esi-20]
  0012c	89 84 24 90 00
	00 00		 mov	 DWORD PTR _v3NewVertex$[esp+264], eax

; 63   : 			v3NewVertex[1] = v3_2;

  00133	8b 06		 mov	 eax, DWORD PTR [esi]
  00135	89 84 24 9c 00
	00 00		 mov	 DWORD PTR _v3NewVertex$[esp+276], eax

; 64   : 			v3NewVertex[2] = v3_3;

  0013c	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  0013f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR _v3NewVertex$[esp+288], eax

; 65   : 
; 66   : 			v3NewNormal[0] = c_pv3Normal[3 * dwi];

  00146	8b 47 f0	 mov	 eax, DWORD PTR [edi-16]
  00149	89 44 24 20	 mov	 DWORD PTR _v3NewNormal$[esp+264], eax

; 67   : 			v3NewNormal[1] = c_pv3Normal[3 * dwi + 1];

  0014d	8b 47 fc	 mov	 eax, DWORD PTR [edi-4]
  00150	89 44 24 2c	 mov	 DWORD PTR _v3NewNormal$[esp+276], eax

; 68   : 			v3NewNormal[2] = c_pv3Normal[3 * dwi + 2];

  00154	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00157	66 0f d6 84 24
	88 00 00 00	 movq	 QWORD PTR _v3NewVertex$[esp+256], xmm0
  00160	f3 0f 7e 46 f8	 movq	 xmm0, QWORD PTR [esi-8]
  00165	89 44 24 38	 mov	 DWORD PTR _v3NewNormal$[esp+288], eax

; 69   : 
; 70   : 			DWORD dwCount = ClipPolygon(3, v3NewVertex, v3NewNormal, v3NewVertex, v3NewNormal);

  00169	8d 44 24 18	 lea	 eax, DWORD PTR _v3NewNormal$[esp+256]
  0016d	50		 push	 eax
  0016e	66 0f d6 84 24
	98 00 00 00	 movq	 QWORD PTR _v3NewVertex$[esp+272], xmm0
  00177	8d 84 24 8c 00
	00 00		 lea	 eax, DWORD PTR _v3NewVertex$[esp+260]
  0017e	f3 0f 7e 46 04	 movq	 xmm0, QWORD PTR [esi+4]
  00183	50		 push	 eax
  00184	66 0f d6 84 24
	a8 00 00 00	 movq	 QWORD PTR _v3NewVertex$[esp+288], xmm0
  0018d	8d 44 24 20	 lea	 eax, DWORD PTR _v3NewNormal$[esp+264]
  00191	f3 0f 7e 47 e8	 movq	 xmm0, QWORD PTR [edi-24]
  00196	50		 push	 eax
  00197	66 0f d6 44 24
	24		 movq	 QWORD PTR _v3NewNormal$[esp+268], xmm0
  0019d	8d 84 24 94 00
	00 00		 lea	 eax, DWORD PTR _v3NewVertex$[esp+268]
  001a4	f3 0f 7e 47 f4	 movq	 xmm0, QWORD PTR [edi-12]
  001a9	66 0f d6 44 24
	30		 movq	 QWORD PTR _v3NewNormal$[esp+280], xmm0
  001af	f3 0f 7e 07	 movq	 xmm0, QWORD PTR [edi]
  001b3	50		 push	 eax
  001b4	6a 03		 push	 3
  001b6	66 0f d6 44 24
	44		 movq	 QWORD PTR _v3NewNormal$[esp+300], xmm0
  001bc	e8 00 00 00 00	 call	 ?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z ; CDecal::ClipPolygon

; 71   : 			if ((dwCount != 0) && (!AddPolygon(dwCount, v3NewVertex, v3NewNormal))) break;

  001c1	85 c0		 test	 eax, eax
  001c3	74 1b		 je	 SHORT $LN54@ClipMesh
  001c5	8d 4c 24 18	 lea	 ecx, DWORD PTR _v3NewNormal$[esp+256]
  001c9	51		 push	 ecx
  001ca	8d 8c 24 8c 00
	00 00		 lea	 ecx, DWORD PTR _v3NewVertex$[esp+260]
  001d1	51		 push	 ecx
  001d2	8b 4c 24 18	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+264]
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 ?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z ; CDecal::AddPolygon
  001dc	84 c0		 test	 al, al
  001de	74 14		 je	 SHORT $LN53@ClipMesh
$LN54@ClipMesh:

; 46   : 	D3DXVECTOR3		v3NewVertex[9];
; 47   : 	D3DXVECTOR3		v3NewNormal[9];
; 48   : 
; 49   : 	// Clip one triangle at a time
; 50   : 	for (DWORD dwi = 0; dwi < dwPrimitiveCount; ++dwi)

  001e0	8b 4c 24 10	 mov	 ecx, DWORD PTR _this$GSCopy$1$[esp+256]
$LN2@ClipMesh:
  001e4	43		 inc	 ebx
  001e5	83 c6 24	 add	 esi, 36			; 00000024H
  001e8	83 c7 24	 add	 edi, 36			; 00000024H
  001eb	3b 5d 08	 cmp	 ebx, DWORD PTR _dwPrimitiveCount$[ebp]
  001ee	0f 82 4c fe ff
	ff		 jb	 $LL4@ClipMesh
$LN53@ClipMesh:

; 72   : 		}
; 73   : 	}
; 74   : }

  001f4	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+256]
  001fb	5f		 pop	 edi
  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
  001fe	33 cc		 xor	 ecx, esp
  00200	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00205	8b e5		 mov	 esp, ebp
  00207	5d		 pop	 ebp
  00208	c2 0c 00	 ret	 12			; 0000000cH
?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z ENDP		; CDecal::ClipMesh
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
;	COMDAT ?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -28					; size = 4
_wIndex$1$ = -24					; size = 4
_aTriangleFanStruct$ = -20				; size = 16
__$ArrayPad$ = -4					; size = 4
_dwAddCount$ = 8					; size = 4
_c_pv3Vertex$ = 12					; size = 4
___formal$ = 16						; size = 4
?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z PROC	; CDecal::AddPolygon, COMDAT
; _this$ = ecx

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx

; 78   : 	if (m_dwVertexCount + dwAddCount >= MAX_DECAL_VERTICES)

  00011	8b 5d 08	 mov	 ebx, DWORD PTR _dwAddCount$[ebp]
  00014	57		 push	 edi
  00015	8b f9		 mov	 edi, ecx
  00017	89 7d e4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  0001a	8b 4f 7c	 mov	 ecx, DWORD PTR [edi+124]
  0001d	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00020	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00025	72 14		 jb	 SHORT $LN5@AddPolygon

; 79   : 		return false;

  00027	5f		 pop	 edi
  00028	32 c0		 xor	 al, al

; 107  : 	}
; 108  : 
; 109  : 	m_dwVertexCount = dwCount;
; 110  : 	return true;
; 111  : }

  0002a	5b		 pop	 ebx
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002e	33 cd		 xor	 ecx, ebp
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 0c 00	 ret	 12			; 0000000cH
$LN5@AddPolygon:

; 80   : 
; 81   : 	TTRIANGLEFANSTRUCT aTriangleFanStruct;
; 82   : 	aTriangleFanStruct.m_wMinIndex = m_dwVertexCount;
; 83   : 	aTriangleFanStruct.m_dwVertexCount = dwAddCount;
; 84   : 	aTriangleFanStruct.m_dwPrimitiveCount = dwAddCount - 2;

  0003b	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]
  0003e	66 89 4d ec	 mov	 WORD PTR _aTriangleFanStruct$[ebp], cx
  00042	89 45 f4	 mov	 DWORD PTR _aTriangleFanStruct$[ebp+8], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00045	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 85   : 	aTriangleFanStruct.m_dwVBOffset = m_dwVertexCount;

  0004b	89 4d f8	 mov	 DWORD PTR _aTriangleFanStruct$[ebp+12], ecx

; 86   : 
; 87   : 	m_TriangleFanStructVector.push_back(aTriangleFanStruct);

  0004e	8d 8f 84 00 00
	00		 lea	 ecx, DWORD PTR [edi+132]
  00054	89 5d f0	 mov	 DWORD PTR _aTriangleFanStruct$[ebp+4], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00057	3b 87 8c 00 00
	00		 cmp	 eax, DWORD PTR [edi+140]
  0005d	74 10		 je	 SHORT $LN10@AddPolygon
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 506  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  0005f	0f 10 45 ec	 movups	 xmm0, XMMWORD PTR _aTriangleFanStruct$[ebp]
  00063	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 854  :         ++_Mylast;

  00066	83 87 88 00 00
	00 10		 add	 DWORD PTR [edi+136], 16	; 00000010H

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0006d	eb 0a		 jmp	 SHORT $LN9@AddPolygon
$LN10@AddPolygon:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0006f	8d 55 ec	 lea	 edx, DWORD PTR _aTriangleFanStruct$[ebp]
  00072	52		 push	 edx
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSTRIANGLEFANSTRUCT@CDecal@@@?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEPAUSTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::STRIANGLEFANSTRUCT const &>
$LN9@AddPolygon:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 89   : 	DWORD dwCount = m_dwVertexCount;

  00079	8b 57 7c	 mov	 edx, DWORD PTR [edi+124]

; 90   : 
; 91   : 	// Add polygon as a triangle fan
; 92   : 	WORD * wIndex = m_Indices + dwCount;

  0007c	8d 87 90 18 00
	00		 lea	 eax, DWORD PTR [edi+6288]
  00082	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00085	89 45 e8	 mov	 DWORD PTR _wIndex$1$[ebp], eax

; 93   : 
; 94   : 	m_dwPrimitiveCount += dwAddCount - 2;

  00088	8d 43 fe	 lea	 eax, DWORD PTR [ebx-2]
  0008b	01 87 80 00 00
	00		 add	 DWORD PTR [edi+128], eax

; 95   : 	//float fOne_over_1MinusDecalEpsilon = 1.0f / (1.0f - m_cfDecalEpsilon);
; 96   : 
; 97   : 	// Assign vertex colors
; 98   : 	for (DWORD dwVertexNum = 0; dwVertexNum < dwAddCount; ++dwVertexNum)

  00091	85 db		 test	 ebx, ebx
  00093	74 47		 je	 SHORT $LN3@AddPolygon

; 89   : 	DWORD dwCount = m_dwVertexCount;

  00095	8d 8f 9c 00 00
	00		 lea	 ecx, DWORD PTR [edi+156]
  0009b	8b 7d e8	 mov	 edi, DWORD PTR _wIndex$1$[ebp]
  0009e	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  000a1	56		 push	 esi
  000a2	8b 75 0c	 mov	 esi, DWORD PTR _c_pv3Vertex$[ebp]
  000a5	8d 0c c1	 lea	 ecx, DWORD PTR [ecx+eax*8]
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@AddPolygon:

; 99   : 	{
; 100  : 		*wIndex++ = (WORD) dwCount;

  000b0	66 89 17	 mov	 WORD PTR [edi], dx
  000b3	8d 7f 02	 lea	 edi, DWORD PTR [edi+2]

; 101  : 		m_Vertices[dwCount].position = c_pv3Vertex[dwVertexNum];

  000b6	f3 0f 7e 06	 movq	 xmm0, QWORD PTR [esi]

; 102  : 		//const D3DXVECTOR3 & v3Normal = c_pv3Normal[dwVertexNum];
; 103  : 		//float fAlpha = (D3DXVec3Dot(&m_v3Normal, &v3Normal) / D3DXVec3Length(&v3Normal) - m_cfDecalEpsilon) * fOne_over_1MinusDecalEpsilon;
; 104  : 		//m_Vertices[dwCount].diffuse = D3DXCOLOR(1.0f, 1.0f, 1.0f, (fAlpha > 0.0f) ? fAlpha : 0.0f);
; 105  : 		m_Vertices[dwCount].diffuse = 0xFFFFFFFF;
; 106  : 		++dwCount;

  000ba	8d 49 18	 lea	 ecx, DWORD PTR [ecx+24]
  000bd	66 0f d6 41 dc	 movq	 QWORD PTR [ecx-36], xmm0
  000c2	8d 76 0c	 lea	 esi, DWORD PTR [esi+12]
  000c5	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  000c8	42		 inc	 edx
  000c9	89 41 e4	 mov	 DWORD PTR [ecx-28], eax
  000cc	c7 41 e8 ff ff
	ff ff		 mov	 DWORD PTR [ecx-24], -1
  000d3	83 eb 01	 sub	 ebx, 1
  000d6	75 d8		 jne	 SHORT $LL4@AddPolygon

; 95   : 	//float fOne_over_1MinusDecalEpsilon = 1.0f / (1.0f - m_cfDecalEpsilon);
; 96   : 
; 97   : 	// Assign vertex colors
; 98   : 	for (DWORD dwVertexNum = 0; dwVertexNum < dwAddCount; ++dwVertexNum)

  000d8	8b 7d e4	 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  000db	5e		 pop	 esi
$LN3@AddPolygon:

; 107  : 	}
; 108  : 
; 109  : 	m_dwVertexCount = dwCount;
; 110  : 	return true;
; 111  : }

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000df	b0 01		 mov	 al, 1
  000e1	89 57 7c	 mov	 DWORD PTR [edi+124], edx
  000e4	33 cd		 xor	 ecx, ebp
  000e6	5f		 pop	 edi
  000e7	5b		 pop	 ebx
  000e8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ed	8b e5		 mov	 esp, ebp
  000ef	5d		 pop	 ebp
  000f0	c2 0c 00	 ret	 12			; 0000000cH
?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z ENDP	; CDecal::AddPolygon
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ PROC ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ ENDP ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAE@XZ PROC ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::~vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN5@vector

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 f0	 and	 ecx, -16		; fffffff0H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00049	5e		 pop	 esi

; 820  :     }

  0004a	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00050	cc		 int	 3
??1?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAE@XZ ENDP ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::~vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
;	COMDAT ?Render@CDecal@@UAEXXZ
_TEXT	SEGMENT
_matWorld$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
?Render@CDecal@@UAEXXZ PROC				; CDecal::Render, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	53		 push	 ebx
  00011	57		 push	 edi

; 228  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matWorld);

  00012	8d 45 bc	 lea	 eax, DWORD PTR _matWorld$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00015	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+56], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 228  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matWorld);

  0001c	50		 push	 eax
  0001d	8b f9		 mov	 edi, ecx
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  0001f	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+52], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 228  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matWorld);

  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0002c	68 00 01 00 00	 push	 256			; 00000100H
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00031	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+48], 0
  00038	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+44], 0
  0003f	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+36], 0
  00046	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+32], 0
  0004d	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+28], 0
  00054	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+24], 0
  0005b	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+16], 0
  00062	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+12], 0
  00069	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+8], 0
  00070	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR _matWorld$[ebp+4], 0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00077	c7 45 f8 00 00
	80 3f		 mov	 DWORD PTR _matWorld$[ebp+60], 1065353216 ; 3f800000H
  0007e	c7 45 e4 00 00
	80 3f		 mov	 DWORD PTR _matWorld$[ebp+40], 1065353216 ; 3f800000H
  00085	c7 45 d0 00 00
	80 3f		 mov	 DWORD PTR _matWorld$[ebp+20], 1065353216 ; 3f800000H
  0008c	c7 45 bc 00 00
	80 3f		 mov	 DWORD PTR _matWorld$[ebp], 1065353216 ; 3f800000H
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 228  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matWorld);

  00093	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 229  : 
; 230  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1);

  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0009e	68 42 01 00 00	 push	 322			; 00000142H
  000a3	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000a8	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 232  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  000ae	33 db		 xor	 ebx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000b0	8b 97 84 00 00
	00		 mov	 edx, DWORD PTR [edi+132]
  000b6	2b c2		 sub	 eax, edx
  000b8	c1 f8 04	 sar	 eax, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 232  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  000bb	85 c0		 test	 eax, eax
  000bd	74 52		 je	 SHORT $LN3@Render
  000bf	56		 push	 esi
  000c0	8d 87 90 00 00
	00		 lea	 eax, DWORD PTR [edi+144]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1899 :         auto& _My_data = _Mypair._Myval2;

  000c6	33 f6		 xor	 esi, esi
$LL4@Render:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 233  : 		STATEMANAGER.DrawIndexedPrimitiveUP(D3DPT_TRIANGLEFAN,

  000c8	0f b7 0c 16	 movzx	 ecx, WORD PTR [esi+edx]
  000cc	6a 18		 push	 24			; 00000018H
  000ce	50		 push	 eax
  000cf	6a 65		 push	 101			; 00000065H
  000d1	8d 87 90 18 00
	00		 lea	 eax, DWORD PTR [edi+6288]
  000d7	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  000da	50		 push	 eax
  000db	ff 74 16 08	 push	 DWORD PTR [esi+edx+8]
  000df	ff 74 16 04	 push	 DWORD PTR [esi+edx+4]
  000e3	51		 push	 ecx
  000e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ea	6a 06		 push	 6
  000ec	e8 00 00 00 00	 call	 ?DrawIndexedPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIIPBXW4_D3DFORMAT@@1I@Z ; CStateManager::DrawIndexedPrimitiveUP
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000f1	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 232  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  000f7	8d 76 10	 lea	 esi, DWORD PTR [esi+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000fa	8b 97 84 00 00
	00		 mov	 edx, DWORD PTR [edi+132]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 232  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  00100	43		 inc	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00101	2b c2		 sub	 eax, edx
  00103	c1 f8 04	 sar	 eax, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 232  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  00106	3b d8		 cmp	 ebx, eax
  00108	8d 87 90 00 00
	00		 lea	 eax, DWORD PTR [edi+144]
  0010e	72 b8		 jb	 SHORT $LL4@Render
  00110	5e		 pop	 esi
$LN3@Render:

; 234  : 		m_TriangleFanStructVector[dwi].m_wMinIndex,
; 235  : 		m_TriangleFanStructVector[dwi].m_dwVertexCount,
; 236  : 		m_TriangleFanStructVector[dwi].m_dwPrimitiveCount,
; 237  : 		m_Indices + m_TriangleFanStructVector[dwi].m_wMinIndex,
; 238  : 		D3DFMT_INDEX16,
; 239  : 		m_Vertices,
; 240  : 		sizeof(TPDTVertex));
; 241  : }

  00111	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00114	5f		 pop	 edi
  00115	33 cd		 xor	 ecx, ebp
  00117	5b		 pop	 ebx
  00118	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011d	8b e5		 mov	 esp, ebp
  0011f	5d		 pop	 ebp
  00120	c3		 ret	 0
?Render@CDecal@@UAEXXZ ENDP				; CDecal::Render
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
;	COMDAT ?Clear@CDecal@@QAEXXZ
_TEXT	SEGMENT
?Clear@CDecal@@QAEXXZ PROC				; CDecal::Clear, COMDAT
; _this$ = ecx

; 24   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	0f 57 c0	 xorps	 xmm0, xmm0

; 25   : 	m_v3Center = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00006	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0000d	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00014	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 26   : 	m_v3Normal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  0001b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00022	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00029	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 27   : 
; 28   : 	m_v4LeftPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);

  00030	0f 11 46 1c	 movups	 XMMWORD PTR [esi+28], xmm0

; 29   : 	m_v4RightPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);
; 30   : 	m_v4TopPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);
; 31   : 	m_v4BottomPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);
; 32   : 	m_v4FrontPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);
; 33   : 	m_v4BackPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);
; 34   : 
; 35   : 	m_dwVertexCount = 0;

  00034	c7 46 7c 00 00
	00 00		 mov	 DWORD PTR [esi+124], 0
  0003b	0f 11 46 2c	 movups	 XMMWORD PTR [esi+44], xmm0

; 36   : 	m_dwPrimitiveCount = 0;

  0003f	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], 0
  00049	0f 11 46 4c	 movups	 XMMWORD PTR [esi+76], xmm0
  0004d	0f 11 46 3c	 movups	 XMMWORD PTR [esi+60], xmm0
  00051	0f 11 46 5c	 movups	 XMMWORD PTR [esi+92], xmm0
  00055	0f 11 46 6c	 movups	 XMMWORD PTR [esi+108], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00059	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  0005f	3b 86 88 00 00
	00		 cmp	 eax, DWORD PTR [esi+136]
  00065	74 06		 je	 SHORT $LN19@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00067	89 86 88 00 00
	00		 mov	 DWORD PTR [esi+136], eax
$LN19@Clear:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 40   : 	memset(m_Vertices, 0, sizeof(m_Vertices));

  0006d	68 00 18 00 00	 push	 6144			; 00001800H
  00072	8d 86 90 00 00
	00		 lea	 eax, DWORD PTR [esi+144]
  00078	6a 00		 push	 0
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 _memset

; 41   : 	memset(m_Indices, 0, sizeof(m_Indices));

  00080	68 00 02 00 00	 push	 512			; 00000200H
  00085	8d 86 90 18 00
	00		 lea	 eax, DWORD PTR [esi+6288]
  0008b	6a 00		 push	 0
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _memset
  00093	83 c4 18	 add	 esp, 24			; 00000018H
  00096	5e		 pop	 esi

; 42   : }

  00097	c3		 ret	 0
?Clear@CDecal@@QAEXXZ ENDP				; CDecal::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
;	COMDAT ??1CDecal@@UAE@XZ
_TEXT	SEGMENT
??1CDecal@@UAE@XZ PROC					; CDecal::~CDecal, COMDAT
; _this$ = ecx

; 19   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDecal@@6B@

; 20   : 	Clear();

  00009	e8 00 00 00 00	 call	 ?Clear@CDecal@@QAEXXZ	; CDecal::Clear
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0000e	8b 86 84 00 00
	00		 mov	 eax, DWORD PTR [esi+132]
  00014	85 c0		 test	 eax, eax
  00016	74 4d		 je	 SHORT $LN8@CDecal

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00018	8b 8e 8c 00 00
	00		 mov	 ecx, DWORD PTR [esi+140]
  0001e	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00020	83 e1 f0	 and	 ecx, -16		; fffffff0H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00023	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00029	72 12		 jb	 SHORT $LN27@CDecal

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002e	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00033	83 c0 fc	 add	 eax, -4			; fffffffcH
  00036	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00039	77 2c		 ja	 SHORT $LN24@CDecal

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003b	8b c2		 mov	 eax, edx
$LN27@CDecal:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0003d	51		 push	 ecx
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00044	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0004e	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00051	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], 0

; 2082 :             _Myend   = nullptr;

  0005b	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], 0
$LN8@CDecal:
  00065	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 21   : }

  00066	c3		 ret	 0
$LN24@CDecal:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00067	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN36@CDecal:
  0006c	cc		 int	 3
??1CDecal@@UAE@XZ ENDP					; CDecal::~CDecal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp
;	COMDAT ??0CDecal@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CDecal@@QAE@XZ PROC					; CDecal::CDecal, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CDecal@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDecal@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002f	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
  00039	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], 0
  00043	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Decal.cpp

; 13   : CDecal::CDecal():m_cfDecalEpsilon(0.25f)

  0004d	c7 86 90 1a 00
	00 00 00 80 3e	 mov	 DWORD PTR [esi+6800], 1048576000 ; 3e800000H

; 15   : 	Clear();

  00057	e8 00 00 00 00	 call	 ?Clear@CDecal@@QAEXXZ	; CDecal::Clear

; 16   : }

  0005c	8b c6		 mov	 eax, esi
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00068	59		 pop	 ecx
  00069	5e		 pop	 esi
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CDecal@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@USTRIANGLEFANSTRUCT@CDecal@@V?$allocator@USTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAE@XZ ; std::vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >::~vector<CDecal::STRIANGLEFANSTRUCT,std::allocator<CDecal::STRIANGLEFANSTRUCT> >
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
__ehhandler$??0CDecal@@QAE@XZ:
  00013	90		 npad	 1
  00014	90		 npad	 1
  00015	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00019	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001c	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CDecal@@QAE@XZ
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CDecal@@QAE@XZ ENDP					; CDecal::CDecal
; Function compile flags: /Ogtp
;	COMDAT ??0SPDTVertex@@QAE@XZ
_TEXT	SEGMENT
??0SPDTVertex@@QAE@XZ PROC				; SPDTVertex::SPDTVertex, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SPDTVertex@@QAE@XZ ENDP				; SPDTVertex::SPDTVertex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
