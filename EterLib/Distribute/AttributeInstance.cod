; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\EterLib\Distribute\AttributeInstance.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@	; CDynamicPool<CAttributeInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 ; CDynamicPool<CAttributeInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCAttributeInstance@@@@8	; CDynamicPool<CAttributeInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCAttributeInstance@@@@8	; CDynamicPool<CAttributeInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_7?$CDynamicPool@VCAttributeInstance@@@@6B@	; CDynamicPool<CAttributeInstance>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CAttributeInstance>::`vector deleting destructor'
;	COMDAT ??_7?$CDynamicPool@VCAttributeInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCAttributeInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@ ; CDynamicPool<CAttributeInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCAttributeInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCAttributeInstance@@@@8 DD 00H	; CDynamicPool<CAttributeInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CAttributeInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCAttributeInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@ DD 00H	; CDynamicPool<CAttributeInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
PUBLIC	??0CAttributeInstance@@QAE@XZ			; CAttributeInstance::CAttributeInstance
PUBLIC	??1CAttributeInstance@@UAE@XZ			; CAttributeInstance::~CAttributeInstance
PUBLIC	?Clear@CAttributeInstance@@QAEXXZ		; CAttributeInstance::Clear
PUBLIC	?IsEmpty@CAttributeInstance@@QBEHXZ		; CAttributeInstance::IsEmpty
PUBLIC	?GetDataFileName@CAttributeInstance@@QBEPBDXZ	; CAttributeInstance::GetDataFileName
PUBLIC	?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z ; CAttributeInstance::SetObjectPointer
PUBLIC	?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z ; CAttributeInstance::RefreshObject
PUBLIC	?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ ; CAttributeInstance::GetObjectPointer
PUBLIC	?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z ; CAttributeInstance::Picking
PUBLIC	?IsInHeight@CAttributeInstance@@QAEHMM@Z	; CAttributeInstance::IsInHeight
PUBLIC	?GetHeight@CAttributeInstance@@QAEHMMPAM@Z	; CAttributeInstance::GetHeight
PUBLIC	??1?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::~vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
PUBLIC	?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength
PUBLIC	?CreateSystem@CAttributeInstance@@SAXI@Z	; CAttributeInstance::CreateSystem
PUBLIC	?DestroySystem@CAttributeInstance@@SAXXZ	; CAttributeInstance::DestroySystem
PUBLIC	?New@CAttributeInstance@@SAPAV1@XZ		; CAttributeInstance::New
PUBLIC	?Delete@CAttributeInstance@@SAXPAV1@@Z		; CAttributeInstance::Delete
PUBLIC	??_GCAttributeInstance@@UAEPAXI@Z		; CAttributeInstance::`scalar deleting destructor'
PUBLIC	??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
PUBLIC	?push_back@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::push_back
PUBLIC	?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::reserve
PUBLIC	?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
PUBLIC	??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>
PUBLIC	??$_Copy_memmove_tail@PAPAVCAttributeInstance@@@std@@YAPAPAVCAttributeInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CAttributeInstance * *>
PUBLIC	??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<D3DXVECTOR3 *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A ; CAttributeInstance::ms_kPool
PUBLIC	??_7CAttributeInstance@@6B@			; CAttributeInstance::`vftable'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CAttributeInstance@@6B@			; CAttributeInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCAttributeInstance@@@8			; CAttributeInstance `RTTI Type Descriptor'
PUBLIC	??_R3CAttributeInstance@@8			; CAttributeInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CAttributeInstance@@8			; CAttributeInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CAttributeInstance@@8		; CAttributeInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	_D3DXVec3TransformCoord@12:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?fMAX@@YAMMM@Z:PROC				; fMAX
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?GetHeightDataCount@CAttributeData@@QBEKXZ:PROC	; CAttributeData::GetHeightDataCount
EXTRN	?GetHeightDataPointer@CAttributeData@@QBEHKPAPBUSHeightData@@@Z:PROC ; CAttributeData::GetHeightDataPointer
EXTRN	?GetMaximizeRadius@CAttributeData@@QAEMXZ:PROC	; CAttributeData::GetMaximizeRadius
EXTRN	??_ECAttributeInstance@@UAEPAXI@Z:PROC		; CAttributeInstance::`vector deleting destructor'
EXTRN	?IsInTriangle2D@@YA_NMMMMMMMM@Z:PROC		; IsInTriangle2D
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_memmove:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CAttributeInstance@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CAttributeInstance@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CAttributeInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAttributeInstance@@8 DD FLAT:??_R0?AVCAttributeInstance@@@8 ; CAttributeInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAttributeInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CAttributeInstance@@8
rdata$r	SEGMENT
??_R2CAttributeInstance@@8 DD FLAT:??_R1A@?0A@EA@CAttributeInstance@@8 ; CAttributeInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CAttributeInstance@@8
rdata$r	SEGMENT
??_R3CAttributeInstance@@8 DD 00H			; CAttributeInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CAttributeInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAttributeInstance@@@8
data$rs	SEGMENT
??_R0?AVCAttributeInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CAttributeInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAttributeInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CAttributeInstance@@6B@
rdata$r	SEGMENT
??_R4CAttributeInstance@@6B@ DD 00H			; CAttributeInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCAttributeInstance@@@8
	DD	FLAT:??_R3CAttributeInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CAttributeInstance@@6B@
CONST	SEGMENT
??_7CAttributeInstance@@6B@ DD FLAT:??_R4CAttributeInstance@@6B@ ; CAttributeInstance::`vftable'
	DD	FLAT:??_ECAttributeInstance@@UAEPAXI@Z
CONST	ENDS
_DATA	SEGMENT
?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCAttributeInstance@@@@6B@ ; CAttributeInstance::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CRef@VCAttributeData@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CAttributeInstance@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1CAttributeInstance@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CAttributeInstance@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z PROC ; std::_Copy_memmove_tail<D3DXVECTOR3 *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z ENDP ; std::_Copy_memmove_tail<D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAVCAttributeInstance@@@std@@YAPAPAVCAttributeInstance@@QBDQAPAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAVCAttributeInstance@@@std@@YAPAPAVCAttributeInstance@@QBDQAPAV1@II@Z PROC ; std::_Copy_memmove_tail<CAttributeInstance * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAVCAttributeInstance@@@std@@YAPAPAVCAttributeInstance@@QBDQAPAV1@II@Z ENDP ; std::_Copy_memmove_tail<CAttributeInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z PROC ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 4d 08	 sub	 ecx, DWORD PTR __First$[ebp]
  0000e	f7 e9		 imul	 ecx
  00010	d1 fa		 sar	 edx, 1
  00012	8b c2		 mov	 eax, edx
  00014	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00017	03 c2		 add	 eax, edx

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00019	50		 push	 eax
  0001a	51		 push	 ecx
  0001b	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  0001e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAUD3DXVECTOR3@@@std@@YAPAUD3DXVECTOR3@@QBDQAU1@II@Z ; std::_Copy_memmove_tail<D3DXVECTOR3 *>
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ENDP ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCAttributeInstance@@@std@@YAPAPAVCAttributeInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CAttributeInstance * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
tv512 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1537 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1538 :         if (_Newsize > max_size()) {

  00005	8b 5d 08	 mov	 ebx, DWORD PTR __Newsize$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	81 fb 55 55 55
	15		 cmp	 ebx, 357913941		; 15555555H
  00012	0f 87 f2 00 00
	00		 ja	 $LN116@Resize_rea

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00018	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001b	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00020	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00022	f7 e9		 imul	 ecx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00024	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00029	d1 fa		 sar	 edx, 1
  0002b	8b ca		 mov	 ecx, edx
  0002d	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00030	03 ca		 add	 ecx, edx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00032	8b d1		 mov	 edx, ecx
  00034	d1 ea		 shr	 edx, 1
  00036	2b c2		 sub	 eax, edx
  00038	3b c8		 cmp	 ecx, eax
  0003a	76 14		 jbe	 SHORT $LN6@Resize_rea

; 1997 :             return _Max; // geometric growth would overflow

  0003c	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00041	c7 45 fc fc ff
	ff ff		 mov	 DWORD PTR tv512[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0004e	eb 3e		 jmp	 SHORT $LN114@Resize_rea
$LN6@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00050	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00053	3b c3		 cmp	 eax, ebx
  00055	73 15		 jae	 SHORT $LN7@Resize_rea

; 2003 :             return _Newsize; // geometric growth would be insufficient

  00057	8b c3		 mov	 eax, ebx
$LN17@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  00059	8d 34 40	 lea	 esi, DWORD PTR [eax+eax*2]
  0005c	c1 e6 02	 shl	 esi, 2

; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005f	8b c6		 mov	 eax, esi

; 122  :     return _Count * _Ty_size;

  00061	89 75 fc	 mov	 DWORD PTR tv512[ebp], esi

; 227  :     if (_Bytes == 0) {

  00064	85 c0		 test	 eax, eax
  00066	75 11		 jne	 SHORT $LN21@Resize_rea

; 228  :         return nullptr;

  00068	33 db		 xor	 ebx, ebx
  0006a	eb 27		 jmp	 SHORT $LN31@Resize_rea
$LN7@Resize_rea:

; 117  :         if (_Count > _Max_possible) {

  0006c	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00071	0f 87 98 00 00
	00		 ja	 $LN117@Resize_rea
  00077	eb e0		 jmp	 SHORT $LN17@Resize_rea
$LN21@Resize_rea:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00079	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007e	72 08		 jb	 SHORT $LN22@Resize_rea

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00086	eb 06		 jmp	 SHORT $LN114@Resize_rea
$LN22@Resize_rea:

; 136  :         return ::operator new(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN114@Resize_rea:

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  0008e	8b d8		 mov	 ebx, eax
  00090	83 c4 04	 add	 esp, 4
$LN31@Resize_rea:
  00093	53		 push	 ebx
  00094	ff 77 04	 push	 DWORD PTR [edi+4]
  00097	ff 37		 push	 DWORD PTR [edi]
  00099	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUD3DXVECTOR3@@PAU1@@std@@YAPAUD3DXVECTOR3@@PAU1@00@Z ; std::_Copy_memmove<D3DXVECTOR3 *,D3DXVECTOR3 *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  0009e	8b 37		 mov	 esi, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000a3	85 f6		 test	 esi, esi
  000a5	74 3f		 je	 SHORT $LN61@Resize_rea

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000a7	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000aa	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000af	2b ce		 sub	 ecx, esi
  000b1	f7 e9		 imul	 ecx
  000b3	d1 fa		 sar	 edx, 1
  000b5	8b c2		 mov	 eax, edx
  000b7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ba	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bc	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  000bf	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000c2	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000c8	72 12		 jb	 SHORT $LN72@Resize_rea

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ca	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  000cd	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000d0	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000d2	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  000d5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000d8	77 2b		 ja	 SHORT $LN69@Resize_rea

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000da	8b f2		 mov	 esi, edx
$LN72@Resize_rea:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000dc	51		 push	 ecx
  000dd	56		 push	 esi
  000de	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000e3	83 c4 08	 add	 esp, 8
$LN61@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  000e6	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000e9	89 1f		 mov	 DWORD PTR [edi], ebx
  000eb	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000ee	8d 04 83	 lea	 eax, DWORD PTR [ebx+eax*4]
  000f1	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  000f4	8b 45 fc	 mov	 eax, DWORD PTR tv512[ebp]
  000f7	03 c3		 add	 eax, ebx
  000f9	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 1571 :     }

  000fc	5f		 pop	 edi
  000fd	5e		 pop	 esi
  000fe	5b		 pop	 ebx
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c2 08 00	 ret	 8
$LN69@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00105	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN116@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1539 :             _Xlength();

  0010a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
$LN117@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0010f	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN113@Resize_rea:
  00114	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >, COMDAT

; 2041 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2042 :     // value-initialize _Count objects to raw _First, using _Al
; 2043 :     using _Ptrty = typename _Alloc::value_type*;
; 2044 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2045 : #if _HAS_CXX20
; 2046 :         if (!_STD is_constant_evaluated())
; 2047 : #endif // _HAS_CXX20
; 2048 :         {
; 2049 :             auto _PFirst = _Unfancy(_First);
; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2051 :             return _First + _Count;
; 2052 :         }
; 2053 :     }
; 2054 : 
; 2055 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2056 :     for (; 0 < _Count; --_Count) {

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	56		 push	 esi

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00007	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]

; 2042 :     // value-initialize _Count objects to raw _First, using _Al
; 2043 :     using _Ptrty = typename _Alloc::value_type*;
; 2044 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2045 : #if _HAS_CXX20
; 2046 :         if (!_STD is_constant_evaluated())
; 2047 : #endif // _HAS_CXX20
; 2048 :         {
; 2049 :             auto _PFirst = _Unfancy(_First);
; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2051 :             return _First + _Count;
; 2052 :         }
; 2053 :     }
; 2054 : 
; 2055 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2056 :     for (; 0 < _Count; --_Count) {

  0000a	85 c0		 test	 eax, eax
  0000c	74 1e		 je	 SHORT $LN3@Uninitiali
  0000e	66 90		 npad	 2
$LL4@Uninitiali:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00010	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
  00016	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  0001d	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  00024	83 c6 0c	 add	 esi, 12			; 0000000cH

; 2042 :     // value-initialize _Count objects to raw _First, using _Al
; 2043 :     using _Ptrty = typename _Alloc::value_type*;
; 2044 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 2045 : #if _HAS_CXX20
; 2046 :         if (!_STD is_constant_evaluated())
; 2047 : #endif // _HAS_CXX20
; 2048 :         {
; 2049 :             auto _PFirst = _Unfancy(_First);
; 2050 :             _Zero_range(_PFirst, _PFirst + _Count);
; 2051 :             return _First + _Count;
; 2052 :         }
; 2053 :     }
; 2054 : 
; 2055 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 2056 :     for (; 0 < _Count; --_Count) {

  00027	83 e8 01	 sub	 eax, 1
  0002a	75 e4		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  0002c	ff 75 10	 push	 DWORD PTR __Al$[ebp]
  0002f	56		 push	 esi
  00030	56		 push	 esi
  00031	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2057 :         _Backout._Emplace_back();
; 2058 :     }
; 2059 : 
; 2060 :     return _Backout._Release();

  00039	8b c6		 mov	 eax, esi
  0003b	5e		 pop	 esi

; 2061 : }

  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
__Oldsize$1$ = -12					; size = 4
tv679 = -8						; size = 4
$T2 = -4						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1537 :     _CONSTEXPR20 void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	57		 push	 edi

; 1538 :         if (_Newsize > max_size()) {

  00008	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000b	8b d9		 mov	 ebx, ecx
  0000d	89 5d f0	 mov	 DWORD PTR _this$1$[ebp], ebx
  00010	81 ff 55 55 55
	15		 cmp	 edi, 357913941		; 15555555H
  00016	0f 87 7e 01 00
	00		 ja	 $LN128@Resize_rea

; 1540 :         }
; 1541 : 
; 1542 :         auto& _Al         = _Getal();
; 1543 :         auto& _My_data    = _Mypair._Myval2;
; 1544 :         pointer& _Myfirst = _My_data._Myfirst;
; 1545 :         pointer& _Mylast  = _My_data._Mylast;
; 1546 : 
; 1547 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

  0001c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0001f	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00024	2b 0b		 sub	 ecx, DWORD PTR [ebx]
  00026	f7 e9		 imul	 ecx

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0002b	2b 0b		 sub	 ecx, DWORD PTR [ebx]

; 1540 :         }
; 1541 : 
; 1542 :         auto& _Al         = _Getal();
; 1543 :         auto& _My_data    = _Mypair._Myval2;
; 1544 :         pointer& _Myfirst = _My_data._Myfirst;
; 1545 :         pointer& _Mylast  = _My_data._Mylast;
; 1546 : 
; 1547 :         const auto _Oldsize    = static_cast<size_type>(_Mylast - _Myfirst);

  0002d	d1 fa		 sar	 edx, 1
  0002f	8b c2		 mov	 eax, edx
  00031	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00034	03 c2		 add	 eax, edx
  00036	89 45 f4	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00039	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0003e	f7 e9		 imul	 ecx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00040	b8 55 55 55 15	 mov	 eax, 357913941		; 15555555H

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00045	d1 fa		 sar	 edx, 1
  00047	8b ca		 mov	 ecx, edx
  00049	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0004c	03 ca		 add	 ecx, edx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004e	8b d1		 mov	 edx, ecx
  00050	d1 ea		 shr	 edx, 1
  00052	2b c2		 sub	 eax, edx
  00054	56		 push	 esi
  00055	3b c8		 cmp	 ecx, eax
  00057	76 19		 jbe	 SHORT $LN6@Resize_rea

; 1997 :             return _Max; // geometric growth would overflow

  00059	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0005e	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv679[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006b	8b f0		 mov	 esi, eax
  0006d	89 75 fc	 mov	 DWORD PTR $T2[ebp], esi
  00070	eb 49		 jmp	 SHORT $LN126@Resize_rea
$LN6@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00072	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 2001 : 
; 2002 :         if (_Geometric < _Newsize) {

  00075	3b c7		 cmp	 eax, edi
  00077	73 16		 jae	 SHORT $LN7@Resize_rea

; 2003 :             return _Newsize; // geometric growth would be insufficient

  00079	8b c7		 mov	 eax, edi
$LN17@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  0007b	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  0007e	c1 e0 02	 shl	 eax, 2
  00081	89 45 f8	 mov	 DWORD PTR tv679[ebp], eax

; 227  :     if (_Bytes == 0) {

  00084	85 c0		 test	 eax, eax
  00086	75 14		 jne	 SHORT $LN21@Resize_rea

; 228  :         return nullptr;

  00088	33 f6		 xor	 esi, esi
  0008a	89 75 fc	 mov	 DWORD PTR $T2[ebp], esi
  0008d	eb 2f		 jmp	 SHORT $LN20@Resize_rea
$LN7@Resize_rea:

; 117  :         if (_Count > _Max_possible) {

  0008f	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  00094	0f 87 05 01 00
	00		 ja	 $LN129@Resize_rea
  0009a	eb df		 jmp	 SHORT $LN17@Resize_rea
$LN21@Resize_rea:

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0009c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a1	72 0d		 jb	 SHORT $LN22@Resize_rea

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a9	8b f0		 mov	 esi, eax
  000ab	89 75 fc	 mov	 DWORD PTR $T2[ebp], esi
  000ae	eb 0b		 jmp	 SHORT $LN126@Resize_rea
$LN22@Resize_rea:

; 136  :         return ::operator new(_Bytes);

  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 256  :         return _Traits::_Allocate(_Bytes);

  000b6	8b f0		 mov	 esi, eax
  000b8	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
$LN126@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1551 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000bb	83 c4 04	 add	 esp, 4
$LN20@Resize_rea:
  000be	8b 55 f4	 mov	 edx, DWORD PTR __Oldsize$1$[ebp]

; 1560 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

  000c1	53		 push	 ebx
  000c2	8d 04 52	 lea	 eax, DWORD PTR [edx+edx*2]
  000c5	8d 0c 86	 lea	 ecx, DWORD PTR [esi+eax*4]
  000c8	8b c7		 mov	 eax, edi
  000ca	2b c2		 sub	 eax, edx
  000cc	50		 push	 eax
  000cd	51		 push	 ecx
  000ce	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);

  000d3	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1560 :             _Appended_last = _Uninitialized_value_construct_n(_Appended_first, _Newsize - _Oldsize, _Al);

  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d9	8b 03		 mov	 eax, DWORD PTR [ebx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  000db	8b fe		 mov	 edi, esi

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  000dd	3b c1		 cmp	 eax, ecx
  000df	74 33		 je	 SHORT $LN30@Resize_rea
  000e1	8b d9		 mov	 ebx, ecx
$LL31@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility

; 773  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000e3	8b 70 08	 mov	 esi, DWORD PTR [eax+8]
  000e6	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000e9	8b 08		 mov	 ecx, DWORD PTR [eax]

; 774  :     _Val         = static_cast<_Other&&>(_New_val);

  000eb	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
  000f2	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  000f9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  000ff	83 c0 0c	 add	 eax, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00102	89 0f		 mov	 DWORD PTR [edi], ecx
  00104	89 57 04	 mov	 DWORD PTR [edi+4], edx
  00107	89 77 08	 mov	 DWORD PTR [edi+8], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  0010a	83 c7 0c	 add	 edi, 12			; 0000000cH

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  0010d	3b c3		 cmp	 eax, ebx
  0010f	75 d2		 jne	 SHORT $LL31@Resize_rea
  00111	8b 5d f0	 mov	 ebx, DWORD PTR _this$1$[ebp]
$LN30@Resize_rea:

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  00114	53		 push	 ebx
  00115	57		 push	 edi
  00116	57		 push	 edi
  00117	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  0011c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  0011e	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00121	85 c9		 test	 ecx, ecx
  00123	74 4e		 je	 SHORT $LN71@Resize_rea

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  00125	53		 push	 ebx
  00126	ff 73 04	 push	 DWORD PTR [ebx+4]
  00129	51		 push	 ecx
  0012a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0012f	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00132	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00137	8b 33		 mov	 esi, DWORD PTR [ebx]
  00139	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013c	2b ce		 sub	 ecx, esi
  0013e	f7 e9		 imul	 ecx
  00140	d1 fa		 sar	 edx, 1
  00142	8b c2		 mov	 eax, edx
  00144	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00147	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00149	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0014c	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0014f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00155	72 12		 jb	 SHORT $LN82@Resize_rea

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00157	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  0015a	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0015d	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0015f	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  00162	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00165	77 2e		 ja	 SHORT $LN79@Resize_rea

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00167	8b f2		 mov	 esi, edx
$LN82@Resize_rea:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00169	51		 push	 ecx
  0016a	56		 push	 esi
  0016b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00170	83 c4 08	 add	 esp, 8
$LN71@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2060 :         _Myfirst = _Newvec;

  00173	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00176	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00179	89 0b		 mov	 DWORD PTR [ebx], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0017b	5e		 pop	 esi

; 1571 :     }

  0017c	5f		 pop	 edi

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0017d	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00180	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00183	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00186	8b 45 f8	 mov	 eax, DWORD PTR tv679[ebp]
  00189	03 c1		 add	 eax, ecx
  0018b	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1571 :     }

  0018e	5b		 pop	 ebx
  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c2 08 00	 ret	 8
$LN79@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00195	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN128@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1539 :             _Xlength();

  0019a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength
$LN129@Resize_rea:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0019f	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN125@Resize_rea:
  001a4	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1098 :         for (; _First != _Last; ++_First) {

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 62		 je	 SHORT $LN46@Destroy_ra
  0000f	57		 push	 edi
$LL4@Destroy_ra:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00010	8b 3e		 mov	 edi, DWORD PTR [esi]
  00012	85 ff		 test	 edi, edi
  00014	74 53		 je	 SHORT $LN17@Destroy_ra

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00019	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001e	2b cf		 sub	 ecx, edi
  00020	f7 e9		 imul	 ecx
  00022	d1 fa		 sar	 edx, 1
  00024	8b c2		 mov	 eax, edx
  00026	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00029	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002b	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0002e	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00031	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00037	72 12		 jb	 SHORT $LN36@Destroy_ra

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00039	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  0003c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0003f	2b fa		 sub	 edi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00041	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00044	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00047	77 2c		 ja	 SHORT $LN33@Destroy_ra

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00049	8b fa		 mov	 edi, edx
$LN36@Destroy_ra:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0004b	51		 push	 ecx
  0004c	57		 push	 edi
  0004d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00052	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00058	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0005b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  00062	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN17@Destroy_ra:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00069	83 c6 0c	 add	 esi, 12			; 0000000cH
  0006c	3b f3		 cmp	 esi, ebx
  0006e	75 a0		 jne	 SHORT $LL4@Destroy_ra
  00070	5f		 pop	 edi
$LN46@Destroy_ra:
  00071	5e		 pop	 esi

; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1100 :         }
; 1101 :     }
; 1102 : }

  00072	5b		 pop	 ebx
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
$LN33@Destroy_ra:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00075	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN54@Destroy_ra:
  0007a	cc		 int	 3
??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CAttributeInstance::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A ; CAttributeInstance::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CAttributeInstance::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CAttributeInstance::ms_kPool'', COMDAT

; 6    : CDynamicPool<CAttributeInstance> CAttributeInstance::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CAttributeInstance::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CAttributeInstance::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();
; 2047 :         auto& _My_data    = _Mypair._Myval2;
; 2048 :         pointer& _Myfirst = _My_data._Myfirst;
; 2049 :         pointer& _Mylast  = _My_data._Mylast;
; 2050 :         pointer& _Myend   = _My_data._Myend;
; 2051 : 
; 2052 :         _My_data._Orphan_all();
; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN10@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000f	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN21@Change_arr

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN18@Change_arr

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN21@Change_arr:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN10@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2060 :         _Myfirst = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 2064 :     }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN18@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
__Size$1$ = 8						; size = 4
?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::reserve, COMDAT
; _this$ = ecx

; 1708 :     _CONSTEXPR20 void reserve(_CRT_GUARDOVERFLOW size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1709 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1710 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	8b 16		 mov	 edx, DWORD PTR [esi]
  0000e	2b c2		 sub	 eax, edx
  00010	c1 f8 02	 sar	 eax, 2

; 1709 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1710 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00013	3b c8		 cmp	 ecx, eax
  00015	0f 86 95 00 00
	00		 jbe	 $LN71@reserve

; 1711 :             if (_Newcapacity > max_size()) {

  0001b	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00021	0f 87 93 00 00
	00		 ja	 $LN97@reserve

; 1634 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00027	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002a	53		 push	 ebx
  0002b	2b c2		 sub	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  0002d	8d 1c 8d 00 00
	00 00		 lea	 ebx, DWORD PTR [ecx*4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1634 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00034	c1 f8 02	 sar	 eax, 2
  00037	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax
  0003a	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  0003b	85 db		 test	 ebx, ebx
  0003d	75 04		 jne	 SHORT $LN20@reserve

; 228  :         return nullptr;

  0003f	33 ff		 xor	 edi, edi
  00041	eb 1a		 jmp	 SHORT $LN19@reserve
$LN20@reserve:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00043	53		 push	 ebx
  00044	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0004a	72 07		 jb	 SHORT $LN21@reserve

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00051	eb 05		 jmp	 SHORT $LN95@reserve
$LN21@reserve:

; 136  :         return ::operator new(_Bytes);

  00053	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN95@reserve:

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  00058	8b f8		 mov	 edi, eax
  0005a	83 c4 04	 add	 esp, 4
$LN19@reserve:
  0005d	57		 push	 edi
  0005e	ff 76 04	 push	 DWORD PTR [esi+4]
  00061	ff 36		 push	 DWORD PTR [esi]
  00063	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00068	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  0006d	85 c0		 test	 eax, eax
  0006f	74 2c		 je	 SHORT $LN47@reserve

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00071	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00074	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00076	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00079	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0007f	72 12		 jb	 SHORT $LN58@reserve

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00081	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00084	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00087	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00089	83 c0 fc	 add	 eax, -4			; fffffffcH
  0008c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0008f	77 24		 ja	 SHORT $LN55@reserve

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00091	8b c2		 mov	 eax, edx
$LN58@reserve:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00093	51		 push	 ecx
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0009a	83 c4 08	 add	 esp, 8
$LN47@reserve:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0009d	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  000a0	89 3e		 mov	 DWORD PTR [esi], edi
  000a2	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  000a5	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  000a8	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  000ab	5f		 pop	 edi
  000ac	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000af	5b		 pop	 ebx
$LN71@reserve:
  000b0	5e		 pop	 esi

; 1713 :             }
; 1714 : 
; 1715 :             _Reallocate<_Reallocation_policy::_At_least>(_Newcapacity);
; 1716 :         }
; 1717 :     }

  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
$LN55@reserve:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN97@reserve:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1712 :                 _Xlength();

  000ba	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
$LN94@reserve:
  000bf	cc		 int	 3
?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -12					; size = 4
tv621 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
$T1 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::push_back, COMDAT
; _this$ = ecx

; 917  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 829  :         if (_Mylast != _My_data._Myend) {

  0000b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00011	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  00014	3b ca		 cmp	 ecx, edx
  00016	74 14		 je	 SHORT $LN4@push_back

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00018	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  0001f	83 46 04 04	 add	 DWORD PTR [esi+4], 4

; 919  :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN4@push_back:

; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0002c	8b 3e		 mov	 edi, DWORD PTR [esi]
  0002e	8b c1		 mov	 eax, ecx
  00030	2b c7		 sub	 eax, edi
  00032	c1 f8 02	 sar	 eax, 2
  00035	89 45 f4	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);
; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  00038	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0003d	0f 84 c0 00 00
	00		 je	 $LN106@push_back

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00043	2b d7		 sub	 edx, edi

; 876  :         const size_type _Newsize = _Oldsize + 1;

  00045	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00048	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004b	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00050	8b fa		 mov	 edi, edx

; 876  :         const size_type _Newsize = _Oldsize + 1;

  00052	89 5d f8	 mov	 DWORD PTR __Newsize$1$[ebp], ebx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00055	d1 ef		 shr	 edi, 1
  00057	2b c7		 sub	 eax, edi
  00059	3b d0		 cmp	 edx, eax
  0005b	76 12		 jbe	 SHORT $LN15@push_back

; 1997 :             return _Max; // geometric growth would overflow

  0005d	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00062	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006d	eb 38		 jmp	 SHORT $LN104@push_back
$LN15@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006f	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00072	3b c3		 cmp	 eax, ebx
  00074	0f 43 d8	 cmovae	 ebx, eax
  00077	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  0007d	0f 87 85 00 00
	00		 ja	 $LN107@push_back

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00083	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]

; 227  :     if (_Bytes == 0) {

  0008a	85 c0		 test	 eax, eax
  0008c	75 04		 jne	 SHORT $LN30@push_back

; 228  :         return nullptr;

  0008e	33 ff		 xor	 edi, edi
  00090	eb 1d		 jmp	 SHORT $LN29@push_back
$LN30@push_back:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00092	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00097	72 08		 jb	 SHORT $LN31@push_back

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009f	eb 06		 jmp	 SHORT $LN104@push_back
$LN31@push_back:

; 136  :         return ::operator new(_Bytes);

  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN104@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  000aa	8b f8		 mov	 edi, eax
  000ac	83 c4 04	 add	 esp, 4
$LN29@push_back:
  000af	8b 45 f4	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  000b2	8d 14 87	 lea	 edx, DWORD PTR [edi+eax*4]
  000b5	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000b8	89 55 f4	 mov	 DWORD PTR tv621[ebp], edx
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	89 02		 mov	 DWORD PTR [edx], eax

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000bf	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c2	8b 16		 mov	 edx, DWORD PTR [esi]
  000c4	3b c8		 cmp	 ecx, eax
  000c6	75 04		 jne	 SHORT $LN10@push_back
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000c8	8b cf		 mov	 ecx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000ca	eb 17		 jmp	 SHORT $LN59@push_back
$LN10@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cc	57		 push	 edi
  000cd	51		 push	 ecx
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000d4	8b 4d f4	 mov	 ecx, DWORD PTR tv621[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000da	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000dd	83 c1 04	 add	 ecx, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000e0	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
$LN59@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 900  :         _Guard._New_begin = nullptr;

  000e3	51		 push	 ecx
  000e4	50		 push	 eax
  000e5	52		 push	 edx
  000e6	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000ee	8b ce		 mov	 ecx, esi
  000f0	53		 push	 ebx
  000f1	ff 75 f8	 push	 DWORD PTR __Newsize$1$[ebp]
  000f4	57		 push	 edi
  000f5	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array

; 919  :     }

  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 04 00	 ret	 4
$LN106@push_back:

; 873  :             _Xlength();

  00103	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
$LN107@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00108	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN103@push_back:
  0010d	cc		 int	 3
?push_back@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ PROC	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCAttributeInstance@@@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN37@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN56@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN56@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 2082 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN37@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN53@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN67@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ENDP	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCAttributeInstance@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCAttributeInstance@@UAEPAXI@Z PROC			; CAttributeInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CAttributeInstance@@UAE@XZ ; CAttributeInstance::~CAttributeInstance
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 5c		 push	 92			; 0000005cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCAttributeInstance@@UAEPAXI@Z ENDP			; CAttributeInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?Delete@CAttributeInstance@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkInst$ = 8						; size = 4
_pkData$ = 8						; size = 4
?Delete@CAttributeInstance@@SAXPAV1@@Z PROC		; CAttributeInstance::Delete, COMDAT

; 194  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 195  : 	ms_kPool.Free(pkInst);

  00003	8b 45 08	 mov	 eax, DWORD PTR _pkInst$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 82   : 			m_kVct_pkFree.push_back(pkData);

  00006	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 195  : 	ms_kPool.Free(pkInst);

  0000b	89 45 08	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 82   : 			m_kVct_pkFree.push_back(pkData);

  0000e	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::push_back
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 196  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?Delete@CAttributeInstance@@SAXPAV1@@Z ENDP		; CAttributeInstance::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?New@CAttributeInstance@@SAPAV1@XZ
_TEXT	SEGMENT
_pkNewData$1 = -4					; size = 4
$T2 = -4						; size = 4
?New@CAttributeInstance@@SAPAV1@XZ PROC			; CAttributeInstance::New, COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00004	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+20
  0000a	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 64   : 			if (m_kVct_pkFree.empty())

  00010	75 3a		 jne	 SHORT $LN4@New

; 65   : 			{
; 66   : 				T* pkNewData=new T;

  00012	6a 5c		 push	 92			; 0000005cH
  00014	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  0001f	85 c0		 test	 eax, eax
  00021	74 09		 je	 SHORT $LN6@New
  00023	8b c8		 mov	 ecx, eax
  00025	e8 00 00 00 00	 call	 ??0CAttributeInstance@@QAE@XZ ; CAttributeInstance::CAttributeInstance
  0002a	eb 02		 jmp	 SHORT $LN7@New
$LN6@New:
  0002c	33 c0		 xor	 eax, eax
$LN7@New:
  0002e	89 45 fc	 mov	 DWORD PTR _pkNewData$1[ebp], eax

; 67   : 				m_kVct_pkData.push_back(pkNewData);

  00031	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+4
  00036	8d 45 fc	 lea	 eax, DWORD PTR _pkNewData$1[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::push_back

; 68   : 				++m_uUsedCapacity;

  0003f	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+32
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 190  : 	return ms_kPool.Alloc();

  00045	8b 45 fc	 mov	 eax, DWORD PTR _pkNewData$1[ebp]

; 191  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN4@New:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 72   : 			T* pkFreeData=m_kVct_pkFree.back();

  0004c	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1744 :         --_Mylast;

  0004f	83 c1 fc	 add	 ecx, -4			; fffffffcH
  00052	89 0d 14 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+20, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 191  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?New@CAttributeInstance@@SAPAV1@XZ ENDP			; CAttributeInstance::New
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?DestroySystem@CAttributeInstance@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CAttributeInstance@@SAXXZ PROC		; CAttributeInstance::DestroySystem, COMDAT

; 184  : {

  00000	56		 push	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  00001	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+4
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 184  : {

  00007	57		 push	 edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  00008	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+8
  0000e	3b f7		 cmp	 esi, edi
  00010	74 29		 je	 SHORT $LN12@DestroySys
$LL6@DestroySys:

; 111  : 			delete pkData;

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	85 c9		 test	 ecx, ecx
  00016	74 06		 je	 SHORT $LN4@DestroySys
  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	6a 01		 push	 1
  0001c	ff 10		 call	 DWORD PTR [eax]
$LN4@DestroySys:

; 50   : 			for (auto v : m_kVct_pkData)

  0001e	83 c6 04	 add	 esi, 4
  00021	3b f7		 cmp	 esi, edi
  00023	75 ed		 jne	 SHORT $LL6@DestroySys
  00025	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+8
  0002b	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	3b f7		 cmp	 esi, edi
  00033	74 06		 je	 SHORT $LN12@DestroySys

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00035	89 35 08 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+8, esi
$LN12@DestroySys:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0003b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+20
  00048	74 05		 je	 SHORT $LN16@DestroySys

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0004a	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+20, eax
$LN16@DestroySys:
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 186  : }

  0004f	c3		 ret	 0
?DestroySystem@CAttributeInstance@@SAXXZ ENDP		; CAttributeInstance::DestroySystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?CreateSystem@CAttributeInstance@@SAXI@Z
_TEXT	SEGMENT
_uCapacity$ = 8						; size = 4
?CreateSystem@CAttributeInstance@@SAXI@Z PROC		; CAttributeInstance::CreateSystem, COMDAT

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 58   : 			m_uInitCapacity=uCapacity;

  00004	8b 75 08	 mov	 esi, DWORD PTR _uCapacity$[ebp]

; 59   : 			m_kVct_pkData.reserve(uCapacity);

  00007	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+4
  0000c	56		 push	 esi
  0000d	89 35 1c 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+28, esi
  00013	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::reserve

; 60   : 			m_kVct_pkFree.reserve(uCapacity);

  00018	56		 push	 esi
  00019	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CAttributeInstance@@2V?$CDynamicPool@VCAttributeInstance@@@@A+16
  0001e	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXI@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::reserve
  00023	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 181  : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?CreateSystem@CAttributeInstance@@SAXI@Z ENDP		; CAttributeInstance::CreateSystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::~vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 64		 je	 SHORT $LN5@vector
  00009	57		 push	 edi

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000a	56		 push	 esi
  0000b	ff 76 04	 push	 DWORD PTR [esi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001c	8b 3e		 mov	 edi, DWORD PTR [esi]
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	2b cf		 sub	 ecx, edi
  00023	f7 e9		 imul	 ecx
  00025	d1 fa		 sar	 edx, 1
  00027	8b c2		 mov	 eax, edx
  00029	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002c	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002e	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00031	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00034	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003a	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003c	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  0003f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00042	2b fa		 sub	 edi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00044	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00047	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004a	77 23		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004c	8b fa		 mov	 edi, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0004e	51		 push	 ecx
  0004f	57		 push	 edi
  00050	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00055	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00058	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 2081 :             _Mylast  = nullptr;

  0005e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  00065	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0006c	5f		 pop	 edi
$LN5@vector:
  0006d	5e		 pop	 esi

; 820  :     }

  0006e	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0006f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00074	cc		 int	 3
??1?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::~vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?GetHeight@CAttributeInstance@@QAEHMMPAM@Z
_TEXT	SEGMENT
_pfHeight$GSCopy$1$ = -40				; size = 4
_bFlag$1$ = -36						; size = 4
_this$GSCopy$1$ = -32					; size = 4
_i$1$ = -28						; size = 4
_j$1$ = -24						; size = 4
tv903 = -20						; size = 4
_v3Cross$1 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_pfHeight$ = 16						; size = 4
?GetHeight@CAttributeInstance@@QAEHMMPAM@Z PROC		; CAttributeInstance::GetHeight, COMDAT
; _this$ = ecx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR _pfHeight$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx
  00016	89 45 d8	 mov	 DWORD PTR _pfHeight$GSCopy$1$[ebp], eax
  00019	89 75 e0	 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi

; 75   : 	if(IsEmpty())

  0001c	e8 00 00 00 00	 call	 ?IsEmpty@CAttributeInstance@@QBEHXZ ; CAttributeInstance::IsEmpty
  00021	85 c0		 test	 eax, eax
  00023	0f 85 f6 02 00
	00		 jne	 $LN63@GetHeight

; 76   : 		return FALSE;
; 77   : 
; 78   : 	fy *= -1.0f;

  00029	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]

; 79   : 
; 80   : 	if (!IsInHeight(fx, fy))

  0002e	83 ec 08	 sub	 esp, 8
  00031	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@bf800000
  00039	8b ce		 mov	 ecx, esi
  0003b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00041	f3 0f 11 45 0c	 movss	 DWORD PTR _fy$[ebp], xmm0
  00046	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0004b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00050	e8 00 00 00 00	 call	 ?IsInHeight@CAttributeInstance@@QAEHMM@Z ; CAttributeInstance::IsInHeight
  00055	85 c0		 test	 eax, eax
  00057	0f 84 c2 02 00
	00		 je	 $LN63@GetHeight
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0005d	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 85   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00060	33 c0		 xor	 eax, eax
  00062	89 45 e4	 mov	 DWORD PTR _i$1$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00065	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0006a	53		 push	 ebx
  0006b	8b 5e 4c	 mov	 ebx, DWORD PTR [esi+76]
  0006e	2b cb		 sub	 ecx, ebx
  00070	f7 e9		 imul	 ecx
  00072	57		 push	 edi
  00073	d1 fa		 sar	 edx, 1
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 83   : 	BOOL bFlag = FALSE;

  00075	33 ff		 xor	 edi, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00077	8b c2		 mov	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 83   : 	BOOL bFlag = FALSE;

  00079	89 7d dc	 mov	 DWORD PTR _bFlag$1$[ebp], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0007c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0007f	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 85   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00081	0f 84 83 02 00
	00		 je	 $LN3@GetHeight
  00087	33 f6		 xor	 esi, esi
  00089	89 75 ec	 mov	 DWORD PTR tv903[ebp], esi
  0008c	0f 1f 40 00	 npad	 4
$LL4@GetHeight:

; 86   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  00090	33 c9		 xor	 ecx, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00092	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 86   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  00097	89 4d e8	 mov	 DWORD PTR _j$1$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0009a	8b fb		 mov	 edi, ebx
  0009c	8b 4c 33 04	 mov	 ecx, DWORD PTR [ebx+esi+4]
  000a0	2b 0c 33	 sub	 ecx, DWORD PTR [ebx+esi]
  000a3	f7 e9		 imul	 ecx
  000a5	d1 fa		 sar	 edx, 1
  000a7	8b c2		 mov	 eax, edx
  000a9	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ac	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 86   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  000ae	0f 84 27 02 00
	00		 je	 $LN2@GetHeight
  000b4	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fx$[ebp]
  000b9	33 f6		 xor	 esi, esi
  000bb	0f 1f 44 00 00	 npad	 5
$LL7@GetHeight:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  000c0	8b 7d ec	 mov	 edi, DWORD PTR tv903[ebp]
  000c3	8b 3c 3b	 mov	 edi, DWORD PTR [ebx+edi]
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 95   : 			fy<c_rv3Vertex0.y && fy<c_rv3Vertex1.y && fy<c_rv3Vertex2.y ||

  000c6	f3 0f 10 24 37	 movss	 xmm4, DWORD PTR [edi+esi]
  000cb	0f 2f e1	 comiss	 xmm4, xmm1
  000ce	76 1a		 jbe	 SHORT $LN12@GetHeight
  000d0	f3 0f 10 44 37
	0c		 movss	 xmm0, DWORD PTR [edi+esi+12]
  000d6	0f 2f c1	 comiss	 xmm0, xmm1
  000d9	76 0f		 jbe	 SHORT $LN12@GetHeight
  000db	f3 0f 10 44 37
	18		 movss	 xmm0, DWORD PTR [edi+esi+24]
  000e1	0f 2f c1	 comiss	 xmm0, xmm1
  000e4	0f 87 bc 01 00
	00		 ja	 $LN5@GetHeight
$LN12@GetHeight:
  000ea	0f 2f cc	 comiss	 xmm1, xmm4
  000ed	76 12		 jbe	 SHORT $LN13@GetHeight
  000ef	0f 2f 4c 37 0c	 comiss	 xmm1, DWORD PTR [edi+esi+12]
  000f4	76 0b		 jbe	 SHORT $LN13@GetHeight
  000f6	0f 2f 4c 37 18	 comiss	 xmm1, DWORD PTR [edi+esi+24]
  000fb	0f 87 a5 01 00
	00		 ja	 $LN5@GetHeight
$LN13@GetHeight:
  00101	f3 0f 10 5c 37
	04		 movss	 xmm3, DWORD PTR [edi+esi+4]
  00107	f3 0f 10 55 0c	 movss	 xmm2, DWORD PTR _fy$[ebp]
  0010c	0f 2f da	 comiss	 xmm3, xmm2
  0010f	76 1a		 jbe	 SHORT $LN14@GetHeight
  00111	f3 0f 10 44 37
	10		 movss	 xmm0, DWORD PTR [edi+esi+16]
  00117	0f 2f c2	 comiss	 xmm0, xmm2
  0011a	76 0f		 jbe	 SHORT $LN14@GetHeight
  0011c	f3 0f 10 44 37
	1c		 movss	 xmm0, DWORD PTR [edi+esi+28]
  00122	0f 2f c2	 comiss	 xmm0, xmm2
  00125	0f 87 7b 01 00
	00		 ja	 $LN5@GetHeight
$LN14@GetHeight:
  0012b	0f 2f d3	 comiss	 xmm2, xmm3
  0012e	76 12		 jbe	 SHORT $LN10@GetHeight
  00130	0f 2f 54 37 10	 comiss	 xmm2, DWORD PTR [edi+esi+16]
  00135	76 0b		 jbe	 SHORT $LN10@GetHeight
  00137	0f 2f 54 37 1c	 comiss	 xmm2, DWORD PTR [edi+esi+28]
  0013c	0f 87 64 01 00
	00		 ja	 $LN5@GetHeight
$LN10@GetHeight:

; 96   : 			fy>c_rv3Vertex0.y && fy>c_rv3Vertex1.y && fy>c_rv3Vertex2.y
; 97   : 			)
; 98   : 			continue;
; 99   : 
; 100  : 		if (IsInTriangle2D(c_rv3Vertex0.x, c_rv3Vertex0.y,

  00142	f3 0f 10 44 37
	1c		 movss	 xmm0, DWORD PTR [edi+esi+28]
  00148	83 ec 20	 sub	 esp, 32			; 00000020H
  0014b	f3 0f 11 54 24
	1c		 movss	 DWORD PTR [esp+28], xmm2
  00151	f3 0f 11 4c 24
	18		 movss	 DWORD PTR [esp+24], xmm1
  00157	f3 0f 11 44 24
	14		 movss	 DWORD PTR [esp+20], xmm0
  0015d	f3 0f 10 44 37
	18		 movss	 xmm0, DWORD PTR [edi+esi+24]
  00163	f3 0f 11 44 24
	10		 movss	 DWORD PTR [esp+16], xmm0
  00169	f3 0f 10 44 37
	10		 movss	 xmm0, DWORD PTR [edi+esi+16]
  0016f	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00175	f3 0f 10 44 37
	0c		 movss	 xmm0, DWORD PTR [edi+esi+12]
  0017b	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00181	f3 0f 11 5c 24
	04		 movss	 DWORD PTR [esp+4], xmm3
  00187	f3 0f 11 24 24	 movss	 DWORD PTR [esp], xmm4
  0018c	e8 00 00 00 00	 call	 ?IsInTriangle2D@@YA_NMMMMMMMM@Z ; IsInTriangle2D
  00191	83 c4 20	 add	 esp, 32			; 00000020H
  00194	84 c0		 test	 al, al
  00196	0f 84 05 01 00
	00		 je	 $LN66@GetHeight
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0019c	f3 0f 10 64 37
	1c		 movss	 xmm4, DWORD PTR [edi+esi+28]
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 109  : 			D3DXVec3Normalize(&v3Cross, &v3Cross);

  001a2	8d 45 f0	 lea	 eax, DWORD PTR _v3Cross$1[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001a5	f3 0f 10 54 37
	20		 movss	 xmm2, DWORD PTR [edi+esi+32]
  001ab	f3 0f 5c 64 37
	04		 subss	 xmm4, DWORD PTR [edi+esi+4]
  001b1	f3 0f 5c 54 37
	08		 subss	 xmm2, DWORD PTR [edi+esi+8]
  001b7	f3 0f 10 74 37
	10		 movss	 xmm6, DWORD PTR [edi+esi+16]
  001bd	f3 0f 10 5c 37
	14		 movss	 xmm3, DWORD PTR [edi+esi+20]
  001c3	f3 0f 5c 74 37
	04		 subss	 xmm6, DWORD PTR [edi+esi+4]
  001c9	f3 0f 5c 5c 37
	08		 subss	 xmm3, DWORD PTR [edi+esi+8]
  001cf	f3 0f 10 6c 37
	18		 movss	 xmm5, DWORD PTR [edi+esi+24]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  001d5	0f 28 c4	 movaps	 xmm0, xmm4

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001d8	f3 0f 5c 2c 37	 subss	 xmm5, DWORD PTR [edi+esi]
  001dd	f3 0f 10 7c 37
	0c		 movss	 xmm7, DWORD PTR [edi+esi+12]

; 182  :     z = fz;

  001e3	0f 28 ca	 movaps	 xmm1, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001e6	f3 0f 5c 3c 37	 subss	 xmm7, DWORD PTR [edi+esi]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  001eb	f3 0f 59 c3	 mulss	 xmm0, xmm3
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 109  : 			D3DXVec3Normalize(&v3Cross, &v3Cross);

  001ef	50		 push	 eax
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  001f0	f3 0f 59 ce	 mulss	 xmm1, xmm6
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 109  : 			D3DXVec3Normalize(&v3Cross, &v3Cross);

  001f4	50		 push	 eax
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  001f5	f3 0f 59 d7	 mulss	 xmm2, xmm7
  001f9	f3 0f 5c c8	 subss	 xmm1, xmm0
  001fd	f3 0f 59 e7	 mulss	 xmm4, xmm7
  00201	0f 28 c5	 movaps	 xmm0, xmm5

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00204	f3 0f 59 ee	 mulss	 xmm5, xmm6
  00208	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0020c	f3 0f 5c e5	 subss	 xmm4, xmm5

; 1280 : 
; 1281 :     *pOut = v;

  00210	f3 0f 11 4d f0	 movss	 DWORD PTR _v3Cross$1[ebp], xmm1
  00215	f3 0f 5c c2	 subss	 xmm0, xmm2
  00219	f3 0f 11 65 f8	 movss	 DWORD PTR _v3Cross$1[ebp+8], xmm4
  0021e	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Cross$1[ebp+4], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 109  : 			D3DXVec3Normalize(&v3Cross, &v3Cross);

  00223	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 110  : 
; 111  : 			if (0.0f != v3Cross.z)

  00228	f3 0f 10 65 f8	 movss	 xmm4, DWORD PTR _v3Cross$1[ebp+8]
  0022d	0f 57 c0	 xorps	 xmm0, xmm0
  00230	0f 2e c4	 ucomiss xmm0, xmm4
  00233	9f		 lahf
  00234	f6 c4 44	 test	 ah, 68			; 00000044H
  00237	7b 68		 jnp	 SHORT $LN66@GetHeight

; 112  : 			{
; 113  : 				float fd = (v3Cross.x*c_rv3Vertex0.x + v3Cross.y*c_rv3Vertex0.y + v3Cross.z*c_rv3Vertex0.z);

  00239	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _v3Cross$1[ebp]

; 114  : 				float fm = (v3Cross.x*fx + v3Cross.y*fy);
; 115  : 				*pfHeight = fMAX((fd - fm) / v3Cross.z, *pfHeight);

  0023e	83 ec 08	 sub	 esp, 8
  00241	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _v3Cross$1[ebp+4]
  00246	0f 28 da	 movaps	 xmm3, xmm2
  00249	f3 0f 59 1c 37	 mulss	 xmm3, DWORD PTR [edi+esi]
  0024e	0f 28 c1	 movaps	 xmm0, xmm1
  00251	8b 5d d8	 mov	 ebx, DWORD PTR _pfHeight$GSCopy$1$[ebp]
  00254	f3 0f 59 44 37
	04		 mulss	 xmm0, DWORD PTR [edi+esi+4]
  0025a	f3 0f 59 55 08	 mulss	 xmm2, DWORD PTR _fx$[ebp]
  0025f	f3 0f 59 4d 0c	 mulss	 xmm1, DWORD PTR _fy$[ebp]
  00264	f3 0f 58 d8	 addss	 xmm3, xmm0
  00268	0f 28 c4	 movaps	 xmm0, xmm4
  0026b	f3 0f 59 44 37
	08		 mulss	 xmm0, DWORD PTR [edi+esi+8]
  00271	f3 0f 58 d1	 addss	 xmm2, xmm1
  00275	f3 0f 58 d8	 addss	 xmm3, xmm0
  00279	f3 0f 10 03	 movss	 xmm0, DWORD PTR [ebx]
  0027d	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00283	f3 0f 5c da	 subss	 xmm3, xmm2
  00287	f3 0f 5e dc	 divss	 xmm3, xmm4
  0028b	f3 0f 11 1c 24	 movss	 DWORD PTR [esp], xmm3
  00290	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  00295	d9 1b		 fstp	 DWORD PTR [ebx]
  00297	83 c4 08	 add	 esp, 8

; 116  : 
; 117  : 				bFlag = TRUE;

  0029a	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _bFlag$1$[ebp], 1
$LN66@GetHeight:

; 86   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  002a1	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fx$[ebp]
$LN5@GetHeight:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  002a6	8b 45 e0	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 86   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  002a9	83 c6 24	 add	 esi, 36			; 00000024H
  002ac	83 45 e8 03	 add	 DWORD PTR _j$1$[ebp], 3
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  002b0	8b 78 4c	 mov	 edi, DWORD PTR [eax+76]

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  002b3	8b df		 mov	 ebx, edi
  002b5	8b 45 ec	 mov	 eax, DWORD PTR tv903[ebp]
  002b8	8b 4c 07 04	 mov	 ecx, DWORD PTR [edi+eax+4]
  002bc	2b 0c 07	 sub	 ecx, DWORD PTR [edi+eax]
  002bf	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  002c4	f7 e9		 imul	 ecx
  002c6	d1 fa		 sar	 edx, 1
  002c8	8b c2		 mov	 eax, edx
  002ca	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002cd	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 86   : 	for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j+=3)

  002cf	39 45 e8	 cmp	 DWORD PTR _j$1$[ebp], eax
  002d2	0f 82 e8 fd ff
	ff		 jb	 $LL7@GetHeight
  002d8	8b 75 ec	 mov	 esi, DWORD PTR tv903[ebp]
$LN2@GetHeight:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  002db	8b 45 e0	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 85   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  002de	83 c6 0c	 add	 esi, 12			; 0000000cH
  002e1	ff 45 e4	 inc	 DWORD PTR _i$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  002e4	8b df		 mov	 ebx, edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 85   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  002e6	89 75 ec	 mov	 DWORD PTR tv903[ebp], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  002e9	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  002ec	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  002f1	2b cf		 sub	 ecx, edi
  002f3	f7 e9		 imul	 ecx
  002f5	d1 fa		 sar	 edx, 1
  002f7	8b ca		 mov	 ecx, edx
  002f9	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  002fc	03 ca		 add	 ecx, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 85   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  002fe	39 4d e4	 cmp	 DWORD PTR _i$1$[ebp], ecx
  00301	0f 82 89 fd ff
	ff		 jb	 $LL4@GetHeight
  00307	8b 7d dc	 mov	 edi, DWORD PTR _bFlag$1$[ebp]
$LN3@GetHeight:

; 118  : 			}
; 119  : 		}
; 120  : 	}
; 121  : 
; 122  : 	return bFlag;

  0030a	8b c7		 mov	 eax, edi
  0030c	5f		 pop	 edi
  0030d	5b		 pop	 ebx
  0030e	5e		 pop	 esi

; 123  : }

  0030f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00312	33 cd		 xor	 ecx, ebp
  00314	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00319	8b e5		 mov	 esp, ebp
  0031b	5d		 pop	 ebp
  0031c	c2 0c 00	 ret	 12			; 0000000cH
$LN63@GetHeight:
  0031f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00322	33 c0		 xor	 eax, eax
  00324	33 cd		 xor	 ecx, ebp
  00326	5e		 pop	 esi
  00327	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0032c	8b e5		 mov	 esp, ebp
  0032e	5d		 pop	 ebp
  0032f	c2 0c 00	 ret	 12			; 0000000cH
?GetHeight@CAttributeInstance@@QAEHMMPAM@Z ENDP		; CAttributeInstance::GetHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?IsInHeight@CAttributeInstance@@QAEHMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
?IsInHeight@CAttributeInstance@@QAEHMM@Z PROC		; CAttributeInstance::IsInHeight, COMDAT
; _this$ = ecx

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	51		 push	 ecx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx

; 131  : 	float fdx = m_matGlobal._41 - fx;

  0000a	f3 0f 10 4e 3c	 movss	 xmm1, DWORD PTR [esi+60]

; 132  : 	float fdy = m_matGlobal._42 - fy;

  0000f	f3 0f 10 46 40	 movss	 xmm0, DWORD PTR [esi+64]
  00014	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _fy$[ebp]
  00019	f3 0f 5c 4d 08	 subss	 xmm1, DWORD PTR _fx$[ebp]

; 133  : 	if (sqrtf(fdx*fdx + fdy*fdy) > m_fHeightRadius)

  0001e	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00022	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00026	f3 0f 58 c1	 addss	 xmm0, xmm1
  0002a	0f 57 c9	 xorps	 xmm1, xmm1
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 808  :             return (float)sqrt(_X);

  0002d	0f 5a c0	 cvtps2pd xmm0, xmm0
  00030	66 0f 2e c8	 ucomisd xmm1, xmm0
  00034	77 18		 ja	 SHORT $LN6@IsInHeight
  00036	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 133  : 	if (sqrtf(fdx*fdx + fdy*fdy) > m_fHeightRadius)

  0003a	33 c0		 xor	 eax, eax
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 808  :             return (float)sqrt(_X);

  0003c	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 133  : 	if (sqrtf(fdx*fdx + fdy*fdy) > m_fHeightRadius)

  00040	0f 2f 46 08	 comiss	 xmm0, DWORD PTR [esi+8]
  00044	0f 96 c0	 setbe	 al

; 134  : 		return FALSE;
; 135  : 
; 136  : 	return TRUE;
; 137  : }

  00047	5e		 pop	 esi
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN6@IsInHeight:
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 808  :             return (float)sqrt(_X);

  0004e	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
  00053	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 133  : 	if (sqrtf(fdx*fdx + fdy*fdy) > m_fHeightRadius)

  00057	33 c0		 xor	 eax, eax
  00059	0f 2f 46 08	 comiss	 xmm0, DWORD PTR [esi+8]

; 134  : 		return FALSE;
; 135  : 
; 136  : 	return TRUE;
; 137  : }

  0005d	5e		 pop	 esi
  0005e	0f 96 c0	 setbe	 al
  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c2 08 00	 ret	 8
?IsInHeight@CAttributeInstance@@QAEHMM@Z ENDP		; CAttributeInstance::IsInHeight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z
_TEXT	SEGMENT
tv2997 = -108						; size = 4
tv2977 = -104						; size = 4
tv2931 = -100						; size = 4
tv2975 = -96						; size = 4
tv2933 = -92						; size = 4
tv2973 = -88						; size = 4
tv2934 = -84						; size = 4
tv2924 = -80						; size = 4
tv2922 = -76						; size = 4
tv2995 = -72						; size = 4
tv2923 = -68						; size = 4
tv2916 = -64						; size = 4
tv2914 = -60						; size = 4
tv3020 = -56						; size = 4
tv2987 = -52						; size = 4
tv2996 = -48						; size = 4
tv2994 = -44						; size = 4
tv2984 = -40						; size = 4
tv2917 = -36						; size = 4
tv2986 = -32						; size = 4
_ny$1$ = -28						; size = 4
_nx$1$ = -24						; size = 4
tv2998 = -20						; size = 4
tv2993 = -16						; size = 4
tv2982 = -12						; size = 4
tv2985 = -8						; size = 4
_bPicked$1$ = -1					; size = 1
_v$ = 8							; size = 4
_dir$ = 12						; size = 4
_out_x$ = 16						; size = 4
_out_y$ = 20						; size = 4
?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z PROC ; CAttributeInstance::Picking, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx

; 12   : 	if (IsEmpty())

  00009	e8 00 00 00 00	 call	 ?IsEmpty@CAttributeInstance@@QBEHXZ ; CAttributeInstance::IsEmpty
  0000e	85 c0		 test	 eax, eax
  00010	74 09		 je	 SHORT $LN8@Picking

; 13   : 		return FALSE;

  00012	32 c0		 xor	 al, al
  00014	5e		 pop	 esi

; 71   : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c2 10 00	 ret	 16			; 00000010H
$LN8@Picking:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0001b	8b 4e 50	 mov	 ecx, DWORD PTR [esi+80]
  0001e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00023	57		 push	 edi
  00024	8b 7e 4c	 mov	 edi, DWORD PTR [esi+76]
  00027	0f 57 c0	 xorps	 xmm0, xmm0
  0002a	2b cf		 sub	 ecx, edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 16   : 	bool bPicked = false;

  0002c	c6 45 ff 00	 mov	 BYTE PTR _bPicked$1$[ebp], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00030	f7 e9		 imul	 ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 17   : 	float nx = 0;

  00032	f3 0f 11 45 e8	 movss	 DWORD PTR _nx$1$[ebp], xmm0

; 18   : 	float ny = 0;

  00037	f3 0f 11 45 e4	 movss	 DWORD PTR _ny$1$[ebp], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0003c	d1 fa		 sar	 edx, 1
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00043	03 c2		 add	 eax, edx
  00045	89 45 c8	 mov	 DWORD PTR tv3020[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 20   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00048	0f 84 07 04 00
	00		 je	 $LN110@Picking
  0004e	66 90		 npad	 2
$LL4@Picking:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00050	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00053	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00058	8b 37		 mov	 esi, DWORD PTR [edi]
  0005a	2b ce		 sub	 ecx, esi
  0005c	f7 e9		 imul	 ecx
  0005e	d1 fa		 sar	 edx, 1
  00060	8b ca		 mov	 ecx, edx
  00062	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00065	03 ca		 add	 ecx, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 21   : 		for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j += 3)

  00067	0f 84 b4 03 00
	00		 je	 $LN2@Picking
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0006d	49		 dec	 ecx
  0006e	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  00073	f7 e1		 mul	 ecx
  00075	8b 4d 08	 mov	 ecx, DWORD PTR _v$[ebp]
  00078	83 c6 20	 add	 esi, 32			; 00000020H
  0007b	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  0007e	d1 ea		 shr	 edx, 1
  00080	42		 inc	 edx
$LL7@Picking:
  00081	f3 0f 10 56 ec	 movss	 xmm2, DWORD PTR [esi-20]
  00086	f3 0f 10 4e e0	 movss	 xmm1, DWORD PTR [esi-32]
  0008b	f3 0f 10 46 f8	 movss	 xmm0, DWORD PTR [esi-8]
  00090	f3 0f 5c c1	 subss	 xmm0, xmm1
  00094	f3 0f 10 76 fc	 movss	 xmm6, DWORD PTR [esi-4]
  00099	f3 0f 10 2e	 movss	 xmm5, DWORD PTR [esi]
  0009d	0f 28 e6	 movaps	 xmm4, xmm6
  000a0	f3 0f 11 4d ac	 movss	 DWORD PTR tv2934[ebp], xmm1
  000a5	0f 28 dd	 movaps	 xmm3, xmm5
  000a8	f3 0f 11 55 a8	 movss	 DWORD PTR tv2973[ebp], xmm2
  000ad	f3 0f 5c d1	 subss	 xmm2, xmm1
  000b1	f3 0f 10 4e f0	 movss	 xmm1, DWORD PTR [esi-16]
  000b6	f3 0f 11 45 dc	 movss	 DWORD PTR tv2917[ebp], xmm0
  000bb	f3 0f 10 46 e4	 movss	 xmm0, DWORD PTR [esi-28]
  000c0	f3 0f 5c e0	 subss	 xmm4, xmm0
  000c4	f3 0f 11 45 a4	 movss	 DWORD PTR tv2933[ebp], xmm0
  000c9	f3 0f 10 46 e8	 movss	 xmm0, DWORD PTR [esi-24]
  000ce	f3 0f 5c d8	 subss	 xmm3, xmm0
  000d2	f3 0f 11 4d a0	 movss	 DWORD PTR tv2975[ebp], xmm1
  000d7	f3 0f 5c 4e e4	 subss	 xmm1, DWORD PTR [esi-28]
  000dc	f3 0f 11 45 9c	 movss	 DWORD PTR tv2931[ebp], xmm0
  000e1	f3 0f 11 65 c0	 movss	 DWORD PTR tv2916[ebp], xmm4
  000e6	f3 0f 11 5d c4	 movss	 DWORD PTR tv2914[ebp], xmm3
  000eb	f3 0f 11 4d f8	 movss	 DWORD PTR tv2985[ebp], xmm1
  000f0	f3 0f 10 4e f4	 movss	 xmm1, DWORD PTR [esi-12]
  000f5	f3 0f 11 4d 98	 movss	 DWORD PTR tv2977[ebp], xmm1
  000fa	f3 0f 5c c8	 subss	 xmm1, xmm0
  000fe	f3 0f 10 46 ec	 movss	 xmm0, DWORD PTR [esi-20]
  00103	f3 0f 5c 46 f8	 subss	 xmm0, DWORD PTR [esi-8]
  00108	f3 0f 11 45 b0	 movss	 DWORD PTR tv2924[ebp], xmm0
  0010d	f3 0f 10 46 f0	 movss	 xmm0, DWORD PTR [esi-16]
  00112	f3 0f 5c c6	 subss	 xmm0, xmm6
  00116	f3 0f 11 45 bc	 movss	 DWORD PTR tv2923[ebp], xmm0
  0011b	f3 0f 10 46 f4	 movss	 xmm0, DWORD PTR [esi-12]
  00120	f3 0f 5c c5	 subss	 xmm0, xmm5
  00124	f3 0f 11 45 b4	 movss	 DWORD PTR tv2922[ebp], xmm0

; 182  :     z = fz;

  00129	0f 28 c1	 movaps	 xmm0, xmm1

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0012c	f3 0f 59 4d dc	 mulss	 xmm1, DWORD PTR tv2917[ebp]

; 182  :     z = fz;

  00131	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00135	f3 0f 11 45 f4	 movss	 DWORD PTR tv2982[ebp], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0013a	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv2985[ebp]
  0013f	f3 0f 10 7d f4	 movss	 xmm7, DWORD PTR tv2982[ebp]
  00144	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00148	f3 0f 5c f8	 subss	 xmm7, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0014c	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00151	f3 0f 5c 46 e4	 subss	 xmm0, DWORD PTR [esi-28]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00156	f3 0f 11 7d f4	 movss	 DWORD PTR tv2982[ebp], xmm7
  0015b	0f 28 fa	 movaps	 xmm7, xmm2
  0015e	f3 0f 59 fb	 mulss	 xmm7, xmm3

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00162	f3 0f 59 d4	 mulss	 xmm2, xmm4
  00166	f3 0f 5c f9	 subss	 xmm7, xmm1
  0016a	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR tv2985[ebp]
  0016f	f3 0f 59 4d dc	 mulss	 xmm1, DWORD PTR tv2917[ebp]
  00174	f3 0f 5c ca	 subss	 xmm1, xmm2

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00178	f3 0f 59 c7	 mulss	 xmm0, xmm7

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0017c	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  00180	f3 0f 5c 56 e0	 subss	 xmm2, DWORD PTR [esi-32]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00185	f3 0f 11 7d d8	 movss	 DWORD PTR tv2984[ebp], xmm7

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0018a	f3 0f 11 4d f8	 movss	 DWORD PTR tv2985[ebp], xmm1

; 182  :     z = fz;

  0018f	f3 0f 59 55 f4	 mulss	 xmm2, DWORD PTR tv2982[ebp]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00194	f3 0f 58 d0	 addss	 xmm2, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00198	f3 0f 10 41 08	 movss	 xmm0, DWORD PTR [ecx+8]
  0019d	f3 0f 5c 46 e8	 subss	 xmm0, DWORD PTR [esi-24]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001a2	f3 0f 59 c1	 mulss	 xmm0, xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 35   : 			t = -D3DXVec3Dot(&_vv, &n) / D3DXVec3Dot(&dir, &n);

  001a6	0f 28 cf	 movaps	 xmm1, xmm7
  001a9	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001ae	f3 0f 58 d0	 addss	 xmm2, xmm0
  001b2	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR tv2982[ebp]
  001b7	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 35   : 			t = -D3DXVec3Dot(&_vv, &n) / D3DXVec3Dot(&dir, &n);

  001bb	0f 57 15 00 00
	00 00		 xorps	 xmm2, DWORD PTR __xmm@80000000800000008000000080000000
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  001c2	f3 0f 58 c8	 addss	 xmm1, xmm0
  001c6	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv2985[ebp]
  001cb	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  001d0	f3 0f 58 c8	 addss	 xmm1, xmm0

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001d4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 35   : 			t = -D3DXVec3Dot(&_vv, &n) / D3DXVec3Dot(&dir, &n);

  001d8	f3 0f 5e d1	 divss	 xmm2, xmm1
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001dc	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  001e1	f3 0f 59 c2	 mulss	 xmm0, xmm2
  001e5	f3 0f 59 ca	 mulss	 xmm1, xmm2

; 182  :     z = fz;

  001e9	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  001ed	f3 0f 11 45 e0	 movss	 DWORD PTR tv2986[ebp], xmm0

; 180  :     x = fx;

  001f2	f3 0f 58 49 04	 addss	 xmm1, DWORD PTR [ecx+4]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  001f7	f3 0f 10 78 08	 movss	 xmm7, DWORD PTR [eax+8]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001fc	0f 28 e0	 movaps	 xmm4, xmm0
  001ff	f3 0f 11 45 f0	 movss	 DWORD PTR tv2993[ebp], xmm0
  00204	f3 0f 5c 46 f8	 subss	 xmm0, DWORD PTR [esi-8]

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00209	f3 0f 59 fa	 mulss	 xmm7, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0020d	f3 0f 5c 66 e0	 subss	 xmm4, DWORD PTR [esi-32]
  00212	0f 28 d9	 movaps	 xmm3, xmm1

; 180  :     x = fx;

  00215	f3 0f 11 4d cc	 movss	 DWORD PTR tv2987[ebp], xmm1

; 181  :     y = fy;

  0021a	f3 0f 58 79 08	 addss	 xmm7, DWORD PTR [ecx+8]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0021f	f3 0f 11 45 f0	 movss	 DWORD PTR tv2993[ebp], xmm0
  00224	0f 28 c1	 movaps	 xmm0, xmm1
  00227	f3 0f 5c c6	 subss	 xmm0, xmm6
  0022b	f3 0f 5c 5e e4	 subss	 xmm3, DWORD PTR [esi-28]
  00230	0f 28 f7	 movaps	 xmm6, xmm7

; 181  :     y = fy;

  00233	f3 0f 11 7d ec	 movss	 DWORD PTR tv2998[ebp], xmm7

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00238	0f 28 d7	 movaps	 xmm2, xmm7

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0023b	f3 0f 10 7d dc	 movss	 xmm7, DWORD PTR tv2917[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00240	f3 0f 11 45 d4	 movss	 DWORD PTR tv2994[ebp], xmm0
  00245	0f 28 c6	 movaps	 xmm0, xmm6
  00248	f3 0f 5c c5	 subss	 xmm0, xmm5

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0024c	f3 0f 10 6d c4	 movss	 xmm5, DWORD PTR tv2914[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00251	f3 0f 5c 56 e8	 subss	 xmm2, DWORD PTR [esi-24]
  00256	f3 0f 5c 76 f4	 subss	 xmm6, DWORD PTR [esi-12]
  0025b	f3 0f 11 45 b8	 movss	 DWORD PTR tv2995[ebp], xmm0
  00260	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR tv2986[ebp]
  00265	f3 0f 5c 46 ec	 subss	 xmm0, DWORD PTR [esi-20]
  0026a	f3 0f 11 75 ec	 movss	 DWORD PTR tv2998[ebp], xmm6

; 182  :     z = fz;

  0026f	f3 0f 10 75 c0	 movss	 xmm6, DWORD PTR tv2916[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00274	f3 0f 11 45 d0	 movss	 DWORD PTR tv2996[ebp], xmm0
  00279	0f 28 c1	 movaps	 xmm0, xmm1
  0027c	f3 0f 5c 46 f0	 subss	 xmm0, DWORD PTR [esi-16]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00281	0f 28 cd	 movaps	 xmm1, xmm5
  00284	f3 0f 59 eb	 mulss	 xmm5, xmm3
  00288	f3 0f 59 cc	 mulss	 xmm1, xmm4

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0028c	f3 0f 11 45 94	 movss	 DWORD PTR tv2997[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00291	0f 28 c7	 movaps	 xmm0, xmm7
  00294	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00298	f3 0f 59 fb	 mulss	 xmm7, xmm3
  0029c	f3 0f 5c c8	 subss	 xmm1, xmm0

; 182  :     z = fz;

  002a0	0f 28 c6	 movaps	 xmm0, xmm6
  002a3	f3 0f 59 c2	 mulss	 xmm0, xmm2

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  002a7	f3 0f 59 f4	 mulss	 xmm6, xmm4

; 1280 : 
; 1281 :     *pOut = v;

  002ab	f3 0f 59 4d d8	 mulss	 xmm1, DWORD PTR tv2984[ebp]
  002b0	f3 0f 5c c5	 subss	 xmm0, xmm5

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  002b4	f3 0f 10 6d f8	 movss	 xmm5, DWORD PTR tv2985[ebp]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  002b9	f3 0f 5c fe	 subss	 xmm7, xmm6

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  002bd	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR tv2982[ebp]
  002c2	f3 0f 59 fd	 mulss	 xmm7, xmm5
  002c6	f3 0f 58 c8	 addss	 xmm1, xmm0
  002ca	0f 57 c0	 xorps	 xmm0, xmm0
  002cd	f3 0f 58 cf	 addss	 xmm1, xmm7
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 43   : 			if (D3DXVec3Dot(&temp, &n) < 0) continue;

  002d1	0f 2f c1	 comiss	 xmm0, xmm1
  002d4	0f 87 3b 01 00
	00		 ja	 $LN5@Picking
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  002da	f3 0f 10 65 bc	 movss	 xmm4, DWORD PTR tv2923[ebp]
  002df	f3 0f 10 55 b4	 movss	 xmm2, DWORD PTR tv2922[ebp]
  002e4	0f 28 cc	 movaps	 xmm1, xmm4
  002e7	f3 0f 59 4d b8	 mulss	 xmm1, DWORD PTR tv2995[ebp]
  002ec	0f 28 c2	 movaps	 xmm0, xmm2
  002ef	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR tv2994[ebp]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  002f4	f3 0f 10 5d b0	 movss	 xmm3, DWORD PTR tv2924[ebp]
  002f9	f3 0f 59 55 f0	 mulss	 xmm2, DWORD PTR tv2993[ebp]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  002fe	f3 0f 59 65 f0	 mulss	 xmm4, DWORD PTR tv2993[ebp]
  00303	f3 0f 5c c8	 subss	 xmm1, xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00307	f3 0f 10 75 f4	 movss	 xmm6, DWORD PTR tv2982[ebp]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0030c	0f 28 c3	 movaps	 xmm0, xmm3
  0030f	f3 0f 59 45 b8	 mulss	 xmm0, DWORD PTR tv2995[ebp]
  00314	f3 0f 59 5d d4	 mulss	 xmm3, DWORD PTR tv2994[ebp]

; 1280 : 
; 1281 :     *pOut = v;

  00319	f3 0f 10 7d d8	 movss	 xmm7, DWORD PTR tv2984[ebp]
  0031e	f3 0f 5c d0	 subss	 xmm2, xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00322	f3 0f 59 ce	 mulss	 xmm1, xmm6
  00326	0f 57 c0	 xorps	 xmm0, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00329	f3 0f 5c dc	 subss	 xmm3, xmm4

; 1280 : 
; 1281 :     *pOut = v;

  0032d	f3 0f 59 d7	 mulss	 xmm2, xmm7

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00331	f3 0f 59 dd	 mulss	 xmm3, xmm5
  00335	f3 0f 58 ca	 addss	 xmm1, xmm2
  00339	f3 0f 58 cb	 addss	 xmm1, xmm3
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 45   : 			if (D3DXVec3Dot(&temp, &n) < 0) continue;

  0033d	0f 2f c1	 comiss	 xmm0, xmm1
  00340	0f 87 cf 00 00
	00		 ja	 $LN5@Picking
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00346	f3 0f 10 55 ac	 movss	 xmm2, DWORD PTR tv2934[ebp]
  0034b	f3 0f 5c 55 a8	 subss	 xmm2, DWORD PTR tv2973[ebp]
  00350	f3 0f 10 5d 9c	 movss	 xmm3, DWORD PTR tv2931[ebp]
  00355	f3 0f 5c 5d 98	 subss	 xmm3, DWORD PTR tv2977[ebp]
  0035a	f3 0f 10 65 a4	 movss	 xmm4, DWORD PTR tv2933[ebp]
  0035f	f3 0f 5c 65 a0	 subss	 xmm4, DWORD PTR tv2975[ebp]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00364	0f 28 c2	 movaps	 xmm0, xmm2
  00367	f3 0f 59 55 94	 mulss	 xmm2, DWORD PTR tv2997[ebp]
  0036c	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR tv2998[ebp]
  00371	0f 28 cb	 movaps	 xmm1, xmm3
  00374	f3 0f 59 4d d0	 mulss	 xmm1, DWORD PTR tv2996[ebp]
  00379	f3 0f 59 5d 94	 mulss	 xmm3, DWORD PTR tv2997[ebp]
  0037e	f3 0f 5c c8	 subss	 xmm1, xmm0

; 182  :     z = fz;

  00382	0f 28 c4	 movaps	 xmm0, xmm4
  00385	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR tv2998[ebp]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0038a	f3 0f 59 65 d0	 mulss	 xmm4, DWORD PTR tv2996[ebp]
  0038f	f3 0f 5c c3	 subss	 xmm0, xmm3

; 1280 : 
; 1281 :     *pOut = v;

  00393	f3 0f 59 cf	 mulss	 xmm1, xmm7
  00397	f3 0f 5c d4	 subss	 xmm2, xmm4

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0039b	f3 0f 59 c6	 mulss	 xmm0, xmm6
  0039f	f3 0f 59 d5	 mulss	 xmm2, xmm5
  003a3	f3 0f 58 c8	 addss	 xmm1, xmm0
  003a7	0f 57 c0	 xorps	 xmm0, xmm0
  003aa	f3 0f 58 ca	 addss	 xmm1, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 48   : 			if (D3DXVec3Dot(&temp, &n) < 0) continue;

  003ae	0f 2f c1	 comiss	 xmm0, xmm1
  003b1	77 62		 ja	 SHORT $LN5@Picking

; 49   : 
; 50   : 			if (bPicked)

  003b3	80 7d ff 00	 cmp	 BYTE PTR _bPicked$1$[ebp], 0
  003b7	f3 0f 10 65 e0	 movss	 xmm4, DWORD PTR tv2986[ebp]
  003bc	f3 0f 10 6d cc	 movss	 xmm5, DWORD PTR tv2987[ebp]
  003c1	74 41		 je	 SHORT $LN12@Picking

; 51   : 			{
; 52   : 				if ((v.x - x.x) * (v.x - x.x) + (v.y - x.y) * (v.y - x.y) < (v.x - nx) * (v.x - nx) + (v.y - ny) * (v.y - ny))

  003c3	f3 0f 10 11	 movss	 xmm2, DWORD PTR [ecx]
  003c7	f3 0f 10 59 04	 movss	 xmm3, DWORD PTR [ecx+4]
  003cc	f3 0f 5c d4	 subss	 xmm2, xmm4
  003d0	f3 0f 10 09	 movss	 xmm1, DWORD PTR [ecx]
  003d4	f3 0f 5c dd	 subss	 xmm3, xmm5
  003d8	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  003dd	f3 0f 5c 45 e4	 subss	 xmm0, DWORD PTR _ny$1$[ebp]
  003e2	f3 0f 5c 4d e8	 subss	 xmm1, DWORD PTR _nx$1$[ebp]
  003e7	f3 0f 59 d2	 mulss	 xmm2, xmm2
  003eb	f3 0f 59 db	 mulss	 xmm3, xmm3
  003ef	f3 0f 59 c0	 mulss	 xmm0, xmm0
  003f3	f3 0f 59 c9	 mulss	 xmm1, xmm1
  003f7	f3 0f 58 da	 addss	 xmm3, xmm2
  003fb	f3 0f 58 c1	 addss	 xmm0, xmm1
  003ff	0f 2f c3	 comiss	 xmm0, xmm3
  00402	76 0a		 jbe	 SHORT $LN13@Picking
$LN12@Picking:

; 53   : 				{
; 54   : 					nx = x.x;
; 55   : 					ny = x.y;
; 56   : 				}
; 57   : 			}
; 58   : 			else
; 59   : 			{
; 60   : 				nx = x.x;
; 61   : 				ny = x.y;
; 62   : 			}
; 63   : 			bPicked = true;

  00404	f3 0f 11 6d e4	 movss	 DWORD PTR _ny$1$[ebp], xmm5
  00409	f3 0f 11 65 e8	 movss	 DWORD PTR _nx$1$[ebp], xmm4
$LN13@Picking:
  0040e	8b 45 0c	 mov	 eax, DWORD PTR _dir$[ebp]
  00411	c6 45 ff 01	 mov	 BYTE PTR _bPicked$1$[ebp], 1
$LN5@Picking:

; 21   : 		for (DWORD j = 0; j < m_v3HeightDataVector[i].size(); j += 3)

  00415	83 c6 24	 add	 esi, 36			; 00000024H
  00418	83 ea 01	 sub	 edx, 1
  0041b	0f 85 60 fc ff
	ff		 jne	 $LL7@Picking
$LN2@Picking:

; 20   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00421	83 c7 0c	 add	 edi, 12			; 0000000cH
  00424	83 6d c8 01	 sub	 DWORD PTR tv3020[ebp], 1
  00428	0f 85 22 fc ff
	ff		 jne	 $LL4@Picking

; 64   : 		}
; 65   : 	if (bPicked)

  0042e	8a 45 ff	 mov	 al, BYTE PTR _bPicked$1$[ebp]
  00431	84 c0		 test	 al, al
  00433	74 23		 je	 SHORT $LN15@Picking

; 66   : 	{
; 67   : 		out_x = nx;

  00435	8b 4d 10	 mov	 ecx, DWORD PTR _out_x$[ebp]
  00438	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _nx$1$[ebp]

; 68   : 		out_y = ny;
; 69   : 	}
; 70   : 	return bPicked;

  0043d	5f		 pop	 edi
  0043e	5e		 pop	 esi
  0043f	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00443	8b 4d 14	 mov	 ecx, DWORD PTR _out_y$[ebp]
  00446	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _ny$1$[ebp]
  0044b	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 71   : }

  0044f	8b e5		 mov	 esp, ebp
  00451	5d		 pop	 ebp
  00452	c2 10 00	 ret	 16			; 00000010H
$LN110@Picking:

; 20   : 	for (DWORD i = 0; i < m_v3HeightDataVector.size(); ++i)

  00455	8a 45 ff	 mov	 al, BYTE PTR _bPicked$1$[ebp]
$LN15@Picking:

; 68   : 		out_y = ny;
; 69   : 	}
; 70   : 	return bPicked;

  00458	5f		 pop	 edi
  00459	5e		 pop	 esi

; 71   : }

  0045a	8b e5		 mov	 esp, ebp
  0045c	5d		 pop	 ebp
  0045d	c2 10 00	 ret	 16			; 00000010H
?Picking@CAttributeInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z ENDP ; CAttributeInstance::Picking
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ
_TEXT	SEGMENT
?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ PROC ; CAttributeInstance::GetObjectPointer, COMDAT
; _this$ = ecx

; 127  : 	return m_roAttributeData.GetPointer();

  00000	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]

; 128  : }

  00003	c3		 ret	 0
?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ ENDP ; CAttributeInstance::GetObjectPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -24					; size = 4
_dwHeightDataCount$1$ = -20				; size = 4
_i$1$ = -16						; size = 4
__Oldsize$1$ = -16					; size = 4
_c_pHeightData$2 = -12					; size = 4
_this$1$ = -8						; size = 4
__My_data$1$ = -4					; size = 4
_c_rmatGlobal$ = 8					; size = 4
tv534 = 8						; size = 4
__Backout$1$sroa$192$1$ = 8				; size = 4
$T3 = 11						; size = 1
$T4 = 11						; size = 1
?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z PROC ; CAttributeInstance::RefreshObject, COMDAT
; _this$ = ecx

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 147  : 	assert(!m_roAttributeData.IsNull());
; 148  : 
; 149  : 	m_matGlobal = c_rmatGlobal;

  00006	8b 45 08	 mov	 eax, DWORD PTR _c_rmatGlobal$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00010	57		 push	 edi
  00011	89 75 f8	 mov	 DWORD PTR _this$1$[ebp], esi

; 150  : 
; 151  : 	// Height
; 152  : 	m_fHeightRadius = m_roAttributeData->GetMaximizeRadius();

  00014	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  00017	0f 11 46 0c	 movups	 XMMWORD PTR [esi+12], xmm0
  0001b	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  0001f	0f 11 46 1c	 movups	 XMMWORD PTR [esi+28], xmm0
  00023	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [eax+32]
  00027	0f 11 46 2c	 movups	 XMMWORD PTR [esi+44], xmm0
  0002b	0f 10 40 30	 movups	 xmm0, XMMWORD PTR [eax+48]
  0002f	0f 11 46 3c	 movups	 XMMWORD PTR [esi+60], xmm0
  00033	e8 00 00 00 00	 call	 ?GetMaximizeRadius@CAttributeData@@QAEMXZ ; CAttributeData::GetMaximizeRadius

; 153  : 
; 154  : 	DWORD dwHeightDataCount = m_roAttributeData->GetHeightDataCount();

  00038	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0003b	d9 5e 08	 fstp	 DWORD PTR [esi+8]
  0003e	e8 00 00 00 00	 call	 ?GetHeightDataCount@CAttributeData@@QBEKXZ ; CAttributeData::GetHeightDataCount
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00043	8b 7e 50	 mov	 edi, DWORD PTR [esi+80]
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 155  : 	m_v3HeightDataVector.clear();

  00046	83 c6 4c	 add	 esi, 76			; 0000004cH
  00049	8b d8		 mov	 ebx, eax
  0004b	89 75 fc	 mov	 DWORD PTR __My_data$1$[ebp], esi
  0004e	89 5d ec	 mov	 DWORD PTR _dwHeightDataCount$1$[ebp], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00051	8b 06		 mov	 eax, DWORD PTR [esi]
  00053	3b c7		 cmp	 eax, edi
  00055	74 10		 je	 SHORT $LN10@RefreshObj

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  00057	56		 push	 esi
  00058	57		 push	 edi
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0005f	8b 3e		 mov	 edi, DWORD PTR [esi]
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	89 7e 04	 mov	 DWORD PTR [esi+4], edi
$LN10@RefreshObj:

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00067	8b cf		 mov	 ecx, edi
  00069	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0006e	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00070	f7 e9		 imul	 ecx
  00072	d1 fa		 sar	 edx, 1
  00074	8b c2		 mov	 eax, edx
  00076	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00079	03 c2		 add	 eax, edx
  0007b	89 45 f0	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1581 :         if (_Newsize < _Oldsize) { // trim

  0007e	3b d8		 cmp	 ebx, eax
  00080	73 1d		 jae	 SHORT $LN17@RefreshObj

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  00082	8b 16		 mov	 edx, DWORD PTR [esi]
  00084	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]

; 1583 :             _Orphan_range(_Newlast, _Mylast);
; 1584 :             _Destroy_range(_Newlast, _Mylast, _Al);

  00087	8b 5d fc	 mov	 ebx, DWORD PTR __My_data$1$[ebp]
  0008a	53		 push	 ebx
  0008b	57		 push	 edi
  0008c	8d 34 82	 lea	 esi, DWORD PTR [edx+eax*4]
  0008f	56		 push	 esi
  00090	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1585 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1586 :             _Mylast = _Newlast;

  00095	89 73 04	 mov	 DWORD PTR [ebx+4], esi

; 1587 :             return;

  00098	8b f3		 mov	 esi, ebx
  0009a	8b 5d ec	 mov	 ebx, DWORD PTR _dwHeightDataCount$1$[ebp]
  0009d	eb 39		 jmp	 SHORT $LN89@RefreshObj
$LN17@RefreshObj:

; 1588 :         }
; 1589 : 
; 1590 :         if (_Newsize > _Oldsize) { // append

  0009f	76 3a		 jbe	 SHORT $LN18@RefreshObj

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  000a1	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000a4	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  000a9	2b 0e		 sub	 ecx, DWORD PTR [esi]
  000ab	f7 e9		 imul	 ecx
  000ad	d1 fa		 sar	 edx, 1
  000af	8b c2		 mov	 eax, edx
  000b1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000b4	03 c2		 add	 eax, edx

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  000b6	3b d8		 cmp	 ebx, eax
  000b8	76 0e		 jbe	 SHORT $LN19@RefreshObj

; 1593 :                 _Resize_reallocate(_Newsize, _Val);

  000ba	8d 45 0b	 lea	 eax, DWORD PTR $T3[ebp]
  000bd	8b ce		 mov	 ecx, esi
  000bf	50		 push	 eax
  000c0	53		 push	 ebx
  000c1	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::_Resize_reallocate<std::_Value_init_tag>

; 1594 :                 return;

  000c6	eb 13		 jmp	 SHORT $LN18@RefreshObj
$LN19@RefreshObj:

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  000c8	8b c3		 mov	 eax, ebx
  000ca	2b 45 f0	 sub	 eax, DWORD PTR __Oldsize$1$[ebp]
  000cd	56		 push	 esi
  000ce	50		 push	 eax
  000cf	57		 push	 edi
  000d0	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@PAV10@IAAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  000d5	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN89@RefreshObj:
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 157  : 	for (DWORD i = 0; i < dwHeightDataCount; ++i)

  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN18@RefreshObj:
  000db	33 c0		 xor	 eax, eax
  000dd	89 45 f0	 mov	 DWORD PTR _i$1$[ebp], eax
  000e0	85 db		 test	 ebx, ebx
  000e2	0f 84 f8 00 00
	00		 je	 $LN3@RefreshObj
  000e8	33 db		 xor	 ebx, ebx
  000ea	66 0f 1f 44 00
	00		 npad	 6
$LL4@RefreshObj:

; 158  : 	{
; 159  : 		const THeightData * c_pHeightData;
; 160  : 		if (!m_roAttributeData->GetHeightDataPointer(i, &c_pHeightData))

  000f0	8d 4d f4	 lea	 ecx, DWORD PTR _c_pHeightData$2[ebp]
  000f3	51		 push	 ecx
  000f4	50		 push	 eax
  000f5	8b 45 f8	 mov	 eax, DWORD PTR _this$1$[ebp]
  000f8	8b 48 58	 mov	 ecx, DWORD PTR [eax+88]
  000fb	e8 00 00 00 00	 call	 ?GetHeightDataPointer@CAttributeData@@QBEHKPAPBUSHeightData@@@Z ; CAttributeData::GetHeightDataPointer
  00100	85 c0		 test	 eax, eax
  00102	0f 84 c2 00 00
	00		 je	 $LN2@RefreshObj
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1899 :         auto& _My_data = _Mypair._Myval2;

  00108	8b 45 f4	 mov	 eax, DWORD PTR _c_pHeightData$2[ebp]

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0010b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0010e	2b 48 24	 sub	 ecx, DWORD PTR [eax+36]
  00111	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00116	f7 e9		 imul	 ecx

; 1919 :         return _My_data._Myfirst[_Pos];

  00118	8b 06		 mov	 eax, DWORD PTR [esi]

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0011a	d1 fa		 sar	 edx, 1
  0011c	8b fa		 mov	 edi, edx
  0011e	c1 ef 1f	 shr	 edi, 31			; 0000001fH

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00121	8b 0c 18	 mov	 ecx, DWORD PTR [eax+ebx]

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00124	03 fa		 add	 edi, edx

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00126	3b 4c 18 04	 cmp	 ecx, DWORD PTR [eax+ebx+4]
  0012a	74 04		 je	 SHORT $LN27@RefreshObj

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0012c	89 4c 18 04	 mov	 DWORD PTR [eax+ebx+4], ecx
$LN27@RefreshObj:

; 1919 :         return _My_data._Myfirst[_Pos];

  00130	8b 36		 mov	 esi, DWORD PTR [esi]
  00132	03 f3		 add	 esi, ebx

; 1580 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00134	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00137	8b c8		 mov	 ecx, eax
  00139	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0013b	89 45 08	 mov	 DWORD PTR __Backout$1$sroa$192$1$[ebp], eax
  0013e	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00143	f7 e9		 imul	 ecx
  00145	d1 fa		 sar	 edx, 1
  00147	8b c2		 mov	 eax, edx
  00149	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0014c	03 c2		 add	 eax, edx
  0014e	89 45 e8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 1581 :         if (_Newsize < _Oldsize) { // trim

  00151	3b f8		 cmp	 edi, eax
  00153	73 0d		 jae	 SHORT $LN37@RefreshObj

; 1582 :             const pointer _Newlast = _Myfirst + _Newsize;

  00155	8b 16		 mov	 edx, DWORD PTR [esi]
  00157	8d 04 7f	 lea	 eax, DWORD PTR [edi+edi*2]
  0015a	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 1585 :             _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Newsize - _Oldsize));
; 1586 :             _Mylast = _Newlast;

  0015d	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1587 :             return;

  00160	eb 3c		 jmp	 SHORT $LN38@RefreshObj
$LN37@RefreshObj:

; 1588 :         }
; 1589 : 
; 1590 :         if (_Newsize > _Oldsize) { // append

  00162	76 3a		 jbe	 SHORT $LN38@RefreshObj

; 1591 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00164	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00167	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0016c	2b 0e		 sub	 ecx, DWORD PTR [esi]
  0016e	f7 e9		 imul	 ecx
  00170	d1 fa		 sar	 edx, 1
  00172	8b c2		 mov	 eax, edx
  00174	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00177	03 c2		 add	 eax, edx

; 1592 :             if (_Newsize > _Oldcapacity) { // reallocate

  00179	3b f8		 cmp	 edi, eax
  0017b	76 0e		 jbe	 SHORT $LN39@RefreshObj

; 1593 :                 _Resize_reallocate(_Newsize, _Val);

  0017d	8d 45 0b	 lea	 eax, DWORD PTR $T4[ebp]
  00180	8b ce		 mov	 ecx, esi
  00182	50		 push	 eax
  00183	57		 push	 edi
  00184	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Resize_reallocate<std::_Value_init_tag>

; 1594 :                 return;

  00189	eb 13		 jmp	 SHORT $LN38@RefreshObj
$LN39@RefreshObj:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  0018b	8b 4d 08	 mov	 ecx, DWORD PTR __Backout$1$sroa$192$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  0018e	8b c7		 mov	 eax, edi
  00190	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 2056 :     for (; 0 < _Count; --_Count) {

  00193	74 06		 je	 SHORT $LN44@RefreshObj
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1603 :                 _Mylast = _Uninitialized_value_construct_n(_Oldlast, _Newsize - _Oldsize, _Al);

  00195	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00198	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
$LN44@RefreshObj:
  0019b	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
$LN38@RefreshObj:
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 166  : 		for (DWORD j = 0; j < dwVertexCount; ++j)

  0019e	85 ff		 test	 edi, edi
  001a0	74 28		 je	 SHORT $LN2@RefreshObj
  001a2	33 f6		 xor	 esi, esi
$LL7@RefreshObj:

; 168  : 			D3DXVec3TransformCoord(&m_v3HeightDataVector[i][j], &c_pHeightData->v3VertexVector[j], &m_matGlobal);

  001a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  001a7	8d 41 0c	 lea	 eax, DWORD PTR [ecx+12]
  001aa	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1929 :         return _My_data._Myfirst[_Pos];

  001ab	8b 45 f4	 mov	 eax, DWORD PTR _c_pHeightData$2[ebp]
  001ae	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  001b1	03 c6		 add	 eax, esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 168  : 			D3DXVec3TransformCoord(&m_v3HeightDataVector[i][j], &c_pHeightData->v3VertexVector[j], &m_matGlobal);

  001b3	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  001b4	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  001b7	8b 04 03	 mov	 eax, DWORD PTR [ebx+eax]
  001ba	03 c6		 add	 eax, esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 168  : 			D3DXVec3TransformCoord(&m_v3HeightDataVector[i][j], &c_pHeightData->v3VertexVector[j], &m_matGlobal);

  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
  001c2	83 c6 0c	 add	 esi, 12			; 0000000cH
  001c5	83 ef 01	 sub	 edi, 1
  001c8	75 da		 jne	 SHORT $LL7@RefreshObj
$LN2@RefreshObj:

; 157  : 	for (DWORD i = 0; i < dwHeightDataCount; ++i)

  001ca	8b 45 f0	 mov	 eax, DWORD PTR _i$1$[ebp]
  001cd	83 c3 0c	 add	 ebx, 12			; 0000000cH
  001d0	8b 75 fc	 mov	 esi, DWORD PTR __My_data$1$[ebp]
  001d3	40		 inc	 eax
  001d4	89 45 f0	 mov	 DWORD PTR _i$1$[ebp], eax
  001d7	3b 45 ec	 cmp	 eax, DWORD PTR _dwHeightDataCount$1$[ebp]
  001da	0f 82 10 ff ff
	ff		 jb	 $LL4@RefreshObj
$LN3@RefreshObj:
  001e0	5f		 pop	 edi

; 169  : 		}
; 170  : 	}
; 171  : }

  001e1	5e		 pop	 esi
  001e2	5b		 pop	 ebx
  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c2 04 00	 ret	 4
?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z ENDP ; CAttributeInstance::RefreshObject
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z
_TEXT	SEGMENT
_pAttributeData$ = 8					; size = 4
?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z PROC ; CAttributeInstance::SetObjectPointer, COMDAT
; _this$ = ecx

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 141  : 	Clear();

  00007	e8 00 00 00 00	 call	 ?Clear@CAttributeInstance@@QAEXXZ ; CAttributeInstance::Clear
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h

; 69   : 			m_pObject = pObject;

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _pAttributeData$[ebp]
  0000f	8b 7e 58	 mov	 edi, DWORD PTR [esi+88]
  00012	89 4e 58	 mov	 DWORD PTR [esi+88], ecx

; 70   : 
; 71   : 			if (m_pObject)

  00015	85 c9		 test	 ecx, ecx
  00017	74 05		 je	 SHORT $LN4@SetObjectP

; 72   : 				m_pObject->AddReference();

  00019	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN4@SetObjectP:

; 73   : 
; 74   : 			if (pOldObject)

  0001e	85 ff		 test	 edi, edi
  00020	74 07		 je	 SHORT $LN5@SetObjectP

; 75   : 				pOldObject->Release();

  00022	8b cf		 mov	 ecx, edi
  00024	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN5@SetObjectP:
  00029	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 143  : }

  0002a	5e		 pop	 esi
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z ENDP ; CAttributeInstance::SetObjectPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?GetDataFileName@CAttributeInstance@@QBEPBDXZ
_TEXT	SEGMENT
?GetDataFileName@CAttributeInstance@@QBEPBDXZ PROC	; CAttributeInstance::GetDataFileName, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2328 :         return _Mypair._Myval2._Myptr();

  00000	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  00003	83 c0 0c	 add	 eax, 12			; 0000000cH

; 434  :         return _Myres > _Small_string_capacity;

  00006	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0000a	76 02		 jbe	 SHORT $LN9@GetDataFil
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 175  : 	return m_roAttributeData->GetFileName();

  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN9@GetDataFil:

; 176  : }

  0000e	c3		 ret	 0
?GetDataFileName@CAttributeInstance@@QBEPBDXZ ENDP	; CAttributeInstance::GetDataFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?IsEmpty@CAttributeInstance@@QBEHXZ
_TEXT	SEGMENT
?IsEmpty@CAttributeInstance@@QBEHXZ PROC		; CAttributeInstance::IsEmpty, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00000	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00003	33 c0		 xor	 eax, eax
  00005	3b 51 50	 cmp	 edx, DWORD PTR [ecx+80]
  00008	0f 94 c0	 sete	 al
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 204  : }

  0000b	c3		 ret	 0
?IsEmpty@CAttributeInstance@@QBEHXZ ENDP		; CAttributeInstance::IsEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ?Clear@CAttributeInstance@@QAEXXZ
_TEXT	SEGMENT
?Clear@CAttributeInstance@@QAEXXZ PROC			; CAttributeInstance::Clear, COMDAT
; _this$ = ecx

; 207  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	57		 push	 edi

; 208  : 	m_fHeightRadius = 0.0f;
; 209  : 	m_fCollisionRadius = 0.0f;
; 210  : 	D3DXMatrixIdentity(&m_matGlobal);
; 211  : 
; 212  : 	m_v3HeightDataVector.clear();

  00004	8d 7e 4c	 lea	 edi, DWORD PTR [esi+76]
  00007	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0000e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00015	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  0001c	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
  00023	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
  0002a	c7 46 38 00 00
	00 00		 mov	 DWORD PTR [esi+56], 0
  00031	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
  00038	c7 46 2c 00 00
	00 00		 mov	 DWORD PTR [esi+44], 0
  0003f	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
  00046	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], 0
  0004d	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
  00054	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0005b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00062	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00069	c7 46 48 00 00
	80 3f		 mov	 DWORD PTR [esi+72], 1065353216 ; 3f800000H
  00070	c7 46 34 00 00
	80 3f		 mov	 DWORD PTR [esi+52], 1065353216 ; 3f800000H
  00077	c7 46 20 00 00
	80 3f		 mov	 DWORD PTR [esi+32], 1065353216 ; 3f800000H
  0007e	c7 46 0c 00 00
	80 3f		 mov	 DWORD PTR [esi+12], 1065353216 ; 3f800000H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00085	8b 07		 mov	 eax, DWORD PTR [edi]
  00087	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0008a	3b c1		 cmp	 eax, ecx
  0008c	74 10		 je	 SHORT $LN5@Clear

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  0008e	57		 push	 edi
  0008f	51		 push	 ecx
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@std@@@std@@YAXPAV?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@0@QAV10@AAV?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00096	8b 07		 mov	 eax, DWORD PTR [edi]
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN5@Clear:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h

; 67   : 			CReferenceObject* pOldObject = m_pObject;

  0009e	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]

; 68   : 
; 69   : 			m_pObject = pObject;

  000a1	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi

; 70   : 
; 71   : 			if (m_pObject)
; 72   : 				m_pObject->AddReference();
; 73   : 
; 74   : 			if (pOldObject)

  000aa	85 c9		 test	 ecx, ecx
  000ac	0f 85 00 00 00
	00		 jne	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 215  : }

  000b2	c3		 ret	 0
?Clear@CAttributeInstance@@QAEXXZ ENDP			; CAttributeInstance::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ??1CAttributeInstance@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CAttributeInstance@@UAE@XZ PROC			; CAttributeInstance::~CAttributeInstance, COMDAT
; _this$ = ecx

; 221  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAttributeInstance@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CAttributeInstance@@6B@
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h

; 53   : 			if (m_pObject)

  0002b	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]

; 37   : 		{

  0002e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 53   : 			if (m_pObject)

  00035	85 c9		 test	 ecx, ecx
  00037	74 0c		 je	 SHORT $LN10@CAttribute

; 54   : 			{
; 55   : 				m_pObject->Release();

  00039	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  0003e	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
$LN10@CAttribute:
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 222  : }

  00045	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
  00048	e8 00 00 00 00	 call	 ??1?$vector@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@V?$allocator@V?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >::~vector<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >,std::allocator<std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> > > >
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	5e		 pop	 esi
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
  0005d	cc		 int	 3
  0005e	cc		 int	 3
  0005f	cc		 int	 3
  00060	cc		 int	 3
  00061	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAttributeInstance@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAttributeInstance@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAttributeInstance@@UAE@XZ ENDP			; CAttributeInstance::~CAttributeInstance
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp
;	COMDAT ??0CAttributeInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CAttributeInstance@@QAE@XZ PROC			; CAttributeInstance::CAttributeInstance, COMDAT
; _this$ = ecx

; 218  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CAttributeInstance@@6B@

; 219  : }

  0000a	8b c1		 mov	 eax, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000c	c7 41 4c 00 00
	00 00		 mov	 DWORD PTR [ecx+76], 0
  00013	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], 0
  0001a	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 218  : {

  00021	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h

; 20   : 		CRef() : m_pObject(NULL)

  00024	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\AttributeInstance.cpp

; 219  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??0CAttributeInstance@@QAE@XZ ENDP			; CAttributeInstance::CAttributeInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
