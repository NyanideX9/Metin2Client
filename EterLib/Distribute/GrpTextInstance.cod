; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\EterLib\Distribute\GrpTextInstance.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@ ; CDynamicPool<CGraphicTextInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8 ; CDynamicPool<CGraphicTextInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8	; CDynamicPool<CGraphicTextInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8	; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8 ; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@	; CDynamicPool<CGraphicTextInstance>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z ; CDynamicPool<CGraphicTextInstance>::`scalar deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CGraphicTextInstance>::`vector deleting destructor'
CONST	SEGMENT
?c_FillRectIndices@@3QBGB DW 00H			; c_FillRectIndices
	DW	02H
	DW	01H
	DW	02H
	DW	03H
	DW	01H
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@ ; CDynamicPool<CGraphicTextInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8 ; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCGraphicTextInstance@@@@8 ; CDynamicPool<CGraphicTextInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8 DD 00H	; CDynamicPool<CGraphicTextInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CGraphicTextInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCGraphicTextInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCGraphicTextInstance@@@@6B@ DD 00H	; CDynamicPool<CGraphicTextInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCGraphicTextInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCGraphicTextInstance@@@@8
rdata$r	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	___local_stdio_printf_options
PUBLIC	_snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0SPDTVertex@@QAE@XZ				; SPDTVertex::SPDTVertex
PUBLIC	?Hyperlink_UpdateMousePos@CGraphicTextInstance@@SAXHH@Z ; CGraphicTextInstance::Hyperlink_UpdateMousePos
PUBLIC	?Hyperlink_GetText@CGraphicTextInstance@@SAHPADH@Z ; CGraphicTextInstance::Hyperlink_GetText
PUBLIC	??0CGraphicTextInstance@@QAE@XZ			; CGraphicTextInstance::CGraphicTextInstance
PUBLIC	??1CGraphicTextInstance@@UAE@XZ			; CGraphicTextInstance::~CGraphicTextInstance
PUBLIC	?Destroy@CGraphicTextInstance@@QAEXXZ		; CGraphicTextInstance::Destroy
PUBLIC	?Update@CGraphicTextInstance@@QAEXXZ		; CGraphicTextInstance::Update
PUBLIC	?Render@CGraphicTextInstance@@QAEXPAUtagRECT@@@Z ; CGraphicTextInstance::Render
PUBLIC	?ShowCursor@CGraphicTextInstance@@QAEXXZ	; CGraphicTextInstance::ShowCursor
PUBLIC	?HideCursor@CGraphicTextInstance@@QAEXXZ	; CGraphicTextInstance::HideCursor
PUBLIC	?ShowOutLine@CGraphicTextInstance@@QAEXXZ	; CGraphicTextInstance::ShowOutLine
PUBLIC	?HideOutLine@CGraphicTextInstance@@QAEXXZ	; CGraphicTextInstance::HideOutLine
PUBLIC	?SetColor@CGraphicTextInstance@@QAEXK@Z		; CGraphicTextInstance::SetColor
PUBLIC	?SetColor@CGraphicTextInstance@@QAEXMMMM@Z	; CGraphicTextInstance::SetColor
PUBLIC	?SetOutLineColor@CGraphicTextInstance@@QAEXK@Z	; CGraphicTextInstance::SetOutLineColor
PUBLIC	?SetOutLineColor@CGraphicTextInstance@@QAEXMMMM@Z ; CGraphicTextInstance::SetOutLineColor
PUBLIC	?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z ; CGraphicTextInstance::SetHorizonalAlign
PUBLIC	?SetVerticalAlign@CGraphicTextInstance@@QAEXH@Z	; CGraphicTextInstance::SetVerticalAlign
PUBLIC	?SetMax@CGraphicTextInstance@@QAEXH@Z		; CGraphicTextInstance::SetMax
PUBLIC	?SetTextPointer@CGraphicTextInstance@@QAEXPAVCGraphicText@@@Z ; CGraphicTextInstance::SetTextPointer
PUBLIC	?SetValueString@CGraphicTextInstance@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CGraphicTextInstance::SetValueString
PUBLIC	?SetValue@CGraphicTextInstance@@QAEXPBDI@Z	; CGraphicTextInstance::SetValue
PUBLIC	?SetPosition@CGraphicTextInstance@@QAEXMMM@Z	; CGraphicTextInstance::SetPosition
PUBLIC	?SetSecret@CGraphicTextInstance@@QAEX_N@Z	; CGraphicTextInstance::SetSecret
PUBLIC	?SetOutline@CGraphicTextInstance@@QAEX_N@Z	; CGraphicTextInstance::SetOutline
PUBLIC	?SetFeather@CGraphicTextInstance@@QAEX_N@Z	; CGraphicTextInstance::SetFeather
PUBLIC	?SetMultiLine@CGraphicTextInstance@@QAEX_N@Z	; CGraphicTextInstance::SetMultiLine
PUBLIC	?SetLimitWidth@CGraphicTextInstance@@QAEXM@Z	; CGraphicTextInstance::SetLimitWidth
PUBLIC	?GetTextSize@CGraphicTextInstance@@QAEXPAH0@Z	; CGraphicTextInstance::GetTextSize
PUBLIC	?GetValueStringReference@CGraphicTextInstance@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CGraphicTextInstance::GetValueStringReference
PUBLIC	?GetTextLineCount@CGraphicTextInstance@@QAEGXZ	; CGraphicTextInstance::GetTextLineCount
PUBLIC	?PixelPositionToCharacterPosition@CGraphicTextInstance@@QAEHH@Z ; CGraphicTextInstance::PixelPositionToCharacterPosition
PUBLIC	?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ ; CGraphicTextInstance::GetHorizontalAlign
PUBLIC	?__Initialize@CGraphicTextInstance@@IAEXXZ	; CGraphicTextInstance::__Initialize
PUBLIC	?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
PUBLIC	?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z	; CGraphicTextInstance::__GetTextPos
PUBLIC	??1SHyperlink@CGraphicTextInstance@@QAE@XZ	; CGraphicTextInstance::SHyperlink::~SHyperlink
PUBLIC	??1?$CRef@VCGraphicText@@@@QAE@XZ		; CRef<CGraphicText>::~CRef<CGraphicText>
PUBLIC	??1?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAE@XZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::~vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
PUBLIC	?_Xlength@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@CAXXZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Xlength
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
PUBLIC	??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::~vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >
PUBLIC	?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::clear
PUBLIC	?_Xlength@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Xlength
PUBLIC	??1?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::~vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >
PUBLIC	?_Xlength@?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::_Xlength
PUBLIC	?CreateSystem@CGraphicTextInstance@@SAXI@Z	; CGraphicTextInstance::CreateSystem
PUBLIC	?DestroySystem@CGraphicTextInstance@@SAXXZ	; CGraphicTextInstance::DestroySystem
PUBLIC	?New@CGraphicTextInstance@@SAPAV1@XZ		; CGraphicTextInstance::New
PUBLIC	?Delete@CGraphicTextInstance@@SAXPAV1@@Z	; CGraphicTextInstance::Delete
PUBLIC	??_GCGraphicTextInstance@@UAEPAXI@Z		; CGraphicTextInstance::`scalar deleting destructor'
PUBLIC	?FindToken@@YAPBDPBD0@Z				; FindToken
PUBLIC	?ReadToken@@YAHPBD@Z				; ReadToken
PUBLIC	??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
PUBLIC	?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::push_back
PUBLIC	?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::reserve
PUBLIC	?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Change_array
PUBLIC	?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlength
PUBLIC	?GraphicTextInstancesReload@@YAXPAVCGraphicText@@@Z ; GraphicTextInstancesReload
PUBLIC	?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z ; __GraphicTextInstancesList
PUBLIC	?isNumberic@@YA_ND@Z				; isNumberic
PUBLIC	?IsValidToken@@YA_NPBD@Z			; IsValidToken
PUBLIC	??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CGraphicTextInstance *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CGraphicTextInstance *,void *> > >
PUBLIC	??$_Emplace_reallocate@ABUSEmoji@CGraphicTextInstance@@@?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@AAEPAUSEmoji@CGraphicTextInstance@@QAU23@ABU23@@Z ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::_Emplace_reallocate<CGraphicTextInstance::SEmoji const &>
PUBLIC	??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_reallocate<CGraphicTextInstance::SHyperlink const &>
PUBLIC	??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKQAKABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>
PUBLIC	??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_reallocate<CGraphicFontTexture::SCharacterInfomation * const &>
PUBLIC	??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z	; std::_Find_vectorized<char const ,char>
PUBLIC	??$construct@USHyperlink@CGraphicTextInstance@@ABU12@@?$_Default_allocator_traits@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@USHyperlink@CGraphicTextInstance@@@1@QAUSHyperlink@CGraphicTextInstance@@ABU34@@Z ; std::_Default_allocator_traits<std::allocator<CGraphicTextInstance::SHyperlink> >::construct<CGraphicTextInstance::SHyperlink,CGraphicTextInstance::SHyperlink const &>
PUBLIC	??1_Reallocation_guard@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >
PUBLIC	??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicTextInstance * *,CGraphicTextInstance * *>
PUBLIC	??$_Copy_memmove@PAUSEmoji@CGraphicTextInstance@@PAU12@@std@@YAPAUSEmoji@CGraphicTextInstance@@PAU12@00@Z ; std::_Copy_memmove<CGraphicTextInstance::SEmoji *,CGraphicTextInstance::SEmoji *>
PUBLIC	??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z	; std::_Copy_memmove<unsigned long *,unsigned long *>
PUBLIC	??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z ; std::_Copy_memmove<CGraphicFontTexture::SCharacterInfomation * *,CGraphicFontTexture::SCharacterInfomation * *>
PUBLIC	??$_Copy_memmove_tail@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CGraphicTextInstance * *>
PUBLIC	??$_Copy_memmove_tail@PAUSEmoji@CGraphicTextInstance@@@std@@YAPAUSEmoji@CGraphicTextInstance@@QBDQAU12@II@Z ; std::_Copy_memmove_tail<CGraphicTextInstance::SEmoji *>
PUBLIC	??$_Copy_memmove_tail@PAK@std@@YAPAKQBDQAKII@Z	; std::_Copy_memmove_tail<unsigned long *>
PUBLIC	??$_Copy_memmove_tail@PAPAUSCharacterInfomation@CGraphicFontTexture@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QBDQAPAU12@II@Z ; std::_Copy_memmove_tail<CGraphicFontTexture::SCharacterInfomation * *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A ; CGraphicTextInstance::ms_kPool
PUBLIC	??_7CGraphicTextInstance@@6B@			; CGraphicTextInstance::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A ; GraphicTextInstances
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_0M@NHBNKCLI@icon?1?$CFs?4tga@		; `string'
PUBLIC	??_C@_0BC@DJBDGBIO@icon?1emoji?1?$CFs?4png@	; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0DG@FOMBDJDA@CGraphicTextInstance?3?3Update?5?9?5@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	??_R4CGraphicTextInstance@@6B@			; CGraphicTextInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGraphicTextInstance@@@8		; CGraphicTextInstance `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicTextInstance@@8			; CGraphicTextInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicTextInstance@@8			; CGraphicTextInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicTextInstance@@8		; CGraphicTextInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@401c000000000000
PUBLIC	__real@437f0000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_find_trivial_1@12:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?Tracef@@YAXPBDZZ:PROC				; Tracef
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?IsEmpty@CResource@@QBE_NXZ:PROC		; CResource::IsEmpty
EXTRN	?SetDefaultIndexBuffer@CGraphicBase@@SAXI@Z:PROC ; CGraphicBase::SetDefaultIndexBuffer
EXTRN	?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z:PROC ; CGraphicBase::SetPDTStream
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	?SelectTexture@CGraphicFontTexture@@QAEXK@Z:PROC ; CGraphicFontTexture::SelectTexture
EXTRN	?UpdateTexture@CGraphicFontTexture@@QAE_NXZ:PROC ; CGraphicFontTexture::UpdateTexture
EXTRN	?GetCharacterInfomation@CGraphicFontTexture@@QAEPAUSCharacterInfomation@1@G_W@Z:PROC ; CGraphicFontTexture::GetCharacterInfomation
EXTRN	?GetFontTexturePointer@CGraphicText@@QAEPAVCGraphicFontTexture@@XZ:PROC ; CGraphicText::GetFontTexturePointer
EXTRN	?GetWidth@CGraphicImage@@QBEHXZ:PROC		; CGraphicImage::GetWidth
EXTRN	?Render@CGraphicImageInstance@@QAEXXZ:PROC	; CGraphicImageInstance::Render
EXTRN	?SetPosition@CGraphicImageInstance@@QAEXMM@Z:PROC ; CGraphicImageInstance::SetPosition
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?GetHeight@CGraphicImageInstance@@QAEHXZ:PROC	; CGraphicImageInstance::GetHeight
EXTRN	?New@CGraphicImageInstance@@SAPAV1@XZ:PROC	; CGraphicImageInstance::New
EXTRN	?Delete@CGraphicImageInstance@@SAXPAV1@@Z:PROC	; CGraphicImageInstance::Delete
EXTRN	??_ECGraphicTextInstance@@UAEPAXI@Z:PROC	; CGraphicTextInstance::`vector deleting destructor'
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z:PROC ; CStateManager::DrawPrimitive
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	?DrawIndexedPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIIPBXW4_D3DFORMAT@@1I@Z:PROC ; CStateManager::DrawIndexedPrimitiveUP
EXTRN	?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::GetRenderState
EXTRN	?GetCurPos@CIME@@SAHXZ:PROC			; CIME::GetCurPos
EXTRN	?GetCompLen@CIME@@SAHXZ:PROC			; CIME::GetCompLen
EXTRN	?GetULBegin@CIME@@SAHXZ:PROC			; CIME::GetULBegin
EXTRN	?GetULEnd@CIME@@SAHXZ:PROC			; CIME::GetULEnd
EXTRN	?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z:PROC ; GetTextTag
EXTRN	?Ymir_WideCharToMultiByte@@YAHIKPB_WHPADHPBDPAH@Z:PROC ; Ymir_WideCharToMultiByte
EXTRN	?Ymir_MultiByteToWideChar@@YAHIKPBDHPA_WH@Z:PROC ; Ymir_MultiByteToWideChar
EXTRN	?Arabic_ConvSymbol@@YA_W_W@Z:PROC		; Arabic_ConvSymbol
EXTRN	?Arabic_IsInSymbol@@YA_N_W@Z:PROC		; Arabic_IsInSymbol
EXTRN	?Arabic_IsInPresentation@@YA_N_W@Z:PROC		; Arabic_IsInPresentation
EXTRN	?Arabic_HasPresentation@@YA_NPA_WH@Z:PROC	; Arabic_HasPresentation
EXTRN	?Arabic_MakeShape@@YAIPA_WI0I@Z:PROC		; Arabic_MakeShape
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?IsFileExist@CResourceManager@@QAE_NPBD@Z:PROC	; CResourceManager::IsFileExist
EXTRN	?GetDefaultCodePage@@YAKXZ:PROC			; GetDefaultCodePage
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	__ftol3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?gs_mx@@3HA DD	01H DUP (?)				; gs_mx
?gs_my@@3HA DD	01H DUP (?)				; gs_my
?pkDefaultFont_RELOAD@@3PAVCGraphicText@@A DD 01H DUP (?) ; pkDefaultFont_RELOAD
?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A DQ 01H DUP (?) ; GraphicTextInstances
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CGraphicTextInstance@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CGraphicTextInstance@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@401c000000000000
CONST	SEGMENT
__real@401c000000000000 DQ 0401c000000000000r	; 7
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicTextInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicTextInstance@@8 DD FLAT:??_R0?AVCGraphicTextInstance@@@8 ; CGraphicTextInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicTextInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicTextInstance@@8
rdata$r	SEGMENT
??_R2CGraphicTextInstance@@8 DD FLAT:??_R1A@?0A@EA@CGraphicTextInstance@@8 ; CGraphicTextInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicTextInstance@@8
rdata$r	SEGMENT
??_R3CGraphicTextInstance@@8 DD 00H			; CGraphicTextInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicTextInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicTextInstance@@@8
data$rs	SEGMENT
??_R0?AVCGraphicTextInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicTextInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicTextInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CGraphicTextInstance@@6B@
rdata$r	SEGMENT
??_R4CGraphicTextInstance@@6B@ DD 00H			; CGraphicTextInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGraphicTextInstance@@@8
	DD	FLAT:??_R3CGraphicTextInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@FOMBDJDA@CGraphicTextInstance?3?3Update?5?9?5@
CONST	SEGMENT
??_C@_0DG@FOMBDJDA@CGraphicTextInstance?3?3Update?5?9?5@ DB 'CGraphicText'
	DB	'Instance::Update - Font has not been set', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DJBDGBIO@icon?1emoji?1?$CFs?4png@
CONST	SEGMENT
??_C@_0BC@DJBDGBIO@icon?1emoji?1?$CFs?4png@ DB 'icon/emoji/%s.png', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NHBNKCLI@icon?1?$CFs?4tga@
CONST	SEGMENT
??_C@_0M@NHBNKCLI@icon?1?$CFs?4tga@ DB 'icon/%s.tga', 00H ; `string'
CONST	ENDS
;	COMDAT ?pathList@?KJ@??Update@CGraphicTextInstance@@QAEXXZ@4PAPBDA
_DATA	SEGMENT
?pathList@?KJ@??Update@CGraphicTextInstance@@QAEXXZ@4PAPBDA DD FLAT:??_C@_0M@NHBNKCLI@icon?1?$CFs?4tga@ ; `CGraphicTextInstance::Update'::`169'::pathList
	DD	FLAT:??_C@_0BC@DJBDGBIO@icon?1emoji?1?$CFs?4png@
	DD	FLAT:??_C@_02DKCKIIND@?$CFs@
_DATA	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_7CGraphicTextInstance@@6B@
CONST	SEGMENT
??_7CGraphicTextInstance@@6B@ DD FLAT:??_R4CGraphicTextInstance@@6B@ ; CGraphicTextInstance::`vftable'
	DD	FLAT:??_ECGraphicTextInstance@@UAEPAXI@Z
CONST	ENDS
_DATA	SEGMENT
?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@ ; CGraphicTextInstance::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A DW 00H ; gs_hyperlinkText
	DB	18 DUP(00H)
	DD	07H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z$0
__ehfuncinfo$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABQAVCGraphicTextInstance@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@1@ABQAVCGraphicTextInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABQAVCGraphicTextInstance@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@1@ABQAVCGraphicTextInstance@@@Z$0
__ehfuncinfo$??$?0ABQAVCGraphicTextInstance@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@1@ABQAVCGraphicTextInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABQAVCGraphicTextInstance@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@1@ABQAVCGraphicTextInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@ABQAVCGraphicTextInstance@@@?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAU?$_List_node@PAVCGraphicTextInstance@@PAX@1@QAU21@ABQAVCGraphicTextInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@ABQAVCGraphicTextInstance@@@?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAU?$_List_node@PAVCGraphicTextInstance@@PAX@1@QAU21@ABQAVCGraphicTextInstance@@@Z$1
__ehfuncinfo$??$_Emplace@ABQAVCGraphicTextInstance@@@?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAU?$_List_node@PAVCGraphicTextInstance@@PAX@1@QAU21@ABQAVCGraphicTextInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@ABQAVCGraphicTextInstance@@@?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEPAU?$_List_node@PAVCGraphicTextInstance@@PAX@1@QAU21@ABQAVCGraphicTextInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z$1
__ehfuncinfo$?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?push_back@?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z$1
__ehfuncinfo$?push_back@?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCGraphicTextInstance@@@@QAEPAVCGraphicTextInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?New@CGraphicTextInstance@@SAPAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?New@CGraphicTextInstance@@SAPAV1@XZ$0
__ehfuncinfo$?New@CGraphicTextInstance@@SAPAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?New@CGraphicTextInstance@@SAPAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CRef@VCGraphicText@@@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Update@CGraphicTextInstance@@QAEXXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Update@CGraphicTextInstance@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Update@CGraphicTextInstance@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CGraphicTextInstance@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1CGraphicTextInstance@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CGraphicTextInstance@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CGraphicTextInstance@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0CGraphicTextInstance@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CGraphicTextInstance@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$5
xdata$x	ENDS
CRT$XCU	SEGMENT
?gs_hyperlinkText$initializer$@@3P6AXXZA DD FLAT:??__Egs_hyperlinkText@@YAXXZ ; gs_hyperlinkText$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?GraphicTextInstances$initializer$@@3P6AXXZA DD FLAT:??__EGraphicTextInstances@@YAXXZ ; GraphicTextInstances$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAUSCharacterInfomation@CGraphicFontTexture@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QBDQAPAU12@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAUSCharacterInfomation@CGraphicFontTexture@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QBDQAPAU12@II@Z PROC ; std::_Copy_memmove_tail<CGraphicFontTexture::SCharacterInfomation * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAUSCharacterInfomation@CGraphicFontTexture@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QBDQAPAU12@II@Z ENDP ; std::_Copy_memmove_tail<CGraphicFontTexture::SCharacterInfomation * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAK@std@@YAPAKQBDQAKII@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAK@std@@YAPAKQBDQAKII@Z PROC	; std::_Copy_memmove_tail<unsigned long *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAK@std@@YAPAKQBDQAKII@Z ENDP	; std::_Copy_memmove_tail<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAUSEmoji@CGraphicTextInstance@@@std@@YAPAUSEmoji@CGraphicTextInstance@@QBDQAU12@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAUSEmoji@CGraphicTextInstance@@@std@@YAPAUSEmoji@CGraphicTextInstance@@QBDQAU12@II@Z PROC ; std::_Copy_memmove_tail<CGraphicTextInstance::SEmoji *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAUSEmoji@CGraphicTextInstance@@@std@@YAPAUSEmoji@CGraphicTextInstance@@QBDQAU12@II@Z ENDP ; std::_Copy_memmove_tail<CGraphicTextInstance::SEmoji *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@QBDQAPAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@QBDQAPAV1@II@Z PROC ; std::_Copy_memmove_tail<CGraphicTextInstance * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@QBDQAPAV1@II@Z ENDP ; std::_Copy_memmove_tail<CGraphicTextInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z PROC ; std::_Copy_memmove<CGraphicFontTexture::SCharacterInfomation * *,CGraphicFontTexture::SCharacterInfomation * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAUSCharacterInfomation@CGraphicFontTexture@@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@QBDQAPAU12@II@Z ; std::_Copy_memmove_tail<CGraphicFontTexture::SCharacterInfomation * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z ENDP ; std::_Copy_memmove<CGraphicFontTexture::SCharacterInfomation * *,CGraphicFontTexture::SCharacterInfomation * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z PROC		; std::_Copy_memmove<unsigned long *,unsigned long *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAK@std@@YAPAKQBDQAKII@Z ; std::_Copy_memmove_tail<unsigned long *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z ENDP		; std::_Copy_memmove<unsigned long *,unsigned long *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAUSEmoji@CGraphicTextInstance@@PAU12@@std@@YAPAUSEmoji@CGraphicTextInstance@@PAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUSEmoji@CGraphicTextInstance@@PAU12@@std@@YAPAUSEmoji@CGraphicTextInstance@@PAU12@00@Z PROC ; std::_Copy_memmove<CGraphicTextInstance::SEmoji *,CGraphicTextInstance::SEmoji *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 03	 sar	 eax, 3

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAUSEmoji@CGraphicTextInstance@@@std@@YAPAUSEmoji@CGraphicTextInstance@@QBDQAU12@II@Z ; std::_Copy_memmove_tail<CGraphicTextInstance::SEmoji *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAUSEmoji@CGraphicTextInstance@@PAU12@@std@@YAPAUSEmoji@CGraphicTextInstance@@PAU12@00@Z ENDP ; std::_Copy_memmove<CGraphicTextInstance::SEmoji *,CGraphicTextInstance::SEmoji *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CGraphicTextInstance * *,CGraphicTextInstance * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCGraphicTextInstance@@@std@@YAPAPAVCGraphicTextInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CGraphicTextInstance * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CGraphicTextInstance * *,CGraphicTextInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  0000a	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000d	74 6f		 je	 SHORT $LN72@Uninitiali
  0000f	53		 push	 ebx

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00010	8b de		 mov	 ebx, esi
  00012	8d 48 18	 lea	 ecx, DWORD PTR [eax+24]
  00015	57		 push	 edi
  00016	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00019	2b d8		 sub	 ebx, eax
  0001b	0f 1f 44 00 00	 npad	 5
$LL4@Uninitiali:
  00020	0f b7 41 e8	 movzx	 eax, WORD PTR [ecx-24]

; 1808 :         ++_Last;

  00024	8d 49 1c	 lea	 ecx, DWORD PTR [ecx+28]
  00027	66 89 06	 mov	 WORD PTR [esi], ax

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  0002a	8d 51 e8	 lea	 edx, DWORD PTR [ecx-24]
  0002d	0f b7 41 ce	 movzx	 eax, WORD PTR [ecx-50]

; 1808 :         ++_Last;

  00031	8d 7f 1c	 lea	 edi, DWORD PTR [edi+28]
  00034	66 89 47 e2	 mov	 WORD PTR [edi-30], ax
  00038	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0003b	0f 11 47 e4	 movups	 XMMWORD PTR [edi-28], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  0003f	c7 47 f4 00 00
	00 00		 mov	 DWORD PTR [edi-12], 0

; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00046	33 c0		 xor	 eax, eax

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00048	c7 44 19 e4 00
	00 00 00	 mov	 DWORD PTR [ecx+ebx-28], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  00050	83 c6 1c	 add	 esi, 28			; 0000001cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00053	0f 10 41 d0	 movups	 xmm0, XMMWORD PTR [ecx-48]
  00057	0f 11 47 e4	 movups	 XMMWORD PTR [edi-28], xmm0
  0005b	f3 0f 7e 41 e0	 movq	 xmm0, QWORD PTR [ecx-32]
  00060	66 0f d6 47 f4	 movq	 QWORD PTR [edi-12], xmm0

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

  00065	c7 41 e0 00 00
	00 00		 mov	 DWORD PTR [ecx-32], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  0006c	c7 41 e4 07 00
	00 00		 mov	 DWORD PTR [ecx-28], 7

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00073	66 89 41 d0	 mov	 WORD PTR [ecx-48], ax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  00077	3b 55 0c	 cmp	 edx, DWORD PTR __Last$[ebp]
  0007a	75 a4		 jne	 SHORT $LL4@Uninitiali
  0007c	5f		 pop	 edi
  0007d	5b		 pop	 ebx
$LN72@Uninitiali:

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1963 :     }
; 1964 : 
; 1965 :     return _Backout._Release();
; 1966 : }

  0007e	8b c6		 mov	 eax, esi
  00080	5e		 pop	 esi
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Reallocation_guard@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Reallocation_guard::~_Reallocation_guard, COMDAT
; _this$ = ecx

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 606  :             if (_New_begin != nullptr) {

  00003	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00007	74 52		 je	 SHORT $LN22@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

  00009	56		 push	 esi
  0000a	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]
  0000d	57		 push	 edi
  0000e	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00011	3b f7		 cmp	 esi, edi
  00013	74 0e		 je	 SHORT $LN7@Reallocati
$LL8@Reallocati:
  00015	8b ce		 mov	 ecx, esi
  00017	e8 00 00 00 00	 call	 ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
  0001c	83 c6 1c	 add	 esi, 28			; 0000001cH
  0001f	3b f7		 cmp	 esi, edi
  00021	75 f2		 jne	 SHORT $LL8@Reallocati
$LN7@Reallocati:

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00026	5f		 pop	 edi
  00027	5e		 pop	 esi
  00028	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  0002f	2b c8		 sub	 ecx, eax
  00031	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00034	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00037	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003d	72 12		 jb	 SHORT $LN33@Reallocati

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003f	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00042	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00045	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00047	83 c0 fc	 add	 eax, -4			; fffffffcH
  0004a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004d	77 0e		 ja	 SHORT $LN30@Reallocati

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004f	8b c2		 mov	 eax, edx
$LN33@Reallocati:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00051	51		 push	 ecx
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00058	83 c4 08	 add	 esp, 8
$LN22@Reallocati:
  0005b	5b		 pop	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 610  :         }

  0005c	c3		 ret	 0
$LN30@Reallocati:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN45@Reallocati:
  00062	cc		 int	 3
??1_Reallocation_guard@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@USHyperlink@CGraphicTextInstance@@ABU12@@?$_Default_allocator_traits@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@USHyperlink@CGraphicTextInstance@@@1@QAUSHyperlink@CGraphicTextInstance@@ABU34@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
__New_capacity$1 = 16					; size = 4
??$construct@USHyperlink@CGraphicTextInstance@@ABU12@@?$_Default_allocator_traits@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@USHyperlink@CGraphicTextInstance@@@1@QAUSHyperlink@CGraphicTextInstance@@ABU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<CGraphicTextInstance::SHyperlink> >::construct<CGraphicTextInstance::SHyperlink,CGraphicTextInstance::SHyperlink const &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00011	8d 71 04	 lea	 esi, DWORD PTR [ecx+4]
  00014	66 89 01	 mov	 WORD PTR [ecx], ax
  00017	8d 5a 04	 lea	 ebx, DWORD PTR [edx+4]
  0001a	0f b7 42 02	 movzx	 eax, WORD PTR [edx+2]
  0001e	66 89 41 02	 mov	 WORD PTR [ecx+2], ax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00022	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00025	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0002c	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 434  :         return _Myres > _Small_string_capacity;

  00033	83 7b 14 07	 cmp	 DWORD PTR [ebx+20], 7
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00037	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 694  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00038	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]

; 426  :         if (_Large_mode_engaged()) {

  0003b	76 02		 jbe	 SHORT $LN22@construct

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0003d	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN22@construct:

; 857  :         if (_Count > max_size()) {

  0003f	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00045	77 66		 ja	 SHORT $LN55@construct

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();
; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

  00047	83 ff 07	 cmp	 edi, 7
  0004a	77 15		 ja	 SHORT $LN30@construct

; 866  :             _My_data._Mysize = _Count;

  0004c	89 7e 10	 mov	 DWORD PTR [esi+16], edi

; 867  :             _My_data._Myres  = _Small_string_capacity;

  0004f	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00056	0f 10 03	 movups	 xmm0, XMMWORD PTR [ebx]
  00059	5f		 pop	 edi
  0005a	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 734  :     }

  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
$LN30@construct:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00061	8b c7		 mov	 eax, edi
  00063	83 c8 07	 or	 eax, 7
  00066	3d fe ff ff 7f	 cmp	 eax, 2147483646		; 7ffffffeH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006b	76 07		 jbe	 SHORT $LN36@construct

; 2944 :             return _Max;

  0006d	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  00072	eb 0a		 jmp	 SHORT $LN35@construct
$LN36@construct:

; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 2948 :             return _Max;
; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00074	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00079	3b c1		 cmp	 eax, ecx
  0007b	0f 42 c1	 cmovb	 eax, ecx
$LN35@construct:

; 887  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

  0007e	89 45 10	 mov	 DWORD PTR __New_capacity$1[ebp], eax

; 888  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00081	8d 45 10	 lea	 eax, DWORD PTR __New_capacity$1[ebp]
  00084	50		 push	 eax
  00085	56		 push	 esi
  00086	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>

; 892  :         _My_data._Myres  = _New_capacity;

  0008b	8b 4d 10	 mov	 ecx, DWORD PTR __New_capacity$1[ebp]
  0008e	89 4e 14	 mov	 DWORD PTR [esi+20], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00091	8d 0c 7d 02 00
	00 00		 lea	 ecx, DWORD PTR [edi*2+2]
  00098	51		 push	 ecx
  00099	53		 push	 ebx
  0009a	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0009b	89 06		 mov	 DWORD PTR [esi], eax

; 890  : 
; 891  :         _My_data._Mysize = _Count;

  0009d	89 7e 10	 mov	 DWORD PTR [esi+16], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a0	e8 00 00 00 00	 call	 _memcpy
  000a5	83 c4 14	 add	 esp, 20			; 00000014H
  000a8	5f		 pop	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 734  :     }

  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
$LN55@construct:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 858  :             _Xlen_string(); // result too long

  000ad	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN53@construct:
  000b2	cc		 int	 3
??$construct@USHyperlink@CGraphicTextInstance@@ABU12@@?$_Default_allocator_traits@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@USHyperlink@CGraphicTextInstance@@@1@QAUSHyperlink@CGraphicTextInstance@@ABU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<CGraphicTextInstance::SHyperlink> >::construct<CGraphicTextInstance::SHyperlink,CGraphicTextInstance::SHyperlink const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 1
??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z PROC	; std::_Find_vectorized<char const ,char>, COMDAT

; 199  : _Ty* _Find_vectorized(_Ty* const _First, _Ty* const _Last, const _TVal _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 200  :     if constexpr (is_pointer_v<_TVal> || is_null_pointer_v<_TVal>) {
; 201  : #ifdef _WIN64
; 202  :         return const_cast<_Ty*>(
; 203  :             static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, reinterpret_cast<uint64_t>(_Val))));
; 204  : #else
; 205  :         return const_cast<_Ty*>(
; 206  :             static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, reinterpret_cast<uint32_t>(_Val))));
; 207  : #endif
; 208  :     } else if constexpr (sizeof(_Ty) == 1) {
; 209  :         return const_cast<_Ty*>(

  00003	ff 75 10	 push	 DWORD PTR __Val$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00009	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000c	e8 00 00 00 00	 call	 ___std_find_trivial_1@12

; 210  :             static_cast<const _Ty*>(::__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 211  :     } else if constexpr (sizeof(_Ty) == 2) {
; 212  :         return const_cast<_Ty*>(
; 213  :             static_cast<const _Ty*>(::__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 214  :     } else if constexpr (sizeof(_Ty) == 4) {
; 215  :         return const_cast<_Ty*>(
; 216  :             static_cast<const _Ty*>(::__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 217  :     } else if constexpr (sizeof(_Ty) == 8) {
; 218  :         return const_cast<_Ty*>(
; 219  :             static_cast<const _Ty*>(::__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 220  :     } else {
; 221  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 222  :     }
; 223  : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z ENDP	; std::_Find_vectorized<char const ,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv652 = -8						; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_reallocate<CGraphicFontTexture::SCharacterInfomation * const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 09 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004a	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv652[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00069	0f 87 c7 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00076	89 45 f8	 mov	 DWORD PTR tv652[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a1	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv650[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	3b d8		 cmp	 ebx, eax
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z ; std::_Copy_memmove<CGraphicFontTexture::SCharacterInfomation * *,CGraphicFontTexture::SCharacterInfomation * *>
  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@@std@@YAPAPAUSCharacterInfomation@CGraphicFontTexture@@PAPAU12@00@Z ; std::_Copy_memmove<CGraphicFontTexture::SCharacterInfomation * *,CGraphicFontTexture::SCharacterInfomation * *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00116	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00118	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR tv652[ebp]
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@CAXXZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_reallocate<CGraphicFontTexture::SCharacterInfomation * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKQAKABK@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv652 = -8						; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKQAKABK@Z PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 09 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004a	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv652[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00069	0f 87 c7 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00076	89 45 f8	 mov	 DWORD PTR tv652[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a1	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv650[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	3b d8		 cmp	 ebx, eax
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z ; std::_Copy_memmove<unsigned long *,unsigned long *>
  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAKPAK@std@@YAPAKPAK00@Z ; std::_Copy_memmove<unsigned long *,unsigned long *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00116	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00118	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR tv652[ebp]
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKQAKABK@Z ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Guard$ = -52						; size = 20
tv566 = -32						; size = 4
__Newsize$1$ = -28					; size = 4
_this$1$ = -24						; size = 4
__Whereoff$1$ = -20					; size = 4
$T2 = -20						; size = 4
tv567 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_reallocate<CGraphicTextInstance::SHyperlink const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f9		 mov	 edi, ecx
  0002a	89 7d e8	 mov	 DWORD PTR _this$1$[ebp], edi

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0002d	8b 75 08	 mov	 esi, DWORD PTR __Whereptr$[ebp]
  00030	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00035	2b 37		 sub	 esi, DWORD PTR [edi]

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00037	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  0003a	2b 0f		 sub	 ecx, DWORD PTR [edi]
  0003c	f7 ee		 imul	 esi
  0003e	03 d6		 add	 edx, esi
  00040	c1 fa 04	 sar	 edx, 4
  00043	8b c2		 mov	 eax, edx
  00045	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00048	03 c2		 add	 eax, edx
  0004a	89 45 ec	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  0004d	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00052	f7 e9		 imul	 ecx
  00054	03 d1		 add	 edx, ecx
  00056	c1 fa 04	 sar	 edx, 4
  00059	8b c2		 mov	 eax, edx
  0005b	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0005e	03 c2		 add	 eax, edx

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  00060	3d 49 92 24 09	 cmp	 eax, 153391689		; 09249249H
  00065	0f 84 9a 01 00
	00		 je	 $LN115@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0006e	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00071	2b 0f		 sub	 ecx, DWORD PTR [edi]
  00073	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00078	f7 e9		 imul	 ecx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0007a	b8 49 92 24 09	 mov	 eax, 153391689		; 09249249H

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0007f	89 5d e4	 mov	 DWORD PTR __Newsize$1$[ebp], ebx

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00082	03 d1		 add	 edx, ecx
  00084	c1 fa 04	 sar	 edx, 4
  00087	8b ca		 mov	 ecx, edx
  00089	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0008c	03 ca		 add	 ecx, edx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0008e	8b d1		 mov	 edx, ecx
  00090	d1 ea		 shr	 edx, 1
  00092	2b c2		 sub	 eax, edx
  00094	3b c8		 cmp	 ecx, eax
  00096	76 19		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00098	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0009d	c7 45 f0 fc ff
	ff ff		 mov	 DWORD PTR tv567[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a4	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1997 :             return _Max; // geometric growth would overflow

  000a5	be 49 92 24 09	 mov	 esi, 153391689		; 09249249H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000aa	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000af	eb 42		 jmp	 SHORT $LN113@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000b1	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  000b4	8b f3		 mov	 esi, ebx
  000b6	3b c3		 cmp	 eax, ebx
  000b8	0f 43 f0	 cmovae	 esi, eax
  000bb	81 fe 49 92 24
	09		 cmp	 esi, 153391689		; 09249249H
  000c1	0f 87 43 01 00
	00		 ja	 $LN116@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  000c7	8d 04 f5 00 00
	00 00		 lea	 eax, DWORD PTR [esi*8]
  000ce	2b c6		 sub	 eax, esi
  000d0	c1 e0 02	 shl	 eax, 2
  000d3	89 45 f0	 mov	 DWORD PTR tv567[ebp], eax

; 227  :     if (_Bytes == 0) {

  000d6	85 c0		 test	 eax, eax
  000d8	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  000da	33 db		 xor	 ebx, ebx
  000dc	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000de	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000e3	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000eb	eb 06		 jmp	 SHORT $LN113@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  000ed	50		 push	 eax
  000ee	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN113@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000f3	8b d8		 mov	 ebx, eax
  000f5	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  000f8	8b 4d ec	 mov	 ecx, DWORD PTR __Whereoff$1$[ebp]

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  000fb	89 7d cc	 mov	 DWORD PTR __Guard$[ebp], edi
  000fe	89 5d d0	 mov	 DWORD PTR __Guard$[ebp+4], ebx
  00101	89 75 d4	 mov	 DWORD PTR __Guard$[ebp+8], esi
  00104	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  0010b	2b c1		 sub	 eax, ecx
  0010d	8d 0c 83	 lea	 ecx, DWORD PTR [ebx+eax*4]
  00110	8d 41 1c	 lea	 eax, DWORD PTR [ecx+28]
  00113	89 4d e0	 mov	 DWORD PTR tv566[ebp], ecx
  00116	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00119	89 45 d8	 mov	 DWORD PTR __Guard$[ebp+12], eax
  0011c	89 45 dc	 mov	 DWORD PTR __Guard$[ebp+16], eax

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;
; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0011f	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  00122	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00129	51		 push	 ecx
  0012a	57		 push	 edi
  0012b	e8 00 00 00 00	 call	 ??$construct@USHyperlink@CGraphicTextInstance@@ABU12@@?$_Default_allocator_traits@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@USHyperlink@CGraphicTextInstance@@@1@QAUSHyperlink@CGraphicTextInstance@@ABU34@@Z ; std::_Default_allocator_traits<std::allocator<CGraphicTextInstance::SHyperlink> >::construct<CGraphicTextInstance::SHyperlink,CGraphicTextInstance::SHyperlink const &>

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00130	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  00133	83 c4 0c	 add	 esp, 12			; 0000000cH
  00136	8b 75 08	 mov	 esi, DWORD PTR __Whereptr$[ebp]
  00139	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0013b	3b f2		 cmp	 esi, edx
  0013d	75 04		 jne	 SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

  0013f	8b c3		 mov	 eax, ebx

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

  00141	eb 14		 jmp	 SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

  00143	57		 push	 edi
  00144	53		 push	 ebx
  00145	56		 push	 esi
  00146	51		 push	 ecx
  00147	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >

; 896  :             _Constructed_first = _Newvec;
; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  0014c	8b 57 04	 mov	 edx, DWORD PTR [edi+4]
  0014f	83 c4 10	 add	 esp, 16			; 00000010H
  00152	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00155	8b ce		 mov	 ecx, esi
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  00157	57		 push	 edi
  00158	50		 push	 eax
  00159	52		 push	 edx
  0015a	51		 push	 ecx
  0015b	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@YAPAUSHyperlink@CGraphicTextInstance@@QAU12@0PAU12@AAV?$allocator@USHyperlink@CGraphicTextInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicTextInstance::SHyperlink *,std::allocator<CGraphicTextInstance::SHyperlink> >

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00160	8b 37		 mov	 esi, DWORD PTR [edi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  00162	83 c4 10	 add	 esp, 16			; 00000010H

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00165	85 f6		 test	 esi, esi
  00167	74 64		 je	 SHORT $LN51@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  00169	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  0016c	3b f0		 cmp	 esi, eax
  0016e	74 13		 je	 SHORT $LN36@Emplace_re
  00170	8b f8		 mov	 edi, eax
$LL37@Emplace_re:
  00172	8b ce		 mov	 ecx, esi
  00174	e8 00 00 00 00	 call	 ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
  00179	83 c6 1c	 add	 esi, 28			; 0000001cH
  0017c	3b f7		 cmp	 esi, edi
  0017e	75 f2		 jne	 SHORT $LL37@Emplace_re
  00180	8b 7d e8	 mov	 edi, DWORD PTR _this$1$[ebp]
$LN36@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00183	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00186	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0018b	8b 37		 mov	 esi, DWORD PTR [edi]
  0018d	2b ce		 sub	 ecx, esi
  0018f	f7 e9		 imul	 ecx
  00191	03 d1		 add	 edx, ecx
  00193	c1 fa 04	 sar	 edx, 4
  00196	8b c2		 mov	 eax, edx
  00198	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0019b	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0019d	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  001a4	2b c8		 sub	 ecx, eax
  001a6	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001a9	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001af	72 12		 jb	 SHORT $LN62@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001b1	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  001b4	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001b7	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001b9	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  001bc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001bf	77 3f		 ja	 SHORT $LN59@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001c1	8b f2		 mov	 esi, edx
$LN62@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001c3	51		 push	 ecx
  001c4	56		 push	 esi
  001c5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001ca	83 c4 08	 add	 esp, 8
$LN51@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  001cd	8b 55 e4	 mov	 edx, DWORD PTR __Newsize$1$[ebp]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  001d0	8b 45 e0	 mov	 eax, DWORD PTR tv566[ebp]

; 2060 :         _Myfirst = _Newvec;

  001d3	89 1f		 mov	 DWORD PTR [edi], ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  001d5	8d 0c d5 00 00
	00 00		 lea	 ecx, DWORD PTR [edx*8]
  001dc	2b ca		 sub	 ecx, edx
  001de	8d 0c 8b	 lea	 ecx, DWORD PTR [ebx+ecx*4]
  001e1	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  001e4	8b 4d f0	 mov	 ecx, DWORD PTR tv567[ebp]
  001e7	03 cb		 add	 ecx, ebx
  001e9	89 4f 08	 mov	 DWORD PTR [edi+8], ecx

; 903  :     }

  001ec	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001f6	59		 pop	 ecx
  001f7	5f		 pop	 edi
  001f8	5e		 pop	 esi
  001f9	5b		 pop	 ebx
  001fa	8b e5		 mov	 esp, ebp
  001fc	5d		 pop	 ebp
  001fd	c2 08 00	 ret	 8
$LN59@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00200	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN115@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00205	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Xlength
$LN116@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0020a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN112@Emplace_re:
  0020f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Reallocation_guard@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Reallocation_guard::~_Reallocation_guard
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_reallocate<CGraphicTextInstance::SHyperlink const &>
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSEmoji@CGraphicTextInstance@@@?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@AAEPAUSEmoji@CGraphicTextInstance@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Newsize$1$ = -8					; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUSEmoji@CGraphicTextInstance@@@?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@AAEPAUSEmoji@CGraphicTextInstance@@QAU23@ABU23@@Z PROC ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::_Emplace_reallocate<CGraphicTextInstance::SEmoji const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 03	 sar	 ebx, 3
  0001a	c1 f8 03	 sar	 eax, 3

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  00022	0f 84 07 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 03	 sar	 edx, 3

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 1f	 mov	 eax, 536870911		; 1fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 f8 ff ff ff	 mov	 eax, -8			; fffffff8H
  0004a	c7 45 fc f8 ff
	ff ff		 mov	 DWORD PTR tv650[ebp], -8 ; fffffff8H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	1f		 cmp	 ecx, 536870911		; 1fffffffH
  00069	0f 87 c5 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00076	89 45 fc	 mov	 DWORD PTR tv650[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 1c df	 lea	 ebx, DWORD PTR [edi+ebx*8]
  000a1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a6	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a9	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  000ac	89 0b		 mov	 DWORD PTR [ebx], ecx
  000ae	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000b1	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b3	3b c2		 cmp	 eax, edx
  000b5	75 04		 jne	 SHORT $LN3@Emplace_re
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b c7		 mov	 eax, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 14		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	50		 push	 eax
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSEmoji@CGraphicTextInstance@@PAU12@@std@@YAPAUSEmoji@CGraphicTextInstance@@PAU12@00@Z ; std::_Copy_memmove<CGraphicTextInstance::SEmoji *,CGraphicTextInstance::SEmoji *>
  000c3	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c6	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000c9	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN52@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 900  :         _Guard._New_begin = nullptr;

  000cf	50		 push	 eax
  000d0	52		 push	 edx
  000d1	51		 push	 ecx
  000d2	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSEmoji@CGraphicTextInstance@@PAU12@@std@@YAPAUSEmoji@CGraphicTextInstance@@PAU12@00@Z ; std::_Copy_memmove<CGraphicTextInstance::SEmoji *,CGraphicTextInstance::SEmoji *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d7	8b 06		 mov	 eax, DWORD PTR [esi]

; 900  :         _Guard._New_begin = nullptr;

  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000dc	85 c0		 test	 eax, eax
  000de	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e0	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e3	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e5	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000e8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ee	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f3	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f6	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f8	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fb	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fe	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00100	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00102	51		 push	 ecx
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00109	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010c	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  0010f	89 3e		 mov	 DWORD PTR [esi], edi
  00111	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00114	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00116	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00119	8b 4d fc	 mov	 ecx, DWORD PTR tv650[ebp]
  0011c	03 cf		 add	 ecx, edi

; 903  :     }

  0011e	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011f	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00122	5e		 pop	 esi
  00123	5b		 pop	 ebx
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  0012f	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00134	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  00139	cc		 int	 3
??$_Emplace_reallocate@ABUSEmoji@CGraphicTextInstance@@@?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@AAEPAUSEmoji@CGraphicTextInstance@@QAU23@ABU23@@Z ENDP ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::_Emplace_reallocate<CGraphicTextInstance::SEmoji const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CGraphicTextInstance *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CGraphicTextInstance *,void *> > >, COMDAT
; _this$ = ecx

; 1168 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN10@Alloc_cons

; 289  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 0c		 push	 12			; 0000000cH
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN10@Alloc_cons:

; 1169 :             _Al.deallocate(_Ptr, 1);
; 1170 :         }
; 1171 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CGraphicTextInstance *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CGraphicTextInstance *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z
_TEXT	SEGMENT
_this$1$ = -12						; size = 4
__New_size$1$ = -8					; size = 4
__Su$1$ = -8						; size = 4
__Old_size$1$ = -4					; size = 4
__Size_increase$ = 8					; size = 4
$T1 = 8							; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 2
??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>, COMDAT
; _this$ = ecx

; 2988 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2989 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 2990 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 2991 :         auto& _My_data            = _Mypair._Myval2;
; 2992 :         const size_type _Old_size = _My_data._Mysize;
; 2993 :         if (max_size() - _Old_size < _Size_increase) {

  00006	8b 55 08	 mov	 edx, DWORD PTR __Size_increase$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	b9 fe ff ff 7f	 mov	 ecx, 2147483646		; 7ffffffeH
  00013	8b c1		 mov	 eax, ecx
  00015	89 7d f4	 mov	 DWORD PTR _this$1$[ebp], edi
  00018	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  0001b	2b c3		 sub	 eax, ebx
  0001d	89 5d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ebx
  00020	3b c2		 cmp	 eax, edx
  00022	0f 82 40 01 00
	00		 jb	 $LN108@Reallocate

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

  00028	8b 77 14	 mov	 esi, DWORD PTR [edi+20]
  0002b	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  0002e	8b d8		 mov	 ebx, eax

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;

  00030	89 45 f8	 mov	 DWORD PTR __New_size$1$[ebp], eax

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00033	83 cb 07	 or	 ebx, 7

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

  00036	89 75 08	 mov	 DWORD PTR $T1[ebp], esi

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00039	3b d9		 cmp	 ebx, ecx

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0003b	76 18		 jbe	 SHORT $LN10@Reallocate

; 2944 :             return _Max;

  0003d	8b d9		 mov	 ebx, ecx
$LN105@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0003f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00044	03 c0		 add	 eax, eax
$LN28@Reallocate:
  00046	50		 push	 eax
  00047	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0004c	72 35		 jb	 SHORT $LN29@Reallocate

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00053	eb 33		 jmp	 SHORT $LN106@Reallocate
$LN10@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00055	8b c6		 mov	 eax, esi
  00057	d1 e8		 shr	 eax, 1
  00059	2b c8		 sub	 ecx, eax
  0005b	3b f1		 cmp	 esi, ecx
  0005d	76 07		 jbe	 SHORT $LN11@Reallocate

; 2948 :             return _Max;

  0005f	bb fe ff ff 7f	 mov	 ebx, 2147483646		; 7ffffffeH
  00064	eb d9		 jmp	 SHORT $LN105@Reallocate
$LN11@Reallocate:

; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00066	03 c6		 add	 eax, esi
  00068	3b d8		 cmp	 ebx, eax
  0006a	0f 42 d8	 cmovb	 ebx, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0006d	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00070	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00075	0f 87 f2 00 00
	00		 ja	 $LN109@Reallocate

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0007b	03 c0		 add	 eax, eax

; 227  :     if (_Bytes == 0) {

  0007d	75 c7		 jne	 SHORT $LN28@Reallocate

; 228  :         return nullptr;

  0007f	33 f6		 xor	 esi, esi
  00081	eb 0a		 jmp	 SHORT $LN27@Reallocate
$LN29@Reallocate:

; 136  :         return ::operator new(_Bytes);

  00083	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN106@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3005 :         _My_data._Mysize      = _New_size;

  00088	8b f0		 mov	 esi, eax
  0008a	83 c4 04	 add	 esp, 4
$LN27@Reallocate:

; 3006 :         _My_data._Myres       = _New_capacity;
; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);
; 3008 :         if (_Old_capacity > _Small_string_capacity) {

  0008d	83 7d 08 07	 cmp	 DWORD PTR $T1[ebp], 7
  00091	8b 45 f8	 mov	 eax, DWORD PTR __New_size$1$[ebp]
  00094	89 5f 14	 mov	 DWORD PTR [edi+20], ebx
  00097	8b 5d fc	 mov	 ebx, DWORD PTR __Old_size$1$[ebp]
  0009a	89 47 10	 mov	 DWORD PTR [edi+16], eax
  0009d	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  000a0	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  000a3	89 4d f8	 mov	 DWORD PTR __Su$1$[ebp], ecx
  000a6	50		 push	 eax
  000a7	76 78		 jbe	 SHORT $LN3@Reallocate

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000a9	8b 1f		 mov	 ebx, DWORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ab	53		 push	 ebx
  000ac	56		 push	 esi
  000ad	e8 00 00 00 00	 call	 _memcpy
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 511  :         for (; 0 < _N; ++_Su, --_N)

  000b2	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b5	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 511  :         for (; 0 < _N; ++_Su, --_N)

  000b8	85 c0		 test	 eax, eax
  000ba	74 1e		 je	 SHORT $LN47@Reallocate
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3009 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000bc	8b 7d f8	 mov	 edi, DWORD PTR __Su$1$[ebp]
  000bf	8b c8		 mov	 ecx, eax
  000c1	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  000c4	0f b7 d0	 movzx	 edx, ax
  000c7	8b c2		 mov	 eax, edx
  000c9	c1 e2 10	 shl	 edx, 16			; 00000010H
  000cc	0b c2		 or	 eax, edx
  000ce	d1 e9		 shr	 ecx, 1
  000d0	f3 ab		 rep stosd
  000d2	13 c9		 adc	 ecx, ecx
  000d4	66 f3 ab	 rep stosw
  000d7	8b 7d f4	 mov	 edi, DWORD PTR _this$1$[ebp]
$LN47@Reallocate:

; 1531 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000da	8b 45 fc	 mov	 eax, DWORD PTR __Old_size$1$[ebp]
  000dd	33 c9		 xor	 ecx, ecx
  000df	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]
  000e2	66 89 0c 46	 mov	 WORD PTR [esi+eax*2], cx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e6	8b 45 08	 mov	 eax, DWORD PTR $T1[ebp]
  000e9	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000f0	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f6	72 12		 jb	 SHORT $LN68@Reallocate

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f8	8b 53 fc	 mov	 edx, DWORD PTR [ebx-4]
  000fb	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fe	2b da		 sub	 ebx, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00100	8d 43 fc	 lea	 eax, DWORD PTR [ebx-4]
  00103	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00106	77 6a		 ja	 SHORT $LN65@Reallocate

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00108	8b da		 mov	 ebx, edx
$LN68@Reallocate:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0010a	51		 push	 ecx
  0010b	53		 push	 ebx
  0010c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00111	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3019 :         return *this;

  00114	89 37		 mov	 DWORD PTR [edi], esi
  00116	8b c7		 mov	 eax, edi

; 3020 :     }

  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx
  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 10 00	 ret	 16			; 00000010H
$LN3@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00121	57		 push	 edi
  00122	56		 push	 esi
  00123	e8 00 00 00 00	 call	 _memcpy
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 511  :         for (; 0 < _N; ++_Su, --_N)

  00128	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 511  :         for (; 0 < _N; ++_Su, --_N)

  0012e	85 c0		 test	 eax, eax
  00130	74 21		 je	 SHORT $LN83@Reallocate
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00132	8b 7d f8	 mov	 edi, DWORD PTR __Su$1$[ebp]
  00135	8b c8		 mov	 ecx, eax
  00137	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0013a	0f b7 d0	 movzx	 edx, ax
  0013d	8b c2		 mov	 eax, edx
  0013f	c1 e2 10	 shl	 edx, 16			; 00000010H
  00142	0b c2		 or	 eax, edx
  00144	d1 e9		 shr	 ecx, 1
  00146	f3 ab		 rep stosd
  00148	13 c9		 adc	 ecx, ecx
  0014a	66 f3 ab	 rep stosw
  0014d	8b 7d f4	 mov	 edi, DWORD PTR _this$1$[ebp]
  00150	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
$LN83@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1531 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00153	03 c3		 add	 eax, ebx
  00155	33 c9		 xor	 ecx, ecx
  00157	66 89 0c 46	 mov	 WORD PTR [esi+eax*2], cx

; 3019 :         return *this;

  0015b	8b c7		 mov	 eax, edi
  0015d	89 37		 mov	 DWORD PTR [edi], esi

; 3020 :     }

  0015f	5f		 pop	 edi
  00160	5e		 pop	 esi
  00161	5b		 pop	 ebx
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c2 10 00	 ret	 16			; 00000010H
$LN108@Reallocate:

; 2994 :             _Xlen_string(); // result too long

  00168	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN109@Reallocate:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0016d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN65@Reallocate:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00172	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN104@Reallocate:
  00177	cc		 int	 3
??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?IsValidToken@@YA_NPBD@Z
_TEXT	SEGMENT
_iter$ = 8						; size = 4
?IsValidToken@@YA_NPBD@Z PROC				; IsValidToken, COMDAT

; 142  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 143  : 	return	iter[0]=='@' &&

  00004	8b 75 08	 mov	 esi, DWORD PTR _iter$[ebp]
  00007	80 3e 40	 cmp	 BYTE PTR [esi], 64	; 00000040H
  0000a	75 49		 jne	 SHORT $LN3@IsValidTok
  0000c	0f b6 46 01	 movzx	 eax, BYTE PTR [esi+1]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ?isNumberic@@YA_ND@Z	; isNumberic
  00016	83 c4 04	 add	 esp, 4
  00019	84 c0		 test	 al, al
  0001b	74 38		 je	 SHORT $LN3@IsValidTok
  0001d	0f b6 46 02	 movzx	 eax, BYTE PTR [esi+2]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ?isNumberic@@YA_ND@Z	; isNumberic
  00027	83 c4 04	 add	 esp, 4
  0002a	84 c0		 test	 al, al
  0002c	74 27		 je	 SHORT $LN3@IsValidTok
  0002e	0f b6 46 03	 movzx	 eax, BYTE PTR [esi+3]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?isNumberic@@YA_ND@Z	; isNumberic
  00038	83 c4 04	 add	 esp, 4
  0003b	84 c0		 test	 al, al
  0003d	74 16		 je	 SHORT $LN3@IsValidTok
  0003f	0f b6 46 04	 movzx	 eax, BYTE PTR [esi+4]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ?isNumberic@@YA_ND@Z	; isNumberic
  00049	83 c4 04	 add	 esp, 4
  0004c	84 c0		 test	 al, al
  0004e	74 05		 je	 SHORT $LN3@IsValidTok
  00050	b0 01		 mov	 al, 1
  00052	5e		 pop	 esi

; 144  : 		isNumberic(iter[1]) &&
; 145  : 		isNumberic(iter[2]) &&
; 146  : 		isNumberic(iter[3]) &&
; 147  : 		isNumberic(iter[4]);
; 148  : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN3@IsValidTok:

; 143  : 	return	iter[0]=='@' &&

  00055	32 c0		 xor	 al, al
  00057	5e		 pop	 esi

; 144  : 		isNumberic(iter[1]) &&
; 145  : 		isNumberic(iter[2]) &&
; 146  : 		isNumberic(iter[3]) &&
; 147  : 		isNumberic(iter[4]);
; 148  : }

  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?IsValidToken@@YA_NPBD@Z ENDP				; IsValidToken
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?isNumberic@@YA_ND@Z
_TEXT	SEGMENT
_chr$ = 8						; size = 1
?isNumberic@@YA_ND@Z PROC				; isNumberic, COMDAT

; 135  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 136  : 	if (chr >= '0' && chr <= '9')

  00003	8a 45 08	 mov	 al, BYTE PTR _chr$[ebp]
  00006	2c 30		 sub	 al, 48			; 00000030H
  00008	3c 09		 cmp	 al, 9
  0000a	0f 96 c0	 setbe	 al

; 137  : 		return true;
; 138  : 	return false;
; 139  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?isNumberic@@YA_ND@Z ENDP				; isNumberic
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z
_TEXT	SEGMENT
__Op$2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_t$ = 8							; size = 4
_add$ = 12						; size = 1
?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z PROC ; __GraphicTextInstancesList, COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 57   : 	if (!t)

  00027	8b 75 08	 mov	 esi, DWORD PTR _t$[ebp]
  0002a	85 f6		 test	 esi, esi
  0002c	0f 84 9d 00 00
	00		 je	 $LN206@GraphicTex

; 58   : 	{
; 59   : 		return;
; 60   : 	}
; 61   : 
; 62   : 	if (add)

  00032	80 7d 0c 00	 cmp	 BYTE PTR _add$[ebp], 0
  00036	74 5c		 je	 SHORT $LN3@GraphicTex
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 1020 :         if (_Mysize == max_size()) {

  00038	81 3d 04 00 00
	00 55 55 55 15	 cmp	 DWORD PTR ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A+4, 357913941 ; 15555555H

; 1264 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  00042	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A

; 1020 :         if (_Mysize == max_size()) {

  00048	0f 84 92 00 00
	00		 je	 $LN218@GraphicTex
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1156 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0004e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __Op$2[ebp], OFFSET ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A ; GraphicTextInstances

; 136  :         return ::operator new(_Bytes);

  00055	6a 0c		 push	 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 583  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00057	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1163 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0005e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Op$2[ebp+4], 0

; 136  :         return ::operator new(_Bytes);

  00065	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0006a	83 c4 04	 add	 esp, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 585  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0006d	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 1025 :         ++_Mysize;

  00070	ff 05 04 00 00
	00		 inc	 DWORD PTR ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A+4

; 598  :         const pointer _Insert_after = _Insert_before->_Prev;

  00076	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 599  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00079	89 38		 mov	 DWORD PTR [eax], edi

; 600  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  0007b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 601  :         const auto _Result    = this->_Ptr;
; 602  :         this->_Ptr            = pointer{};
; 603  :         _Insert_before->_Prev = _Result;

  0007e	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 604  :         _Insert_after->_Next  = _Result;

  00081	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 73   : }

  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN3@GraphicTex:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00094	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A
  0009a	8b 01		 mov	 eax, DWORD PTR [ecx]

; 72   :         return _Ptr == _Right._Ptr;

  0009c	3b c1		 cmp	 eax, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 6175 :     for (; _First != _Last; ++_First) {

  0009e	74 2f		 je	 SHORT $LN206@GraphicTex
$LL123@GraphicTex:

; 6176 :         if (*_First == _Val) {

  000a0	39 70 08	 cmp	 DWORD PTR [eax+8], esi
  000a3	74 06		 je	 SHORT $LN209@GraphicTex
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 50   :         _Ptr = _Ptr->_Next;

  000a5	8b 00		 mov	 eax, DWORD PTR [eax]

; 72   :         return _Ptr == _Right._Ptr;

  000a7	3b c1		 cmp	 eax, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 6175 :     for (; _First != _Last; ++_First) {

  000a9	75 f5		 jne	 SHORT $LL123@GraphicTex
$LN209@GraphicTex:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  000ab	3b c1		 cmp	 eax, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 69   : 	if (it != GraphicTextInstances.end())

  000ad	74 20		 je	 SHORT $LN206@GraphicTex
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 395  :         _Pnode->_Prev->_Next = _Pnode->_Next;

  000af	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b4	6a 0c		 push	 12			; 0000000cH
  000b6	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 395  :         _Pnode->_Prev->_Next = _Pnode->_Next;

  000b7	89 0a		 mov	 DWORD PTR [edx], ecx

; 396  :         _Pnode->_Next->_Prev = _Pnode->_Prev;

  000b9	8b 10		 mov	 edx, DWORD PTR [eax]
  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 397  :         --_Mysize;

  000c1	ff 0d 04 00 00
	00		 dec	 DWORD PTR ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A+4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000c7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000cc	83 c4 08	 add	 esp, 8
$LN206@GraphicTex:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 73   : }

  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d9	59		 pop	 ecx
  000da	5f		 pop	 edi
  000db	5e		 pop	 esi
  000dc	8b e5		 mov	 esp, ebp
  000de	5d		 pop	 ebp
  000df	c3		 ret	 0
$LN218@GraphicTex:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 1021 :             _Xlength_error("list too long");

  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  000e5	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN215@GraphicTex:
  000ea	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z$1:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Op$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAVCGraphicTextInstance@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CGraphicTextInstance *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CGraphicTextInstance *,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z ENDP ; __GraphicTextInstancesList
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?GraphicTextInstancesReload@@YAXPAVCGraphicText@@@Z
_TEXT	SEGMENT
_pkDefaultFont$ = 8					; size = 4
?GraphicTextInstancesReload@@YAXPAVCGraphicText@@@Z PROC ; GraphicTextInstancesReload, COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 37   : 	pkDefaultFont_RELOAD = pkDefaultFont;

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _pkDefaultFont$[ebp]
  0000b	56		 push	 esi
  0000c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?pkDefaultFont_RELOAD@@3PAVCGraphicText@@A, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 37   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00012	8b 30		 mov	 esi, DWORD PTR [eax]
  00014	3b f0		 cmp	 esi, eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 40   : 	for (; it != GraphicTextInstances.end(); it++)

  00016	74 3a		 je	 SHORT $LN3@GraphicTex
  00018	57		 push	 edi
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@GraphicTex:

; 41   : 	{
; 42   : 
; 43   : 		CGraphicTextInstance * t = *(it);

  00020	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 44   : 		if (!t || t->GetDynamicFontOff())

  00023	85 ff		 test	 edi, edi
  00025	74 24		 je	 SHORT $LN2@GraphicTex
  00027	80 7f 44 00	 cmp	 BYTE PTR [edi+68], 0
  0002b	75 1e		 jne	 SHORT $LN2@GraphicTex

; 45   : 		{
; 46   : 			continue;
; 47   : 		}
; 48   : 
; 49   : 		t->SetTextPointer(pkDefaultFont_RELOAD);

  0002d	51		 push	 ecx
  0002e	8b cf		 mov	 ecx, edi
  00030	e8 00 00 00 00	 call	 ?SetTextPointer@CGraphicTextInstance@@QAEXPAVCGraphicText@@@Z ; CGraphicTextInstance::SetTextPointer

; 51   : 		t->Update();

  00035	8b cf		 mov	 ecx, edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h

; 76   : 		void DisableUpdate() { m_isUpdate = false; }

  00037	c6 47 45 00	 mov	 BYTE PTR [edi+69], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 51   : 		t->Update();

  0003b	e8 00 00 00 00	 call	 ?Update@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Update
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?pkDefaultFont_RELOAD@@3PAVCGraphicText@@A
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A
$LN2@GraphicTex:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 164  :         this->_Ptr = this->_Ptr->_Next;

  0004b	8b 36		 mov	 esi, DWORD PTR [esi]

; 197  :         return this->_Ptr == _Right._Ptr;

  0004d	3b f0		 cmp	 esi, eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 40   : 	for (; it != GraphicTextInstances.end(); it++)

  0004f	75 cf		 jne	 SHORT $LL4@GraphicTex
  00051	5f		 pop	 edi
$LN3@GraphicTex:
  00052	5e		 pop	 esi

; 52   : 	}
; 53   : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
?GraphicTextInstancesReload@@YAXPAVCGraphicText@@@Z ENDP ; GraphicTextInstancesReload
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??__FGraphicTextInstances@@YAXXZ
text$yd	SEGMENT
??__FGraphicTextInstances@@YAXXZ PROC			; `dynamic atexit destructor for 'GraphicTextInstances'', COMDAT
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 1508 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00009	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 01		 mov	 eax, DWORD PTR [ecx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00011	85 c0		 test	 eax, eax
  00013	74 15		 je	 SHORT $LN71@dynamic
  00015	56		 push	 esi
$LL12@dynamic:

; 328  :             _Pnext = _Pnode->_Next;

  00016	8b 30		 mov	 esi, DWORD PTR [eax]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00018	6a 0c		 push	 12			; 0000000cH
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00020	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00023	8b c6		 mov	 eax, esi
  00025	85 f6		 test	 esi, esi
  00027	75 ed		 jne	 SHORT $LL12@dynamic
  00029	5e		 pop	 esi
$LN71@dynamic:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002a	6a 0c		 push	 12			; 0000000cH
  0002c	ff 35 00 00 00
	00		 push	 DWORD PTR ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00037	83 c4 08	 add	 esp, 8
  0003a	c3		 ret	 0
??__FGraphicTextInstances@@YAXXZ ENDP			; `dynamic atexit destructor for 'GraphicTextInstances''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ??__EGraphicTextInstances@@YAXXZ
text$di	SEGMENT
??__EGraphicTextInstances@@YAXXZ PROC			; `dynamic initializer for 'GraphicTextInstances'', COMDAT
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 136  :         return ::operator new(_Bytes);

  00000	6a 0c		 push	 12			; 0000000cH
  00002	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 33   : t_GraphicTextInstances GraphicTextInstances;

  00007	68 00 00 00 00	 push	 OFFSET ??__FGraphicTextInstances@@YAXXZ ; `dynamic atexit destructor for 'GraphicTextInstances''
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\list

; 1844 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  0000c	89 00		 mov	 DWORD PTR [eax], eax

; 1845 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0000e	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1846 :         _Mypair._Myval2._Myhead = _Newhead;

  00011	a3 00 00 00 00	 mov	 DWORD PTR ?GraphicTextInstances@@3V?$list@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@A, eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 33   : t_GraphicTextInstances GraphicTextInstances;

  00016	e8 00 00 00 00	 call	 _atexit
  0001b	83 c4 08	 add	 esp, 8
  0001e	c3		 ret	 0
??__EGraphicTextInstances@@YAXXZ ENDP			; `dynamic initializer for 'GraphicTextInstances''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??__Fgs_hyperlinkText@@YAXXZ
text$yd	SEGMENT
??__Fgs_hyperlinkText@@YAXXZ PROC			; `dynamic atexit destructor for 'gs_hyperlinkText'', COMDAT

; 434  :         return _Myres > _Small_string_capacity;

  00000	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+20
  00006	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 35		 jbe	 SHORT $LN23@dynamic
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  00011	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00018	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 14		 jb	 SHORT $LN34@dynamic

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00022	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00025	83 c1 23	 add	 ecx, 35			; 00000023H
  00028	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00030	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn
$LN34@dynamic:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00036	51		 push	 ecx
  00037	52		 push	 edx
  00038	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003d	83 c4 08	 add	 esp, 8
$LN23@dynamic:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	33 c0		 xor	 eax, eax
  00042	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16, 0
  0004c	c7 05 14 00 00
	00 07 00 00 00	 mov	 DWORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+20, 7
  00056	66 a3 00 00 00
	00		 mov	 WORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A, ax
  0005c	c3		 ret	 0
??__Fgs_hyperlinkText@@YAXXZ ENDP			; `dynamic atexit destructor for 'gs_hyperlinkText''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ??__Egs_hyperlinkText@@YAXXZ
text$di	SEGMENT
??__Egs_hyperlinkText@@YAXXZ PROC			; `dynamic initializer for 'gs_hyperlinkText'', COMDAT

; 26   : static std::wstring gs_hyperlinkText;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_hyperlinkText@@YAXXZ ; `dynamic atexit destructor for 'gs_hyperlinkText''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_hyperlinkText@@YAXXZ ENDP			; `dynamic initializer for 'gs_hyperlinkText''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CGraphicTextInstance::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A ; CGraphicTextInstance::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
??__F?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CGraphicTextInstance::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ??__E?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CGraphicTextInstance::ms_kPool'', COMDAT

; 21   : CDynamicPool<CGraphicTextInstance>		CGraphicTextInstance::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CGraphicTextInstance::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CGraphicTextInstance::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CGraphicTextInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCGraphicTextInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CGraphicTextInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();
; 2047 :         auto& _My_data    = _Mypair._Myval2;
; 2048 :         pointer& _Myfirst = _My_data._Myfirst;
; 2049 :         pointer& _Mylast  = _My_data._Mylast;
; 2050 :         pointer& _Myend   = _My_data._Myend;
; 2051 : 
; 2052 :         _My_data._Orphan_all();
; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 06		 mov	 eax, DWORD PTR [esi]
  00008	85 c0		 test	 eax, eax
  0000a	74 2c		 je	 SHORT $LN10@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000f	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN21@Change_arr

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 28		 ja	 SHORT $LN18@Change_arr

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN21@Change_arr:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN10@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2060 :         _Myfirst = _Newvec;

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0003b	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0003e	89 0e		 mov	 DWORD PTR [esi], ecx
  00040	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00043	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00046	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00049	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 2064 :     }

  00050	5d		 pop	 ebp
  00051	c2 0c 00	 ret	 12			; 0000000cH
$LN18@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00054	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@Change_arr:
  00059	cc		 int	 3
?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
__Size$1$ = 8						; size = 4
?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::reserve, COMDAT
; _this$ = ecx

; 1708 :     _CONSTEXPR20 void reserve(_CRT_GUARDOVERFLOW size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1709 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1710 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	8b 16		 mov	 edx, DWORD PTR [esi]
  0000e	2b c2		 sub	 eax, edx
  00010	c1 f8 02	 sar	 eax, 2

; 1709 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1710 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00013	3b c8		 cmp	 ecx, eax
  00015	0f 86 95 00 00
	00		 jbe	 $LN71@reserve

; 1711 :             if (_Newcapacity > max_size()) {

  0001b	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00021	0f 87 93 00 00
	00		 ja	 $LN97@reserve

; 1634 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00027	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0002a	53		 push	 ebx
  0002b	2b c2		 sub	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  0002d	8d 1c 8d 00 00
	00 00		 lea	 ebx, DWORD PTR [ecx*4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1634 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00034	c1 f8 02	 sar	 eax, 2
  00037	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax
  0003a	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  0003b	85 db		 test	 ebx, ebx
  0003d	75 04		 jne	 SHORT $LN20@reserve

; 228  :         return nullptr;

  0003f	33 ff		 xor	 edi, edi
  00041	eb 1a		 jmp	 SHORT $LN19@reserve
$LN20@reserve:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00043	53		 push	 ebx
  00044	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0004a	72 07		 jb	 SHORT $LN21@reserve

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00051	eb 05		 jmp	 SHORT $LN95@reserve
$LN21@reserve:

; 136  :         return ::operator new(_Bytes);

  00053	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN95@reserve:

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  00058	8b f8		 mov	 edi, eax
  0005a	83 c4 04	 add	 esp, 4
$LN19@reserve:
  0005d	57		 push	 edi
  0005e	ff 76 04	 push	 DWORD PTR [esi+4]
  00061	ff 36		 push	 DWORD PTR [esi]
  00063	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicTextInstance * *,CGraphicTextInstance * *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00068	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  0006d	85 c0		 test	 eax, eax
  0006f	74 2c		 je	 SHORT $LN47@reserve

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00071	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00074	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00076	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00079	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0007f	72 12		 jb	 SHORT $LN58@reserve

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00081	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00084	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00087	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00089	83 c0 fc	 add	 eax, -4			; fffffffcH
  0008c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0008f	77 24		 ja	 SHORT $LN55@reserve

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00091	8b c2		 mov	 eax, edx
$LN58@reserve:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00093	51		 push	 ecx
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0009a	83 c4 08	 add	 esp, 8
$LN47@reserve:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0009d	8b 45 08	 mov	 eax, DWORD PTR __Size$1$[ebp]
  000a0	89 3e		 mov	 DWORD PTR [esi], edi
  000a2	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  000a5	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  000a8	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  000ab	5f		 pop	 edi
  000ac	89 46 08	 mov	 DWORD PTR [esi+8], eax
  000af	5b		 pop	 ebx
$LN71@reserve:
  000b0	5e		 pop	 esi

; 1713 :             }
; 1714 : 
; 1715 :             _Reallocate<_Reallocation_policy::_At_least>(_Newcapacity);
; 1716 :         }
; 1717 :     }

  000b1	5d		 pop	 ebp
  000b2	c2 04 00	 ret	 4
$LN55@reserve:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b5	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN97@reserve:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1712 :                 _Xlength();

  000ba	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlength
$LN94@reserve:
  000bf	cc		 int	 3
?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -12					; size = 4
tv621 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
$T1 = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z PROC ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::push_back, COMDAT
; _this$ = ecx

; 917  :     _CONSTEXPR20 void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 829  :         if (_Mylast != _My_data._Myend) {

  0000b	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0000e	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00011	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  00014	3b ca		 cmp	 ecx, edx
  00016	74 14		 je	 SHORT $LN4@push_back

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00018	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  0001f	83 46 04 04	 add	 DWORD PTR [esi+4], 4

; 919  :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
$LN4@push_back:

; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0002c	8b 3e		 mov	 edi, DWORD PTR [esi]
  0002e	8b c1		 mov	 eax, ecx
  00030	2b c7		 sub	 eax, edi
  00032	c1 f8 02	 sar	 eax, 2
  00035	89 45 f4	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);
; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  00038	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0003d	0f 84 c0 00 00
	00		 je	 $LN106@push_back

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00043	2b d7		 sub	 edx, edi

; 876  :         const size_type _Newsize = _Oldsize + 1;

  00045	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00048	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0004b	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00050	8b fa		 mov	 edi, edx

; 876  :         const size_type _Newsize = _Oldsize + 1;

  00052	89 5d f8	 mov	 DWORD PTR __Newsize$1$[ebp], ebx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00055	d1 ef		 shr	 edi, 1
  00057	2b c7		 sub	 eax, edi
  00059	3b d0		 cmp	 edx, eax
  0005b	76 12		 jbe	 SHORT $LN15@push_back

; 1997 :             return _Max; // geometric growth would overflow

  0005d	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00062	bb ff ff ff 3f	 mov	 ebx, 1073741823		; 3fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0006d	eb 38		 jmp	 SHORT $LN104@push_back
$LN15@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0006f	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00072	3b c3		 cmp	 eax, ebx
  00074	0f 43 d8	 cmovae	 ebx, eax
  00077	81 fb ff ff ff
	3f		 cmp	 ebx, 1073741823		; 3fffffffH
  0007d	0f 87 85 00 00
	00		 ja	 $LN107@push_back

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00083	8d 04 9d 00 00
	00 00		 lea	 eax, DWORD PTR [ebx*4]

; 227  :     if (_Bytes == 0) {

  0008a	85 c0		 test	 eax, eax
  0008c	75 04		 jne	 SHORT $LN30@push_back

; 228  :         return nullptr;

  0008e	33 ff		 xor	 edi, edi
  00090	eb 1d		 jmp	 SHORT $LN29@push_back
$LN30@push_back:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00092	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00097	72 08		 jb	 SHORT $LN31@push_back

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0009f	eb 06		 jmp	 SHORT $LN104@push_back
$LN31@push_back:

; 136  :         return ::operator new(_Bytes);

  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN104@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  000aa	8b f8		 mov	 edi, eax
  000ac	83 c4 04	 add	 esp, 4
$LN29@push_back:
  000af	8b 45 f4	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  000b2	8d 14 87	 lea	 edx, DWORD PTR [edi+eax*4]
  000b5	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  000b8	89 55 f4	 mov	 DWORD PTR tv621[ebp], edx
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	89 02		 mov	 DWORD PTR [edx], eax

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000bf	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c2	8b 16		 mov	 edx, DWORD PTR [esi]
  000c4	3b c8		 cmp	 ecx, eax
  000c6	75 04		 jne	 SHORT $LN10@push_back
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000c8	8b cf		 mov	 ecx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000ca	eb 17		 jmp	 SHORT $LN59@push_back
$LN10@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cc	57		 push	 edi
  000cd	51		 push	 ecx
  000ce	52		 push	 edx
  000cf	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicTextInstance * *,CGraphicTextInstance * *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000d4	8b 4d f4	 mov	 ecx, DWORD PTR tv621[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000da	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000dd	83 c1 04	 add	 ecx, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000e0	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
$LN59@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 900  :         _Guard._New_begin = nullptr;

  000e3	51		 push	 ecx
  000e4	50		 push	 eax
  000e5	52		 push	 edx
  000e6	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicTextInstance@@PAPAV1@@std@@YAPAPAVCGraphicTextInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicTextInstance * *,CGraphicTextInstance * *>
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  000ee	8b ce		 mov	 ecx, esi
  000f0	53		 push	 ebx
  000f1	ff 75 f8	 push	 DWORD PTR __Newsize$1$[ebp]
  000f4	57		 push	 edi
  000f5	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@AAEXQAPAVCGraphicTextInstance@@II@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Change_array

; 919  :     }

  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5b		 pop	 ebx
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 04 00	 ret	 4
$LN106@push_back:

; 873  :             _Xlength();

  00103	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::_Xlength
$LN107@push_back:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00108	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN103@push_back:
  0010d	cc		 int	 3
?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ENDP ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ PROC	; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCGraphicTextInstance@@@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN37@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN56@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN56@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 2082 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN37@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN53@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN67@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@VCGraphicTextInstance@@@@UAE@XZ ENDP	; CDynamicPool<CGraphicTextInstance>::~CDynamicPool<CGraphicTextInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?ReadToken@@YAHPBD@Z
_TEXT	SEGMENT
_token$ = 8						; size = 4
?ReadToken@@YAHPBD@Z PROC				; ReadToken, COMDAT

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 171  : 	int nRet = (token[1]-'0')*1000 + (token[2]-'0')*100 + (token[3]-'0')*10 + (token[4]-'0');

  00003	8b 55 08	 mov	 edx, DWORD PTR _token$[ebp]
  00006	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  0000a	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  0000d	0f be 42 02	 movsx	 eax, BYTE PTR [edx+2]
  00011	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00014	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00017	0f be 42 03	 movsx	 eax, BYTE PTR [edx+3]
  0001b	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0001e	8d 0c 80	 lea	 ecx, DWORD PTR [eax+eax*4]
  00021	0f be 42 04	 movsx	 eax, BYTE PTR [edx+4]
  00025	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]

; 172  : 	if (nRet == 9999)

  00028	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  0002d	05 b0 2f ff ff	 add	 eax, -53328		; ffff2fb0H
  00032	3d 0f 27 00 00	 cmp	 eax, 9999		; 0000270fH
  00037	0f 44 c1	 cmove	 eax, ecx

; 173  : 		return CP_UTF8;
; 174  : 	return nRet;
; 175  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?ReadToken@@YAHPBD@Z ENDP				; ReadToken
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?FindToken@@YAPBDPBD0@Z
_TEXT	SEGMENT
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
?FindToken@@YAPBDPBD0@Z PROC				; FindToken, COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 152  : 	while(begin < end)

  00004	8b 75 08	 mov	 esi, DWORD PTR _begin$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR _end$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	73 2a		 jae	 SHORT $LN18@FindToken
  0000f	90		 npad	 1
$LL2@FindToken:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 6143 :             const auto _Result    = _STD _Find_vectorized(_First_ptr, _STD _To_address(_Last), _Val);

  00010	6a 40		 push	 64			; 00000040H
  00012	57		 push	 edi
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??$_Find_vectorized@$$CBDD@std@@YAPBDQBD0D@Z ; std::_Find_vectorized<char const ,char>
  00019	8b f0		 mov	 esi, eax
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 156  : 		if(end-begin>5 && IsValidToken(begin))

  0001e	8b c7		 mov	 eax, edi
  00020	2b c6		 sub	 eax, esi
  00022	83 f8 05	 cmp	 eax, 5
  00025	7e 0d		 jle	 SHORT $LN4@FindToken
  00027	56		 push	 esi
  00028	e8 00 00 00 00	 call	 ?IsValidToken@@YA_NPBD@Z ; IsValidToken
  0002d	83 c4 04	 add	 esp, 4
  00030	84 c0		 test	 al, al
  00032	75 0b		 jne	 SHORT $LN17@FindToken
$LN4@FindToken:

; 159  : 		}
; 160  : 		else
; 161  : 		{
; 162  : 			++begin;

  00034	46		 inc	 esi
  00035	3b f7		 cmp	 esi, edi
  00037	72 d7		 jb	 SHORT $LL2@FindToken
$LN18@FindToken:

; 163  : 		}
; 164  : 	}
; 165  : 
; 166  : 	return end;

  00039	8b c7		 mov	 eax, edi
  0003b	5f		 pop	 edi

; 167  : }

  0003c	5e		 pop	 esi
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
$LN17@FindToken:
  0003f	5f		 pop	 edi

; 157  : 		{
; 158  : 			return begin;

  00040	8b c6		 mov	 eax, esi

; 167  : }

  00042	5e		 pop	 esi
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?FindToken@@YAPBDPBD0@Z ENDP				; FindToken
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCGraphicTextInstance@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCGraphicTextInstance@@UAEPAXI@Z PROC		; CGraphicTextInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CGraphicTextInstance@@UAE@XZ ; CGraphicTextInstance::~CGraphicTextInstance
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 7c		 push	 124			; 0000007cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCGraphicTextInstance@@UAEPAXI@Z ENDP		; CGraphicTextInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Delete@CGraphicTextInstance@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkInst$ = 8						; size = 4
_pkData$ = 8						; size = 4
?Delete@CGraphicTextInstance@@SAXPAV1@@Z PROC		; CGraphicTextInstance::Delete, COMDAT

; 1151 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1152 : #ifdef ENABLE_DYNAMIC_FONTS
; 1153 : 	__GraphicTextInstancesList(pkInst, false);

  00004	8b 75 08	 mov	 esi, DWORD PTR _pkInst$[ebp]
  00007	6a 00		 push	 0
  00009	56		 push	 esi
  0000a	e8 00 00 00 00	 call	 ?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z ; __GraphicTextInstancesList
  0000f	83 c4 08	 add	 esp, 8

; 1154 : #endif
; 1155 : 
; 1156 : 	pkInst->Destroy();

  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ?Destroy@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Destroy
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 82   : 			m_kVct_pkFree.push_back(pkData);

  00019	8d 45 08	 lea	 eax, DWORD PTR _pkData$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1157 : 	ms_kPool.Free(pkInst);

  0001c	89 75 08	 mov	 DWORD PTR _pkData$[ebp], esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 82   : 			m_kVct_pkFree.push_back(pkData);

  0001f	50		 push	 eax
  00020	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+16
  00025	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::push_back
  0002a	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1158 : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?Delete@CGraphicTextInstance@@SAXPAV1@@Z ENDP		; CGraphicTextInstance::Delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?New@CGraphicTextInstance@@SAPAV1@XZ
_TEXT	SEGMENT
_pkNewData$2 = -16					; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?New@CGraphicTextInstance@@SAPAV1@XZ PROC		; CGraphicTextInstance::New, COMDAT

; 1140 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?New@CGraphicTextInstance@@SAPAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00024	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+20
  0002a	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+16, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 64   : 			if (m_kVct_pkFree.empty())

  00030	75 46		 jne	 SHORT $LN4@New

; 65   : 			{
; 66   : 				T* pkNewData=new T;

  00032	6a 7c		 push	 124			; 0000007cH
  00034	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00039	83 c4 04	 add	 esp, 4
  0003c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0003f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	85 c0		 test	 eax, eax
  00048	74 09		 je	 SHORT $LN6@New
  0004a	8b c8		 mov	 ecx, eax
  0004c	e8 00 00 00 00	 call	 ??0CGraphicTextInstance@@QAE@XZ ; CGraphicTextInstance::CGraphicTextInstance
  00051	eb 02		 jmp	 SHORT $LN7@New
$LN6@New:
  00053	33 c0		 xor	 eax, eax
$LN7@New:
  00055	89 45 f0	 mov	 DWORD PTR _pkNewData$2[ebp], eax

; 67   : 				m_kVct_pkData.push_back(pkNewData);

  00058	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+4
  0005d	8d 45 f0	 lea	 eax, DWORD PTR _pkNewData$2[ebp]
  00060	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXABQAVCGraphicTextInstance@@@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::push_back

; 68   : 				++m_uUsedCapacity;

  0006d	ff 05 20 00 00
	00		 inc	 DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+32

; 69   : 				return pkNewData;

  00073	8b 75 f0	 mov	 esi, DWORD PTR _pkNewData$2[ebp]
  00076	eb 0c		 jmp	 SHORT $LN3@New
$LN4@New:

; 70   : 			}
; 71   : 
; 72   : 			T* pkFreeData=m_kVct_pkFree.back();

  00078	8b 71 fc	 mov	 esi, DWORD PTR [ecx-4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1744 :         --_Mylast;

  0007b	83 c1 fc	 add	 ecx, -4			; fffffffcH
  0007e	89 0d 14 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+20, ecx
$LN3@New:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1143 : 	__GraphicTextInstancesList(t);

  00084	6a 01		 push	 1
  00086	56		 push	 esi
  00087	e8 00 00 00 00	 call	 ?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z ; __GraphicTextInstancesList
  0008c	83 c4 08	 add	 esp, 8

; 1144 : 	return t;

  0008f	8b c6		 mov	 eax, esi

; 1145 : #else
; 1146 : 	return ms_kPool.Alloc();
; 1147 : #endif
; 1148 : }

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	5e		 pop	 esi
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?New@CGraphicTextInstance@@SAPAV1@XZ$0:
  00000	6a 7c		 push	 124			; 0000007cH
  00002	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
__ehhandler$?New@CGraphicTextInstance@@SAPAV1@XZ:
  00014	90		 npad	 1
  00015	90		 npad	 1
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?New@CGraphicTextInstance@@SAPAV1@XZ
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?New@CGraphicTextInstance@@SAPAV1@XZ ENDP		; CGraphicTextInstance::New
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?DestroySystem@CGraphicTextInstance@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CGraphicTextInstance@@SAXXZ PROC		; CGraphicTextInstance::DestroySystem, COMDAT

; 1135 : {

  00000	56		 push	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  00001	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+4
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1135 : {

  00007	57		 push	 edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  00008	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+8
  0000e	3b f7		 cmp	 esi, edi
  00010	74 29		 je	 SHORT $LN12@DestroySys
$LL6@DestroySys:

; 111  : 			delete pkData;

  00012	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00014	85 c9		 test	 ecx, ecx
  00016	74 06		 je	 SHORT $LN4@DestroySys
  00018	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001a	6a 01		 push	 1
  0001c	ff 10		 call	 DWORD PTR [eax]
$LN4@DestroySys:

; 50   : 			for (auto v : m_kVct_pkData)

  0001e	83 c6 04	 add	 esi, 4
  00021	3b f7		 cmp	 esi, edi
  00023	75 ed		 jne	 SHORT $LL6@DestroySys
  00025	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+8
  0002b	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	3b f7		 cmp	 esi, edi
  00033	74 06		 je	 SHORT $LN12@DestroySys

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00035	89 35 08 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+8, esi
$LN12@DestroySys:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0003b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+16
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+20
  00048	74 05		 je	 SHORT $LN16@DestroySys

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0004a	a3 14 00 00 00	 mov	 DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+20, eax
$LN16@DestroySys:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1137 : }

  0004f	c3		 ret	 0
?DestroySystem@CGraphicTextInstance@@SAXXZ ENDP		; CGraphicTextInstance::DestroySystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?CreateSystem@CGraphicTextInstance@@SAXI@Z
_TEXT	SEGMENT
_uCapacity$ = 8						; size = 4
?CreateSystem@CGraphicTextInstance@@SAXI@Z PROC		; CGraphicTextInstance::CreateSystem, COMDAT

; 1130 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 58   : 			m_uInitCapacity=uCapacity;

  00004	8b 75 08	 mov	 esi, DWORD PTR _uCapacity$[ebp]

; 59   : 			m_kVct_pkData.reserve(uCapacity);

  00007	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+4
  0000c	56		 push	 esi
  0000d	89 35 1c 00 00
	00		 mov	 DWORD PTR ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+28, esi
  00013	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::reserve

; 60   : 			m_kVct_pkFree.reserve(uCapacity);

  00018	56		 push	 esi
  00019	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicTextInstance@@2V?$CDynamicPool@VCGraphicTextInstance@@@@A+16
  0001e	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCGraphicTextInstance@@V?$allocator@PAVCGraphicTextInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicTextInstance *,std::allocator<CGraphicTextInstance *> >::reserve
  00023	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1132 : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?CreateSystem@CGraphicTextInstance@@SAXI@Z ENDP		; CGraphicTextInstance::CreateSystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::~vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN5@vector

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 f8	 and	 ecx, -8			; fffffff8H

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00049	5e		 pop	 esi

; 820  :     }

  0004a	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00050	cc		 int	 3
??1?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::~vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::clear, COMDAT
; _this$ = ecx

; 1792 :     _CONSTEXPR20 void clear() noexcept { // erase all

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1793 :         auto& _My_data    = _Mypair._Myval2;
; 1794 :         pointer& _Myfirst = _My_data._Myfirst;
; 1795 :         pointer& _Mylast  = _My_data._Mylast;
; 1796 : 
; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00005	8b 33		 mov	 esi, DWORD PTR [ebx]
  00007	8b 7b 04	 mov	 edi, DWORD PTR [ebx+4]
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 15		 je	 SHORT $LN1@clear
  0000e	66 90		 npad	 2
$LL8@clear:
  00010	8b ce		 mov	 ecx, esi
  00012	e8 00 00 00 00	 call	 ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00017	83 c6 1c	 add	 esi, 28			; 0000001cH
  0001a	3b f7		 cmp	 esi, edi
  0001c	75 f2		 jne	 SHORT $LL8@clear
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1807 :         _Mylast = _Myfirst;

  0001e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00020	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$LN1@clear:

; 1808 :     }

  00023	5f		 pop	 edi
  00024	5e		 pop	 esi
  00025	5b		 pop	 ebx
  00026	c3		 ret	 0
?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::~vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	74 75		 je	 SHORT $LN5@vector
  0000a	53		 push	 ebx

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000b	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  0000e	3b f3		 cmp	 esi, ebx
  00010	74 0e		 je	 SHORT $LN10@vector
$LL11@vector:
  00012	8b ce		 mov	 ecx, esi
  00014	e8 00 00 00 00	 call	 ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
  00019	83 c6 1c	 add	 esi, 28			; 0000001cH
  0001c	3b f3		 cmp	 esi, ebx
  0001e	75 f2		 jne	 SHORT $LL11@vector
$LN10@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00020	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00023	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00028	8b 37		 mov	 esi, DWORD PTR [edi]
  0002a	2b ce		 sub	 ecx, esi
  0002c	f7 e9		 imul	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002e	5b		 pop	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0002f	03 d1		 add	 edx, ecx
  00031	c1 fa 04	 sar	 edx, 4
  00034	8b c2		 mov	 eax, edx
  00036	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00039	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0003b	8d 0c c5 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*8]
  00042	2b c8		 sub	 ecx, eax
  00044	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00047	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004d	72 12		 jb	 SHORT $LN36@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0004f	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00052	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00055	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00057	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0005a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005d	77 23		 ja	 SHORT $LN33@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0005f	8b f2		 mov	 esi, edx
$LN36@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00061	51		 push	 ecx
  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00068	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0006e	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00071	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 2082 :             _Myend   = nullptr;

  00078	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN5@vector:
  0007f	5f		 pop	 edi

; 820  :     }

  00080	5e		 pop	 esi
  00081	c3		 ret	 0
$LN33@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00082	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN49@vector:
  00087	cc		 int	 3
??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::~vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ PROC ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@KV?$allocator@K@std@@@std@@CAXXZ ENDP ; std::vector<unsigned long,std::allocator<unsigned long> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN5@vector

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00049	5e		 pop	 esi

; 820  :     }

  0004a	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00050	cc		 int	 3
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::~vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN5@vector

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0000c	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00011	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00019	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001c	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00029	8b c2		 mov	 eax, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002b	51		 push	 ecx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN5@vector:
  00049	5e		 pop	 esi

; 820  :     }

  0004a	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00050	cc		 int	 3
??1?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::~vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
;	COMDAT ??1?$CRef@VCGraphicText@@@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1?$CRef@VCGraphicText@@@@QAE@XZ PROC			; CRef<CGraphicText>::~CRef<CGraphicText>, COMDAT
; _this$ = ecx

; 37   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CRef@VCGraphicText@@@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 53   : 			if (m_pObject)

  00025	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00027	85 c9		 test	 ecx, ecx
  00029	74 0b		 je	 SHORT $LN5@CRef

; 54   : 			{
; 55   : 				m_pObject->Release();

  0002b	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  00030	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
$LN5@CRef:

; 38   : 			Clear();
; 39   : 		}

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	5e		 pop	 esi
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
  0004a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CRef@VCGraphicText@@@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CRef@VCGraphicText@@@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CRef@VCGraphicText@@@@QAE@XZ ENDP			; CRef<CGraphicText>::~CRef<CGraphicText>
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
_TEXT	SEGMENT
??1SHyperlink@CGraphicTextInstance@@QAE@XZ PROC		; CGraphicTextInstance::SHyperlink::~SHyperlink, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00006	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 2e		 jbe	 SHORT $LN24@SHyperlink
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0000e	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00015	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001b	72 12		 jb	 SHORT $LN35@SHyperlink

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00020	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00023	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00025	83 c0 fc	 add	 eax, -4			; fffffffcH
  00028	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002b	77 22		 ja	 SHORT $LN32@SHyperlink

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002d	8b c2		 mov	 eax, edx
$LN35@SHyperlink:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002f	51		 push	 ecx
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	83 c4 08	 add	 esp, 8
$LN24@SHyperlink:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00039	33 c0		 xor	 eax, eax
  0003b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00042	c7 46 18 07 00
	00 00		 mov	 DWORD PTR [esi+24], 7
  00049	66 89 46 04	 mov	 WORD PTR [esi+4], ax
  0004d	5e		 pop	 esi
  0004e	c3		 ret	 0
$LN32@SHyperlink:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN45@SHyperlink:
  00054	cc		 int	 3
??1SHyperlink@CGraphicTextInstance@@QAE@XZ ENDP		; CGraphicTextInstance::SHyperlink::~SHyperlink
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z PROC	; CGraphicTextInstance::__GetTextPos, COMDAT
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00006	0f 57 c9	 xorps	 xmm1, xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 111  : {

  00009	56		 push	 esi

; 112  : 	index = min(index, m_pCharInfoVector.size());

  0000a	8b 75 08	 mov	 esi, DWORD PTR _index$[ebp]
  0000d	0f 57 db	 xorps	 xmm3, xmm3
  00010	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00011	8b 79 4c	 mov	 edi, DWORD PTR [ecx+76]
  00014	0f 57 d2	 xorps	 xmm2, xmm2
  00017	2b c7		 sub	 eax, edi
  00019	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 112  : 	index = min(index, m_pCharInfoVector.size());

  0001c	3b f0		 cmp	 esi, eax
  0001e	0f 43 f0	 cmovae	 esi, eax

; 113  : 
; 114  : 	float sx = 0;

  00021	33 d2		 xor	 edx, edx

; 115  : 	float sy = 0;
; 116  : 	float fFontMaxHeight = 0;
; 117  : 
; 118  : 	for(DWORD i=0; i<index; ++i)

  00023	85 f6		 test	 esi, esi
  00025	74 46		 je	 SHORT $LN3@GetTextPos

; 119  : 	{
; 120  : 		if (sx+float(m_pCharInfoVector[i]->width) > m_fLimitWidth)

  00027	f3 0f 10 61 14	 movss	 xmm4, DWORD PTR [ecx+20]
  0002c	0f 1f 40 00	 npad	 4
$LL4@GetTextPos:
  00030	8b 0c 97	 mov	 ecx, DWORD PTR [edi+edx*4]
  00033	0f bf 41 02	 movsx	 eax, WORD PTR [ecx+2]
  00037	66 0f 6e c0	 movd	 xmm0, eax
  0003b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0003e	f3 0f 58 c1	 addss	 xmm0, xmm1
  00042	0f 2f c4	 comiss	 xmm0, xmm4
  00045	76 0a		 jbe	 SHORT $LN5@GetTextPos

; 121  : 		{
; 122  : 			sx = 0;
; 123  : 			sy += fFontMaxHeight;

  00047	0f 28 c2	 movaps	 xmm0, xmm2
  0004a	0f 57 c9	 xorps	 xmm1, xmm1
  0004d	f3 0f 58 d8	 addss	 xmm3, xmm0
$LN5@GetTextPos:

; 124  : 		}
; 125  : 
; 126  : 		sx += float(m_pCharInfoVector[i]->advance);
; 127  : 		fFontMaxHeight = max(float(m_pCharInfoVector[i]->height), fFontMaxHeight);

  00051	0f bf 41 04	 movsx	 eax, WORD PTR [ecx+4]
  00055	42		 inc	 edx
  00056	f3 0f 58 49 18	 addss	 xmm1, DWORD PTR [ecx+24]
  0005b	66 0f 6e c0	 movd	 xmm0, eax
  0005f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00062	f3 0f 5f c2	 maxss	 xmm0, xmm2
  00066	0f 28 d0	 movaps	 xmm2, xmm0
  00069	3b d6		 cmp	 edx, esi
  0006b	72 c3		 jb	 SHORT $LL4@GetTextPos
$LN3@GetTextPos:

; 128  : 	}
; 129  : 
; 130  : 	*x = sx;

  0006d	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]

; 131  : 	*y = sy;

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	f3 0f 11 08	 movss	 DWORD PTR [eax], xmm1
  00076	8b 45 10	 mov	 eax, DWORD PTR _y$[ebp]
  00079	f3 0f 11 18	 movss	 DWORD PTR [eax], xmm3

; 132  : }

  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z ENDP	; CGraphicTextInstance::__GetTextPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z
_TEXT	SEGMENT
_pFontTexture$ = 8					; size = 4
_codePage$ = 12						; size = 2
_pInsCharInfo$ = 16					; size = 4
_text$ = 16						; size = 2
_dwColor$ = 20						; size = 4
?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z PROC ; CGraphicTextInstance::__DrawCharacter, COMDAT
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 95   : 	CGraphicFontTexture::TCharacterInfomation* pInsCharInfo = pFontTexture->GetCharacterInfomation(codePage, text);

  00005	ff 75 10	 push	 DWORD PTR _text$[ebp]
  00008	8b f9		 mov	 edi, ecx
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pFontTexture$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR _codePage$[ebp]
  00010	e8 00 00 00 00	 call	 ?GetCharacterInfomation@CGraphicFontTexture@@QAEPAUSCharacterInfomation@1@G_W@Z ; CGraphicFontTexture::GetCharacterInfomation
  00015	8b d8		 mov	 ebx, eax
  00017	89 5d 10	 mov	 DWORD PTR _pInsCharInfo$[ebp], ebx
  0001a	85 db		 test	 ebx, ebx

; 96   : 
; 97   : 	if (pInsCharInfo)

  0001c	74 7b		 je	 SHORT $LN2@DrawCharac
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0001e	8b 4f 5c	 mov	 ecx, DWORD PTR [edi+92]
  00021	3b 4f 60	 cmp	 ecx, DWORD PTR [edi+96]
  00024	74 0b		 je	 SHORT $LN9@DrawCharac

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00026	8b 45 14	 mov	 eax, DWORD PTR _dwColor$[ebp]
  00029	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  0002b	83 47 5c 04	 add	 DWORD PTR [edi+92], 4

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002f	eb 0d		 jmp	 SHORT $LN8@DrawCharac
$LN9@DrawCharac:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00031	8d 55 14	 lea	 edx, DWORD PTR _dwColor$[ebp]
  00034	52		 push	 edx
  00035	51		 push	 ecx
  00036	8d 4f 58	 lea	 ecx, DWORD PTR [edi+88]
  00039	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABK@?$vector@KV?$allocator@K@std@@@std@@AAEPAKQAKABK@Z ; std::vector<unsigned long,std::allocator<unsigned long> >::_Emplace_reallocate<unsigned long const &>
$LN8@DrawCharac:

; 829  :         if (_Mylast != _My_data._Myend) {

  0003e	8b 47 50	 mov	 eax, DWORD PTR [edi+80]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 100  : 		m_pCharInfoVector.push_back(pInsCharInfo);

  00041	8d 4f 4c	 lea	 ecx, DWORD PTR [edi+76]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00044	3b 47 54	 cmp	 eax, DWORD PTR [edi+84]
  00047	74 08		 je	 SHORT $LN16@DrawCharac

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00049	89 18		 mov	 DWORD PTR [eax], ebx

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  0004b	83 47 50 04	 add	 DWORD PTR [edi+80], 4

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0004f	eb 0d		 jmp	 SHORT $LN15@DrawCharac
$LN16@DrawCharac:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00051	8d 55 10	 lea	 edx, DWORD PTR _pInsCharInfo$[ebp]
  00054	52		 push	 edx
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAUSCharacterInfomation@CGraphicFontTexture@@@?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@AAEPAPAUSCharacterInfomation@CGraphicFontTexture@@QAPAU23@ABQAU23@@Z ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::_Emplace_reallocate<CGraphicFontTexture::SCharacterInfomation * const &>
  0005b	8b 5d 10	 mov	 ebx, DWORD PTR _pInsCharInfo$[ebp]
$LN15@DrawCharac:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 102  : 		m_textWidth += pInsCharInfo->advance;

  0005e	0f b7 47 0c	 movzx	 eax, WORD PTR [edi+12]

; 103  : 		m_textHeight = max(pInsCharInfo->height, m_textHeight);

  00062	0f b7 4f 0e	 movzx	 ecx, WORD PTR [edi+14]
  00066	56		 push	 esi
  00067	66 0f 6e c0	 movd	 xmm0, eax
  0006b	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0006e	f3 0f 58 43 18	 addss	 xmm0, DWORD PTR [ebx+24]
  00073	f3 0f 2c c0	 cvttss2si eax, xmm0
  00077	66 89 47 0c	 mov	 WORD PTR [edi+12], ax
  0007b	8b c1		 mov	 eax, ecx
  0007d	0f bf 73 04	 movsx	 esi, WORD PTR [ebx+4]
  00081	3b f1		 cmp	 esi, ecx
  00083	0f b7 d6	 movzx	 edx, si

; 104  : 		return pInsCharInfo->advance;

  00086	5e		 pop	 esi
  00087	0f 4e d0	 cmovle	 edx, eax
  0008a	66 89 57 0e	 mov	 WORD PTR [edi+14], dx
  0008e	f3 0f 2c 43 18	 cvttss2si eax, DWORD PTR [ebx+24]
  00093	5f		 pop	 edi

; 108  : }

  00094	5b		 pop	 ebx
  00095	5d		 pop	 ebp
  00096	c2 10 00	 ret	 16			; 00000010H
$LN2@DrawCharac:
  00099	5f		 pop	 edi

; 105  : 	}
; 106  : 
; 107  : 	return 0;

  0009a	33 c0		 xor	 eax, eax

; 108  : }

  0009c	5b		 pop	 ebx
  0009d	5d		 pop	 ebp
  0009e	c2 10 00	 ret	 16			; 00000010H
?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ENDP ; CGraphicTextInstance::__DrawCharacter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?__Initialize@CGraphicTextInstance@@IAEXXZ
_TEXT	SEGMENT
?__Initialize@CGraphicTextInstance@@IAEXXZ PROC		; CGraphicTextInstance::__Initialize, COMDAT
; _this$ = ecx

; 1351 : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h

; 67   : 			CReferenceObject* pOldObject = m_pObject;

  00003	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]

; 68   : 
; 69   : 			m_pObject = pObject;

  00006	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0

; 70   : 
; 71   : 			if (m_pObject)
; 72   : 				m_pObject->AddReference();
; 73   : 
; 74   : 			if (pOldObject)

  0000d	85 c9		 test	 ecx, ecx
  0000f	74 05		 je	 SHORT $LN7@Initialize

; 75   : 				pOldObject->Release();

  00011	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN7@Initialize:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1369 : 	m_textWidth = 0;

  00016	33 c0		 xor	 eax, eax
  00018	c7 46 10 01 10
	00 00		 mov	 DWORD PTR [esi+16], 4097 ; 00001001H
  0001f	c7 46 14 00 00
	c8 44		 mov	 DWORD PTR [esi+20], 1153957888 ; 44c80000H
  00026	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0002d	c7 46 1c 00 00
	00 3f		 mov	 DWORD PTR [esi+28], 1056964608 ; 3f000000H

; 1370 : 	m_textHeight = 0;
; 1371 : 
; 1372 : 	m_v3Position.x = m_v3Position.y = m_v3Position.z = 0.0f;
; 1373 : 
; 1374 : 	m_dwOutLineColor=0xff000000;
; 1375 : #ifdef ENABLE_DYNAMIC_FONTS
; 1376 : 	dynamic_font_off = false;

  00034	66 c7 46 44 00
	00		 mov	 WORD PTR [esi+68], 0
  0003a	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  0003d	89 46 40	 mov	 DWORD PTR [esi+64], eax
  00040	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  00043	89 46 38	 mov	 DWORD PTR [esi+56], eax
  00046	c7 46 08 00 00
	00 ff		 mov	 DWORD PTR [esi+8], -16777216 ; ff000000H
  0004d	5e		 pop	 esi

; 1377 : #endif
; 1378 : }

  0004e	c3		 ret	 0
?__Initialize@CGraphicTextInstance@@IAEXXZ ENDP		; CGraphicTextInstance::__Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ
_TEXT	SEGMENT
?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ PROC	; CGraphicTextInstance::GetHorizontalAlign, COMDAT
; _this$ = ecx

; 1347 : 	return m_hAlign;

  00000	0f b6 41 10	 movzx	 eax, BYTE PTR [ecx+16]

; 1348 : }

  00004	c3		 ret	 0
?GetHorizontalAlign@CGraphicTextInstance@@QAEHXZ ENDP	; CGraphicTextInstance::GetHorizontalAlign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?PixelPositionToCharacterPosition@CGraphicTextInstance@@QAEHH@Z
_TEXT	SEGMENT
_iPixelPosition$ = 8					; size = 4
?PixelPositionToCharacterPosition@CGraphicTextInstance@@QAEHH@Z PROC ; CGraphicTextInstance::PixelPositionToCharacterPosition, COMDAT
; _this$ = ecx

; 1331 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1333 : 	for (int i = 0; i < (int)m_pCharInfoVector.size(); ++i)

  00006	33 c0		 xor	 eax, eax
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000b	8b 79 50	 mov	 edi, DWORD PTR [ecx+80]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1332 : 	int icurPosition = 0;

  0000e	33 f6		 xor	 esi, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00010	2b fa		 sub	 edi, edx
  00012	c1 ff 02	 sar	 edi, 2
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1333 : 	for (int i = 0; i < (int)m_pCharInfoVector.size(); ++i)

  00015	85 ff		 test	 edi, edi
  00017	7e 1b		 jle	 SHORT $LN3@PixelPosit
  00019	8b 5d 08	 mov	 ebx, DWORD PTR _iPixelPosition$[ebp]
  0001c	0f 1f 40 00	 npad	 4
$LL4@PixelPosit:

; 1334 : 	{
; 1335 : 		CGraphicFontTexture::TCharacterInfomation* pCurCharInfo = m_pCharInfoVector[i];
; 1336 : 		icurPosition += pCurCharInfo->width;

  00020	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00022	0f bf 49 02	 movsx	 ecx, WORD PTR [ecx+2]
  00026	03 f1		 add	 esi, ecx

; 1337 : 
; 1338 : 		if (iPixelPosition < icurPosition)

  00028	3b de		 cmp	 ebx, esi
  0002a	7c 0b		 jl	 SHORT $LN1@PixelPosit

; 1333 : 	for (int i = 0; i < (int)m_pCharInfoVector.size(); ++i)

  0002c	40		 inc	 eax
  0002d	83 c2 04	 add	 edx, 4
  00030	3b c7		 cmp	 eax, edi
  00032	7c ec		 jl	 SHORT $LL4@PixelPosit
$LN3@PixelPosit:

; 1339 : 			return i;
; 1340 : 	}
; 1341 : 
; 1342 : 	return -1;

  00034	83 c8 ff	 or	 eax, -1
$LN1@PixelPosit:
  00037	5f		 pop	 edi

; 1343 : }

  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
?PixelPositionToCharacterPosition@CGraphicTextInstance@@QAEHH@Z ENDP ; CGraphicTextInstance::PixelPositionToCharacterPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?GetTextLineCount@CGraphicTextInstance@@QAEGXZ
_TEXT	SEGMENT
?GetTextLineCount@CGraphicTextInstance@@QAEGXZ PROC	; CGraphicTextInstance::GetTextLineCount, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00003	0f 57 c0	 xorps	 xmm0, xmm0
  00006	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1298 : {

  00009	57		 push	 edi

; 1299 : 	CGraphicFontTexture::TCharacterInfomation* pCurCharInfo;
; 1300 : 	CGraphicFontTexture::TPCharacterInfomationVector::iterator itor;
; 1301 : 
; 1302 : 	float fx = 0.0f;
; 1303 : 	WORD wLineCount = 1;

  0000a	bf 01 00 00 00	 mov	 edi, 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0000f	3b c2		 cmp	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1304 : 	for (itor=m_pCharInfoVector.begin(); itor!=m_pCharInfoVector.end(); ++itor)

  00011	74 4e		 je	 SHORT $LN47@GetTextLin

; 1310 : 		//float fFontHeight=float(pCurCharInfo->height);
; 1311 : 
; 1312 : 		if (fx+fFontWidth > m_fLimitWidth)

  00013	f3 0f 10 59 14	 movss	 xmm3, DWORD PTR [ecx+20]
  00018	56		 push	 esi
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@GetTextLin:

; 1305 : 	{
; 1306 : 		pCurCharInfo = *itor;
; 1307 : 
; 1308 : 		float fFontWidth=float(pCurCharInfo->width);
; 1309 : 		float fFontAdvance=float(pCurCharInfo->advance);

  00020	8b 08		 mov	 ecx, DWORD PTR [eax]
  00022	f3 0f 10 51 18	 movss	 xmm2, DWORD PTR [ecx+24]

; 1310 : 		//float fFontHeight=float(pCurCharInfo->height);
; 1311 : 
; 1312 : 		if (fx+fFontWidth > m_fLimitWidth)

  00027	0f bf 49 02	 movsx	 ecx, WORD PTR [ecx+2]
  0002b	66 0f 6e c9	 movd	 xmm1, ecx
  0002f	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00032	f3 0f 58 c8	 addss	 xmm1, xmm0
  00036	0f 2f cb	 comiss	 xmm1, xmm3
  00039	76 03		 jbe	 SHORT $LN5@GetTextLin
  0003b	0f 57 c0	 xorps	 xmm0, xmm0
$LN5@GetTextLin:

; 1318 : 		fx += fFontAdvance;

  0003e	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00041	0f b7 f1	 movzx	 esi, cx
  00044	f3 0f 58 c2	 addss	 xmm0, xmm2
  00048	0f b7 cf	 movzx	 ecx, di
  0004b	0f 46 f1	 cmovbe	 esi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 82   :         ++_Ptr;

  0004e	83 c0 04	 add	 eax, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1318 : 		fx += fFontAdvance;

  00051	0f b7 ce	 movzx	 ecx, si
  00054	8b f1		 mov	 esi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00056	8b f9		 mov	 edi, ecx

; 166  :         return _Ptr == _Right._Ptr;

  00058	3b c2		 cmp	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1304 : 	for (itor=m_pCharInfoVector.begin(); itor!=m_pCharInfoVector.end(); ++itor)

  0005a	75 c4		 jne	 SHORT $LL4@GetTextLin

; 1319 : 	}
; 1320 : 
; 1321 : 	return wLineCount;

  0005c	8b c6		 mov	 eax, esi
  0005e	5e		 pop	 esi
  0005f	5f		 pop	 edi

; 1322 : }

  00060	c3		 ret	 0
$LN47@GetTextLin:

; 1319 : 	}
; 1320 : 
; 1321 : 	return wLineCount;

  00061	66 8b c7	 mov	 ax, di
  00064	5f		 pop	 edi

; 1322 : }

  00065	c3		 ret	 0
?GetTextLineCount@CGraphicTextInstance@@QAEGXZ ENDP	; CGraphicTextInstance::GetTextLineCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?GetValueStringReference@CGraphicTextInstance@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
?GetValueStringReference@CGraphicTextInstance@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CGraphicTextInstance::GetValueStringReference, COMDAT
; _this$ = ecx

; 1294 : 	return m_stText;

  00000	8d 41 20	 lea	 eax, DWORD PTR [ecx+32]

; 1295 : }

  00003	c3		 ret	 0
?GetValueStringReference@CGraphicTextInstance@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CGraphicTextInstance::GetValueStringReference
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?GetTextSize@CGraphicTextInstance@@QAEXPAH0@Z
_TEXT	SEGMENT
_pRetWidth$ = 8						; size = 4
_pRetHeight$ = 12					; size = 4
?GetTextSize@CGraphicTextInstance@@QAEXPAH0@Z PROC	; CGraphicTextInstance::GetTextSize, COMDAT
; _this$ = ecx

; 1325 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1326 : 	*pRetWidth = m_textWidth;

  00003	8b 45 08	 mov	 eax, DWORD PTR _pRetWidth$[ebp]
  00006	0f b7 51 0c	 movzx	 edx, WORD PTR [ecx+12]
  0000a	89 10		 mov	 DWORD PTR [eax], edx

; 1327 : 	*pRetHeight = m_textHeight;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR _pRetHeight$[ebp]
  0000f	0f b7 49 0e	 movzx	 ecx, WORD PTR [ecx+14]
  00013	89 08		 mov	 DWORD PTR [eax], ecx

; 1328 : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
?GetTextSize@CGraphicTextInstance@@QAEXPAH0@Z ENDP	; CGraphicTextInstance::GetTextSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetLimitWidth@CGraphicTextInstance@@QAEXM@Z
_TEXT	SEGMENT
_fWidth$ = 8						; size = 4
?SetLimitWidth@CGraphicTextInstance@@QAEXM@Z PROC	; CGraphicTextInstance::SetLimitWidth, COMDAT
; _this$ = ecx

; 1250 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1251 : 	m_fLimitWidth = fWidth;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fWidth$[ebp]
  00008	f3 0f 11 41 14	 movss	 DWORD PTR [ecx+20], xmm0

; 1252 : }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?SetLimitWidth@CGraphicTextInstance@@QAEXM@Z ENDP	; CGraphicTextInstance::SetLimitWidth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetMultiLine@CGraphicTextInstance@@QAEX_N@Z
_TEXT	SEGMENT
_Value$ = 8						; size = 1
?SetMultiLine@CGraphicTextInstance@@QAEX_N@Z PROC	; CGraphicTextInstance::SetMultiLine, COMDAT
; _this$ = ecx

; 1230 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1231 : 	m_isMultiLine = Value;

  00003	8a 45 08	 mov	 al, BYTE PTR _Value$[ebp]
  00006	88 41 1a	 mov	 BYTE PTR [ecx+26], al

; 1232 : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetMultiLine@CGraphicTextInstance@@QAEX_N@Z ENDP	; CGraphicTextInstance::SetMultiLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetFeather@CGraphicTextInstance@@QAEX_N@Z
_TEXT	SEGMENT
_Value$ = 8						; size = 1
?SetFeather@CGraphicTextInstance@@QAEX_N@Z PROC		; CGraphicTextInstance::SetFeather, COMDAT
; _this$ = ecx

; 1218 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1219 : 	if (Value)

  00003	80 7d 08 00	 cmp	 BYTE PTR _Value$[ebp], 0
  00007	74 11		 je	 SHORT $LN2@SetFeather

; 1220 : 	{
; 1221 : 		m_fFontFeather = c_fFontFeather;

  00009	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000

; 1222 : 	}
; 1223 : 	else
; 1224 : 	{
; 1225 : 		m_fFontFeather = 0.0f;
; 1226 : 	}
; 1227 : }

  00011	f3 0f 11 41 1c	 movss	 DWORD PTR [ecx+28], xmm0
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@SetFeather:
  0001a	0f 57 c0	 xorps	 xmm0, xmm0
  0001d	f3 0f 11 41 1c	 movss	 DWORD PTR [ecx+28], xmm0
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
?SetFeather@CGraphicTextInstance@@QAEX_N@Z ENDP		; CGraphicTextInstance::SetFeather
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetOutline@CGraphicTextInstance@@QAEX_N@Z
_TEXT	SEGMENT
_Value$ = 8						; size = 1
?SetOutline@CGraphicTextInstance@@QAEX_N@Z PROC		; CGraphicTextInstance::SetOutline, COMDAT
; _this$ = ecx

; 1213 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1214 : 	m_isOutline = Value;

  00003	8a 45 08	 mov	 al, BYTE PTR _Value$[ebp]
  00006	88 41 1b	 mov	 BYTE PTR [ecx+27], al

; 1215 : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetOutline@CGraphicTextInstance@@QAEX_N@Z ENDP		; CGraphicTextInstance::SetOutline
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetSecret@CGraphicTextInstance@@QAEX_N@Z
_TEXT	SEGMENT
_Value$ = 8						; size = 1
?SetSecret@CGraphicTextInstance@@QAEX_N@Z PROC		; CGraphicTextInstance::SetSecret, COMDAT
; _this$ = ecx

; 1208 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1209 : 	m_isSecret = Value;

  00003	8a 45 08	 mov	 al, BYTE PTR _Value$[ebp]
  00006	88 41 19	 mov	 BYTE PTR [ecx+25], al

; 1210 : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetSecret@CGraphicTextInstance@@QAEX_N@Z ENDP		; CGraphicTextInstance::SetSecret
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetPosition@CGraphicTextInstance@@QAEXMMM@Z
_TEXT	SEGMENT
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_fz$ = 16						; size = 4
?SetPosition@CGraphicTextInstance@@QAEXMMM@Z PROC	; CGraphicTextInstance::SetPosition, COMDAT
; _this$ = ecx

; 1273 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1274 : 	m_v3Position.x = fx;

  00003	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00008	f3 0f 11 41 38	 movss	 DWORD PTR [ecx+56], xmm0

; 1275 : 	m_v3Position.y = fy;

  0000d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00012	f3 0f 11 41 3c	 movss	 DWORD PTR [ecx+60], xmm0

; 1276 : 	m_v3Position.z = fz;

  00017	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0001c	f3 0f 11 41 40	 movss	 DWORD PTR [ecx+64], xmm0

; 1277 : }

  00021	5d		 pop	 ebp
  00022	c2 0c 00	 ret	 12			; 0000000cH
?SetPosition@CGraphicTextInstance@@QAEXMMM@Z ENDP	; CGraphicTextInstance::SetPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetValue@CGraphicTextInstance@@QAEXPBDI@Z
_TEXT	SEGMENT
_c_szText$ = 8						; size = 4
_len$ = 12						; size = 4
?SetValue@CGraphicTextInstance@@QAEXPBDI@Z PROC		; CGraphicTextInstance::SetValue, COMDAT
; _this$ = ecx

; 1264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  00005	8b 75 08	 mov	 esi, DWORD PTR _c_szText$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1264 : {

  00008	8b d9		 mov	 ebx, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  0000a	8b d6		 mov	 edx, esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1264 : {

  0000c	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  0000d	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
$LL24@SetValue:
  00010	8a 02		 mov	 al, BYTE PTR [edx]
  00012	42		 inc	 edx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL24@SetValue
  00017	2b d1		 sub	 edx, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  00019	8d 43 20	 lea	 eax, DWORD PTR [ebx+32]

; 434  :         return _Myres > _Small_string_capacity;

  0001c	83 7b 34 0f	 cmp	 DWORD PTR [ebx+52], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00020	76 03		 jbe	 SHORT $LN11@SetValue

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00022	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
$LN11@SetValue:

; 2876 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00025	52		 push	 edx
  00026	56		 push	 esi
  00027	ff 73 30	 push	 DWORD PTR [ebx+48]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  00030	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1265 : 	if (0 == m_stText.compare(c_szText))

  00033	85 c0		 test	 eax, eax
  00035	74 20		 je	 SHORT $LN1@SetValue
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  00037	8b d6		 mov	 edx, esi
  00039	8d 4a 01	 lea	 ecx, DWORD PTR [edx+1]
  0003c	0f 1f 40 00	 npad	 4
$LL25@SetValue:
  00040	8a 02		 mov	 al, BYTE PTR [edx]
  00042	42		 inc	 edx
  00043	84 c0		 test	 al, al
  00045	75 f9		 jne	 SHORT $LL25@SetValue
  00047	2b d1		 sub	 edx, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00049	8d 4b 20	 lea	 ecx, DWORD PTR [ebx+32]
  0004c	52		 push	 edx
  0004d	56		 push	 esi
  0004e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1269 : 	m_isUpdate = false;

  00053	c6 43 45 00	 mov	 BYTE PTR [ebx+69], 0
$LN1@SetValue:

; 1270 : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
?SetValue@CGraphicTextInstance@@QAEXPBDI@Z ENDP		; CGraphicTextInstance::SetValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetValueString@CGraphicTextInstance@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_c_stValue$ = 8						; size = 4
tv302 = 8						; size = 4
?SetValueString@CGraphicTextInstance@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CGraphicTextInstance::SetValueString, COMDAT
; _this$ = ecx

; 1255 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2854 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00005	8b 75 08	 mov	 esi, DWORD PTR _c_stValue$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1255 : {

  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  0000b	8b c6		 mov	 eax, esi

; 434  :         return _Myres > _Small_string_capacity;

  0000d	83 7e 14 0f	 cmp	 DWORD PTR [esi+20], 15	; 0000000fH
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1256 : 	if (0 == m_stText.compare(c_stValue))

  00011	8d 7b 20	 lea	 edi, DWORD PTR [ebx+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2854 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00014	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00017	89 4d 08	 mov	 DWORD PTR tv302[ebp], ecx

; 426  :         if (_Large_mode_engaged()) {

  0001a	76 02		 jbe	 SHORT $LN32@SetValueSt

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
$LN32@SetValueSt:

; 434  :         return _Myres > _Small_string_capacity;

  0001e	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00022	8b d7		 mov	 edx, edi

; 426  :         if (_Large_mode_engaged()) {

  00024	76 02		 jbe	 SHORT $LN15@SetValueSt

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00026	8b 17		 mov	 edx, DWORD PTR [edi]
$LN15@SetValueSt:

; 2854 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	ff 77 10	 push	 DWORD PTR [edi+16]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  00033	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1256 : 	if (0 == m_stText.compare(c_stValue))

  00036	85 c0		 test	 eax, eax
  00038	74 1b		 je	 SHORT $LN1@SetValueSt
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1371 :         if (this == _STD addressof(_Right)) {

  0003a	3b fe		 cmp	 edi, esi
  0003c	74 13		 je	 SHORT $LN21@SetValueSt

; 434  :         return _Myres > _Small_string_capacity;

  0003e	83 7e 14 0f	 cmp	 DWORD PTR [esi+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00042	76 02		 jbe	 SHORT $LN25@SetValueSt

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00044	8b 36		 mov	 esi, DWORD PTR [esi]
$LN25@SetValueSt:

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00046	ff 75 08	 push	 DWORD PTR tv302[ebp]
  00049	8b cf		 mov	 ecx, edi
  0004b	56		 push	 esi
  0004c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN21@SetValueSt:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1260 : 	m_isUpdate = false;

  00051	c6 43 45 00	 mov	 BYTE PTR [ebx+69], 0
$LN1@SetValueSt:
  00055	5f		 pop	 edi

; 1261 : }

  00056	5e		 pop	 esi
  00057	5b		 pop	 ebx
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?SetValueString@CGraphicTextInstance@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CGraphicTextInstance::SetValueString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetTextPointer@CGraphicTextInstance@@QAEXPAVCGraphicText@@@Z
_TEXT	SEGMENT
_pText$ = 8						; size = 4
?SetTextPointer@CGraphicTextInstance@@QAEXPAVCGraphicText@@@Z PROC ; CGraphicTextInstance::SetTextPointer, COMDAT
; _this$ = ecx

; 1280 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1281 : #ifdef ENABLE_DYNAMIC_FONTS
; 1282 : 	if (pkDefaultFont_RELOAD && !dynamic_font_off)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?pkDefaultFont_RELOAD@@3PAVCGraphicText@@A
  00008	56		 push	 esi
  00009	85 c0		 test	 eax, eax
  0000b	74 0e		 je	 SHORT $LN2@SetTextPoi
  0000d	80 79 44 00	 cmp	 BYTE PTR [ecx+68], 0
  00011	75 08		 jne	 SHORT $LN2@SetTextPoi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h

; 67   : 			CReferenceObject* pOldObject = m_pObject;

  00013	8b 71 48	 mov	 esi, DWORD PTR [ecx+72]

; 69   : 			m_pObject = pObject;

  00016	89 41 48	 mov	 DWORD PTR [ecx+72], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1285 : 		return;

  00019	eb 0d		 jmp	 SHORT $LN22@SetTextPoi
$LN2@SetTextPoi:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h

; 69   : 			m_pObject = pObject;

  0001b	8b 45 08	 mov	 eax, DWORD PTR _pText$[ebp]
  0001e	8b 71 48	 mov	 esi, DWORD PTR [ecx+72]
  00021	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 70   : 
; 71   : 			if (m_pObject)

  00024	85 c0		 test	 eax, eax
  00026	74 07		 je	 SHORT $LN13@SetTextPoi
$LN22@SetTextPoi:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1290 : }

  00028	8b c8		 mov	 ecx, eax
  0002a	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference
$LN13@SetTextPoi:
  0002f	85 f6		 test	 esi, esi
  00031	74 07		 je	 SHORT $LN14@SetTextPoi
  00033	8b ce		 mov	 ecx, esi
  00035	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN14@SetTextPoi:
  0003a	5e		 pop	 esi
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
?SetTextPointer@CGraphicTextInstance@@QAEXPAVCGraphicText@@@Z ENDP ; CGraphicTextInstance::SetTextPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetMax@CGraphicTextInstance@@QAEXH@Z
_TEXT	SEGMENT
_iMax$ = 8						; size = 4
?SetMax@CGraphicTextInstance@@QAEXH@Z PROC		; CGraphicTextInstance::SetMax, COMDAT
; _this$ = ecx

; 1245 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1246 : 	m_iMax = iMax;

  00003	66 8b 45 08	 mov	 ax, WORD PTR _iMax$[ebp]
  00007	66 89 41 12	 mov	 WORD PTR [ecx+18], ax

; 1247 : }

  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?SetMax@CGraphicTextInstance@@QAEXH@Z ENDP		; CGraphicTextInstance::SetMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetVerticalAlign@CGraphicTextInstance@@QAEXH@Z
_TEXT	SEGMENT
_vAlign$ = 8						; size = 4
?SetVerticalAlign@CGraphicTextInstance@@QAEXH@Z PROC	; CGraphicTextInstance::SetVerticalAlign, COMDAT
; _this$ = ecx

; 1240 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1241 : 	m_vAlign = vAlign;

  00003	8a 45 08	 mov	 al, BYTE PTR _vAlign$[ebp]
  00006	88 41 11	 mov	 BYTE PTR [ecx+17], al

; 1242 : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetVerticalAlign@CGraphicTextInstance@@QAEXH@Z ENDP	; CGraphicTextInstance::SetVerticalAlign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z
_TEXT	SEGMENT
_hAlign$ = 8						; size = 4
?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z PROC	; CGraphicTextInstance::SetHorizonalAlign, COMDAT
; _this$ = ecx

; 1235 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1236 : 	m_hAlign = hAlign;

  00003	8a 45 08	 mov	 al, BYTE PTR _hAlign$[ebp]
  00006	88 41 10	 mov	 BYTE PTR [ecx+16], al

; 1237 : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetHorizonalAlign@CGraphicTextInstance@@QAEXH@Z ENDP	; CGraphicTextInstance::SetHorizonalAlign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetOutLineColor@CGraphicTextInstance@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
?SetOutLineColor@CGraphicTextInstance@@QAEXMMMM@Z PROC	; CGraphicTextInstance::SetOutLineColor, COMDAT
; _this$ = ecx

; 1203 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00004	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _r$[ebp]
  00009	0f 57 c9	 xorps	 xmm1, xmm1
  0000c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1203 : {

  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00019	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  00021	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  00029	72 07		 jb	 SHORT $LN9@SetOutLine
  0002b	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  00030	eb 2b		 jmp	 SHORT $LN8@SetOutLine
$LN9@SetOutLine:
  00032	0f 2f c8	 comiss	 xmm1, xmm0
  00035	72 04		 jb	 SHORT $LN7@SetOutLine
  00037	33 db		 xor	 ebx, ebx
  00039	eb 22		 jmp	 SHORT $LN8@SetOutLine
$LN7@SetOutLine:
  0003b	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0003f	f3 0f 58 c4	 addss	 xmm0, xmm4
  00043	e8 00 00 00 00	 call	 __ftol3
  00048	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  00050	8b d8		 mov	 ebx, eax
  00052	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  0005a	0f 57 c9	 xorps	 xmm1, xmm1
$LN8@SetOutLine:

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0005d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _g$[ebp]
  00062	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00069	72 07		 jb	 SHORT $LN13@SetOutLine
  0006b	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH
  00070	eb 18		 jmp	 SHORT $LN12@SetOutLine
$LN13@SetOutLine:
  00072	0f 2f c8	 comiss	 xmm1, xmm0
  00075	72 04		 jb	 SHORT $LN11@SetOutLine
  00077	33 ff		 xor	 edi, edi
  00079	eb 0f		 jmp	 SHORT $LN12@SetOutLine
$LN11@SetOutLine:
  0007b	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0007f	f3 0f 58 c4	 addss	 xmm0, xmm4
  00083	e8 00 00 00 00	 call	 __ftol3
  00088	8b f8		 mov	 edi, eax
$LN12@SetOutLine:

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0008a	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _b$[ebp]
  0008f	0f 57 c9	 xorps	 xmm1, xmm1
  00092	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00099	72 07		 jb	 SHORT $LN17@SetOutLine
  0009b	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
  000a0	eb 23		 jmp	 SHORT $LN16@SetOutLine
$LN17@SetOutLine:
  000a2	0f 2f c8	 comiss	 xmm1, xmm0
  000a5	72 04		 jb	 SHORT $LN15@SetOutLine
  000a7	33 f6		 xor	 esi, esi
  000a9	eb 1a		 jmp	 SHORT $LN16@SetOutLine
$LN15@SetOutLine:
  000ab	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000b3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000bb	e8 00 00 00 00	 call	 __ftol3
  000c0	8b f0		 mov	 esi, eax
  000c2	0f 57 c9	 xorps	 xmm1, xmm1
$LN16@SetOutLine:

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  000c5	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _a$[ebp]
  000ca	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000d1	72 07		 jb	 SHORT $LN21@SetOutLine
  000d3	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000d8	eb 1e		 jmp	 SHORT $LN20@SetOutLine
$LN21@SetOutLine:
  000da	0f 2f c8	 comiss	 xmm1, xmm0
  000dd	72 04		 jb	 SHORT $LN19@SetOutLine
  000df	33 c0		 xor	 eax, eax
  000e1	eb 15		 jmp	 SHORT $LN20@SetOutLine
$LN19@SetOutLine:
  000e3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000eb	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000f3	e8 00 00 00 00	 call	 __ftol3
$LN20@SetOutLine:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1204 : 	m_dwOutLineColor=D3DXCOLOR(r, g, b, a);

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  000fb	c1 e0 08	 shl	 eax, 8
  000fe	0b c3		 or	 eax, ebx
  00100	c1 e0 08	 shl	 eax, 8
  00103	0b c7		 or	 eax, edi
  00105	c1 e0 08	 shl	 eax, 8
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1204 : 	m_dwOutLineColor=D3DXCOLOR(r, g, b, a);

  00108	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00109	0b c6		 or	 eax, esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1204 : 	m_dwOutLineColor=D3DXCOLOR(r, g, b, a);

  0010b	5e		 pop	 esi
  0010c	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0010f	5b		 pop	 ebx

; 1205 : }

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 10 00	 ret	 16			; 00000010H
?SetOutLineColor@CGraphicTextInstance@@QAEXMMMM@Z ENDP	; CGraphicTextInstance::SetOutLineColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetOutLineColor@CGraphicTextInstance@@QAEXK@Z
_TEXT	SEGMENT
_color$ = 8						; size = 4
?SetOutLineColor@CGraphicTextInstance@@QAEXK@Z PROC	; CGraphicTextInstance::SetOutLineColor, COMDAT
; _this$ = ecx

; 1198 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1199 : 	m_dwOutLineColor=color;

  00003	8b 45 08	 mov	 eax, DWORD PTR _color$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1200 : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetOutLineColor@CGraphicTextInstance@@QAEXK@Z ENDP	; CGraphicTextInstance::SetOutLineColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetColor@CGraphicTextInstance@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_r$ = 8							; size = 4
_g$ = 12						; size = 4
_b$ = 16						; size = 4
_a$ = 20						; size = 4
?SetColor@CGraphicTextInstance@@QAEXMMMM@Z PROC		; CGraphicTextInstance::SetColor, COMDAT
; _this$ = ecx

; 1193 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00004	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _r$[ebp]
  00009	0f 57 c9	 xorps	 xmm1, xmm1
  0000c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1193 : {

  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	89 4d fc	 mov	 DWORD PTR _this$1$[ebp], ecx
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00019	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  00021	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  00029	72 07		 jb	 SHORT $LN9@SetColor
  0002b	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  00030	eb 2b		 jmp	 SHORT $LN8@SetColor
$LN9@SetColor:
  00032	0f 2f c8	 comiss	 xmm1, xmm0
  00035	72 04		 jb	 SHORT $LN7@SetColor
  00037	33 db		 xor	 ebx, ebx
  00039	eb 22		 jmp	 SHORT $LN8@SetColor
$LN7@SetColor:
  0003b	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0003f	f3 0f 58 c4	 addss	 xmm0, xmm4
  00043	e8 00 00 00 00	 call	 __ftol3
  00048	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  00050	8b d8		 mov	 ebx, eax
  00052	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  0005a	0f 57 c9	 xorps	 xmm1, xmm1
$LN8@SetColor:

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0005d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _g$[ebp]
  00062	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00069	72 07		 jb	 SHORT $LN13@SetColor
  0006b	bf ff 00 00 00	 mov	 edi, 255		; 000000ffH
  00070	eb 18		 jmp	 SHORT $LN12@SetColor
$LN13@SetColor:
  00072	0f 2f c8	 comiss	 xmm1, xmm0
  00075	72 04		 jb	 SHORT $LN11@SetColor
  00077	33 ff		 xor	 edi, edi
  00079	eb 0f		 jmp	 SHORT $LN12@SetColor
$LN11@SetColor:
  0007b	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0007f	f3 0f 58 c4	 addss	 xmm0, xmm4
  00083	e8 00 00 00 00	 call	 __ftol3
  00088	8b f8		 mov	 edi, eax
$LN12@SetColor:

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0008a	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _b$[ebp]
  0008f	0f 57 c9	 xorps	 xmm1, xmm1
  00092	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00099	72 07		 jb	 SHORT $LN17@SetColor
  0009b	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
  000a0	eb 23		 jmp	 SHORT $LN16@SetColor
$LN17@SetColor:
  000a2	0f 2f c8	 comiss	 xmm1, xmm0
  000a5	72 04		 jb	 SHORT $LN15@SetColor
  000a7	33 f6		 xor	 esi, esi
  000a9	eb 1a		 jmp	 SHORT $LN16@SetColor
$LN15@SetColor:
  000ab	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000b3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000bb	e8 00 00 00 00	 call	 __ftol3
  000c0	8b f0		 mov	 esi, eax
  000c2	0f 57 c9	 xorps	 xmm1, xmm1
$LN16@SetColor:

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  000c5	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _a$[ebp]
  000ca	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000d1	72 07		 jb	 SHORT $LN21@SetColor
  000d3	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000d8	eb 1e		 jmp	 SHORT $LN20@SetColor
$LN21@SetColor:
  000da	0f 2f c8	 comiss	 xmm1, xmm0
  000dd	72 04		 jb	 SHORT $LN19@SetColor
  000df	33 c0		 xor	 eax, eax
  000e1	eb 15		 jmp	 SHORT $LN20@SetColor
$LN19@SetColor:
  000e3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000eb	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000f3	e8 00 00 00 00	 call	 __ftol3
$LN20@SetColor:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1194 : 	SetColor(D3DXCOLOR(r, g, b, a));

  000f8	8b 4d fc	 mov	 ecx, DWORD PTR _this$1$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  000fb	c1 e0 08	 shl	 eax, 8
  000fe	0b c3		 or	 eax, ebx
  00100	c1 e0 08	 shl	 eax, 8
  00103	0b c7		 or	 eax, edi
  00105	c1 e0 08	 shl	 eax, 8
  00108	0b c6		 or	 eax, esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1194 : 	SetColor(D3DXCOLOR(r, g, b, a));

  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 ?SetColor@CGraphicTextInstance@@QAEXK@Z ; CGraphicTextInstance::SetColor
  00110	5f		 pop	 edi
  00111	5e		 pop	 esi
  00112	5b		 pop	 ebx

; 1195 : }

  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 10 00	 ret	 16			; 00000010H
?SetColor@CGraphicTextInstance@@QAEXMMMM@Z ENDP		; CGraphicTextInstance::SetColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?SetColor@CGraphicTextInstance@@QAEXK@Z
_TEXT	SEGMENT
_color$ = 8						; size = 4
?SetColor@CGraphicTextInstance@@QAEXK@Z PROC		; CGraphicTextInstance::SetColor, COMDAT
; _this$ = ecx

; 1181 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1182 : 	if (m_dwTextColor != color)

  00003	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00006	57		 push	 edi
  00007	8b 7d 08	 mov	 edi, DWORD PTR _color$[ebp]
  0000a	3b d7		 cmp	 edx, edi
  0000c	74 32		 je	 SHORT $LN5@SetColor
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000e	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00011	2b 41 4c	 sub	 eax, DWORD PTR [ecx+76]
  00014	56		 push	 esi
  00015	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1184 : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  00018	33 f6		 xor	 esi, esi
  0001a	85 c0		 test	 eax, eax
  0001c	74 1e		 je	 SHORT $LN3@SetColor
  0001e	66 90		 npad	 2
$LL4@SetColor:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00020	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1185 : 			if (m_dwColorInfoVector[i] == m_dwTextColor)

  00023	39 14 b0	 cmp	 DWORD PTR [eax+esi*4], edx
  00026	75 06		 jne	 SHORT $LN2@SetColor

; 1186 : 				m_dwColorInfoVector[i] = color;

  00028	89 3c b0	 mov	 DWORD PTR [eax+esi*4], edi
  0002b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
$LN2@SetColor:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0002e	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1184 : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  00031	46		 inc	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00032	2b 41 4c	 sub	 eax, DWORD PTR [ecx+76]
  00035	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1184 : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  00038	3b f0		 cmp	 esi, eax
  0003a	72 e4		 jb	 SHORT $LL4@SetColor
$LN3@SetColor:

; 1187 : 
; 1188 : 		m_dwTextColor = color;

  0003c	89 79 04	 mov	 DWORD PTR [ecx+4], edi
  0003f	5e		 pop	 esi
$LN5@SetColor:
  00040	5f		 pop	 edi

; 1189 : 	}
; 1190 : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
?SetColor@CGraphicTextInstance@@QAEXK@Z ENDP		; CGraphicTextInstance::SetColor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?HideOutLine@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
?HideOutLine@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::HideOutLine, COMDAT
; _this$ = ecx

; 1177 : 	m_isOutline = false;

  00000	c6 41 1b 00	 mov	 BYTE PTR [ecx+27], 0

; 1178 : }

  00004	c3		 ret	 0
?HideOutLine@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::HideOutLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?ShowOutLine@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
?ShowOutLine@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::ShowOutLine, COMDAT
; _this$ = ecx

; 1172 : 	m_isOutline = true;

  00000	c6 41 1b 01	 mov	 BYTE PTR [ecx+27], 1

; 1173 : }

  00004	c3		 ret	 0
?ShowOutLine@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::ShowOutLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?HideCursor@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
?HideCursor@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::HideCursor, COMDAT
; _this$ = ecx

; 1167 : 	m_isCursor = false;

  00000	c6 41 18 00	 mov	 BYTE PTR [ecx+24], 0

; 1168 : }

  00004	c3		 ret	 0
?HideCursor@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::HideCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?ShowCursor@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
?ShowCursor@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::ShowCursor, COMDAT
; _this$ = ecx

; 1162 : 	m_isCursor = true;

  00000	c6 41 18 01	 mov	 BYTE PTR [ecx+24], 1

; 1163 : }

  00004	c3		 ret	 0
?ShowCursor@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::ShowCursor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\eterBase\Singleton.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\eterBase\Singleton.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Render@CGraphicTextInstance@@QAEXPAUtagRECT@@@Z
_TEXT	SEGMENT
_dwFogEnable$1$ = -160					; size = 4
tv2468 = -156						; size = 8
_dwLighting$1$ = -152					; size = 4
_defCodePage$1$ = -148					; size = 4
_ulend$1$ = -148					; size = 4
_pCurCharInfo$1$ = -144					; size = 4
_fFontSy$2$ = -144					; size = 4
tv2346 = -140						; size = 4
_curpos$1$ = -140					; size = 4
_fFontSx$2$ = -140					; size = 4
_fFontSy$1$ = -136					; size = 4
_fFontEy$2$ = -136					; size = 4
_fFontEx$1$ = -132					; size = 4
_fFontEx$2$ = -132					; size = 4
_fCurY$1$ = -128					; size = 4
_fCurY$2$ = -128					; size = 4
_i$1$ = -124						; size = 4
_fFontEy$1$ = -124					; size = 4
_fStanY$1$ = -120					; size = 4
_ex$5 = -116						; size = 4
tv2384 = -116						; size = 4
_fFontSx$1$ = -116					; size = 4
_fStanX$1$ = -112					; size = 4
_sx$6 = -108						; size = 4
_fCurX$1$ = -108					; size = 4
_fCurX$2$ = -108					; size = 4
_sy$7 = -104						; size = 4
_pFontTexture$1$ = -104					; size = 4
_akVertex$8 = -100					; size = 96
_vertices$9 = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
_pClipRect$ = 8						; size = 4
?Render@CGraphicTextInstance@@QAEXPAUtagRECT@@@Z PROC	; CGraphicTextInstance::Render, COMDAT
; _this$ = ecx

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	8b d9		 mov	 ebx, ecx

; 575  : 	if (!m_isUpdate)

  00016	80 7b 45 00	 cmp	 BYTE PTR [ebx+69], 0
  0001a	0f 84 28 0b 00
	00		 je	 $LN19@Render

; 576  : 		return;
; 577  : 
; 578  : 	CGraphicText* pkText=m_roText.GetPointer();

  00020	8b 4b 48	 mov	 ecx, DWORD PTR [ebx+72]

; 579  : 	if (!pkText)

  00023	85 c9		 test	 ecx, ecx
  00025	0f 84 1d 0b 00
	00		 je	 $LN19@Render

; 580  : 		return;
; 581  : 
; 582  : 	CGraphicFontTexture* pFontTexture = pkText->GetFontTexturePointer();

  0002b	56		 push	 esi
  0002c	e8 00 00 00 00	 call	 ?GetFontTexturePointer@CGraphicText@@QAEPAVCGraphicFontTexture@@XZ ; CGraphicText::GetFontTexturePointer
  00031	8b f0		 mov	 esi, eax
  00033	89 75 98	 mov	 DWORD PTR _pFontTexture$1$[ebp], esi

; 583  : 	if (!pFontTexture)

  00036	85 f6		 test	 esi, esi
  00038	0f 84 09 0b 00
	00		 je	 $LN320@Render

; 584  : 		return;
; 585  : 
; 586  : 	float fStanX = m_v3Position.x;

  0003e	f3 0f 10 43 38	 movss	 xmm0, DWORD PTR [ebx+56]
  00043	f3 0f 11 45 90	 movss	 DWORD PTR _fStanX$1$[ebp], xmm0

; 587  : 	float fStanY = m_v3Position.y + 1.0f;

  00048	f3 0f 10 43 3c	 movss	 xmm0, DWORD PTR [ebx+60]
  0004d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00055	f3 0f 11 45 88	 movss	 DWORD PTR _fStanY$1$[ebp], xmm0

; 588  : 
; 589  : 	UINT defCodePage = GetDefaultCodePage();

  0005a	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  0005f	0f b6 4b 10	 movzx	 ecx, BYTE PTR [ebx+16]
  00063	89 85 6c ff ff
	ff		 mov	 DWORD PTR _defCodePage$1$[ebp], eax

; 590  : 
; 591  : 	if (defCodePage == CP_ARABIC)

  00069	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  0006e	75 41		 jne	 SHORT $LN24@Render

; 592  : 	{
; 593  : 		switch (m_hAlign)

  00070	83 e9 01	 sub	 ecx, 1
  00073	74 46		 je	 SHORT $LN26@Render
  00075	83 e9 01	 sub	 ecx, 1
  00078	75 1f		 jne	 SHORT $LN4@Render
$LN29@Render:

; 607  : 		{
; 608  : 			case HORIZONTAL_ALIGN_RIGHT:
; 609  : 				fStanX -= m_textWidth;
; 610  : 				break;
; 611  : 
; 612  : 			case HORIZONTAL_ALIGN_CENTER:
; 613  : 				fStanX -= float(m_textWidth / 2);
; 614  : 				break;
; 615  : 		}
; 616  : 	}
; 617  : 
; 618  : 	switch (m_vAlign)

  0007a	66 8b 43 0c	 mov	 ax, WORD PTR [ebx+12]
  0007e	66 d1 e8	 shr	 ax, 1
  00081	0f b7 c0	 movzx	 eax, ax
$LN322@Render:
  00084	f3 0f 10 4d 90	 movss	 xmm1, DWORD PTR _fStanX$1$[ebp]
  00089	66 0f 6e c0	 movd	 xmm0, eax
  0008d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00090	f3 0f 5c c8	 subss	 xmm1, xmm0
  00094	f3 0f 11 4d 90	 movss	 DWORD PTR _fStanX$1$[ebp], xmm1
$LN4@Render:
  00099	8a 43 11	 mov	 al, BYTE PTR [ebx+17]
  0009c	3c 20		 cmp	 al, 32			; 00000020H
  0009e	74 21		 je	 SHORT $LN31@Render
  000a0	3c 30		 cmp	 al, 48			; 00000030H
  000a2	75 3e		 jne	 SHORT $LN6@Render

; 619  : 	{
; 620  : 		case VERTICAL_ALIGN_BOTTOM:
; 621  : 			fStanY -= m_textHeight;

  000a4	0f b7 43 0e	 movzx	 eax, WORD PTR [ebx+14]
  000a8	66 0f 6e c0	 movd	 xmm0, eax
  000ac	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 622  : 			break;

  000af	eb 23		 jmp	 SHORT $LN323@Render
$LN24@Render:

; 594  : 		{
; 595  : 			case HORIZONTAL_ALIGN_LEFT:
; 596  : 				fStanX -= m_textWidth;
; 597  : 				break;
; 598  : 
; 599  : 			case HORIZONTAL_ALIGN_CENTER:
; 600  : 				fStanX -= float(m_textWidth / 2);
; 601  : 				break;
; 602  : 		}
; 603  : 	}
; 604  : 	else
; 605  : 	{
; 606  : 		switch (m_hAlign)

  000b1	83 e9 02	 sub	 ecx, 2
  000b4	74 c4		 je	 SHORT $LN29@Render
  000b6	83 e9 01	 sub	 ecx, 1
  000b9	75 de		 jne	 SHORT $LN4@Render
$LN26@Render:

; 607  : 		{
; 608  : 			case HORIZONTAL_ALIGN_RIGHT:
; 609  : 				fStanX -= m_textWidth;
; 610  : 				break;
; 611  : 
; 612  : 			case HORIZONTAL_ALIGN_CENTER:
; 613  : 				fStanX -= float(m_textWidth / 2);
; 614  : 				break;
; 615  : 		}
; 616  : 	}
; 617  : 
; 618  : 	switch (m_vAlign)

  000bb	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  000bf	eb c3		 jmp	 SHORT $LN322@Render
$LN31@Render:

; 623  : 
; 624  : 		case VERTICAL_ALIGN_CENTER:
; 625  : 			fStanY -= float(m_textHeight) / 2.0f;

  000c1	0f b7 43 0e	 movzx	 eax, WORD PTR [ebx+14]
  000c5	66 0f 6e c0	 movd	 xmm0, eax
  000c9	0f 5b c0	 cvtdq2ps xmm0, xmm0
  000cc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
$LN323@Render:

; 626  : 			break;
; 627  : 	}
; 628  : 
; 629  : 	STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  000d4	f3 0f 10 4d 88	 movss	 xmm1, DWORD PTR _fStanY$1$[ebp]
  000d9	f3 0f 5c c8	 subss	 xmm1, xmm0
  000dd	f3 0f 11 4d 88	 movss	 DWORD PTR _fStanY$1$[ebp], xmm1
$LN6@Render:
  000e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000e8	57		 push	 edi
  000e9	6a 05		 push	 5
  000eb	6a 13		 push	 19			; 00000013H
  000ed	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 630  : 	STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  000f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f8	6a 06		 push	 6
  000fa	6a 14		 push	 20			; 00000014H
  000fc	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 631  : 	DWORD dwFogEnable = STATEMANAGER.GetRenderState(D3DRS_FOGENABLE);

  00101	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00107	6a 1c		 push	 28			; 0000001cH
  00109	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState

; 632  : 	DWORD dwLighting = STATEMANAGER.GetRenderState(D3DRS_LIGHTING);

  0010e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00114	68 89 00 00 00	 push	 137			; 00000089H
  00119	89 85 60 ff ff
	ff		 mov	 DWORD PTR _dwFogEnable$1$[ebp], eax
  0011f	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState

; 633  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0012a	6a 00		 push	 0
  0012c	6a 1c		 push	 28			; 0000001cH
  0012e	89 85 68 ff ff
	ff		 mov	 DWORD PTR _dwLighting$1$[ebp], eax
  00134	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 634  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  00139	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0013f	6a 00		 push	 0
  00141	68 89 00 00 00	 push	 137			; 00000089H
  00146	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 635  : 
; 636  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1);

  0014b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00151	68 42 01 00 00	 push	 322			; 00000142H
  00156	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 637  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1,	D3DTA_TEXTURE);

  0015b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00161	6a 02		 push	 2
  00163	6a 02		 push	 2
  00165	6a 00		 push	 0
  00167	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 638  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2,	D3DTA_DIFFUSE);

  0016c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00172	6a 00		 push	 0
  00174	6a 03		 push	 3
  00176	6a 00		 push	 0
  00178	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 639  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,	D3DTOP_MODULATE);

  0017d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00183	6a 04		 push	 4
  00185	6a 01		 push	 1
  00187	6a 00		 push	 0
  00189	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 640  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1,	D3DTA_TEXTURE);

  0018e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00194	6a 02		 push	 2
  00196	6a 05		 push	 5
  00198	6a 00		 push	 0
  0019a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 641  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2,	D3DTA_DIFFUSE);

  0019f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001a5	6a 00		 push	 0
  001a7	6a 06		 push	 6
  001a9	6a 00		 push	 0
  001ab	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 642  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,	D3DTOP_MODULATE);

  001b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b6	6a 04		 push	 4
  001b8	6a 04		 push	 4
  001ba	6a 00		 push	 0
  001bc	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 643  : #ifdef ENABLE_FIX_MOBS_LAG
; 644  : //	std::map<CGraphicImageTexture*, std::vector<SPDTVertexRaw>> verticesMap;
; 645  : 	std::unordered_map<CGraphicImageTexture*, std::vector<SPDTVertexRaw>> verticesMap; //Poprawka GPT
; 646  : 
; 647  : #endif
; 648  : 
; 649  : 	{
; 650  : 		const float fFontHalfWeight=1.0f;
; 651  : 
; 652  : 		float fCurX;
; 653  : 		float fCurY;
; 654  : 
; 655  : 		float fFontSx;
; 656  : 		float fFontSy;
; 657  : 		float fFontEx;
; 658  : 		float fFontEy;
; 659  : 		float fFontWidth;
; 660  : 		float fFontHeight;
; 661  : 		float fFontMaxHeight;
; 662  : 		float fFontAdvance;
; 663  : 
; 664  : #ifdef ENABLE_FIX_MOBS_LAG
; 665  : 		SPDTVertexRaw akVertex[4];
; 666  : 		akVertex[0].pz = m_v3Position.z;
; 667  : 		akVertex[1].pz = m_v3Position.z;
; 668  : 		akVertex[2].pz = m_v3Position.z;
; 669  : 		akVertex[3].pz = m_v3Position.z;
; 670  : #else
; 671  : 		SVertex akVertex[4];
; 672  : 		akVertex[0].z=m_v3Position.z;
; 673  : 		akVertex[1].z=m_v3Position.z;
; 674  : 		akVertex[2].z=m_v3Position.z;
; 675  : 		akVertex[3].z=m_v3Position.z;
; 676  : #endif
; 677  : 
; 678  : 		CGraphicFontTexture::TCharacterInfomation* pCurCharInfo;
; 679  : 
; 680  : 		if (m_isOutline)

  001c1	80 7b 1b 00	 cmp	 BYTE PTR [ebx+27], 0
  001c5	0f 57 c9	 xorps	 xmm1, xmm1
  001c8	f3 0f 10 43 40	 movss	 xmm0, DWORD PTR [ebx+64]
  001cd	f3 0f 11 45 a4	 movss	 DWORD PTR _akVertex$8[ebp+8], xmm0
  001d2	f3 0f 11 45 bc	 movss	 DWORD PTR _akVertex$8[ebp+32], xmm0
  001d7	f3 0f 11 45 d4	 movss	 DWORD PTR _akVertex$8[ebp+56], xmm0
  001dc	f3 0f 11 45 ec	 movss	 DWORD PTR _akVertex$8[ebp+80], xmm0
  001e1	0f 84 56 03 00
	00		 je	 $LN34@Render

; 682  : 			fCurX=fStanX;

  001e7	f3 0f 10 55 90	 movss	 xmm2, DWORD PTR _fStanX$1$[ebp]

; 683  : 			fCurY=fStanY;

  001ec	f3 0f 10 5d 88	 movss	 xmm3, DWORD PTR _fStanY$1$[ebp]
  001f1	0f 28 e2	 movaps	 xmm4, xmm2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  001f4	8b 73 4c	 mov	 esi, DWORD PTR [ebx+76]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 682  : 			fCurX=fStanX;

  001f7	f3 0f 11 65 94	 movss	 DWORD PTR _fCurX$1$[ebp], xmm4

; 683  : 			fCurY=fStanY;

  001fc	f3 0f 11 5d 80	 movss	 DWORD PTR _fCurY$1$[ebp], xmm3
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00201	3b 73 50	 cmp	 esi, DWORD PTR [ebx+80]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 687  : 			for (i=m_pCharInfoVector.begin(); i!=m_pCharInfoVector.end(); ++i)

  00204	0f 84 30 03 00
	00		 je	 $LN276@Render
  0020a	66 0f 1f 44 00
	00		 npad	 6
$LL10@Render:

; 688  : 			{
; 689  : 				pCurCharInfo = *i;

  00210	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00212	89 8d 70 ff ff
	ff		 mov	 DWORD PTR _pCurCharInfo$1$[ebp], ecx

; 690  : 
; 691  : 				fFontWidth=float(pCurCharInfo->width);

  00218	0f bf 41 02	 movsx	 eax, WORD PTR [ecx+2]

; 692  : 				fFontHeight=float(pCurCharInfo->height);
; 693  : 				fFontAdvance=float(pCurCharInfo->advance);

  0021c	f3 0f 10 41 18	 movss	 xmm0, DWORD PTR [ecx+24]
  00221	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR tv2346[ebp], xmm0
  00229	66 0f 6e e8	 movd	 xmm5, eax
  0022d	0f bf 41 04	 movsx	 eax, WORD PTR [ecx+4]
  00231	0f 5b ed	 cvtdq2ps xmm5, xmm5
  00234	66 0f 6e f0	 movd	 xmm6, eax

; 694  : 
; 695  : 				if ((fCurX+fFontWidth)-m_v3Position.x > m_fLimitWidth)

  00238	0f 28 c5	 movaps	 xmm0, xmm5
  0023b	f3 0f 58 c4	 addss	 xmm0, xmm4
  0023f	0f 5b f6	 cvtdq2ps xmm6, xmm6
  00242	f3 0f 5c 43 38	 subss	 xmm0, DWORD PTR [ebx+56]
  00247	0f 2f 43 14	 comiss	 xmm0, DWORD PTR [ebx+20]
  0024b	76 1b		 jbe	 SHORT $LN35@Render

; 696  : 				{
; 697  : 					if (m_isMultiLine)

  0024d	80 7b 1a 00	 cmp	 BYTE PTR [ebx+26], 0
  00251	0f 84 e3 02 00
	00		 je	 $LN276@Render

; 698  : 					{
; 699  : 						fCurX=fStanX;
; 700  : 						fCurY+=fFontMaxHeight;

  00257	f3 0f 58 d9	 addss	 xmm3, xmm1
  0025b	0f 28 e2	 movaps	 xmm4, xmm2
  0025e	f3 0f 11 65 94	 movss	 DWORD PTR _fCurX$1$[ebp], xmm4
  00263	f3 0f 11 5d 80	 movss	 DWORD PTR _fCurY$1$[ebp], xmm3
$LN35@Render:

; 701  : 					}
; 702  : 					else
; 703  : 					{
; 704  : 						break;
; 705  : 					}
; 706  : 				}
; 707  : 
; 708  : 				if (pClipRect)

  00268	8b 45 08	 mov	 eax, DWORD PTR _pClipRect$[ebp]
  0026b	85 c0		 test	 eax, eax
  0026d	74 11		 je	 SHORT $LN37@Render

; 709  : 				{
; 710  : 					if (fCurY <= pClipRect->top)

  0026f	66 0f 6e 40 04	 movd	 xmm0, DWORD PTR [eax+4]
  00274	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00277	0f 2f c3	 comiss	 xmm0, xmm3
  0027a	0f 83 a1 02 00
	00		 jae	 $LN8@Render
$LN37@Render:

; 711  : 					{
; 712  : 						fCurX += fFontAdvance;
; 713  : 						continue;
; 714  : 					}
; 715  : 				}
; 716  : 
; 717  : 				fFontSx = fCurX - 0.5f;
; 718  : 				fFontSy = fCurY - 0.5f;
; 719  : 				fFontEx = fFontSx + fFontWidth;
; 720  : 				fFontEy = fFontSy + fFontHeight;
; 721  : 
; 722  : #ifdef ENABLE_FIX_MOBS_LAG
; 723  : 				const auto tex = pFontTexture->GetTexture(pCurCharInfo->index);
; 724  : 				auto & batchVertices = verticesMap[tex];
; 725  : #else
; 726  : 				pFontTexture->SelectTexture(pCurCharInfo->index);

  00280	0f bf 01	 movsx	 eax, WORD PTR [ecx]
  00283	0f 28 cc	 movaps	 xmm1, xmm4
  00286	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3f000000
  0028e	8b 4d 98	 mov	 ecx, DWORD PTR _pFontTexture$1$[ebp]
  00291	0f 28 c3	 movaps	 xmm0, xmm3
  00294	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  0029c	50		 push	 eax
  0029d	f3 0f 11 4d 8c	 movss	 DWORD PTR _fFontSx$1$[ebp], xmm1
  002a2	f3 0f 58 cd	 addss	 xmm1, xmm5
  002a6	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _fFontSy$1$[ebp], xmm0
  002ae	f3 0f 58 c6	 addss	 xmm0, xmm6
  002b2	f3 0f 11 8d 7c
	ff ff ff	 movss	 DWORD PTR _fFontEx$1$[ebp], xmm1
  002ba	f3 0f 11 45 84	 movss	 DWORD PTR _fFontEy$1$[ebp], xmm0
  002bf	e8 00 00 00 00	 call	 ?SelectTexture@CGraphicFontTexture@@QAEXK@Z ; CGraphicFontTexture::SelectTexture

; 727  : 				STATEMANAGER.SetTexture(0, pFontTexture->GetD3DTexture());

  002c4	8b 4d 98	 mov	 ecx, DWORD PTR _pFontTexture$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  002c7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 727  : 				STATEMANAGER.SetTexture(0, pFontTexture->GetD3DTexture());

  002cd	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  002d2	50		 push	 eax
  002d3	6a 00		 push	 0
  002d5	8b cf		 mov	 ecx, edi
  002d7	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 728  : #endif
; 729  : 
; 730  : 				akVertex[0].u=pCurCharInfo->left;

  002dc	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _pCurCharInfo$1$[ebp]
  002e2	0f 57 d2	 xorps	 xmm2, xmm2

; 731  : 				akVertex[0].v=pCurCharInfo->top;
; 732  : 				akVertex[1].u=pCurCharInfo->left;
; 733  : 				akVertex[1].v=pCurCharInfo->bottom;
; 734  : 				akVertex[2].u=pCurCharInfo->right;
; 735  : 				akVertex[2].v=pCurCharInfo->top;
; 736  : 				akVertex[3].u=pCurCharInfo->right;
; 737  : 				akVertex[3].v=pCurCharInfo->bottom;
; 738  : 
; 739  : #ifdef ENABLE_FIX_MOBS_LAG
; 740  : 				akVertex[3].diffuse = akVertex[2].diffuse = akVertex[1].diffuse = akVertex[0].diffuse = m_dwOutLineColor;
; 741  : #else
; 742  : 				akVertex[3].color = akVertex[2].color = akVertex[1].color = akVertex[0].color = m_dwOutLineColor;
; 743  : #endif
; 744  : 
; 745  : 				float feather = 0.0f; // m_fFontFeather
; 746  : 
; 747  : #ifdef ENABLE_FIX_MOBS_LAG
; 748  : 				akVertex[0].py = fFontSy - feather;
; 749  : 				akVertex[1].py = fFontEy + feather;
; 750  : 				akVertex[2].py = fFontSy - feather;
; 751  : 				akVertex[3].py = fFontEy + feather;
; 752  : 				akVertex[0].px = fFontSx - fFontHalfWeight - feather;
; 753  : 				akVertex[1].px = fFontSx - fFontHalfWeight - feather;
; 754  : 				akVertex[2].px = fFontEx - fFontHalfWeight + feather;
; 755  : 				akVertex[3].px = fFontEx - fFontHalfWeight + feather;
; 756  : #else
; 757  : 				akVertex[0].y=fFontSy-feather;

  002e5	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fFontSy$1$[ebp]
  002ed	f3 0f 5c ca	 subss	 xmm1, xmm2

; 758  : 				akVertex[1].y=fFontEy+feather;
; 759  : 				akVertex[2].y=fFontSy-feather;
; 760  : 				akVertex[3].y=fFontEy+feather;
; 761  : 				akVertex[0].x=fFontSx-fFontHalfWeight-feather;
; 762  : 				akVertex[1].x=fFontSx-fFontHalfWeight-feather;
; 763  : 				akVertex[2].x=fFontEx-fFontHalfWeight+feather;
; 764  : 				akVertex[3].x=fFontEx-fFontHalfWeight+feather;
; 765  : #endif
; 766  : 
; 767  : #ifdef ENABLE_FIX_MOBS_LAG
; 768  : 				batchVertices.insert(batchVertices.end(),
; 769  : 				std::begin(akVertex), std::end(akVertex));
; 770  : 				
; 771  : 				akVertex[0].px = fFontSx + fFontHalfWeight - feather;
; 772  : 				akVertex[1].px = fFontSx + fFontHalfWeight - feather;
; 773  : 				akVertex[2].px = fFontEx + fFontHalfWeight + feather;
; 774  : 				akVertex[3].px = fFontEx + fFontHalfWeight + feather;
; 775  : #else
; 776  : 				if (CGraphicBase::SetPDTStream((SPDTVertex*)akVertex, 4))

  002f1	6a 04		 push	 4
  002f3	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002f8	f3 0f 11 45 ac	 movss	 DWORD PTR _akVertex$8[ebp+16], xmm0
  002fd	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00302	f3 0f 11 45 b0	 movss	 DWORD PTR _akVertex$8[ebp+20], xmm0
  00307	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0030c	f3 0f 11 45 c4	 movss	 DWORD PTR _akVertex$8[ebp+40], xmm0
  00311	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00316	f3 0f 11 45 c8	 movss	 DWORD PTR _akVertex$8[ebp+44], xmm0
  0031b	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00320	f3 0f 11 45 dc	 movss	 DWORD PTR _akVertex$8[ebp+64], xmm0
  00325	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0032a	f3 0f 11 45 e0	 movss	 DWORD PTR _akVertex$8[ebp+68], xmm0
  0032f	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [eax+16]
  00334	f3 0f 11 45 f4	 movss	 DWORD PTR _akVertex$8[ebp+88], xmm0
  00339	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0033e	f3 0f 11 45 f8	 movss	 DWORD PTR _akVertex$8[ebp+92], xmm0
  00343	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _fFontEy$1$[ebp]
  00348	f3 0f 58 c2	 addss	 xmm0, xmm2
  0034c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0034f	89 45 a8	 mov	 DWORD PTR _akVertex$8[ebp+12], eax
  00352	89 45 c0	 mov	 DWORD PTR _akVertex$8[ebp+36], eax
  00355	89 45 d8	 mov	 DWORD PTR _akVertex$8[ebp+60], eax
  00358	89 45 f0	 mov	 DWORD PTR _akVertex$8[ebp+84], eax
  0035b	8d 45 9c	 lea	 eax, DWORD PTR _akVertex$8[ebp]
  0035e	f3 0f 11 45 b8	 movss	 DWORD PTR _akVertex$8[ebp+28], xmm0
  00363	f3 0f 11 45 e8	 movss	 DWORD PTR _akVertex$8[ebp+76], xmm0
  00368	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _fFontSx$1$[ebp]
  0036d	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00375	50		 push	 eax
  00376	f3 0f 11 4d a0	 movss	 DWORD PTR _akVertex$8[ebp+4], xmm1
  0037b	f3 0f 11 4d d0	 movss	 DWORD PTR _akVertex$8[ebp+52], xmm1
  00380	f3 0f 5c c2	 subss	 xmm0, xmm2
  00384	f3 0f 11 45 9c	 movss	 DWORD PTR _akVertex$8[ebp], xmm0
  00389	f3 0f 11 45 b4	 movss	 DWORD PTR _akVertex$8[ebp+24], xmm0
  0038e	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$1$[ebp]
  00396	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0039e	f3 0f 58 c2	 addss	 xmm0, xmm2
  003a2	f3 0f 11 45 cc	 movss	 DWORD PTR _akVertex$8[ebp+48], xmm0
  003a7	f3 0f 11 45 e4	 movss	 DWORD PTR _akVertex$8[ebp+72], xmm0
  003ac	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  003b1	83 c4 08	 add	 esp, 8
  003b4	84 c0		 test	 al, al
  003b6	74 11		 je	 SHORT $LN38@Render

; 777  : 					STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

  003b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003be	6a 02		 push	 2
  003c0	6a 00		 push	 0
  003c2	6a 05		 push	 5
  003c4	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN38@Render:

; 778  : 
; 779  : 				akVertex[0].x=fFontSx+fFontHalfWeight-feather;

  003c9	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _fFontSx$1$[ebp]

; 780  : 				akVertex[1].x=fFontSx+fFontHalfWeight-feather;
; 781  : 				akVertex[2].x=fFontEx+fFontHalfWeight+feather;
; 782  : 				akVertex[3].x=fFontEx+fFontHalfWeight+feather;
; 783  : #endif
; 784  : 
; 785  : 
; 786  : #ifdef ENABLE_FIX_MOBS_LAG
; 787  : 				batchVertices.insert(batchVertices.end(),
; 788  : 					std::begin(akVertex), std::end(akVertex));
; 789  : 
; 790  : 				akVertex[0].px = fFontSx - feather;
; 791  : 				akVertex[1].px = fFontSx - feather;
; 792  : 				akVertex[2].px = fFontEx + feather;
; 793  : 				akVertex[3].px = fFontEx + feather;
; 794  : 				
; 795  : 				akVertex[0].py = fFontSy - fFontHalfWeight - feather;
; 796  : 				akVertex[1].py = fFontEy - fFontHalfWeight + feather;
; 797  : 				akVertex[2].py = fFontSy - fFontHalfWeight - feather;
; 798  : 				akVertex[3].py = fFontEy - fFontHalfWeight + feather;
; 799  : #else
; 800  : 				if (CGraphicBase::SetPDTStream((SPDTVertex*)akVertex, 4))

  003ce	8d 45 9c	 lea	 eax, DWORD PTR _akVertex$8[ebp]
  003d1	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  003d9	0f 57 c9	 xorps	 xmm1, xmm1
  003dc	6a 04		 push	 4
  003de	50		 push	 eax
  003df	f3 0f 5c c1	 subss	 xmm0, xmm1
  003e3	f3 0f 11 45 9c	 movss	 DWORD PTR _akVertex$8[ebp], xmm0
  003e8	f3 0f 11 45 b4	 movss	 DWORD PTR _akVertex$8[ebp+24], xmm0
  003ed	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$1$[ebp]
  003f5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  003fd	f3 0f 58 c1	 addss	 xmm0, xmm1
  00401	f3 0f 11 45 cc	 movss	 DWORD PTR _akVertex$8[ebp+48], xmm0
  00406	f3 0f 11 45 e4	 movss	 DWORD PTR _akVertex$8[ebp+72], xmm0
  0040b	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  00410	83 c4 08	 add	 esp, 8
  00413	84 c0		 test	 al, al
  00415	74 11		 je	 SHORT $LN39@Render

; 801  : 					STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

  00417	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0041d	6a 02		 push	 2
  0041f	6a 00		 push	 0
  00421	6a 05		 push	 5
  00423	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN39@Render:

; 802  : 
; 803  : 				akVertex[0].x=fFontSx-feather;

  00428	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _fFontSx$1$[ebp]

; 804  : 				akVertex[1].x=fFontSx-feather;
; 805  : 				akVertex[2].x=fFontEx+feather;
; 806  : 				akVertex[3].x=fFontEx+feather;
; 807  : 
; 808  : 				akVertex[0].y=fFontSy-fFontHalfWeight-feather;
; 809  : 				akVertex[1].y=fFontEy-fFontHalfWeight+feather;
; 810  : 				akVertex[2].y=fFontSy-fFontHalfWeight-feather;
; 811  : 				akVertex[3].y=fFontEy-fFontHalfWeight+feather;
; 812  : #endif
; 813  : 
; 814  : #ifdef ENABLE_FIX_MOBS_LAG
; 815  : 				batchVertices.insert(batchVertices.end(),
; 816  : 					std::begin(akVertex), std::end(akVertex));
; 817  : 
; 818  : 				akVertex[0].py = fFontSy + fFontHalfWeight - feather;
; 819  : 				akVertex[1].py = fFontEy + fFontHalfWeight + feather;
; 820  : 				akVertex[2].py = fFontSy + fFontHalfWeight - feather;
; 821  : 				akVertex[3].py = fFontEy + fFontHalfWeight + feather;
; 822  : #else
; 823  : 				// 20041216.myevan.DrawPrimitiveUP
; 824  : 				if (CGraphicBase::SetPDTStream((SPDTVertex*)akVertex, 4))

  0042d	8d 45 9c	 lea	 eax, DWORD PTR _akVertex$8[ebp]
  00430	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fFontSy$1$[ebp]
  00438	0f 57 d2	 xorps	 xmm2, xmm2
  0043b	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3f800000
  00443	f3 0f 5c c2	 subss	 xmm0, xmm2
  00447	6a 04		 push	 4
  00449	50		 push	 eax
  0044a	f3 0f 5c ca	 subss	 xmm1, xmm2
  0044e	f3 0f 11 45 9c	 movss	 DWORD PTR _akVertex$8[ebp], xmm0
  00453	f3 0f 11 45 b4	 movss	 DWORD PTR _akVertex$8[ebp+24], xmm0
  00458	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontEx$1$[ebp]
  00460	f3 0f 58 c2	 addss	 xmm0, xmm2
  00464	f3 0f 11 4d a0	 movss	 DWORD PTR _akVertex$8[ebp+4], xmm1
  00469	f3 0f 11 4d d0	 movss	 DWORD PTR _akVertex$8[ebp+52], xmm1
  0046e	f3 0f 11 45 cc	 movss	 DWORD PTR _akVertex$8[ebp+48], xmm0
  00473	f3 0f 11 45 e4	 movss	 DWORD PTR _akVertex$8[ebp+72], xmm0
  00478	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _fFontEy$1$[ebp]
  0047d	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00485	f3 0f 58 c2	 addss	 xmm0, xmm2
  00489	f3 0f 11 45 b8	 movss	 DWORD PTR _akVertex$8[ebp+28], xmm0
  0048e	f3 0f 11 45 e8	 movss	 DWORD PTR _akVertex$8[ebp+76], xmm0
  00493	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  00498	83 c4 08	 add	 esp, 8
  0049b	84 c0		 test	 al, al
  0049d	74 11		 je	 SHORT $LN40@Render

; 825  : 					STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

  0049f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004a5	6a 02		 push	 2
  004a7	6a 00		 push	 0
  004a9	6a 05		 push	 5
  004ab	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN40@Render:

; 826  : 
; 827  : 				akVertex[0].y=fFontSy+fFontHalfWeight-feather;

  004b0	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _fFontSy$1$[ebp]

; 828  : 				akVertex[1].y=fFontEy+fFontHalfWeight+feather;
; 829  : 				akVertex[2].y=fFontSy+fFontHalfWeight-feather;
; 830  : 				akVertex[3].y=fFontEy+fFontHalfWeight+feather;
; 831  : #endif
; 832  : 
; 833  : #ifdef ENABLE_FIX_MOBS_LAG
; 834  : 				batchVertices.insert(batchVertices.end(),
; 835  : 					std::begin(akVertex), std::end(akVertex));
; 836  : #else
; 837  : 				// 20041216.myevan.DrawPrimitiveUP
; 838  : 				if (CGraphicBase::SetPDTStream((SPDTVertex*)akVertex, 4))

  004b8	8d 45 9c	 lea	 eax, DWORD PTR _akVertex$8[ebp]
  004bb	f3 0f 10 55 84	 movss	 xmm2, DWORD PTR _fFontEy$1$[ebp]
  004c0	0f 57 c9	 xorps	 xmm1, xmm1
  004c3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  004cb	f3 0f 58 15 00
	00 00 00	 addss	 xmm2, DWORD PTR __real@3f800000
  004d3	6a 04		 push	 4
  004d5	50		 push	 eax
  004d6	f3 0f 5c c1	 subss	 xmm0, xmm1
  004da	f3 0f 58 d1	 addss	 xmm2, xmm1
  004de	f3 0f 11 45 a0	 movss	 DWORD PTR _akVertex$8[ebp+4], xmm0
  004e3	f3 0f 11 55 b8	 movss	 DWORD PTR _akVertex$8[ebp+28], xmm2
  004e8	f3 0f 11 45 d0	 movss	 DWORD PTR _akVertex$8[ebp+52], xmm0
  004ed	f3 0f 11 55 e8	 movss	 DWORD PTR _akVertex$8[ebp+76], xmm2
  004f2	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  004f7	83 c4 08	 add	 esp, 8
  004fa	84 c0		 test	 al, al
  004fc	74 11		 je	 SHORT $LN273@Render

; 839  : 					STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

  004fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00504	6a 02		 push	 2
  00506	6a 00		 push	 0
  00508	6a 05		 push	 5
  0050a	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN273@Render:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 82   :         ++_Ptr;

  0050f	f3 0f 10 65 94	 movss	 xmm4, DWORD PTR _fCurX$1$[ebp]
  00514	0f 57 c9	 xorps	 xmm1, xmm1
  00517	f3 0f 10 5d 80	 movss	 xmm3, DWORD PTR _fCurY$1$[ebp]
  0051c	f3 0f 10 55 90	 movss	 xmm2, DWORD PTR _fStanX$1$[ebp]
$LN8@Render:
  00521	f3 0f 58 a5 74
	ff ff ff	 addss	 xmm4, DWORD PTR tv2346[ebp]
  00529	83 c6 04	 add	 esi, 4

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0052c	f3 0f 11 65 94	 movss	 DWORD PTR _fCurX$1$[ebp], xmm4

; 166  :         return _Ptr == _Right._Ptr;

  00531	3b 73 50	 cmp	 esi, DWORD PTR [ebx+80]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 687  : 			for (i=m_pCharInfoVector.begin(); i!=m_pCharInfoVector.end(); ++i)

  00534	0f 85 d6 fc ff
	ff		 jne	 $LL10@Render
$LN276@Render:

; 846  : 		fCurX=fStanX;

  0053a	8b 75 98	 mov	 esi, DWORD PTR _pFontTexture$1$[ebp]
$LN34@Render:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0053d	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 850  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  00540	33 ff		 xor	 edi, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00542	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  00545	2b c1		 sub	 eax, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 846  : 		fCurX=fStanX;

  00547	f3 0f 10 4d 90	 movss	 xmm1, DWORD PTR _fStanX$1$[ebp]

; 847  : 		fCurY=fStanY;

  0054c	f3 0f 10 5d 88	 movss	 xmm3, DWORD PTR _fStanY$1$[ebp]
  00551	0f 28 d1	 movaps	 xmm2, xmm1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00554	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 846  : 		fCurX=fStanX;

  00557	f3 0f 11 55 94	 movss	 DWORD PTR _fCurX$2$[ebp], xmm2

; 847  : 		fCurY=fStanY;

  0055c	f3 0f 11 5d 80	 movss	 DWORD PTR _fCurY$2$[ebp], xmm3

; 850  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  00561	89 7d 84	 mov	 DWORD PTR _i$1$[ebp], edi
  00564	85 c0		 test	 eax, eax
  00566	0f 84 db 01 00
	00		 je	 $LN272@Render
  0056c	0f 1f 40 00	 npad	 4
$LL13@Render:

; 851  : 		{
; 852  : 			pCurCharInfo = m_pCharInfoVector[i];

  00570	8b 3c b9	 mov	 edi, DWORD PTR [ecx+edi*4]

; 853  : 
; 854  : 			fFontWidth=float(pCurCharInfo->width);

  00573	0f bf 47 02	 movsx	 eax, WORD PTR [edi+2]

; 855  : 			fFontHeight=float(pCurCharInfo->height);
; 856  : 			fFontMaxHeight=max(fFontHeight, pCurCharInfo->height);
; 857  : 			fFontAdvance=float(pCurCharInfo->advance);

  00577	f3 0f 10 47 18	 movss	 xmm0, DWORD PTR [edi+24]
  0057c	f3 0f 11 45 8c	 movss	 DWORD PTR tv2384[ebp], xmm0
  00581	66 0f 6e e8	 movd	 xmm5, eax
  00585	0f bf 47 04	 movsx	 eax, WORD PTR [edi+4]
  00589	0f 5b ed	 cvtdq2ps xmm5, xmm5
  0058c	66 0f 6e e0	 movd	 xmm4, eax

; 858  : 
; 859  : 			if ((fCurX+fFontWidth)-m_v3Position.x > m_fLimitWidth)

  00590	0f 28 c5	 movaps	 xmm0, xmm5
  00593	f3 0f 58 c2	 addss	 xmm0, xmm2
  00597	0f 5b e4	 cvtdq2ps xmm4, xmm4
  0059a	f3 0f 5c 43 38	 subss	 xmm0, DWORD PTR [ebx+56]
  0059f	0f 2f 43 14	 comiss	 xmm0, DWORD PTR [ebx+20]
  005a3	76 1e		 jbe	 SHORT $LN44@Render

; 860  : 			{
; 861  : 				if (m_isMultiLine)

  005a5	80 7b 1a 00	 cmp	 BYTE PTR [ebx+26], 0
  005a9	0f 84 98 01 00
	00		 je	 $LN272@Render

; 862  : 				{
; 863  : 					fCurX=fStanX;
; 864  : 					fCurY+=fFontMaxHeight;

  005af	0f 28 c4	 movaps	 xmm0, xmm4
  005b2	0f 28 d1	 movaps	 xmm2, xmm1
  005b5	f3 0f 58 d8	 addss	 xmm3, xmm0
  005b9	f3 0f 11 55 94	 movss	 DWORD PTR _fCurX$2$[ebp], xmm2
  005be	f3 0f 11 5d 80	 movss	 DWORD PTR _fCurY$2$[ebp], xmm3
$LN44@Render:

; 865  : 				}
; 866  : 				else
; 867  : 				{
; 868  : 					break;
; 869  : 				}
; 870  : 			}
; 871  : 
; 872  : 			if (pClipRect)

  005c3	8b 45 08	 mov	 eax, DWORD PTR _pClipRect$[ebp]
  005c6	85 c0		 test	 eax, eax
  005c8	74 11		 je	 SHORT $LN269@Render

; 873  : 			{
; 874  : 				if (fCurY <= pClipRect->top)

  005ca	66 0f 6e 40 04	 movd	 xmm0, DWORD PTR [eax+4]
  005cf	0f 5b c0	 cvtdq2ps xmm0, xmm0
  005d2	0f 2f c3	 comiss	 xmm0, xmm3
  005d5	0f 83 45 01 00
	00		 jae	 $LN275@Render
$LN269@Render:

; 875  : 				{
; 876  : 					fCurX += fFontAdvance;
; 877  : 					continue;
; 878  : 				}
; 879  : 			}
; 880  : 
; 881  : 
; 882  : #ifdef ENABLE_FIX_MOBS_LAG
; 883  : 			fFontSx = fCurX - 0.5f;
; 884  : 			fFontSy = fCurY - 0.5f;
; 885  : 			fFontEx = fFontSx + fFontWidth;
; 886  : 			fFontEy = fFontSy + fFontHeight;
; 887  : 			const auto tex = pFontTexture->GetTexture(pCurCharInfo->index);
; 888  : 			auto & batchVertices = verticesMap[tex];
; 889  : 
; 890  : 			akVertex[0].px = fFontSx;
; 891  : 			akVertex[0].py = fFontSy;
; 892  : 			akVertex[0].u = pCurCharInfo->left;
; 893  : 			akVertex[0].v = pCurCharInfo->top;
; 894  : 
; 895  : 			akVertex[1].px = fFontSx;
; 896  : 			akVertex[1].py = fFontEy;
; 897  : 			akVertex[1].u = pCurCharInfo->left;
; 898  : 			akVertex[1].v = pCurCharInfo->bottom;
; 899  : 
; 900  : 			akVertex[2].px = fFontEx;
; 901  : 			akVertex[2].py = fFontSy;
; 902  : 			akVertex[2].u = pCurCharInfo->right;
; 903  : 			akVertex[2].v = pCurCharInfo->top;
; 904  : 
; 905  : 			akVertex[3].px = fFontEx;
; 906  : 			akVertex[3].py = fFontEy;
; 907  : 			akVertex[3].u = pCurCharInfo->right;
; 908  : 			akVertex[3].v = pCurCharInfo->bottom;
; 909  : 
; 910  : 			akVertex[0].diffuse = akVertex[1].diffuse = akVertex[2].diffuse = akVertex[3].diffuse = m_dwColorInfoVector[i];
; 911  : #else
; 912  : 			fFontSx = fCurX-0.5f;
; 913  : 			fFontSy = fCurY-0.5f;
; 914  : 			fFontEx = fFontSx + fFontWidth;
; 915  : 			fFontEy = fFontSy + fFontHeight;
; 916  : 
; 917  : 			pFontTexture->SelectTexture(pCurCharInfo->index);

  005db	0f bf 07	 movsx	 eax, WORD PTR [edi]
  005de	0f 28 c2	 movaps	 xmm0, xmm2
  005e1	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  005e9	0f 28 cb	 movaps	 xmm1, xmm3
  005ec	8b ce		 mov	 ecx, esi
  005ee	f3 0f 5c 0d 00
	00 00 00	 subss	 xmm1, DWORD PTR __real@3f000000
  005f6	50		 push	 eax
  005f7	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _fFontSx$2$[ebp], xmm0
  005ff	f3 0f 58 c5	 addss	 xmm0, xmm5
  00603	f3 0f 11 8d 70
	ff ff ff	 movss	 DWORD PTR _fFontSy$2$[ebp], xmm1
  0060b	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _fFontEx$2$[ebp], xmm0
  00613	0f 28 c1	 movaps	 xmm0, xmm1
  00616	f3 0f 58 c4	 addss	 xmm0, xmm4
  0061a	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _fFontEy$2$[ebp], xmm0
  00622	e8 00 00 00 00	 call	 ?SelectTexture@CGraphicFontTexture@@QAEXK@Z ; CGraphicFontTexture::SelectTexture

; 918  : 			STATEMANAGER.SetTexture(0, pFontTexture->GetD3DTexture());

  00627	8b 4d 98	 mov	 ecx, DWORD PTR _pFontTexture$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0062a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 918  : 			STATEMANAGER.SetTexture(0, pFontTexture->GetD3DTexture());

  00630	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00635	50		 push	 eax
  00636	6a 00		 push	 0
  00638	8b ce		 mov	 ecx, esi
  0063a	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 919  : 
; 920  : 			akVertex[0].x=fFontSx;

  0063f	f3 0f 10 8d 74
	ff ff ff	 movss	 xmm1, DWORD PTR _fFontSx$2$[ebp]

; 921  : 			akVertex[0].y=fFontSy;

  00647	f3 0f 10 95 70
	ff ff ff	 movss	 xmm2, DWORD PTR _fFontSy$2$[ebp]

; 922  : 			akVertex[0].u=pCurCharInfo->left;
; 923  : 			akVertex[0].v=pCurCharInfo->top;
; 924  : 
; 925  : 			akVertex[1].x=fFontSx;
; 926  : 			akVertex[1].y=fFontEy;
; 927  : 			akVertex[1].u=pCurCharInfo->left;
; 928  : 			akVertex[1].v=pCurCharInfo->bottom;
; 929  : 
; 930  : 			akVertex[2].x=fFontEx;

  0064f	f3 0f 10 9d 7c
	ff ff ff	 movss	 xmm3, DWORD PTR _fFontEx$2$[ebp]
  00657	f3 0f 11 4d 9c	 movss	 DWORD PTR _akVertex$8[ebp], xmm1
  0065c	f3 0f 11 55 a0	 movss	 DWORD PTR _akVertex$8[ebp+4], xmm2
  00661	f3 0f 10 47 08	 movss	 xmm0, DWORD PTR [edi+8]

; 931  : 			akVertex[2].y=fFontSy;
; 932  : 			akVertex[2].u=pCurCharInfo->right;
; 933  : 			akVertex[2].v=pCurCharInfo->top;
; 934  : 
; 935  : 			akVertex[3].x=fFontEx;
; 936  : 			akVertex[3].y=fFontEy;
; 937  : 			akVertex[3].u=pCurCharInfo->right;
; 938  : 			akVertex[3].v=pCurCharInfo->bottom;
; 939  : 
; 940  : 			//m_dwColorInfoVector[i];
; 941  : 			//m_dwTextColor;
; 942  : 			akVertex[0].color = akVertex[1].color = akVertex[2].color = akVertex[3].color = m_dwColorInfoVector[i];

  00666	8b 43 58	 mov	 eax, DWORD PTR [ebx+88]
  00669	f3 0f 11 45 ac	 movss	 DWORD PTR _akVertex$8[ebp+16], xmm0
  0066e	f3 0f 10 47 0c	 movss	 xmm0, DWORD PTR [edi+12]
  00673	f3 0f 11 4d b4	 movss	 DWORD PTR _akVertex$8[ebp+24], xmm1
  00678	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fFontEy$2$[ebp]
  00680	f3 0f 11 45 b0	 movss	 DWORD PTR _akVertex$8[ebp+20], xmm0
  00685	f3 0f 11 4d b8	 movss	 DWORD PTR _akVertex$8[ebp+28], xmm1
  0068a	f3 0f 10 47 08	 movss	 xmm0, DWORD PTR [edi+8]
  0068f	f3 0f 11 45 c4	 movss	 DWORD PTR _akVertex$8[ebp+40], xmm0
  00694	f3 0f 10 47 14	 movss	 xmm0, DWORD PTR [edi+20]
  00699	f3 0f 11 45 c8	 movss	 DWORD PTR _akVertex$8[ebp+44], xmm0
  0069e	f3 0f 11 5d cc	 movss	 DWORD PTR _akVertex$8[ebp+48], xmm3
  006a3	f3 0f 11 55 d0	 movss	 DWORD PTR _akVertex$8[ebp+52], xmm2
  006a8	f3 0f 10 47 10	 movss	 xmm0, DWORD PTR [edi+16]
  006ad	f3 0f 11 45 dc	 movss	 DWORD PTR _akVertex$8[ebp+64], xmm0
  006b2	f3 0f 10 47 0c	 movss	 xmm0, DWORD PTR [edi+12]
  006b7	f3 0f 11 45 e0	 movss	 DWORD PTR _akVertex$8[ebp+68], xmm0
  006bc	f3 0f 11 5d e4	 movss	 DWORD PTR _akVertex$8[ebp+72], xmm3
  006c1	f3 0f 11 4d e8	 movss	 DWORD PTR _akVertex$8[ebp+76], xmm1
  006c6	f3 0f 10 47 10	 movss	 xmm0, DWORD PTR [edi+16]
  006cb	f3 0f 11 45 f4	 movss	 DWORD PTR _akVertex$8[ebp+88], xmm0
  006d0	f3 0f 10 47 14	 movss	 xmm0, DWORD PTR [edi+20]
  006d5	8b 7d 84	 mov	 edi, DWORD PTR _i$1$[ebp]
  006d8	f3 0f 11 45 f8	 movss	 DWORD PTR _akVertex$8[ebp+92], xmm0

; 943  : #endif
; 944  : 
; 945  : #ifdef ENABLE_FIX_MOBS_LAG
; 946  : 			batchVertices.insert(batchVertices.end(),
; 947  : 				std::begin(akVertex), std::end(akVertex));
; 948  : 
; 949  : 			fCurX += fFontAdvance;
; 950  : 		}
; 951  : 	}
; 952  : 
; 953  : 	for (auto& p : verticesMap)
; 954  : 	{
; 955  : 		STATEMANAGER.SetTexture(0, p.first->GetD3DTexture());
; 956  : 		
; 957  : 		for (auto f = p.second.begin(), l = p.second.end(); f != l; )
; 958  : 		{
; 959  : 			 auto batchCount = std::min<std::size_t>(LARGE_PDT_VERTEX_BUFFER_SIZE,
; 960  : 				l - f);
; 961  : 			
; 962  : 			if (CGraphicBase::SetPDTStream(&*f, batchCount))
; 963  : 			STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0,
; 964  : 				batchCount - 2);		
; 965  : 				f += batchCount;
; 966  : 		}
; 967  : 	}
; 968  : 
; 969  : 	//Poprawka GPT (4)
; 970  : 
; 971  : 
; 972  : #else
; 973  : 			// 20041216.myevan.DrawPrimitiveUP
; 974  : 			if (CGraphicBase::SetPDTStream((SPDTVertex*)akVertex, 4))

  006dd	6a 04		 push	 4
  006df	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  006e2	89 45 f0	 mov	 DWORD PTR _akVertex$8[ebp+84], eax
  006e5	89 45 d8	 mov	 DWORD PTR _akVertex$8[ebp+60], eax
  006e8	89 45 c0	 mov	 DWORD PTR _akVertex$8[ebp+36], eax
  006eb	89 45 a8	 mov	 DWORD PTR _akVertex$8[ebp+12], eax
  006ee	8d 45 9c	 lea	 eax, DWORD PTR _akVertex$8[ebp]
  006f1	50		 push	 eax
  006f2	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  006f7	83 c4 08	 add	 esp, 8
  006fa	84 c0		 test	 al, al
  006fc	74 11		 je	 SHORT $LN274@Render

; 975  : 				STATEMANAGER.DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

  006fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00704	6a 02		 push	 2
  00706	6a 00		 push	 0
  00708	6a 05		 push	 5
  0070a	e8 00 00 00 00	 call	 ?DrawPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@II@Z ; CStateManager::DrawPrimitive
$LN274@Render:

; 850  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  0070f	f3 0f 10 4d 90	 movss	 xmm1, DWORD PTR _fStanX$1$[ebp]
  00714	f3 0f 10 55 94	 movss	 xmm2, DWORD PTR _fCurX$2$[ebp]
  00719	f3 0f 10 5d 80	 movss	 xmm3, DWORD PTR _fCurY$2$[ebp]
  0071e	eb 03		 jmp	 SHORT $LN11@Render
$LN275@Render:

; 873  : 			{
; 874  : 				if (fCurY <= pClipRect->top)

  00720	8b 7d 84	 mov	 edi, DWORD PTR _i$1$[ebp]
$LN11@Render:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00723	8b 43 50	 mov	 eax, DWORD PTR [ebx+80]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 850  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  00726	47		 inc	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00727	8b 4b 4c	 mov	 ecx, DWORD PTR [ebx+76]
  0072a	2b c1		 sub	 eax, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 850  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  0072c	f3 0f 58 55 8c	 addss	 xmm2, DWORD PTR tv2384[ebp]
  00731	8b 75 98	 mov	 esi, DWORD PTR _pFontTexture$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00734	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 850  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  00737	89 7d 84	 mov	 DWORD PTR _i$1$[ebp], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0073a	f3 0f 11 55 94	 movss	 DWORD PTR _fCurX$2$[ebp], xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 850  : 		for (int i = 0; i < m_pCharInfoVector.size(); ++i)

  0073f	3b f8		 cmp	 edi, eax
  00741	0f 82 29 fe ff
	ff		 jb	 $LL13@Render
$LN272@Render:

; 976  : 			//STATEMANAGER.DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, akVertex, sizeof(SVertex));
; 977  : 
; 978  : 			fCurX += fFontAdvance;
; 979  : 		}
; 980  : 	}
; 981  : #endif
; 982  : 
; 983  : 	if (m_isCursor)

  00747	80 7b 18 00	 cmp	 BYTE PTR [ebx+24], 0
  0074b	0f 84 81 02 00
	00		 je	 $LN56@Render

; 984  : 	{
; 985  : 		// Draw Cursor
; 986  : 		float sx, sy, ex, ey;
; 987  : 		TDiffuse diffuse;
; 988  : 
; 989  : 		int curpos = CIME::GetCurPos();

  00751	e8 00 00 00 00	 call	 ?GetCurPos@CIME@@SAHXZ	; CIME::GetCurPos
  00756	8b f0		 mov	 esi, eax
  00758	89 b5 74 ff ff
	ff		 mov	 DWORD PTR _curpos$1$[ebp], esi

; 990  : 		int compend = curpos + CIME::GetCompLen();

  0075e	e8 00 00 00 00	 call	 ?GetCompLen@CIME@@SAHXZ	; CIME::GetCompLen

; 991  : 
; 992  : 		__GetTextPos(curpos, &sx, &sy);

  00763	8b cb		 mov	 ecx, ebx
  00765	8d 3c 06	 lea	 edi, DWORD PTR [esi+eax]
  00768	8d 45 98	 lea	 eax, DWORD PTR _sy$7[ebp]
  0076b	50		 push	 eax
  0076c	8d 45 94	 lea	 eax, DWORD PTR _sx$6[ebp]
  0076f	50		 push	 eax
  00770	56		 push	 esi
  00771	e8 00 00 00 00	 call	 ?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z ; CGraphicTextInstance::__GetTextPos

; 993  : 
; 994  : 		// If Composition
; 995  : 		if(curpos<compend)

  00776	f3 0f 10 4d 94	 movss	 xmm1, DWORD PTR _sx$6[ebp]
  0077b	3b f7		 cmp	 esi, edi
  0077d	7d 21		 jge	 SHORT $LN49@Render

; 996  : 		{
; 997  : 			diffuse = 0x7fffffff;
; 998  : 			__GetTextPos(compend, &ex, &sy);

  0077f	8d 45 98	 lea	 eax, DWORD PTR _sy$7[ebp]
  00782	8b cb		 mov	 ecx, ebx
  00784	50		 push	 eax
  00785	8d 45 8c	 lea	 eax, DWORD PTR _ex$5[ebp]
  00788	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0078d	50		 push	 eax
  0078e	57		 push	 edi
  0078f	e8 00 00 00 00	 call	 ?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z ; CGraphicTextInstance::__GetTextPos

; 999  : 		}

  00794	f3 0f 10 65 8c	 movss	 xmm4, DWORD PTR _ex$5[ebp]
  00799	f3 0f 10 4d 94	 movss	 xmm1, DWORD PTR _sx$6[ebp]
  0079e	eb 0e		 jmp	 SHORT $LN50@Render
$LN49@Render:

; 1000 : 		else
; 1001 : 		{
; 1002 : 			diffuse = 0xffffffff;
; 1003 : 			ex = sx + 2;

  007a0	0f 28 e1	 movaps	 xmm4, xmm1
  007a3	83 ce ff	 or	 esi, -1
  007a6	f3 0f 58 25 00
	00 00 00	 addss	 xmm4, DWORD PTR __real@40000000
$LN50@Render:

; 1004 : 		}
; 1005 : 
; 1006 : 		// FOR_ARABIC_ALIGN
; 1007 : 		if (defCodePage == CP_ARABIC)

  007ae	81 bd 6c ff ff
	ff e8 04 00 00	 cmp	 DWORD PTR _defCodePage$1$[ebp], 1256 ; 000004e8H
  007b8	0f b7 4b 0e	 movzx	 ecx, WORD PTR [ebx+14]
  007bc	f3 0f 10 53 38	 movss	 xmm2, DWORD PTR [ebx+56]
  007c1	66 0f 6e e9	 movd	 xmm5, ecx
  007c5	0f 5b ed	 cvtdq2ps xmm5, xmm5
  007c8	75 18		 jne	 SHORT $LN51@Render

; 1008 : 		{
; 1009 : 			sx += m_v3Position.x - m_textWidth;

  007ca	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  007ce	66 0f 6e c0	 movd	 xmm0, eax
  007d2	0f 5b c0	 cvtdq2ps xmm0, xmm0
  007d5	f3 0f 5c d0	 subss	 xmm2, xmm0
  007d9	0f 28 da	 movaps	 xmm3, xmm2
  007dc	f3 0f 58 d9	 addss	 xmm3, xmm1

; 1010 : 			ex += m_v3Position.x - m_textWidth;
; 1011 : 			sy += m_v3Position.y;
; 1012 : 			ey = sy + m_textHeight;
; 1013 : 		}

  007e0	eb 07		 jmp	 SHORT $LN324@Render
$LN51@Render:

; 1014 : 		else
; 1015 : 		{
; 1016 : 			sx += m_v3Position.x;

  007e2	0f 28 d9	 movaps	 xmm3, xmm1
  007e5	f3 0f 58 da	 addss	 xmm3, xmm2
$LN324@Render:

; 1017 : 			sy += m_v3Position.y;
; 1018 : 			ex += m_v3Position.x;
; 1019 : 			ey = sy + m_textHeight;
; 1020 : 		}
; 1021 : 
; 1022 : 		switch (m_vAlign)

  007e9	f3 0f 10 4d 98	 movss	 xmm1, DWORD PTR _sy$7[ebp]
  007ee	f3 0f 58 d4	 addss	 xmm2, xmm4
  007f2	f3 0f 58 4b 3c	 addss	 xmm1, DWORD PTR [ebx+60]
  007f7	8b c1		 mov	 eax, ecx
  007f9	f3 0f 11 5d 94	 movss	 DWORD PTR _sx$6[ebp], xmm3
  007fe	8a 4b 11	 mov	 cl, BYTE PTR [ebx+17]
  00801	f3 0f 11 55 8c	 movss	 DWORD PTR _ex$5[ebp], xmm2
  00806	f3 0f 11 4d 98	 movss	 DWORD PTR _sy$7[ebp], xmm1
  0080b	0f 28 e1	 movaps	 xmm4, xmm1
  0080e	f3 0f 58 e9	 addss	 xmm5, xmm1
  00812	80 f9 20	 cmp	 cl, 32			; 00000020H
  00815	74 11		 je	 SHORT $LN54@Render
  00817	80 f9 30	 cmp	 cl, 48			; 00000030H
  0081a	75 2a		 jne	 SHORT $LN14@Render

; 1023 : 		{
; 1024 : 			case VERTICAL_ALIGN_BOTTOM:
; 1025 : 				sy -= m_textHeight;

  0081c	0f b7 c0	 movzx	 eax, ax
  0081f	66 0f 6e c0	 movd	 xmm0, eax
  00823	0f 5b c0	 cvtdq2ps xmm0, xmm0

; 1026 : 				break;

  00826	eb 12		 jmp	 SHORT $LN325@Render
$LN54@Render:

; 1027 : 
; 1028 : 			case VERTICAL_ALIGN_CENTER:
; 1029 : 				sy -= float(m_textHeight) / 2.0f;

  00828	0f b7 c0	 movzx	 eax, ax
  0082b	66 0f 6e c0	 movd	 xmm0, eax
  0082f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00832	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
$LN325@Render:

; 1030 : 				break;
; 1031 : 		}
; 1032 : 
; 1033 : 		TPDTVertex vertices[4];
; 1034 : 		vertices[0].diffuse = diffuse;

  0083a	0f 28 cc	 movaps	 xmm1, xmm4
  0083d	f3 0f 5c c8	 subss	 xmm1, xmm0
  00841	f3 0f 11 4d 98	 movss	 DWORD PTR _sy$7[ebp], xmm1
$LN14@Render:

; 1035 : 		vertices[1].diffuse = diffuse;
; 1036 : 		vertices[2].diffuse = diffuse;
; 1037 : 		vertices[3].diffuse = diffuse;
; 1038 : 		vertices[0].position = TPosition(sx, sy, 0.0f);
; 1039 : 		vertices[1].position = TPosition(ex, sy, 0.0f);
; 1040 : 		vertices[2].position = TPosition(sx, ey, 0.0f);
; 1041 : 		vertices[3].position = TPosition(ex, ey, 0.0f);
; 1042 : 
; 1043 : 		STATEMANAGER.SetTexture(0, NULL);

  00846	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0084c	6a 00		 push	 0
  0084e	6a 00		 push	 0
  00850	89 75 a8	 mov	 DWORD PTR _vertices$9[ebp+12], esi
  00853	89 75 c0	 mov	 DWORD PTR _vertices$9[ebp+36], esi
  00856	89 75 d8	 mov	 DWORD PTR _vertices$9[ebp+60], esi
  00859	89 75 f0	 mov	 DWORD PTR _vertices$9[ebp+84], esi
  0085c	f3 0f 11 5d 9c	 movss	 DWORD PTR _vertices$9[ebp], xmm3
  00861	f3 0f 11 4d a0	 movss	 DWORD PTR _vertices$9[ebp+4], xmm1
  00866	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _vertices$9[ebp+8], 0
  0086d	f3 0f 11 55 b4	 movss	 DWORD PTR _vertices$9[ebp+24], xmm2
  00872	f3 0f 11 4d b8	 movss	 DWORD PTR _vertices$9[ebp+28], xmm1
  00877	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _vertices$9[ebp+32], 0
  0087e	f3 0f 11 5d cc	 movss	 DWORD PTR _vertices$9[ebp+48], xmm3
  00883	f3 0f 11 6d d0	 movss	 DWORD PTR _vertices$9[ebp+52], xmm5
  00888	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _vertices$9[ebp+56], 0
  0088f	f3 0f 11 55 e4	 movss	 DWORD PTR _vertices$9[ebp+72], xmm2
  00894	f3 0f 11 6d e8	 movss	 DWORD PTR _vertices$9[ebp+76], xmm5
  00899	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _vertices$9[ebp+80], 0
  008a0	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 1044 : 
; 1045 : 		CGraphicBase::SetDefaultIndexBuffer(CGraphicBase::DEFAULT_IB_FILL_RECT);

  008a5	6a 05		 push	 5
  008a7	e8 00 00 00 00	 call	 ?SetDefaultIndexBuffer@CGraphicBase@@SAXI@Z ; CGraphicBase::SetDefaultIndexBuffer

; 1046 : 		if (CGraphicBase::SetPDTStream(vertices, 4))

  008ac	8d 45 9c	 lea	 eax, DWORD PTR _vertices$9[ebp]
  008af	6a 04		 push	 4
  008b1	50		 push	 eax
  008b2	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  008b7	83 c4 0c	 add	 esp, 12			; 0000000cH
  008ba	84 c0		 test	 al, al
  008bc	74 15		 je	 SHORT $LN55@Render

; 1047 : 			STATEMANAGER.DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 4, 0, 2);

  008be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  008c4	6a 02		 push	 2
  008c6	6a 00		 push	 0
  008c8	6a 04		 push	 4
  008ca	6a 00		 push	 0
  008cc	6a 04		 push	 4
  008ce	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN55@Render:

; 1048 : 
; 1049 : 		int ulbegin = CIME::GetULBegin();

  008d3	e8 00 00 00 00	 call	 ?GetULBegin@CIME@@SAHXZ	; CIME::GetULBegin
  008d8	8b f8		 mov	 edi, eax

; 1050 : 		int ulend = CIME::GetULEnd();

  008da	e8 00 00 00 00	 call	 ?GetULEnd@CIME@@SAHXZ	; CIME::GetULEnd
  008df	89 85 6c ff ff
	ff		 mov	 DWORD PTR _ulend$1$[ebp], eax

; 1051 : 
; 1052 : 		if(ulbegin < ulend)

  008e5	3b f8		 cmp	 edi, eax
  008e7	0f 8d e5 00 00
	00		 jge	 $LN56@Render

; 1053 : 		{
; 1054 : 			__GetTextPos(curpos+ulbegin, &sx, &sy);

  008ed	8b b5 74 ff ff
	ff		 mov	 esi, DWORD PTR _curpos$1$[ebp]
  008f3	8d 45 98	 lea	 eax, DWORD PTR _sy$7[ebp]
  008f6	50		 push	 eax
  008f7	8d 45 94	 lea	 eax, DWORD PTR _sx$6[ebp]
  008fa	50		 push	 eax
  008fb	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
  008fe	51		 push	 ecx
  008ff	8b cb		 mov	 ecx, ebx
  00901	e8 00 00 00 00	 call	 ?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z ; CGraphicTextInstance::__GetTextPos

; 1055 : 			__GetTextPos(curpos+ulend, &ex, &sy);

  00906	8d 45 98	 lea	 eax, DWORD PTR _sy$7[ebp]
  00909	8b cb		 mov	 ecx, ebx
  0090b	50		 push	 eax
  0090c	8d 45 8c	 lea	 eax, DWORD PTR _ex$5[ebp]
  0090f	50		 push	 eax
  00910	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _ulend$1$[ebp]
  00916	03 c6		 add	 eax, esi
  00918	50		 push	 eax
  00919	e8 00 00 00 00	 call	 ?__GetTextPos@CGraphicTextInstance@@IAEXKPAM0@Z ; CGraphicTextInstance::__GetTextPos

; 1056 : 
; 1057 : 			sx += m_v3Position.x;
; 1058 : 			sy += m_v3Position.y + m_textHeight;

  0091e	0f b7 43 0e	 movzx	 eax, WORD PTR [ebx+14]
  00922	f3 0f 10 5d 94	 movss	 xmm3, DWORD PTR _sx$6[ebp]

; 1059 : 			ex += m_v3Position.x;

  00927	f3 0f 10 55 8c	 movss	 xmm2, DWORD PTR _ex$5[ebp]
  0092c	f3 0f 58 5b 38	 addss	 xmm3, DWORD PTR [ebx+56]
  00931	f3 0f 58 53 38	 addss	 xmm2, DWORD PTR [ebx+56]

; 1060 : 			ey = sy + 2;
; 1061 : 
; 1062 : 			vertices[0].diffuse = 0xFFFF0000;
; 1063 : 			vertices[1].diffuse = 0xFFFF0000;
; 1064 : 			vertices[2].diffuse = 0xFFFF0000;
; 1065 : 			vertices[3].diffuse = 0xFFFF0000;
; 1066 : 			vertices[0].position = TPosition(sx, sy, 0.0f);
; 1067 : 			vertices[1].position = TPosition(ex, sy, 0.0f);
; 1068 : 			vertices[2].position = TPosition(sx, ey, 0.0f);
; 1069 : 			vertices[3].position = TPosition(ex, ey, 0.0f);
; 1070 : 
; 1071 : 			STATEMANAGER.DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 4, 2, c_FillRectIndices, D3DFMT_INDEX16, vertices, sizeof(TPDTVertex));

  00936	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0093c	66 0f 6e c8	 movd	 xmm1, eax
  00940	8d 45 9c	 lea	 eax, DWORD PTR _vertices$9[ebp]
  00943	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00946	6a 18		 push	 24			; 00000018H
  00948	50		 push	 eax
  00949	6a 65		 push	 101			; 00000065H
  0094b	68 00 00 00 00	 push	 OFFSET ?c_FillRectIndices@@3QBGB
  00950	6a 02		 push	 2
  00952	f3 0f 58 4b 3c	 addss	 xmm1, DWORD PTR [ebx+60]
  00957	6a 04		 push	 4
  00959	6a 00		 push	 0
  0095b	6a 04		 push	 4
  0095d	c7 45 a8 00 00
	ff ff		 mov	 DWORD PTR _vertices$9[ebp+12], -65536 ; ffff0000H
  00964	f3 0f 58 4d 98	 addss	 xmm1, DWORD PTR _sy$7[ebp]
  00969	c7 45 c0 00 00
	ff ff		 mov	 DWORD PTR _vertices$9[ebp+36], -65536 ; ffff0000H
  00970	c7 45 d8 00 00
	ff ff		 mov	 DWORD PTR _vertices$9[ebp+60], -65536 ; ffff0000H
  00977	c7 45 f0 00 00
	ff ff		 mov	 DWORD PTR _vertices$9[ebp+84], -65536 ; ffff0000H
  0097e	f3 0f 11 5d 9c	 movss	 DWORD PTR _vertices$9[ebp], xmm3
  00983	0f 28 c1	 movaps	 xmm0, xmm1
  00986	f3 0f 11 4d a0	 movss	 DWORD PTR _vertices$9[ebp+4], xmm1
  0098b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40000000
  00993	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR _vertices$9[ebp+8], 0
  0099a	f3 0f 11 55 b4	 movss	 DWORD PTR _vertices$9[ebp+24], xmm2
  0099f	f3 0f 11 4d b8	 movss	 DWORD PTR _vertices$9[ebp+28], xmm1
  009a4	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR _vertices$9[ebp+32], 0
  009ab	f3 0f 11 5d cc	 movss	 DWORD PTR _vertices$9[ebp+48], xmm3
  009b0	f3 0f 11 45 d0	 movss	 DWORD PTR _vertices$9[ebp+52], xmm0
  009b5	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _vertices$9[ebp+56], 0
  009bc	f3 0f 11 55 e4	 movss	 DWORD PTR _vertices$9[ebp+72], xmm2
  009c1	f3 0f 11 45 e8	 movss	 DWORD PTR _vertices$9[ebp+76], xmm0
  009c6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _vertices$9[ebp+80], 0
  009cd	e8 00 00 00 00	 call	 ?DrawIndexedPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIIPBXW4_D3DFORMAT@@1I@Z ; CStateManager::DrawIndexedPrimitiveUP
$LN56@Render:

; 1072 : 		}
; 1073 : 	}
; 1074 : 
; 1075 : 	STATEMANAGER.RestoreRenderState(D3DRS_SRCBLEND);

  009d2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009d8	6a 13		 push	 19			; 00000013H
  009da	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 1076 : 	STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);

  009df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009e5	6a 14		 push	 20			; 00000014H
  009e7	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 1077 : 
; 1078 : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  009ec	ff b5 60 ff ff
	ff		 push	 DWORD PTR _dwFogEnable$1$[ebp]
  009f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009f8	6a 1c		 push	 28			; 0000001cH
  009fa	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 1079 : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, dwLighting);

  009ff	ff b5 68 ff ff
	ff		 push	 DWORD PTR _dwLighting$1$[ebp]
  00a05	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a0b	68 89 00 00 00	 push	 137			; 00000089H
  00a10	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00a15	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]
  00a18	3b 43 68	 cmp	 eax, DWORD PTR [ebx+104]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1081 : 	if (!m_hyperlinkVector.empty())

  00a1b	0f 84 9c 00 00
	00		 je	 $LN237@Render

; 1082 : 	{
; 1083 : 		int lx = gs_mx - m_v3Position.x;

  00a21	66 0f 6e 05 00
	00 00 00	 movd	 xmm0, DWORD PTR ?gs_mx@@3HA
  00a29	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00a2c	f3 0f 5c 43 38	 subss	 xmm0, DWORD PTR [ebx+56]
  00a31	f3 0f 2c f0	 cvttss2si esi, xmm0
  00a35	66 0f 6e 05 00
	00 00 00	 movd	 xmm0, DWORD PTR ?gs_my@@3HA

; 1084 : 		int ly = gs_my - m_v3Position.y;

  00a3d	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00a40	f3 0f 5c 43 3c	 subss	 xmm0, DWORD PTR [ebx+60]
  00a45	f3 0f 2c f8	 cvttss2si edi, xmm0

; 1085 : 
; 1086 : 		if (GetDefaultCodePage() == CP_ARABIC)

  00a49	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  00a4e	3d e8 04 00 00	 cmp	 eax, 1256		; 000004e8H
  00a53	75 0a		 jne	 SHORT $LN270@Render

; 1087 : 		{
; 1088 : 			lx = -lx;
; 1089 : 			ly = -ly + m_textHeight;

  00a55	0f b7 43 0e	 movzx	 eax, WORD PTR [ebx+14]
  00a59	f7 de		 neg	 esi
  00a5b	2b c7		 sub	 eax, edi
  00a5d	8b f8		 mov	 edi, eax
$LN270@Render:

; 1090 : 		}
; 1091 : 
; 1092 : 		if (lx >= 0 && ly >= 0 && lx < m_textWidth && ly < m_textHeight)

  00a5f	85 f6		 test	 esi, esi
  00a61	78 5a		 js	 SHORT $LN237@Render
  00a63	85 ff		 test	 edi, edi
  00a65	78 56		 js	 SHORT $LN237@Render
  00a67	0f b7 43 0c	 movzx	 eax, WORD PTR [ebx+12]
  00a6b	3b f0		 cmp	 esi, eax
  00a6d	7d 4e		 jge	 SHORT $LN237@Render
  00a6f	0f b7 43 0e	 movzx	 eax, WORD PTR [ebx+14]
  00a73	3b f8		 cmp	 edi, eax
  00a75	7d 46		 jge	 SHORT $LN237@Render
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00a77	8b 43 64	 mov	 eax, DWORD PTR [ebx+100]
  00a7a	8b 53 68	 mov	 edx, DWORD PTR [ebx+104]
  00a7d	3b c2		 cmp	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1096 : 			while (it != m_hyperlinkVector.end())

  00a7f	74 3c		 je	 SHORT $LN237@Render
$LL16@Render:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 292  :         _Vector_iterator _Tmp = *this;

  00a81	8b f8		 mov	 edi, eax

; 82   :         ++_Ptr;

  00a83	83 c0 1c	 add	 eax, 28			; 0000001cH
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1099 : 				if (lx >= link.sx && lx < link.ex)

  00a86	0f bf 0f	 movsx	 ecx, WORD PTR [edi]
  00a89	3b f1		 cmp	 esi, ecx
  00a8b	7c 08		 jl	 SHORT $LN60@Render
  00a8d	0f bf 4f 02	 movsx	 ecx, WORD PTR [edi+2]
  00a91	3b f1		 cmp	 esi, ecx
  00a93	7c 06		 jl	 SHORT $LN217@Render
$LN60@Render:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00a95	3b c2		 cmp	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1096 : 			while (it != m_hyperlinkVector.end())

  00a97	75 e8		 jne	 SHORT $LL16@Render
  00a99	eb 22		 jmp	 SHORT $LN237@Render
$LN217@Render:

; 1100 : 				{
; 1101 : 					gs_hyperlinkText = link.text;

  00a9b	83 c7 04	 add	 edi, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1371 :         if (this == _STD addressof(_Right)) {

  00a9e	81 ff 00 00 00
	00		 cmp	 edi, OFFSET ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  00aa4	74 17		 je	 SHORT $LN237@Render

; 434  :         return _Myres > _Small_string_capacity;

  00aa6	83 7f 14 07	 cmp	 DWORD PTR [edi+20], 7

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00aaa	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 426  :         if (_Large_mode_engaged()) {

  00aad	76 02		 jbe	 SHORT $LN206@Render

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00aaf	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN206@Render:

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00ab1	50		 push	 eax
  00ab2	57		 push	 edi
  00ab3	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  00ab8	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN237@Render:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00abd	8b 73 70	 mov	 esi, DWORD PTR [ebx+112]
  00ac0	8b 43 74	 mov	 eax, DWORD PTR [ebx+116]
  00ac3	8b d8		 mov	 ebx, eax
  00ac5	3b f3		 cmp	 esi, ebx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1114 : 	if (m_emojiVector.empty() == false)

  00ac7	0f 84 79 00 00
	00		 je	 $LN321@Render
  00acd	0f 1f 00	 npad	 3
$LL20@Render:

; 1117 : 		{
; 1118 : 			if (rEmo.pInstance)

  00ad0	8b 7e 04	 mov	 edi, DWORD PTR [esi+4]
  00ad3	85 ff		 test	 edi, edi
  00ad5	74 68		 je	 SHORT $LN18@Render

; 1119 : 			{
; 1120 : 				rEmo.pInstance->SetPosition(fStanX + rEmo.x, (fStanY + 7.0) - (rEmo.pInstance->GetHeight() / 2));

  00ad7	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _fStanY$1$[ebp]
  00adc	8b cf		 mov	 ecx, edi
  00ade	0f 5a c0	 cvtps2pd xmm0, xmm0
  00ae1	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@401c000000000000
  00ae9	f2 0f 11 85 64
	ff ff ff	 movsd	 QWORD PTR tv2468[ebp], xmm0
  00af1	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00af6	f2 0f 10 8d 64
	ff ff ff	 movsd	 xmm1, QWORD PTR tv2468[ebp]
  00afe	83 ec 08	 sub	 esp, 8
  00b01	99		 cdq
  00b02	8b cf		 mov	 ecx, edi
  00b04	2b c2		 sub	 eax, edx
  00b06	d1 f8		 sar	 eax, 1
  00b08	66 0f 6e c0	 movd	 xmm0, eax
  00b0c	0f bf 06	 movsx	 eax, WORD PTR [esi]
  00b0f	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00b13	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00b17	66 0f 5a c1	 cvtpd2ps xmm0, xmm1
  00b1b	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00b21	66 0f 6e c0	 movd	 xmm0, eax
  00b25	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00b28	f3 0f 58 45 90	 addss	 xmm0, DWORD PTR _fStanX$1$[ebp]
  00b2d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b32	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 1121 : 				rEmo.pInstance->Render();

  00b37	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00b3a	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render
$LN18@Render:

; 1115 : 	{
; 1116 : 		for(auto& rEmo : m_emojiVector)

  00b3f	83 c6 08	 add	 esi, 8
  00b42	3b f3		 cmp	 esi, ebx
  00b44	75 8a		 jne	 SHORT $LL20@Render
$LN321@Render:
  00b46	5f		 pop	 edi
$LN320@Render:
  00b47	5e		 pop	 esi
$LN19@Render:

; 1122 : 			}
; 1123 : 		}
; 1124 : 	}
; 1125 : #endif
; 1126 : 
; 1127 : }

  00b48	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b4b	33 cd		 xor	 ecx, ebp
  00b4d	5b		 pop	 ebx
  00b4e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b53	8b e5		 mov	 esp, ebp
  00b55	5d		 pop	 ebp
  00b56	c2 04 00	 ret	 4
?Render@CGraphicTextInstance@@QAEXPAUtagRECT@@@Z ENDP	; CGraphicTextInstance::Render
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Update@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
_token$1$ = -1544					; size = 4
_len$2 = -1540						; size = 4
$T3 = -1536						; size = 1
$T4 = -1532						; size = 1
$T5 = -1528						; size = 1
$T6 = -1524						; size = 1
_defCodePage$1$ = -1520					; size = 4
_wTextMax$1$ = -1516					; size = 4
__My_data$1$ = -1512					; size = 4
_kEmoji$7 = -1508					; size = 8
_len$8 = -1500						; size = 4
_wText$1$ = -1496					; size = 4
_pSpaceInfo$1$ = -1492					; size = 4
_e$1$ = -1488						; size = 4
_e$1$ = -1488						; size = 4
_end$1$ = -1484						; size = 4
$T9 = -1484						; size = 4
_wArabicTextLen$1$ = -1480				; size = 4
__Result$2$ = -1480					; size = 4
_pImage$1$ = -1480					; size = 4
_pFontTexture$1$ = -1476				; size = 4
_dataCodePage$1$ = -1472				; size = 4
__Old_capacity$1$ = -1468				; size = 4
_x$1$ = -1468						; size = 4
tv4327 = -1464						; size = 4
_nEnglishBase$1$ = -1464				; size = 4
_wTextLen$1$ = -1460					; size = 4
_no_hyperlink$1$ = -1460				; size = 4
__Old_capacity$1$ = -1456				; size = 4
tv4169 = -1456						; size = 4
_i$1$ = -1452						; size = 4
_i$1$ = -1452						; size = 4
__Result$2$ = -1448					; size = 4
__Result$2$ = -1448					; size = 4
_hyperlinkStep$1$ = -1448				; size = 4
_hyperlinkStep$1$ = -1448				; size = 4
_emojiStep$1$ = -1444					; size = 4
_wArabicText$1$ = -1444					; size = 4
_i$1$ = -1444						; size = 4
_this$GSCopy$1$ = -1440					; size = 4
tv4487 = -1436						; size = 4
tv4484 = -1436						; size = 4
tv4481 = -1436						; size = 4
_charWidth$1$ = -1436					; size = 4
_charWidth$1$ = -1436					; size = 4
tv4474 = -1436						; size = 4
_charWidth$1$ = -1436					; size = 4
tv4439 = -1436						; size = 4
$T10 = -1436						; size = 4
tv4434 = -1436						; size = 4
__Result$2$ = -1436					; size = 4
__Result$2$ = -1436					; size = 4
__Result$2$ = -1436					; size = 4
$T11 = -1436						; size = 4
$T12 = -1436						; size = 4
_dwColor$1$ = -1432					; size = 4
_isEnglish$1$ = -1425					; size = 1
_kHyperlink$13 = -1424					; size = 28
_emojiBuffer$14 = -1396					; size = 24
_hyperlinkBuffer$15 = -1372				; size = 24
_kHyperlink$16 = -1348					; size = 28
_hyperlinkBuffer$17 = -1320				; size = 24
_retBuf$18 = -1296					; size = 1024
_szPath$19 = -272					; size = 255
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Update@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::Update, COMDAT
; _this$ = ecx

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Update@CGraphicTextInstance@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec fc 05 00
	00		 sub	 esp, 1532		; 000005fcH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx
  0002f	89 b5 60 fa ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi

; 179  : 	if (m_isUpdate)

  00035	80 7e 45 00	 cmp	 BYTE PTR [esi+69], 0
  00039	0f 85 52 16 00
	00		 jne	 $LN1@Update
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h

; 62   : 			return m_pObject == NULL ? true : false;

  0003f	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00042	85 c9		 test	 ecx, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 182  : 	if (m_roText.IsNull())

  00044	75 12		 jne	 SHORT $LN41@Update

; 183  : 	{
; 184  : 		Tracef("CGraphicTextInstance::Update - Font has not been set\n");

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@FOMBDJDA@CGraphicTextInstance?3?3Update?5?9?5@
  0004b	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00050	83 c4 04	 add	 esp, 4

; 185  : 		return;

  00053	e9 39 16 00 00	 jmp	 $LN1@Update
$LN41@Update:

; 186  : 	}
; 187  : 
; 188  : 	if (m_roText->IsEmpty())

  00058	e8 00 00 00 00	 call	 ?IsEmpty@CResource@@QBE_NXZ ; CResource::IsEmpty
  0005d	84 c0		 test	 al, al
  0005f	0f 85 2c 16 00
	00		 jne	 $LN1@Update

; 189  : 		return;
; 190  : 
; 191  : 	CGraphicFontTexture* pFontTexture = m_roText->GetFontTexturePointer();

  00065	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]
  00068	e8 00 00 00 00	 call	 ?GetFontTexturePointer@CGraphicText@@QAEPAVCGraphicFontTexture@@XZ ; CGraphicText::GetFontTexturePointer
  0006d	8b f8		 mov	 edi, eax
  0006f	89 bd 3c fa ff
	ff		 mov	 DWORD PTR _pFontTexture$1$[ebp], edi

; 192  : 	if (!pFontTexture)

  00075	85 ff		 test	 edi, edi
  00077	0f 84 14 16 00
	00		 je	 $LN1@Update

; 193  : 		return;
; 194  : 
; 195  : 	UINT defCodePage = GetDefaultCodePage();

  0007d	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage

; 196  : 
; 197  : 	UINT dataCodePage = defCodePage;
; 198  : 
; 199  : 	CGraphicFontTexture::TCharacterInfomation* pSpaceInfo = pFontTexture->GetCharacterInfomation(dataCodePage, ' ');

  00082	6a 20		 push	 32			; 00000020H
  00084	50		 push	 eax
  00085	8b cf		 mov	 ecx, edi
  00087	89 85 10 fa ff
	ff		 mov	 DWORD PTR _defCodePage$1$[ebp], eax
  0008d	89 85 40 fa ff
	ff		 mov	 DWORD PTR _dataCodePage$1$[ebp], eax
  00093	e8 00 00 00 00	 call	 ?GetCharacterInfomation@CGraphicFontTexture@@QAEPAUSCharacterInfomation@1@G_W@Z ; CGraphicFontTexture::GetCharacterInfomation
  00098	89 85 2c fa ff
	ff		 mov	 DWORD PTR _pSpaceInfo$1$[ebp], eax

; 200  : 
; 201  : 	int spaceHeight = pSpaceInfo ? pSpaceInfo->height : 12;

  0009e	85 c0		 test	 eax, eax
  000a0	74 0c		 je	 SHORT $LN119@Update
  000a2	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  000a6	89 8d 34 fa ff
	ff		 mov	 DWORD PTR $T9[ebp], ecx
  000ac	eb 0a		 jmp	 SHORT $LN120@Update
$LN119@Update:
  000ae	c7 85 34 fa ff
	ff 0c 00 00 00	 mov	 DWORD PTR $T9[ebp], 12	; 0000000cH
$LN120@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000b8	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  000bb	3b 46 50	 cmp	 eax, DWORD PTR [esi+80]
  000be	74 03		 je	 SHORT $LN640@Update

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  000c0	89 46 50	 mov	 DWORD PTR [esi+80], eax
$LN640@Update:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000c3	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  000c6	3b 46 5c	 cmp	 eax, DWORD PTR [esi+92]
  000c9	74 03		 je	 SHORT $LN644@Update

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  000cb	89 46 5c	 mov	 DWORD PTR [esi+92], eax
$LN644@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 205  : 	m_hyperlinkVector.clear();

  000ce	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  000d1	e8 00 00 00 00	 call	 ?clear@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::clear

; 206  : #ifdef ENABLE_EMOJI_SYSTEM
; 207  : 	for (auto& rEmo : m_emojiVector)

  000d6	8b 7e 74	 mov	 edi, DWORD PTR [esi+116]
  000d9	8d 4e 70	 lea	 ecx, DWORD PTR [esi+112]
  000dc	8b 31		 mov	 esi, DWORD PTR [ecx]
  000de	89 8d 18 fa ff
	ff		 mov	 DWORD PTR __My_data$1$[ebp], ecx
  000e4	3b f7		 cmp	 esi, edi
  000e6	74 1d		 je	 SHORT $LN3@Update
$LL4@Update:

; 208  : 	{
; 209  : 		if (rEmo.pInstance)

  000e8	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000eb	85 c0		 test	 eax, eax
  000ed	74 09		 je	 SHORT $LN2@Update

; 210  : 			CGraphicImageInstance::Delete(rEmo.pInstance);

  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 ?Delete@CGraphicImageInstance@@SAXPAV1@@Z ; CGraphicImageInstance::Delete
  000f5	83 c4 04	 add	 esp, 4
$LN2@Update:

; 206  : #ifdef ENABLE_EMOJI_SYSTEM
; 207  : 	for (auto& rEmo : m_emojiVector)

  000f8	83 c6 08	 add	 esi, 8
  000fb	3b f7		 cmp	 esi, edi
  000fd	75 e9		 jne	 SHORT $LL4@Update
  000ff	8b 8d 18 fa ff
	ff		 mov	 ecx, DWORD PTR __My_data$1$[ebp]
$LN3@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00105	8b 01		 mov	 eax, DWORD PTR [ecx]
  00107	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0010a	74 03		 je	 SHORT $LN562@Update

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0010c	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN562@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 215  : 	m_textWidth = 0;

  0010f	8b b5 60 fa ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00115	33 c0		 xor	 eax, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2328 :         return _Mypair._Myval2._Myptr();

  00117	8d 7e 20	 lea	 edi, DWORD PTR [esi+32]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 215  : 	m_textWidth = 0;

  0011a	66 89 46 0c	 mov	 WORD PTR [esi+12], ax

; 216  : 	m_textHeight = spaceHeight;

  0011e	8b 85 34 fa ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00124	66 89 46 0e	 mov	 WORD PTR [esi+14], ax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00128	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0012c	76 02		 jbe	 SHORT $LN570@Update

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0012e	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN570@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 221  : 	const char* end = begin + m_stText.length();

  00130	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00133	8d 0c 38	 lea	 ecx, DWORD PTR [eax+edi]

; 222  : 
; 223  : 	int wTextMax = (end - begin) * 2;

  00136	03 c0		 add	 eax, eax
  00138	89 85 14 fa ff
	ff		 mov	 DWORD PTR _wTextMax$1$[ebp], eax

; 224  : 	wchar_t* wText = (wchar_t*)_alloca(sizeof(wchar_t)*wTextMax);

  0013e	03 c0		 add	 eax, eax
  00140	89 8d 34 fa ff
	ff		 mov	 DWORD PTR _end$1$[ebp], ecx
  00146	e8 00 00 00 00	 call	 __alloca_probe_16

; 225  : 
; 226  : 	DWORD dwColor = m_dwTextColor;
; 227  : 
; 228  : 	/* wstring end */
; 229  : 	while (begin < end)

  0014b	8b 85 34 fa ff
	ff		 mov	 eax, DWORD PTR _end$1$[ebp]
  00151	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00154	89 a5 28 fa ff
	ff		 mov	 DWORD PTR _wText$1$[ebp], esp
  0015a	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi
  00160	3b f8		 cmp	 edi, eax
  00162	0f 83 14 15 00
	00		 jae	 $LN1040@Update
$LL5@Update:

; 230  : 	{
; 231  : 		const char * token = FindToken(begin, end);

  00168	50		 push	 eax
  00169	57		 push	 edi
  0016a	e8 00 00 00 00	 call	 ?FindToken@@YAPBDPBD0@Z	; FindToken

; 232  : 
; 233  : 		int wTextLen = Ymir_MultiByteToWideChar(dataCodePage, 0, begin, token - begin, wText, wTextMax);

  0016f	ff b5 14 fa ff
	ff		 push	 DWORD PTR _wTextMax$1$[ebp]
  00175	89 85 f8 f9 ff
	ff		 mov	 DWORD PTR _token$1$[ebp], eax
  0017b	2b c7		 sub	 eax, edi
  0017d	ff b5 28 fa ff
	ff		 push	 DWORD PTR _wText$1$[ebp]
  00183	50		 push	 eax
  00184	57		 push	 edi
  00185	8b bd 40 fa ff
	ff		 mov	 edi, DWORD PTR _dataCodePage$1$[ebp]
  0018b	6a 00		 push	 0
  0018d	57		 push	 edi
  0018e	e8 00 00 00 00	 call	 ?Ymir_MultiByteToWideChar@@YAHIKPBDHPA_WH@Z ; Ymir_MultiByteToWideChar
  00193	8b d0		 mov	 edx, eax
  00195	83 c4 20	 add	 esp, 32			; 00000020H

; 234  : 
; 235  : 		if (m_isSecret)

  00198	8b 85 60 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  0019e	89 95 4c fa ff
	ff		 mov	 DWORD PTR _wTextLen$1$[ebp], edx
  001a4	80 78 19 00	 cmp	 BYTE PTR [eax+25], 0
  001a8	74 30		 je	 SHORT $LN45@Update

; 236  : 		{
; 237  : 			for(int i=0; i<wTextLen; ++i)

  001aa	85 d2		 test	 edx, edx
  001ac	0f 8e 9c 14 00
	00		 jle	 $LN338@Update
  001b2	0f b7 ff	 movzx	 edi, di
$LL9@Update:

; 238  : 				__DrawCharacter(pFontTexture, dataCodePage, '*', dwColor);

  001b5	56		 push	 esi
  001b6	6a 2a		 push	 42			; 0000002aH
  001b8	57		 push	 edi
  001b9	ff b5 3c fa ff
	ff		 push	 DWORD PTR _pFontTexture$1$[ebp]
  001bf	8b c8		 mov	 ecx, eax
  001c1	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
  001c6	83 ad 4c fa ff
	ff 01		 sub	 DWORD PTR _wTextLen$1$[ebp], 1
  001cd	8b 85 60 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  001d3	75 e0		 jne	 SHORT $LL9@Update

; 239  : 		}

  001d5	e9 74 14 00 00	 jmp	 $LN338@Update
$LN45@Update:

; 240  : 		else
; 241  : 		{
; 242  : 			if (defCodePage == CP_ARABIC) // ARABIC

  001da	81 bd 10 fa ff
	ff e8 04 00 00	 cmp	 DWORD PTR _defCodePage$1$[ebp], 1256 ; 000004e8H
  001e4	0f 85 45 0c 00
	00		 jne	 $LN47@Update

; 243  : 			{
; 244  : 
; 245  : 				wchar_t* wArabicText = (wchar_t*)_alloca(sizeof(wchar_t) * wTextLen);

  001ea	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  001ed	e8 00 00 00 00	 call	 __alloca_probe_16

; 246  : 				int wArabicTextLen = Arabic_MakeShape(wText, wTextLen, wArabicText, wTextLen);

  001f2	8b 85 4c fa ff
	ff		 mov	 eax, DWORD PTR _wTextLen$1$[ebp]
  001f8	8b cc		 mov	 ecx, esp
  001fa	50		 push	 eax
  001fb	51		 push	 ecx
  001fc	50		 push	 eax
  001fd	ff b5 28 fa ff
	ff		 push	 DWORD PTR _wText$1$[ebp]
  00203	89 8d 5c fa ff
	ff		 mov	 DWORD PTR _wArabicText$1$[ebp], ecx
  00209	e8 00 00 00 00	 call	 ?Arabic_MakeShape@@YAIPA_WI0I@Z ; Arabic_MakeShape
  0020e	8b d0		 mov	 edx, eax

; 250  : 
; 251  : 				int x = 0;
; 252  : 
; 253  : 				int len;
; 254  : 				int hyperlinkStep = 0;

  00210	c7 85 58 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 0
  0021a	0f 57 c0	 xorps	 xmm0, xmm0
  0021d	89 95 38 fa ff
	ff		 mov	 DWORD PTR _wArabicTextLen$1$[ebp], edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00223	bf 07 00 00 00	 mov	 edi, 7
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h

; 94   : 			SHyperlink() : sx(0), ex(0) { }

  00228	33 c9		 xor	 ecx, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0022a	0f 11 85 c0 fa
	ff ff		 movups	 XMMWORD PTR _kHyperlink$16[ebp+4], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 249  : 				int nEnglishBase = wArabicTextLen - 1;

  00231	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h

; 94   : 			SHyperlink() : sx(0), ex(0) { }

  00234	89 8d 50 fa ff
	ff		 mov	 DWORD PTR tv4169[ebp], ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 249  : 				int nEnglishBase = wArabicTextLen - 1;

  0023a	89 85 48 fa ff
	ff		 mov	 DWORD PTR _nEnglishBase$1$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h

; 94   : 			SHyperlink() : sx(0), ex(0) { }

  00240	33 c0		 xor	 eax, eax
  00242	89 85 bc fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00248	89 85 d0 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp+20], eax

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0024e	89 bd 44 fa ff
	ff		 mov	 DWORD PTR __Old_capacity$1$[ebp], edi
  00254	89 bd d4 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp+24], edi

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0025a	66 89 85 c0 fa
	ff ff		 mov	 WORD PTR _kHyperlink$16[ebp+4], ax

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00261	0f 11 85 d8 fa
	ff ff		 movups	 XMMWORD PTR _hyperlinkBuffer$17[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 255  : 				SHyperlink kHyperlink;

  00268	89 4d fc	 mov	 DWORD PTR __$EHRec$[ebp+8], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  0026b	89 8d e8 fa ff
	ff		 mov	 DWORD PTR _hyperlinkBuffer$17[ebp+16], ecx

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00271	89 bd ec fa ff
	ff		 mov	 DWORD PTR _hyperlinkBuffer$17[ebp+20], edi

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00277	66 89 85 d8 fa
	ff ff		 mov	 WORD PTR _hyperlinkBuffer$17[ebp], ax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 259  : 				if (Arabic_IsInSymbol(wArabicText[wArabicTextLen - 1]))

  0027e	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _wArabicText$1$[ebp]
  00284	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00288	89 8d 4c fa ff
	ff		 mov	 DWORD PTR _no_hyperlink$1$[ebp], ecx
  0028e	0f b7 44 50 fe	 movzx	 eax, WORD PTR [eax+edx*2-2]
  00293	50		 push	 eax
  00294	e8 00 00 00 00	 call	 ?Arabic_IsInSymbol@@YA_N_W@Z ; Arabic_IsInSymbol

; 260  : 				{
; 261  : 					isEnglish = false;
; 262  : 				}
; 263  : 
; 264  : 				int i = 0;
; 265  : 				for (i = wArabicTextLen - 1 ; i >= 0; --i)

  00299	8b 95 48 fa ff
	ff		 mov	 edx, DWORD PTR _nEnglishBase$1$[ebp]
  0029f	83 c4 14	 add	 esp, 20			; 00000014H
  002a2	8b ca		 mov	 ecx, edx
  002a4	34 01		 xor	 al, 1
  002a6	89 8d 54 fa ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ecx
  002ac	85 c9		 test	 ecx, ecx
  002ae	0f 88 c7 06 00
	00		 js	 $LN11@Update
  002b4	88 85 6f fa ff
	ff		 mov	 BYTE PTR _isEnglish$1$[ebp], al
  002ba	8b fa		 mov	 edi, edx
  002bc	0f 1f 40 00	 npad	 4
$LL12@Update:

; 266  : 				{
; 267  : 					wchar_t wArabicChar = wArabicText[i];

  002c0	8b 95 5c fa ff
	ff		 mov	 edx, DWORD PTR _wArabicText$1$[ebp]
  002c6	0f b7 3c 7a	 movzx	 edi, WORD PTR [edx+edi*2]

; 268  : 
; 269  : 					if (isEnglish)

  002ca	57		 push	 edi
  002cb	84 c0		 test	 al, al
  002cd	0f 84 90 05 00
	00		 je	 $LN50@Update

; 270  : 					{
; 271  : 
; 272  : 						//	(2)
; 273  : 						//		or
; 274  : 						//
; 275  : 						//
; 276  : 						if (Arabic_IsInSymbol(wArabicChar) && (

  002d3	e8 00 00 00 00	 call	 ?Arabic_IsInSymbol@@YA_N_W@Z ; Arabic_IsInSymbol
  002d8	83 c4 04	 add	 esp, 4
  002db	84 c0		 test	 al, al
  002dd	74 6d		 je	 SHORT $LN1083@Update
  002df	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  002e5	85 c0		 test	 eax, eax
  002e7	0f 84 67 06 00
	00		 je	 $LN1102@Update
  002ed	7e 4c		 jle	 SHORT $LN1105@Update
  002ef	48		 dec	 eax
  002f0	50		 push	 eax
  002f1	ff b5 5c fa ff
	ff		 push	 DWORD PTR _wArabicText$1$[ebp]
  002f7	e8 00 00 00 00	 call	 ?Arabic_HasPresentation@@YA_NPA_WH@Z ; Arabic_HasPresentation
  002fc	8b 8d 5c fa ff
	ff		 mov	 ecx, DWORD PTR _wArabicText$1$[ebp]
  00302	83 c4 08	 add	 esp, 8
  00305	84 c0		 test	 al, al
  00307	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  0030d	75 32		 jne	 SHORT $LN55@Update
  0030f	0f b7 44 41 02	 movzx	 eax, WORD PTR [ecx+eax*2+2]
  00314	50		 push	 eax
  00315	e8 00 00 00 00	 call	 ?Arabic_IsInPresentation@@YA_N_W@Z ; Arabic_IsInPresentation
  0031a	8b 8d 5c fa ff
	ff		 mov	 ecx, DWORD PTR _wArabicText$1$[ebp]
  00320	83 c4 04	 add	 esp, 4
  00323	84 c0		 test	 al, al
  00325	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  0032b	75 14		 jne	 SHORT $LN55@Update
  0032d	66 83 7c 41 02
	7c		 cmp	 WORD PTR [ecx+eax*2+2], 124 ; 0000007cH
  00333	0f 85 1b 06 00
	00		 jne	 $LN1102@Update
  00339	eb 06		 jmp	 SHORT $LN55@Update
$LN1105@Update:
  0033b	8b 8d 5c fa ff
	ff		 mov	 ecx, DWORD PTR _wArabicText$1$[ebp]
$LN55@Update:
  00341	66 83 3c 41 7c	 cmp	 WORD PTR [ecx+eax*2], 124 ; 0000007cH
  00346	0f 84 08 06 00
	00		 je	 $LN1102@Update
$LN1083@Update:

; 277  : 								(i == 0) ||
; 278  : 								(i > 0 &&
; 279  : 									!(Arabic_HasPresentation(wArabicText, i - 1) || Arabic_IsInPresentation(wArabicText[i + 1]))  &&
; 280  : 									wArabicText[i+1] != '|'
; 281  : 								) ||
; 282  : 								wArabicText[i] == '|'
; 283  : 							))//if end.
; 284  : 						{
; 285  : 							// pass
; 286  : 							int temptest = 1;
; 287  : 						}
; 288  : 						else if (Arabic_IsInPresentation(wArabicChar) || Arabic_IsInSymbol(wArabicChar))

  0034c	57		 push	 edi
  0034d	e8 00 00 00 00	 call	 ?Arabic_IsInPresentation@@YA_N_W@Z ; Arabic_IsInPresentation
  00352	83 c4 04	 add	 esp, 4
  00355	84 c0		 test	 al, al
  00357	75 11		 jne	 SHORT $LN57@Update
  00359	57		 push	 edi
  0035a	e8 00 00 00 00	 call	 ?Arabic_IsInSymbol@@YA_N_W@Z ; Arabic_IsInSymbol
  0035f	83 c4 04	 add	 esp, 4
  00362	84 c0		 test	 al, al
  00364	0f 84 ea 05 00
	00		 je	 $LN1102@Update
$LN57@Update:

; 289  : 						{
; 290  : 							for (int e = i + 1; e <= nEnglishBase;) {

  0036a	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  00370	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  00373	89 8d 30 fa ff
	ff		 mov	 DWORD PTR _e$1$[ebp], ecx
  00379	3b 8d 48 fa ff
	ff		 cmp	 ecx, DWORD PTR _nEnglishBase$1$[ebp]
  0037f	0f 8f 23 04 00
	00		 jg	 $LN14@Update
  00385	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL15@Update:

; 291  : 								int ret = GetTextTag(&wArabicText[e], wArabicTextLen - e, len, hyperlinkBuffer);

  00390	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _wArabicText$1$[ebp]
  00396	8d 3c 48	 lea	 edi, DWORD PTR [eax+ecx*2]
  00399	8d 85 d8 fa ff
	ff		 lea	 eax, DWORD PTR _hyperlinkBuffer$17[ebp]
  0039f	50		 push	 eax
  003a0	8d 85 24 fa ff
	ff		 lea	 eax, DWORD PTR _len$8[ebp]
  003a6	50		 push	 eax
  003a7	8b 85 38 fa ff
	ff		 mov	 eax, DWORD PTR _wArabicTextLen$1$[ebp]
  003ad	2b c1		 sub	 eax, ecx
  003af	50		 push	 eax
  003b0	57		 push	 edi
  003b1	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  003b6	83 c4 10	 add	 esp, 16			; 00000010H

; 292  : 
; 293  : 								if (ret == TEXT_TAG_PLAIN || ret == TEXT_TAG_TAG)

  003b9	85 c0		 test	 eax, eax
  003bb	0f 84 b1 02 00
	00		 je	 $LN60@Update
  003c1	83 f8 01	 cmp	 eax, 1
  003c4	0f 84 a8 02 00
	00		 je	 $LN60@Update

; 311  : 										}
; 312  : 									}
; 313  : 								}
; 314  : 								else
; 315  : 								{
; 316  : 									if (ret == TEXT_TAG_COLOR)

  003ca	83 f8 02	 cmp	 eax, 2
  003cd	0f 85 87 00 00
	00		 jne	 $LN64@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  003d3	83 bd ec fa ff
	ff 07		 cmp	 DWORD PTR _hyperlinkBuffer$17[ebp+20], 7

; 425  :         const value_type* _Result = _Bx._Buf;

  003da	8d 85 d8 fa ff
	ff		 lea	 eax, DWORD PTR _hyperlinkBuffer$17[ebp]

; 426  :         if (_Large_mode_engaged()) {

  003e0	0f 47 85 d8 fa
	ff ff		 cmova	 eax, DWORD PTR _hyperlinkBuffer$17[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h

; 149  :     int x = 0, y = 1;

  003e7	33 f6		 xor	 esi, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  003e9	89 85 64 fa ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h

; 149  :     int x = 0, y = 1;

  003ef	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi

; 150  :     s += size;
; 151  : 
; 152  :     while (t <= --s)

  003f5	8d 78 0e	 lea	 edi, DWORD PTR [eax+14]
  003f8	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  003fb	3b c7		 cmp	 eax, edi
  003fd	0f 87 81 03 00
	00		 ja	 $LN1010@Update
$LL587@Update:

; 153  :     {
; 154  : 		if (L'0' <= *s && *s <= L'9')

  00403	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00406	8d 48 d0	 lea	 ecx, DWORD PTR [eax-48]
  00409	66 83 f9 09	 cmp	 cx, 9
  0040d	77 05		 ja	 SHORT $LN589@Update

; 155  :             x += y * (*s - L'0');

  0040f	83 e8 30	 sub	 eax, 48			; 00000030H
  00412	eb 1a		 jmp	 SHORT $LN1108@Update
$LN589@Update:

; 156  :         else if (L'a' <= *s && *s <= L'f')

  00414	8d 48 9f	 lea	 ecx, DWORD PTR [eax-97]
  00417	66 83 f9 05	 cmp	 cx, 5
  0041b	77 05		 ja	 SHORT $LN591@Update

; 157  :             x += y * (*s - L'a' + 10);

  0041d	83 e8 57	 sub	 eax, 87			; 00000057H
  00420	eb 0c		 jmp	 SHORT $LN1108@Update
$LN591@Update:

; 158  :         else if (L'A' <= *s && *s <= L'F')

  00422	8d 48 bf	 lea	 ecx, DWORD PTR [eax-65]
  00425	66 83 f9 05	 cmp	 cx, 5
  00429	77 21		 ja	 SHORT $LN593@Update

; 159  :             x += y * (10 + *s - L'A');

  0042b	83 e8 37	 sub	 eax, 55			; 00000037H
$LN1108@Update:

; 162  :         y <<= 4;

  0042e	0f af c2	 imul	 eax, edx
  00431	83 ef 02	 sub	 edi, 2
  00434	c1 e2 04	 shl	 edx, 4
  00437	03 f0		 add	 esi, eax
  00439	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi
  0043f	39 bd 64 fa ff
	ff		 cmp	 DWORD PTR __Result$2$[ebp], edi
  00445	76 bc		 jbe	 SHORT $LL587@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00447	e9 38 03 00 00	 jmp	 $LN1010@Update
$LN593@Update:
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h

; 161  :             return -1; /* invalid input! */

  0044c	83 ce ff	 or	 esi, -1
  0044f	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 317  : 										dwColor = htoi(hyperlinkBuffer.c_str(), 8);

  00455	e9 2a 03 00 00	 jmp	 $LN1010@Update
$LN64@Update:

; 318  : 									else if (ret == TEXT_TAG_RESTORE_COLOR)

  0045a	83 f8 05	 cmp	 eax, 5
  0045d	75 14		 jne	 SHORT $LN66@Update

; 319  : 										dwColor = m_dwTextColor;

  0045f	8b 85 60 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00465	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00468	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi
  0046e	e9 11 03 00 00	 jmp	 $LN1010@Update
$LN66@Update:

; 320  : 									else if (ret == TEXT_TAG_HYPERLINK_START)

  00473	83 f8 03	 cmp	 eax, 3
  00476	75 21		 jne	 SHORT $LN68@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00478	6a 00		 push	 0
  0047a	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  0047f	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 322  : 										hyperlinkStep = 1;

  00485	c7 85 58 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0048f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 324  : 									}

  00494	e9 eb 02 00 00	 jmp	 $LN1010@Update
$LN68@Update:

; 325  : 									else if (ret == TEXT_TAG_HYPERLINK_END)

  00499	83 f8 04	 cmp	 eax, 4
  0049c	0f 85 e2 02 00
	00		 jne	 $LN1010@Update

; 326  : 									{
; 327  : 										if (hyperlinkStep == 1)

  004a2	83 bd 58 fa ff
	ff 01		 cmp	 DWORD PTR _hyperlinkStep$1$[ebp], 1
  004a9	75 1d		 jne	 SHORT $LN71@Update

; 328  : 										{
; 329  : 											++hyperlinkStep;
; 330  : 											kHyperlink.ex = kHyperlink.sx = 0;

  004ab	33 c0		 xor	 eax, eax
  004ad	c7 85 58 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 2
  004b7	89 85 bc fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp], eax
  004bd	89 85 50 fa ff
	ff		 mov	 DWORD PTR tv4169[ebp], eax

; 331  : 										}

  004c3	e9 bc 02 00 00	 jmp	 $LN1010@Update
$LN71@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  004c8	83 bd ec fa ff
	ff 07		 cmp	 DWORD PTR _hyperlinkBuffer$17[ebp+20], 7

; 425  :         const value_type* _Result = _Bx._Buf;

  004cf	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  004d5	8b bd e8 fa ff
	ff		 mov	 edi, DWORD PTR _hyperlinkBuffer$17[ebp+16]

; 426  :         if (_Large_mode_engaged()) {

  004db	0f 47 8d d8 fa
	ff ff		 cmova	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]

; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  004e2	8b 95 44 fa ff
	ff		 mov	 edx, DWORD PTR __Old_capacity$1$[ebp]

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  004e8	89 bd 64 fa ff
	ff		 mov	 DWORD PTR $T11[ebp], edi

; 426  :         if (_Large_mode_engaged()) {

  004ee	89 8d 58 fa ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], ecx

; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  004f4	3b fa		 cmp	 edi, edx
  004f6	77 2f		 ja	 SHORT $LN785@Update

; 1595 :             _ASAN_STRING_REMOVE(*this);
; 1596 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 1597 :             _Mypair._Myval2._Mysize = _Count;

  004f8	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  004fb	89 bd d0 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp+20], edi

; 434  :         return _Myres > _Small_string_capacity;

  00501	83 fa 07	 cmp	 edx, 7

; 416  :         value_type* _Result = _Bx._Buf;

  00504	8d b5 c0 fa ff
	ff		 lea	 esi, DWORD PTR _kHyperlink$16[ebp+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0050a	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 417  :         if (_Large_mode_engaged()) {

  0050b	0f 47 b5 c0 fa
	ff ff		 cmova	 esi, DWORD PTR _kHyperlink$16[ebp+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00512	51		 push	 ecx
  00513	56		 push	 esi
  00514	e8 00 00 00 00	 call	 _memmove
  00519	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0051c	33 c0		 xor	 eax, eax
  0051e	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax

; 1600 :             _ASAN_STRING_CREATE(*this);
; 1601 :             return *this;

  00522	e9 dc 00 00 00	 jmp	 $LN800@Update
$LN785@Update:

; 2962 :         if (_New_size > max_size()) {

  00527	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  0052d	0f 87 89 11 00
	00		 ja	 $LN1016@Update

; 2963 :             _Xlen_string(); // result too long
; 2964 :         }
; 2965 : 
; 2966 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  00533	8b f7		 mov	 esi, edi
  00535	83 ce 07	 or	 esi, 7

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00538	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0053e	77 2d		 ja	 SHORT $LN1109@Update

; 2944 :             return _Max;
; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00540	8b ca		 mov	 ecx, edx
  00542	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  00547	d1 e9		 shr	 ecx, 1
  00549	2b c1		 sub	 eax, ecx
  0054b	3b d0		 cmp	 edx, eax
  0054d	77 1e		 ja	 SHORT $LN1109@Update

; 2948 :             return _Max;
; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0054f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00552	3b f0		 cmp	 esi, eax
  00554	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  00557	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0055a	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0055f	0f 87 52 11 00
	00		 ja	 $LN1017@Update

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00565	03 c0		 add	 eax, eax

; 227  :     if (_Bytes == 0) {

  00567	75 10		 jne	 SHORT $LN824@Update

; 228  :         return nullptr;

  00569	33 ff		 xor	 edi, edi
  0056b	eb 25		 jmp	 SHORT $LN823@Update
$LN1109@Update:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0056d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00572	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  00577	03 c0		 add	 eax, eax
$LN824@Update:
  00579	50		 push	 eax
  0057a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0057f	72 07		 jb	 SHORT $LN825@Update

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00581	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00586	eb 05		 jmp	 SHORT $LN1110@Update
$LN825@Update:

; 136  :         return ::operator new(_Bytes);

  00588	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN1110@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  0058d	8b f8		 mov	 edi, eax
  0058f	83 c4 04	 add	 esp, 4
$LN823@Update:
  00592	8b 85 64 fa ff
	ff		 mov	 eax, DWORD PTR $T11[ebp]

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  00598	89 b5 d4 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp+24], esi
  0059e	89 85 d0 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp+20], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  005a4	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]
  005a7	56		 push	 esi
  005a8	ff b5 58 fa ff
	ff		 push	 DWORD PTR __Result$2$[ebp]
  005ae	57		 push	 edi
  005af	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  005b4	33 c0		 xor	 eax, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  005b6	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  005b9	66 89 04 3e	 mov	 WORD PTR [esi+edi], ax

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  005bd	8b 85 44 fa ff
	ff		 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]
  005c3	83 f8 07	 cmp	 eax, 7
  005c6	76 35		 jbe	 SHORT $LN799@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  005c8	8b 95 c0 fa ff
	ff		 mov	 edx, DWORD PTR _kHyperlink$16[ebp+4]
  005ce	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]
  005d5	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  005d7	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  005dd	72 14		 jb	 SHORT $LN856@Update

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  005df	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  005e2	83 c1 23	 add	 ecx, 35			; 00000023H
  005e5	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  005e7	83 c0 fc	 add	 eax, -4			; fffffffcH
  005ea	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  005ed	0f 87 ce 10 00
	00		 ja	 $LN167@Update
$LN856@Update:

; 289  :         ::operator delete(_Ptr, _Bytes);

  005f3	51		 push	 ecx
  005f4	52		 push	 edx
  005f5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  005fa	83 c4 08	 add	 esp, 8
$LN799@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  005fd	89 bd c0 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp+4], edi
$LN800@Update:
  00603	8b b5 60 fa ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00609	8d 8d bc fa ff
	ff		 lea	 ecx, DWORD PTR _kHyperlink$16[ebp]
  0060f	83 c6 64	 add	 esi, 100		; 00000064H
  00612	51		 push	 ecx
  00613	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00616	50		 push	 eax
  00617	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0061a	74 0f		 je	 SHORT $LN770@Update

; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0061c	56		 push	 esi
  0061d	e8 00 00 00 00	 call	 ??$construct@USHyperlink@CGraphicTextInstance@@ABU12@@?$_Default_allocator_traits@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@USHyperlink@CGraphicTextInstance@@@1@QAUSHyperlink@CGraphicTextInstance@@ABU34@@Z ; std::_Default_allocator_traits<std::allocator<CGraphicTextInstance::SHyperlink> >::construct<CGraphicTextInstance::SHyperlink,CGraphicTextInstance::SHyperlink const &>
  00622	83 c4 0c	 add	 esp, 12			; 0000000cH

; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00625	83 46 04 1c	 add	 DWORD PTR [esi+4], 28	; 0000001cH

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00629	eb 07		 jmp	 SHORT $LN769@Update
$LN770@Update:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0062b	8b ce		 mov	 ecx, esi
  0062d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_reallocate<CGraphicTextInstance::SHyperlink const &>
$LN769@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 336  : 											no_hyperlink++;

  00632	ff 85 4c fa ff
	ff		 inc	 DWORD PTR _no_hyperlink$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00638	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]
  0063e	6a 00		 push	 0
  00640	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 339  : 											hyperlinkStep = 0;

  00645	c7 85 58 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0064f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00654	8b 85 d4 fa ff
	ff		 mov	 eax, DWORD PTR _kHyperlink$16[ebp+24]
  0065a	89 85 44 fa ff
	ff		 mov	 DWORD PTR __Old_capacity$1$[ebp], eax
  00660	66 8b 85 be fa
	ff ff		 mov	 ax, WORD PTR _kHyperlink$16[ebp+2]
  00667	89 85 50 fa ff
	ff		 mov	 DWORD PTR tv4169[ebp], eax
  0066d	e9 0c 01 00 00	 jmp	 $LN1093@Update
$LN60@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 295  : 									if (hyperlinkStep == 1)

  00672	83 bd 58 fa ff
	ff 01		 cmp	 DWORD PTR _hyperlinkStep$1$[ebp], 1
  00679	0f b7 07	 movzx	 eax, WORD PTR [edi]
  0067c	75 62		 jne	 SHORT $LN61@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1515 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0067e	8b bd ec fa ff
	ff		 mov	 edi, DWORD PTR _hyperlinkBuffer$17[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 296  : 										hyperlinkBuffer.append(1, wArabicText[e]);

  00684	8b d0		 mov	 edx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1515 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00686	8b 8d e8 fa ff
	ff		 mov	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp+16]
  0068c	8b c7		 mov	 eax, edi
  0068e	2b c1		 sub	 eax, ecx

; 1516 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00690	83 f8 01	 cmp	 eax, 1
  00693	72 29		 jb	 SHORT $LN381@Update

; 1517 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1518 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00695	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 434  :         return _Myres > _Small_string_capacity;

  00698	83 ff 07	 cmp	 edi, 7

; 1518 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0069b	89 85 e8 fa ff
	ff		 mov	 DWORD PTR _hyperlinkBuffer$17[ebp+16], eax

; 416  :         value_type* _Result = _Bx._Buf;

  006a1	8d 85 d8 fa ff
	ff		 lea	 eax, DWORD PTR _hyperlinkBuffer$17[ebp]

; 417  :         if (_Large_mode_engaged()) {

  006a7	0f 47 85 d8 fa
	ff ff		 cmova	 eax, DWORD PTR _hyperlinkBuffer$17[ebp]
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 513  :             *_Su = _C;

  006ae	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1521 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  006b2	33 d2		 xor	 edx, edx
  006b4	66 89 54 48 02	 mov	 WORD PTR [eax+ecx*2+2], dx

; 1522 :             return *this;

  006b9	e9 c6 00 00 00	 jmp	 $LN1010@Update
$LN381@Update:

; 1523 :         }
; 1524 : 
; 1525 :         return _Reallocate_grow_by(

  006be	52		 push	 edx
  006bf	6a 01		 push	 1
  006c1	c6 85 0c fa ff
	ff 00		 mov	 BYTE PTR $T6[ebp], 0
  006c8	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]
  006ce	ff b5 0c fa ff
	ff		 push	 DWORD PTR $T6[ebp]
  006d4	6a 01		 push	 1
  006d6	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 296  : 										hyperlinkBuffer.append(1, wArabicText[e]);

  006db	e9 a4 00 00 00	 jmp	 $LN1010@Update
$LN61@Update:

; 297  : 									else
; 298  : 									{
; 299  : 										int charWidth = __DrawCharacter(pFontTexture, dataCodePage, wArabicText[e], dwColor);

  006e0	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  006e6	56		 push	 esi
  006e7	50		 push	 eax
  006e8	ff b5 40 fa ff
	ff		 push	 DWORD PTR _dataCodePage$1$[ebp]
  006ee	ff b5 3c fa ff
	ff		 push	 DWORD PTR _pFontTexture$1$[ebp]
  006f4	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter

; 300  : 										kHyperlink.ex += charWidth;

  006f9	8b 8d 50 fa ff
	ff		 mov	 ecx, DWORD PTR tv4169[ebp]

; 303  : 										for (int j = 1; j <= no_hyperlink; j++)

  006ff	bf 01 00 00 00	 mov	 edi, 1
  00704	0f b7 c0	 movzx	 eax, ax
  00707	66 03 c8	 add	 cx, ax
  0070a	89 85 64 fa ff
	ff		 mov	 DWORD PTR tv4434[ebp], eax
  00710	89 8d 50 fa ff
	ff		 mov	 DWORD PTR tv4169[ebp], ecx
  00716	66 89 8d be fa
	ff ff		 mov	 WORD PTR _kHyperlink$16[ebp+2], cx
  0071d	39 bd 4c fa ff
	ff		 cmp	 DWORD PTR _no_hyperlink$1$[ebp], edi
  00723	7c 5f		 jl	 SHORT $LN1010@Update
  00725	8b f0		 mov	 esi, eax
  00727	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00730	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00736	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00739	8b 49 68	 mov	 ecx, DWORD PTR [ecx+104]
  0073c	2b c8		 sub	 ecx, eax
  0073e	89 85 64 fa ff
	ff		 mov	 DWORD PTR tv4487[ebp], eax
  00744	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00749	f7 e9		 imul	 ecx
  0074b	03 d1		 add	 edx, ecx
  0074d	c1 fa 04	 sar	 edx, 4
  00750	8b ca		 mov	 ecx, edx
  00752	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00755	03 ca		 add	 ecx, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 305  : 											if(m_hyperlinkVector.size() < j)

  00757	3b cf		 cmp	 ecx, edi
  00759	72 23		 jb	 SHORT $LN1093@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0075b	2b cf		 sub	 ecx, edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 303  : 										for (int j = 1; j <= no_hyperlink; j++)

  0075d	47		 inc	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0075e	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00765	2b c1		 sub	 eax, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 309  : 											tempLink.ex += charWidth;

  00767	8b 8d 64 fa ff
	ff		 mov	 ecx, DWORD PTR tv4487[ebp]
  0076d	66 01 74 81 02	 add	 WORD PTR [ecx+eax*4+2], si

; 310  : 											tempLink.sx += charWidth;

  00772	66 01 34 81	 add	 WORD PTR [ecx+eax*4], si
  00776	3b bd 4c fa ff
	ff		 cmp	 edi, DWORD PTR _no_hyperlink$1$[ebp]
  0077c	7e b2		 jle	 SHORT $LL18@Update
$LN1093@Update:

; 340  : 											hyperlinkBuffer = L"";
; 341  : 										}
; 342  : 									}
; 343  : 								}
; 344  : 								e += len;

  0077e	8b b5 68 fa ff
	ff		 mov	 esi, DWORD PTR _dwColor$1$[ebp]
$LN1010@Update:
  00784	8b 8d 30 fa ff
	ff		 mov	 ecx, DWORD PTR _e$1$[ebp]
  0078a	03 8d 24 fa ff
	ff		 add	 ecx, DWORD PTR _len$8[ebp]
  00790	89 8d 30 fa ff
	ff		 mov	 DWORD PTR _e$1$[ebp], ecx
  00796	3b 8d 48 fa ff
	ff		 cmp	 ecx, DWORD PTR _nEnglishBase$1$[ebp]
  0079c	0f 8e ee fb ff
	ff		 jle	 $LL15@Update
  007a2	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
$LN14@Update:

; 345  : 							}
; 346  : 
; 347  : 							int charWidth = __DrawCharacter(pFontTexture, dataCodePage, Arabic_ConvSymbol(wArabicText[i]), dwColor);

  007a8	8b 8d 5c fa ff
	ff		 mov	 ecx, DWORD PTR _wArabicText$1$[ebp]
  007ae	56		 push	 esi
  007af	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  007b3	50		 push	 eax
  007b4	e8 00 00 00 00	 call	 ?Arabic_ConvSymbol@@YA_W_W@Z ; Arabic_ConvSymbol
  007b9	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  007bf	83 c4 04	 add	 esp, 4
  007c2	0f b7 c0	 movzx	 eax, ax
  007c5	50		 push	 eax
  007c6	ff b5 40 fa ff
	ff		 push	 DWORD PTR _dataCodePage$1$[ebp]
  007cc	ff b5 3c fa ff
	ff		 push	 DWORD PTR _pFontTexture$1$[ebp]
  007d2	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter

; 348  : 							kHyperlink.ex += charWidth;

  007d7	8b 8d 50 fa ff
	ff		 mov	 ecx, DWORD PTR tv4169[ebp]

; 350  : 							for (int j = 1; j <= no_hyperlink; j++)

  007dd	bf 01 00 00 00	 mov	 edi, 1
  007e2	66 03 c8	 add	 cx, ax
  007e5	89 85 64 fa ff
	ff		 mov	 DWORD PTR _charWidth$1$[ebp], eax
  007eb	89 8d 50 fa ff
	ff		 mov	 DWORD PTR tv4169[ebp], ecx
  007f1	66 89 8d be fa
	ff ff		 mov	 WORD PTR _kHyperlink$16[ebp+2], cx
  007f8	39 bd 4c fa ff
	ff		 cmp	 DWORD PTR _no_hyperlink$1$[ebp], edi
  007fe	7c 56		 jl	 SHORT $LN1013@Update
  00800	8b f0		 mov	 esi, eax
$LL21@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00802	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00808	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  0080b	8b 49 68	 mov	 ecx, DWORD PTR [ecx+104]
  0080e	2b c8		 sub	 ecx, eax
  00810	89 85 64 fa ff
	ff		 mov	 DWORD PTR tv4484[ebp], eax
  00816	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  0081b	f7 e9		 imul	 ecx
  0081d	03 d1		 add	 edx, ecx
  0081f	c1 fa 04	 sar	 edx, 4
  00822	8b ca		 mov	 ecx, edx
  00824	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00827	03 ca		 add	 ecx, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 352  : 								if(m_hyperlinkVector.size() < j)

  00829	3b cf		 cmp	 ecx, edi
  0082b	72 23		 jb	 SHORT $LN1094@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0082d	2b cf		 sub	 ecx, edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 350  : 							for (int j = 1; j <= no_hyperlink; j++)

  0082f	47		 inc	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00830	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00837	2b c1		 sub	 eax, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 356  : 								tempLink.ex += charWidth;

  00839	8b 8d 64 fa ff
	ff		 mov	 ecx, DWORD PTR tv4484[ebp]
  0083f	66 01 74 81 02	 add	 WORD PTR [ecx+eax*4+2], si

; 357  : 								tempLink.sx += charWidth;

  00844	66 01 34 81	 add	 WORD PTR [ecx+eax*4], si
  00848	3b bd 4c fa ff
	ff		 cmp	 edi, DWORD PTR _no_hyperlink$1$[ebp]
  0084e	7e b2		 jle	 SHORT $LL21@Update
$LN1094@Update:
  00850	8b b5 68 fa ff
	ff		 mov	 esi, DWORD PTR _dwColor$1$[ebp]
$LN1013@Update:

; 358  : 							}
; 359  : 
; 360  : 							isEnglish = false;

  00856	32 c0		 xor	 al, al
  00858	88 85 6f fa ff
	ff		 mov	 BYTE PTR _isEnglish$1$[ebp], al

; 361  : 						}
; 362  : 					}

  0085e	e9 f7 00 00 00	 jmp	 $LN1111@Update
$LN50@Update:

; 363  : 					else
; 364  : 					{
; 365  : 						if (Arabic_IsInPresentation(wArabicChar) || Arabic_IsInSymbol(wArabicChar))

  00863	e8 00 00 00 00	 call	 ?Arabic_IsInPresentation@@YA_N_W@Z ; Arabic_IsInPresentation
  00868	83 c4 04	 add	 esp, 4
  0086b	84 c0		 test	 al, al
  0086d	75 26		 jne	 SHORT $LN76@Update
  0086f	57		 push	 edi
  00870	e8 00 00 00 00	 call	 ?Arabic_IsInSymbol@@YA_N_W@Z ; Arabic_IsInSymbol
  00875	83 c4 04	 add	 esp, 4
  00878	84 c0		 test	 al, al
  0087a	75 19		 jne	 SHORT $LN76@Update

; 379  : 							}
; 380  : 						}
; 381  : 						else
; 382  : 						{
; 383  : 							nEnglishBase = i;

  0087c	8b 95 54 fa ff
	ff		 mov	 edx, DWORD PTR _i$1$[ebp]

; 384  : 							isEnglish = true;

  00882	b0 01		 mov	 al, 1
  00884	89 95 48 fa ff
	ff		 mov	 DWORD PTR _nEnglishBase$1$[ebp], edx
  0088a	88 85 6f fa ff
	ff		 mov	 BYTE PTR _isEnglish$1$[ebp], al
  00890	e9 cb 00 00 00	 jmp	 $LN10@Update
$LN76@Update:

; 366  : 						{
; 367  : 							int charWidth = __DrawCharacter(pFontTexture, dataCodePage, Arabic_ConvSymbol(wArabicText[i]), dwColor);

  00895	8b 8d 5c fa ff
	ff		 mov	 ecx, DWORD PTR _wArabicText$1$[ebp]
  0089b	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  008a1	56		 push	 esi
  008a2	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  008a6	50		 push	 eax
  008a7	e8 00 00 00 00	 call	 ?Arabic_ConvSymbol@@YA_W_W@Z ; Arabic_ConvSymbol
  008ac	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  008b2	83 c4 04	 add	 esp, 4
  008b5	0f b7 c0	 movzx	 eax, ax
  008b8	50		 push	 eax
  008b9	ff b5 40 fa ff
	ff		 push	 DWORD PTR _dataCodePage$1$[ebp]
  008bf	ff b5 3c fa ff
	ff		 push	 DWORD PTR _pFontTexture$1$[ebp]
  008c5	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter

; 368  : 							kHyperlink.ex += charWidth;

  008ca	8b 8d 50 fa ff
	ff		 mov	 ecx, DWORD PTR tv4169[ebp]

; 371  : 							for (int j = 1; j <= no_hyperlink; j++)

  008d0	bf 01 00 00 00	 mov	 edi, 1
  008d5	66 03 c8	 add	 cx, ax
  008d8	89 85 64 fa ff
	ff		 mov	 DWORD PTR _charWidth$1$[ebp], eax
  008de	89 8d 50 fa ff
	ff		 mov	 DWORD PTR tv4169[ebp], ecx
  008e4	66 89 8d be fa
	ff ff		 mov	 WORD PTR _kHyperlink$16[ebp+2], cx
  008eb	39 bd 4c fa ff
	ff		 cmp	 DWORD PTR _no_hyperlink$1$[ebp], edi
  008f1	7c 61		 jl	 SHORT $LN1102@Update
  008f3	8b f0		 mov	 esi, eax
  008f5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL24@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00900	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00906	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00909	8b 49 68	 mov	 ecx, DWORD PTR [ecx+104]
  0090c	2b c8		 sub	 ecx, eax
  0090e	89 85 64 fa ff
	ff		 mov	 DWORD PTR tv4481[ebp], eax
  00914	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00919	f7 e9		 imul	 ecx
  0091b	03 d1		 add	 edx, ecx
  0091d	c1 fa 04	 sar	 edx, 4
  00920	8b ca		 mov	 ecx, edx
  00922	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00925	03 ca		 add	 ecx, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 373  : 								if(m_hyperlinkVector.size() < j)

  00927	3b cf		 cmp	 ecx, edi
  00929	72 23		 jb	 SHORT $LN1095@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0092b	2b cf		 sub	 ecx, edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 371  : 							for (int j = 1; j <= no_hyperlink; j++)

  0092d	47		 inc	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0092e	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00935	2b c1		 sub	 eax, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 377  : 								tempLink.ex += charWidth;

  00937	8b 8d 64 fa ff
	ff		 mov	 ecx, DWORD PTR tv4481[ebp]
  0093d	66 01 74 81 02	 add	 WORD PTR [ecx+eax*4+2], si

; 378  : 								tempLink.sx += charWidth;

  00942	66 01 34 81	 add	 WORD PTR [ecx+eax*4], si
  00946	3b bd 4c fa ff
	ff		 cmp	 edi, DWORD PTR _no_hyperlink$1$[ebp]
  0094c	7e b2		 jle	 SHORT $LL24@Update
$LN1095@Update:
  0094e	8b b5 68 fa ff
	ff		 mov	 esi, DWORD PTR _dwColor$1$[ebp]
$LN1102@Update:

; 260  : 				{
; 261  : 					isEnglish = false;
; 262  : 				}
; 263  : 
; 264  : 				int i = 0;
; 265  : 				for (i = wArabicTextLen - 1 ; i >= 0; --i)

  00954	8a 85 6f fa ff
	ff		 mov	 al, BYTE PTR _isEnglish$1$[ebp]
$LN1111@Update:
  0095a	8b 95 48 fa ff
	ff		 mov	 edx, DWORD PTR _nEnglishBase$1$[ebp]
$LN10@Update:
  00960	8b bd 54 fa ff
	ff		 mov	 edi, DWORD PTR _i$1$[ebp]
  00966	83 ef 01	 sub	 edi, 1
  00969	89 bd 54 fa ff
	ff		 mov	 DWORD PTR _i$1$[ebp], edi
  0096f	0f 89 4b f9 ff
	ff		 jns	 $LL12@Update
  00975	8b bd 44 fa ff
	ff		 mov	 edi, DWORD PTR __Old_capacity$1$[ebp]
$LN11@Update:

; 385  : 						}
; 386  : 					}
; 387  : 				}
; 388  : 
; 389  : 				if (isEnglish)

  0097b	84 c0		 test	 al, al
  0097d	0f 84 29 04 00
	00		 je	 $LN1088@Update

; 390  : 				{
; 391  : 					for (int e = i + 1; e <= nEnglishBase;) {

  00983	8b 8d 54 fa ff
	ff		 mov	 ecx, DWORD PTR _i$1$[ebp]
  00989	41		 inc	 ecx
  0098a	89 8d 30 fa ff
	ff		 mov	 DWORD PTR _e$1$[ebp], ecx
  00990	3b ca		 cmp	 ecx, edx
  00992	0f 8f 14 04 00
	00		 jg	 $LN1088@Update
  00998	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL27@Update:

; 392  : 						int ret = GetTextTag(&wArabicText[e], wArabicTextLen - e, len, hyperlinkBuffer);

  009a0	8b 85 5c fa ff
	ff		 mov	 eax, DWORD PTR _wArabicText$1$[ebp]
  009a6	8d 3c 48	 lea	 edi, DWORD PTR [eax+ecx*2]
  009a9	8d 85 d8 fa ff
	ff		 lea	 eax, DWORD PTR _hyperlinkBuffer$17[ebp]
  009af	50		 push	 eax
  009b0	8d 85 24 fa ff
	ff		 lea	 eax, DWORD PTR _len$8[ebp]
  009b6	50		 push	 eax
  009b7	8b 85 38 fa ff
	ff		 mov	 eax, DWORD PTR _wArabicTextLen$1$[ebp]
  009bd	2b c1		 sub	 eax, ecx
  009bf	50		 push	 eax
  009c0	57		 push	 edi
  009c1	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  009c6	83 c4 10	 add	 esp, 16			; 00000010H

; 393  : 
; 394  : 						if (ret == TEXT_TAG_PLAIN || ret == TEXT_TAG_TAG)

  009c9	85 c0		 test	 eax, eax
  009cb	0f 84 b1 02 00
	00		 je	 $LN81@Update
  009d1	83 f8 01	 cmp	 eax, 1
  009d4	0f 84 a8 02 00
	00		 je	 $LN81@Update

; 411  : 								}
; 412  : 							}
; 413  : 						}
; 414  : 						else
; 415  : 						{
; 416  : 							if (ret == TEXT_TAG_COLOR)

  009da	83 f8 02	 cmp	 eax, 2
  009dd	0f 85 87 00 00
	00		 jne	 $LN85@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  009e3	83 bd ec fa ff
	ff 07		 cmp	 DWORD PTR _hyperlinkBuffer$17[ebp+20], 7

; 425  :         const value_type* _Result = _Bx._Buf;

  009ea	8d 85 d8 fa ff
	ff		 lea	 eax, DWORD PTR _hyperlinkBuffer$17[ebp]

; 426  :         if (_Large_mode_engaged()) {

  009f0	0f 47 85 d8 fa
	ff ff		 cmova	 eax, DWORD PTR _hyperlinkBuffer$17[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h

; 149  :     int x = 0, y = 1;

  009f7	33 f6		 xor	 esi, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  009f9	89 85 64 fa ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h

; 149  :     int x = 0, y = 1;

  009ff	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi

; 150  :     s += size;
; 151  : 
; 152  :     while (t <= --s)

  00a05	8d 78 0e	 lea	 edi, DWORD PTR [eax+14]
  00a08	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  00a0b	3b c7		 cmp	 eax, edi
  00a0d	0f 87 75 03 00
	00		 ja	 $LN1087@Update
$LL417@Update:

; 153  :     {
; 154  : 		if (L'0' <= *s && *s <= L'9')

  00a13	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  00a16	8d 41 d0	 lea	 eax, DWORD PTR [ecx-48]
  00a19	66 83 f8 09	 cmp	 ax, 9
  00a1d	77 05		 ja	 SHORT $LN419@Update

; 155  :             x += y * (*s - L'0');

  00a1f	8d 41 d0	 lea	 eax, DWORD PTR [ecx-48]
  00a22	eb 1a		 jmp	 SHORT $LN1112@Update
$LN419@Update:

; 156  :         else if (L'a' <= *s && *s <= L'f')

  00a24	8d 41 9f	 lea	 eax, DWORD PTR [ecx-97]
  00a27	66 83 f8 05	 cmp	 ax, 5
  00a2b	77 05		 ja	 SHORT $LN421@Update

; 157  :             x += y * (*s - L'a' + 10);

  00a2d	8d 41 a9	 lea	 eax, DWORD PTR [ecx-87]
  00a30	eb 0c		 jmp	 SHORT $LN1112@Update
$LN421@Update:

; 158  :         else if (L'A' <= *s && *s <= L'F')

  00a32	8d 41 bf	 lea	 eax, DWORD PTR [ecx-65]
  00a35	66 83 f8 05	 cmp	 ax, 5
  00a39	77 21		 ja	 SHORT $LN423@Update

; 159  :             x += y * (10 + *s - L'A');

  00a3b	8d 41 c9	 lea	 eax, DWORD PTR [ecx-55]
$LN1112@Update:

; 162  :         y <<= 4;

  00a3e	0f af c2	 imul	 eax, edx
  00a41	83 ef 02	 sub	 edi, 2
  00a44	c1 e2 04	 shl	 edx, 4
  00a47	03 f0		 add	 esi, eax
  00a49	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi
  00a4f	39 bd 64 fa ff
	ff		 cmp	 DWORD PTR __Result$2$[ebp], edi
  00a55	76 bc		 jbe	 SHORT $LL417@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00a57	e9 2c 03 00 00	 jmp	 $LN1087@Update
$LN423@Update:
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h

; 161  :             return -1; /* invalid input! */

  00a5c	83 ce ff	 or	 esi, -1
  00a5f	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 417  : 								dwColor = htoi(hyperlinkBuffer.c_str(), 8);

  00a65	e9 1e 03 00 00	 jmp	 $LN1087@Update
$LN85@Update:

; 418  : 							else if (ret == TEXT_TAG_RESTORE_COLOR)

  00a6a	83 f8 05	 cmp	 eax, 5
  00a6d	75 14		 jne	 SHORT $LN87@Update

; 419  : 								dwColor = m_dwTextColor;

  00a6f	8b 85 60 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00a75	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00a78	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi
  00a7e	e9 05 03 00 00	 jmp	 $LN1087@Update
$LN87@Update:

; 420  : 							else if (ret == TEXT_TAG_HYPERLINK_START)

  00a83	83 f8 03	 cmp	 eax, 3
  00a86	75 21		 jne	 SHORT $LN89@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a88	6a 00		 push	 0
  00a8a	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00a8f	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 422  : 								hyperlinkStep = 1;

  00a95	c7 85 58 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00a9f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 424  : 							}

  00aa4	e9 df 02 00 00	 jmp	 $LN1087@Update
$LN89@Update:

; 425  : 							else if (ret == TEXT_TAG_HYPERLINK_END)

  00aa9	83 f8 04	 cmp	 eax, 4
  00aac	0f 85 d6 02 00
	00		 jne	 $LN1087@Update

; 426  : 							{
; 427  : 								if (hyperlinkStep == 1)

  00ab2	83 bd 58 fa ff
	ff 01		 cmp	 DWORD PTR _hyperlinkStep$1$[ebp], 1
  00ab9	75 1d		 jne	 SHORT $LN92@Update

; 428  : 								{
; 429  : 									++hyperlinkStep;
; 430  : 									kHyperlink.ex = kHyperlink.sx = 0;

  00abb	33 c0		 xor	 eax, eax
  00abd	c7 85 58 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 2
  00ac7	89 85 bc fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp], eax
  00acd	89 85 50 fa ff
	ff		 mov	 DWORD PTR tv4169[ebp], eax

; 431  : 								}

  00ad3	e9 b0 02 00 00	 jmp	 $LN1087@Update
$LN92@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00ad8	83 bd ec fa ff
	ff 07		 cmp	 DWORD PTR _hyperlinkBuffer$17[ebp+20], 7

; 425  :         const value_type* _Result = _Bx._Buf;

  00adf	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00ae5	8b bd e8 fa ff
	ff		 mov	 edi, DWORD PTR _hyperlinkBuffer$17[ebp+16]

; 426  :         if (_Large_mode_engaged()) {

  00aeb	0f 47 8d d8 fa
	ff ff		 cmova	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]

; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  00af2	8b 95 44 fa ff
	ff		 mov	 edx, DWORD PTR __Old_capacity$1$[ebp]

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00af8	89 bd 64 fa ff
	ff		 mov	 DWORD PTR $T10[ebp], edi

; 426  :         if (_Large_mode_engaged()) {

  00afe	89 8d 58 fa ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], ecx

; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  00b04	3b fa		 cmp	 edi, edx
  00b06	77 2f		 ja	 SHORT $LN682@Update

; 1595 :             _ASAN_STRING_REMOVE(*this);
; 1596 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 1597 :             _Mypair._Myval2._Mysize = _Count;

  00b08	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  00b0b	89 bd d0 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp+20], edi

; 434  :         return _Myres > _Small_string_capacity;

  00b11	83 fa 07	 cmp	 edx, 7

; 416  :         value_type* _Result = _Bx._Buf;

  00b14	8d b5 c0 fa ff
	ff		 lea	 esi, DWORD PTR _kHyperlink$16[ebp+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00b1a	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 417  :         if (_Large_mode_engaged()) {

  00b1b	0f 47 b5 c0 fa
	ff ff		 cmova	 esi, DWORD PTR _kHyperlink$16[ebp+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00b22	51		 push	 ecx
  00b23	56		 push	 esi
  00b24	e8 00 00 00 00	 call	 _memmove
  00b29	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00b2c	33 c0		 xor	 eax, eax
  00b2e	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax

; 1600 :             _ASAN_STRING_CREATE(*this);
; 1601 :             return *this;

  00b32	e9 dc 00 00 00	 jmp	 $LN697@Update
$LN682@Update:

; 2962 :         if (_New_size > max_size()) {

  00b37	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  00b3d	0f 87 79 0b 00
	00		 ja	 $LN1016@Update

; 2963 :             _Xlen_string(); // result too long
; 2964 :         }
; 2965 : 
; 2966 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  00b43	8b f7		 mov	 esi, edi
  00b45	83 ce 07	 or	 esi, 7

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00b48	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00b4e	77 2d		 ja	 SHORT $LN1113@Update

; 2944 :             return _Max;
; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00b50	8b ca		 mov	 ecx, edx
  00b52	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  00b57	d1 e9		 shr	 ecx, 1
  00b59	2b c1		 sub	 eax, ecx
  00b5b	3b d0		 cmp	 edx, eax
  00b5d	77 1e		 ja	 SHORT $LN1113@Update

; 2948 :             return _Max;
; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00b5f	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
  00b62	3b f0		 cmp	 esi, eax
  00b64	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  00b67	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00b6a	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00b6f	0f 87 42 0b 00
	00		 ja	 $LN1017@Update

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00b75	03 c0		 add	 eax, eax

; 227  :     if (_Bytes == 0) {

  00b77	75 10		 jne	 SHORT $LN721@Update

; 228  :         return nullptr;

  00b79	33 ff		 xor	 edi, edi
  00b7b	eb 25		 jmp	 SHORT $LN720@Update
$LN1113@Update:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00b7d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00b82	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  00b87	03 c0		 add	 eax, eax
$LN721@Update:
  00b89	50		 push	 eax
  00b8a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00b8f	72 07		 jb	 SHORT $LN722@Update

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00b91	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00b96	eb 05		 jmp	 SHORT $LN1114@Update
$LN722@Update:

; 136  :         return ::operator new(_Bytes);

  00b98	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN1114@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  00b9d	8b f8		 mov	 edi, eax
  00b9f	83 c4 04	 add	 esp, 4
$LN720@Update:
  00ba2	8b 85 64 fa ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  00ba8	89 b5 d4 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp+24], esi
  00bae	89 85 d0 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp+20], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00bb4	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]
  00bb7	56		 push	 esi
  00bb8	ff b5 58 fa ff
	ff		 push	 DWORD PTR __Result$2$[ebp]
  00bbe	57		 push	 edi
  00bbf	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00bc4	33 c0		 xor	 eax, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00bc6	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00bc9	66 89 04 3e	 mov	 WORD PTR [esi+edi], ax

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  00bcd	8b 85 44 fa ff
	ff		 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]
  00bd3	83 f8 07	 cmp	 eax, 7
  00bd6	76 35		 jbe	 SHORT $LN696@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00bd8	8b 95 c0 fa ff
	ff		 mov	 edx, DWORD PTR _kHyperlink$16[ebp+4]
  00bde	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]
  00be5	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00be7	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00bed	72 14		 jb	 SHORT $LN753@Update

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00bef	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00bf2	83 c1 23	 add	 ecx, 35			; 00000023H
  00bf5	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00bf7	83 c0 fc	 add	 eax, -4			; fffffffcH
  00bfa	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00bfd	0f 87 be 0a 00
	00		 ja	 $LN167@Update
$LN753@Update:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00c03	51		 push	 ecx
  00c04	52		 push	 edx
  00c05	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00c0a	83 c4 08	 add	 esp, 8
$LN696@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00c0d	89 bd c0 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$16[ebp+4], edi
$LN697@Update:
  00c13	8b b5 60 fa ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00c19	8d 8d bc fa ff
	ff		 lea	 ecx, DWORD PTR _kHyperlink$16[ebp]
  00c1f	83 c6 64	 add	 esi, 100		; 00000064H
  00c22	51		 push	 ecx
  00c23	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00c26	50		 push	 eax
  00c27	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00c2a	74 0f		 je	 SHORT $LN667@Update

; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00c2c	56		 push	 esi
  00c2d	e8 00 00 00 00	 call	 ??$construct@USHyperlink@CGraphicTextInstance@@ABU12@@?$_Default_allocator_traits@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@USHyperlink@CGraphicTextInstance@@@1@QAUSHyperlink@CGraphicTextInstance@@ABU34@@Z ; std::_Default_allocator_traits<std::allocator<CGraphicTextInstance::SHyperlink> >::construct<CGraphicTextInstance::SHyperlink,CGraphicTextInstance::SHyperlink const &>
  00c32	83 c4 0c	 add	 esp, 12			; 0000000cH

; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00c35	83 46 04 1c	 add	 DWORD PTR [esi+4], 28	; 0000001cH

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00c39	eb 07		 jmp	 SHORT $LN666@Update
$LN667@Update:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00c3b	8b ce		 mov	 ecx, esi
  00c3d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_reallocate<CGraphicTextInstance::SHyperlink const &>
$LN666@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 436  : 									no_hyperlink++;

  00c42	ff 85 4c fa ff
	ff		 inc	 DWORD PTR _no_hyperlink$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00c48	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]
  00c4e	6a 00		 push	 0
  00c50	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 438  : 									hyperlinkStep = 0;

  00c55	c7 85 58 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00c5f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  00c64	0f b7 8d be fa
	ff ff		 movzx	 ecx, WORD PTR _kHyperlink$16[ebp+2]
  00c6b	8b 85 d4 fa ff
	ff		 mov	 eax, DWORD PTR _kHyperlink$16[ebp+24]
  00c71	89 85 44 fa ff
	ff		 mov	 DWORD PTR __Old_capacity$1$[ebp], eax
  00c77	89 8d 50 fa ff
	ff		 mov	 DWORD PTR tv4169[ebp], ecx
  00c7d	e9 00 01 00 00	 jmp	 $LN1096@Update
$LN81@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 396  : 							if (hyperlinkStep == 1)

  00c82	83 bd 58 fa ff
	ff 01		 cmp	 DWORD PTR _hyperlinkStep$1$[ebp], 1
  00c89	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00c8c	75 62		 jne	 SHORT $LN82@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1515 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00c8e	8b bd ec fa ff
	ff		 mov	 edi, DWORD PTR _hyperlinkBuffer$17[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 397  : 								hyperlinkBuffer.append(1, wArabicText[e]);

  00c94	8b d0		 mov	 edx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1515 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00c96	8b 8d e8 fa ff
	ff		 mov	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp+16]
  00c9c	8b c7		 mov	 eax, edi
  00c9e	2b c1		 sub	 eax, ecx

; 1516 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00ca0	83 f8 01	 cmp	 eax, 1
  00ca3	72 29		 jb	 SHORT $LN363@Update

; 1517 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1518 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00ca5	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 434  :         return _Myres > _Small_string_capacity;

  00ca8	83 ff 07	 cmp	 edi, 7

; 1518 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00cab	89 85 e8 fa ff
	ff		 mov	 DWORD PTR _hyperlinkBuffer$17[ebp+16], eax

; 416  :         value_type* _Result = _Bx._Buf;

  00cb1	8d 85 d8 fa ff
	ff		 lea	 eax, DWORD PTR _hyperlinkBuffer$17[ebp]

; 417  :         if (_Large_mode_engaged()) {

  00cb7	0f 47 85 d8 fa
	ff ff		 cmova	 eax, DWORD PTR _hyperlinkBuffer$17[ebp]
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 513  :             *_Su = _C;

  00cbe	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1521 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00cc2	33 d2		 xor	 edx, edx
  00cc4	66 89 54 48 02	 mov	 WORD PTR [eax+ecx*2+2], dx

; 1522 :             return *this;

  00cc9	e9 ba 00 00 00	 jmp	 $LN1087@Update
$LN363@Update:

; 1523 :         }
; 1524 : 
; 1525 :         return _Reallocate_grow_by(

  00cce	52		 push	 edx
  00ccf	6a 01		 push	 1
  00cd1	c6 85 08 fa ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0
  00cd8	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]
  00cde	ff b5 08 fa ff
	ff		 push	 DWORD PTR $T5[ebp]
  00ce4	6a 01		 push	 1
  00ce6	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 397  : 								hyperlinkBuffer.append(1, wArabicText[e]);

  00ceb	e9 98 00 00 00	 jmp	 $LN1087@Update
$LN82@Update:

; 398  : 							else
; 399  : 							{
; 400  : 								int charWidth = __DrawCharacter(pFontTexture, dataCodePage, wArabicText[e], dwColor);

  00cf0	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00cf6	56		 push	 esi
  00cf7	50		 push	 eax
  00cf8	ff b5 40 fa ff
	ff		 push	 DWORD PTR _dataCodePage$1$[ebp]
  00cfe	ff b5 3c fa ff
	ff		 push	 DWORD PTR _pFontTexture$1$[ebp]
  00d04	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter

; 401  : 								kHyperlink.ex += charWidth;

  00d09	8b 95 50 fa ff
	ff		 mov	 edx, DWORD PTR tv4169[ebp]

; 402  : 
; 403  : 								for (int j = 1; j <= no_hyperlink; j++)

  00d0f	bf 01 00 00 00	 mov	 edi, 1
  00d14	66 03 d0	 add	 dx, ax
  00d17	89 85 64 fa ff
	ff		 mov	 DWORD PTR _charWidth$1$[ebp], eax
  00d1d	89 95 50 fa ff
	ff		 mov	 DWORD PTR tv4169[ebp], edx
  00d23	66 89 95 be fa
	ff ff		 mov	 WORD PTR _kHyperlink$16[ebp+2], dx
  00d2a	39 bd 4c fa ff
	ff		 cmp	 DWORD PTR _no_hyperlink$1$[ebp], edi
  00d30	7c 56		 jl	 SHORT $LN1087@Update
  00d32	8b f0		 mov	 esi, eax
$LL30@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00d34	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00d3a	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00d3d	8b 49 68	 mov	 ecx, DWORD PTR [ecx+104]
  00d40	2b c8		 sub	 ecx, eax
  00d42	89 85 64 fa ff
	ff		 mov	 DWORD PTR tv4474[ebp], eax
  00d48	b8 93 24 49 92	 mov	 eax, -1840700269	; 92492493H
  00d4d	f7 e9		 imul	 ecx
  00d4f	03 d1		 add	 edx, ecx
  00d51	c1 fa 04	 sar	 edx, 4
  00d54	8b ca		 mov	 ecx, edx
  00d56	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00d59	03 ca		 add	 ecx, edx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 405  : 									if(m_hyperlinkVector.size() < j)

  00d5b	3b cf		 cmp	 ecx, edi
  00d5d	72 23		 jb	 SHORT $LN1096@Update

; 406  : 										break;
; 407  : 
; 408  : 									SHyperlink & tempLink = m_hyperlinkVector[m_hyperlinkVector.size() - j];

  00d5f	2b cf		 sub	 ecx, edi
  00d61	47		 inc	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00d62	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*8]
  00d69	2b c1		 sub	 eax, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 409  : 									tempLink.ex += charWidth;

  00d6b	8b 8d 64 fa ff
	ff		 mov	 ecx, DWORD PTR tv4474[ebp]
  00d71	66 01 74 81 02	 add	 WORD PTR [ecx+eax*4+2], si

; 410  : 									tempLink.sx += charWidth;

  00d76	66 01 34 81	 add	 WORD PTR [ecx+eax*4], si
  00d7a	3b bd 4c fa ff
	ff		 cmp	 edi, DWORD PTR _no_hyperlink$1$[ebp]
  00d80	7e b2		 jle	 SHORT $LL30@Update
$LN1096@Update:

; 439  : 									hyperlinkBuffer = L"";
; 440  : 								}
; 441  : 							}
; 442  : 						}
; 443  : 						e += len;

  00d82	8b b5 68 fa ff
	ff		 mov	 esi, DWORD PTR _dwColor$1$[ebp]
$LN1087@Update:
  00d88	8b 8d 30 fa ff
	ff		 mov	 ecx, DWORD PTR _e$1$[ebp]
  00d8e	03 8d 24 fa ff
	ff		 add	 ecx, DWORD PTR _len$8[ebp]
  00d94	89 8d 30 fa ff
	ff		 mov	 DWORD PTR _e$1$[ebp], ecx
  00d9a	3b 8d 48 fa ff
	ff		 cmp	 ecx, DWORD PTR _nEnglishBase$1$[ebp]
  00da0	0f 8e fa fb ff
	ff		 jle	 $LL27@Update
  00da6	8b bd 44 fa ff
	ff		 mov	 edi, DWORD PTR __Old_capacity$1$[ebp]
$LN1088@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00dac	8b 8d ec fa ff
	ff		 mov	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 447  : 			}

  00db2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00db6	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00db9	76 35		 jbe	 SHORT $LN198@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00dbb	8b 95 d8 fa ff
	ff		 mov	 edx, DWORD PTR _hyperlinkBuffer$17[ebp]
  00dc1	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  00dc8	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00dca	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00dd0	72 14		 jb	 SHORT $LN209@Update

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00dd2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00dd5	83 c1 23	 add	 ecx, 35			; 00000023H
  00dd8	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00dda	83 c0 fc	 add	 eax, -4			; fffffffcH
  00ddd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00de0	0f 87 db 08 00
	00		 ja	 $LN167@Update
$LN209@Update:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00de6	51		 push	 ecx
  00de7	52		 push	 edx
  00de8	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ded	83 c4 08	 add	 esp, 8
$LN198@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00df0	33 c0		 xor	 eax, eax
  00df2	c7 85 e8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _hyperlinkBuffer$17[ebp+16], 0
  00dfc	c7 85 ec fa ff
	ff 07 00 00 00	 mov	 DWORD PTR _hyperlinkBuffer$17[ebp+20], 7
  00e06	66 89 85 d8 fa
	ff ff		 mov	 WORD PTR _hyperlinkBuffer$17[ebp], ax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 447  : 			}

  00e0d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00e14	83 ff 07	 cmp	 edi, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00e17	0f 86 31 08 00
	00		 jbe	 $LN338@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00e1d	8b 95 c0 fa ff
	ff		 mov	 edx, DWORD PTR _kHyperlink$16[ebp+4]
  00e23	8d 0c 7d 02 00
	00 00		 lea	 ecx, DWORD PTR [edi*2+2]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 447  : 			}

  00e2a	e9 f7 07 00 00	 jmp	 $LN1120@Update
$LN47@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h

; 94   : 			SHyperlink() : sx(0), ex(0) { }

  00e2f	33 c0		 xor	 eax, eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 450  : 				int x = 0;

  00e31	c7 85 44 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _x$1$[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h

; 94   : 			SHyperlink() : sx(0), ex(0) { }

  00e3b	89 85 70 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$13[ebp], eax
  00e41	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00e44	89 85 84 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$13[ebp+20], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h

; 94   : 			SHyperlink() : sx(0), ex(0) { }

  00e4a	33 ff		 xor	 edi, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00e4c	b8 07 00 00 00	 mov	 eax, 7
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 452  : 				int hyperlinkStep = 0;

  00e51	c7 85 58 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00e5b	89 85 50 fa ff
	ff		 mov	 DWORD PTR __Old_capacity$1$[ebp], eax
  00e61	89 85 88 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$13[ebp+24], eax

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00e67	33 c0		 xor	 eax, eax

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00e69	0f 11 85 74 fa
	ff ff		 movups	 XMMWORD PTR _kHyperlink$13[ebp+4], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h

; 94   : 			SHyperlink() : sx(0), ex(0) { }

  00e70	89 bd 48 fa ff
	ff		 mov	 DWORD PTR tv4327[ebp], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00e76	66 89 85 74 fa
	ff ff		 mov	 WORD PTR _kHyperlink$13[ebp+4], ax

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00e7d	0f 11 85 a4 fa
	ff ff		 movups	 XMMWORD PTR _hyperlinkBuffer$15[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 453  : 				SHyperlink kHyperlink;

  00e84	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00e8b	89 85 b4 fa ff
	ff		 mov	 DWORD PTR _hyperlinkBuffer$15[ebp+16], eax

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00e91	c7 85 b8 fa ff
	ff 07 00 00 00	 mov	 DWORD PTR _hyperlinkBuffer$15[ebp+20], 7

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00e9b	66 89 85 a4 fa
	ff ff		 mov	 WORD PTR _hyperlinkBuffer$15[ebp], ax

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00ea2	b9 07 00 00 00	 mov	 ecx, 7
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h

; 102  : 			SEmoji() : x(0)

  00ea7	66 89 85 1c fa
	ff ff		 mov	 WORD PTR _kEmoji$7[ebp], ax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00eae	0f 11 85 8c fa
	ff ff		 movups	 XMMWORD PTR _emojiBuffer$14[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.h

; 104  : 				pInstance = NULL;

  00eb5	89 85 20 fa ff
	ff		 mov	 DWORD PTR _kEmoji$7[ebp+4], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 457  : 				int emojiStep = 0;

  00ebb	89 85 5c fa ff
	ff		 mov	 DWORD PTR _emojiStep$1$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00ec1	89 85 9c fa ff
	ff		 mov	 DWORD PTR _emojiBuffer$14[ebp+16], eax

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00ec7	89 8d a0 fa ff
	ff		 mov	 DWORD PTR _emojiBuffer$14[ebp+20], ecx

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00ecd	66 89 85 8c fa
	ff ff		 mov	 WORD PTR _emojiBuffer$14[ebp], ax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 458  : 				std::wstring emojiBuffer;

  00ed4	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 459  : #endif
; 460  : 
; 461  : 				for (int i = 0; i < wTextLen; )

  00ed8	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  00ede	85 d2		 test	 edx, edx
  00ee0	0f 8e 65 06 00
	00		 jle	 $LN1090@Update
  00ee6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL33@Update:

; 462  : 				{
; 463  : 					int ret = GetTextTag(&wText[i], wTextLen - i, len, hyperlinkBuffer);

  00ef0	8b 8d 28 fa ff
	ff		 mov	 ecx, DWORD PTR _wText$1$[ebp]
  00ef6	2b 95 54 fa ff
	ff		 sub	 edx, DWORD PTR _i$1$[ebp]
  00efc	8d 3c 41	 lea	 edi, DWORD PTR [ecx+eax*2]
  00eff	8d 85 a4 fa ff
	ff		 lea	 eax, DWORD PTR _hyperlinkBuffer$15[ebp]
  00f05	50		 push	 eax
  00f06	8d 85 fc f9 ff
	ff		 lea	 eax, DWORD PTR _len$2[ebp]
  00f0c	50		 push	 eax
  00f0d	52		 push	 edx
  00f0e	57		 push	 edi
  00f0f	e8 00 00 00 00	 call	 ?GetTextTag@@YAHPB_WHAAHAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; GetTextTag
  00f14	83 c4 10	 add	 esp, 16			; 00000010H

; 464  : 
; 465  : 					if (ret == TEXT_TAG_PLAIN || ret == TEXT_TAG_TAG)

  00f17	85 c0		 test	 eax, eax
  00f19	0f 84 fd 04 00
	00		 je	 $LN96@Update
  00f1f	83 f8 01	 cmp	 eax, 1
  00f22	0f 84 f4 04 00
	00		 je	 $LN96@Update

; 478  : 						}
; 479  : 					}
; 480  : 					else
; 481  : 					{
; 482  : 						if (ret == TEXT_TAG_COLOR)

  00f28	83 f8 02	 cmp	 eax, 2
  00f2b	0f 85 87 00 00
	00		 jne	 $LN101@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00f31	83 bd b8 fa ff
	ff 07		 cmp	 DWORD PTR _hyperlinkBuffer$15[ebp+20], 7

; 425  :         const value_type* _Result = _Bx._Buf;

  00f38	8d 85 a4 fa ff
	ff		 lea	 eax, DWORD PTR _hyperlinkBuffer$15[ebp]

; 426  :         if (_Large_mode_engaged()) {

  00f3e	0f 47 85 a4 fa
	ff ff		 cmova	 eax, DWORD PTR _hyperlinkBuffer$15[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h

; 149  :     int x = 0, y = 1;

  00f45	33 f6		 xor	 esi, esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  00f47	89 85 64 fa ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h

; 149  :     int x = 0, y = 1;

  00f4d	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi

; 150  :     s += size;
; 151  : 
; 152  :     while (t <= --s)

  00f53	8d 78 0e	 lea	 edi, DWORD PTR [eax+14]
  00f56	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
  00f59	3b c7		 cmp	 eax, edi
  00f5b	0f 87 c4 05 00
	00		 ja	 $LN100@Update
$LL607@Update:

; 153  :     {
; 154  : 		if (L'0' <= *s && *s <= L'9')

  00f61	0f b7 0f	 movzx	 ecx, WORD PTR [edi]
  00f64	8d 41 d0	 lea	 eax, DWORD PTR [ecx-48]
  00f67	66 83 f8 09	 cmp	 ax, 9
  00f6b	77 05		 ja	 SHORT $LN609@Update

; 155  :             x += y * (*s - L'0');

  00f6d	8d 41 d0	 lea	 eax, DWORD PTR [ecx-48]
  00f70	eb 1a		 jmp	 SHORT $LN1115@Update
$LN609@Update:

; 156  :         else if (L'a' <= *s && *s <= L'f')

  00f72	8d 41 9f	 lea	 eax, DWORD PTR [ecx-97]
  00f75	66 83 f8 05	 cmp	 ax, 5
  00f79	77 05		 ja	 SHORT $LN611@Update

; 157  :             x += y * (*s - L'a' + 10);

  00f7b	8d 41 a9	 lea	 eax, DWORD PTR [ecx-87]
  00f7e	eb 0c		 jmp	 SHORT $LN1115@Update
$LN611@Update:

; 158  :         else if (L'A' <= *s && *s <= L'F')

  00f80	8d 41 bf	 lea	 eax, DWORD PTR [ecx-65]
  00f83	66 83 f8 05	 cmp	 ax, 5
  00f87	77 21		 ja	 SHORT $LN613@Update

; 159  :             x += y * (10 + *s - L'A');

  00f89	8d 41 c9	 lea	 eax, DWORD PTR [ecx-55]
$LN1115@Update:

; 162  :         y <<= 4;

  00f8c	0f af c2	 imul	 eax, edx
  00f8f	83 ef 02	 sub	 edi, 2
  00f92	c1 e2 04	 shl	 edx, 4
  00f95	03 f0		 add	 esi, eax
  00f97	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi
  00f9d	39 bd 64 fa ff
	ff		 cmp	 DWORD PTR __Result$2$[ebp], edi
  00fa3	76 bc		 jbe	 SHORT $LL607@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00fa5	e9 7b 05 00 00	 jmp	 $LN100@Update
$LN613@Update:
; File C:\Marty 5.5\Src-Client\Client\EterBase\Utils.h

; 161  :             return -1; /* invalid input! */

  00faa	83 ce ff	 or	 esi, -1
  00fad	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 483  : 							dwColor = htoi(hyperlinkBuffer.c_str(), 8);

  00fb3	e9 6d 05 00 00	 jmp	 $LN100@Update
$LN101@Update:

; 484  : 						else if (ret == TEXT_TAG_RESTORE_COLOR)

  00fb8	83 f8 05	 cmp	 eax, 5
  00fbb	75 14		 jne	 SHORT $LN103@Update

; 485  : 							dwColor = m_dwTextColor;

  00fbd	8b 85 60 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  00fc3	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00fc6	89 b5 68 fa ff
	ff		 mov	 DWORD PTR _dwColor$1$[ebp], esi
  00fcc	e9 54 05 00 00	 jmp	 $LN100@Update
$LN103@Update:

; 486  : 						else if (ret == TEXT_TAG_HYPERLINK_START)

  00fd1	83 f8 03	 cmp	 eax, 3
  00fd4	75 21		 jne	 SHORT $LN105@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00fd6	6a 00		 push	 0
  00fd8	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00fdd	8d 8d a4 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$15[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 488  : 							hyperlinkStep = 1;

  00fe3	c7 85 58 fa ff
	ff 01 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00fed	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 490  : 						}

  00ff2	e9 2e 05 00 00	 jmp	 $LN100@Update
$LN105@Update:

; 491  : 						else if (ret == TEXT_TAG_HYPERLINK_END)

  00ff7	83 f8 04	 cmp	 eax, 4
  00ffa	0f 85 dc 01 00
	00		 jne	 $LN107@Update

; 492  : 						{
; 493  : 							if (hyperlinkStep == 1)

  01000	83 bd 58 fa ff
	ff 01		 cmp	 DWORD PTR _hyperlinkStep$1$[ebp], 1
  01007	75 29		 jne	 SHORT $LN109@Update

; 494  : 							{
; 495  : 								++hyperlinkStep;
; 496  : 								kHyperlink.ex = kHyperlink.sx = x;

  01009	8b bd 44 fa ff
	ff		 mov	 edi, DWORD PTR _x$1$[ebp]
  0100f	c7 85 58 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 2
  01019	66 89 bd 70 fa
	ff ff		 mov	 WORD PTR _kHyperlink$13[ebp], di
  01020	89 bd 48 fa ff
	ff		 mov	 DWORD PTR tv4327[ebp], edi
  01026	66 89 bd 72 fa
	ff ff		 mov	 WORD PTR _kHyperlink$13[ebp+2], di

; 497  : 							}

  0102d	e9 f3 04 00 00	 jmp	 $LN100@Update
$LN109@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  01032	83 bd b8 fa ff
	ff 07		 cmp	 DWORD PTR _hyperlinkBuffer$15[ebp+20], 7

; 425  :         const value_type* _Result = _Bx._Buf;

  01039	8d 8d a4 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$15[ebp]

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0103f	8b bd b4 fa ff
	ff		 mov	 edi, DWORD PTR _hyperlinkBuffer$15[ebp+16]

; 426  :         if (_Large_mode_engaged()) {

  01045	0f 47 8d a4 fa
	ff ff		 cmova	 ecx, DWORD PTR _hyperlinkBuffer$15[ebp]

; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  0104c	8b 95 50 fa ff
	ff		 mov	 edx, DWORD PTR __Old_capacity$1$[ebp]

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  01052	89 bd 64 fa ff
	ff		 mov	 DWORD PTR $T12[ebp], edi

; 426  :         if (_Large_mode_engaged()) {

  01058	89 8d 38 fa ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], ecx

; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  0105e	3b fa		 cmp	 edi, edx
  01060	77 2f		 ja	 SHORT $LN873@Update

; 1595 :             _ASAN_STRING_REMOVE(*this);
; 1596 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 1597 :             _Mypair._Myval2._Mysize = _Count;

  01062	8d 04 3f	 lea	 eax, DWORD PTR [edi+edi]
  01065	89 bd 84 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$13[ebp+20], edi

; 434  :         return _Myres > _Small_string_capacity;

  0106b	83 fa 07	 cmp	 edx, 7

; 416  :         value_type* _Result = _Bx._Buf;

  0106e	8d b5 74 fa ff
	ff		 lea	 esi, DWORD PTR _kHyperlink$13[ebp+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  01074	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 417  :         if (_Large_mode_engaged()) {

  01075	0f 47 b5 74 fa
	ff ff		 cmova	 esi, DWORD PTR _kHyperlink$13[ebp+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0107c	51		 push	 ecx
  0107d	56		 push	 esi
  0107e	e8 00 00 00 00	 call	 _memmove
  01083	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  01086	33 c0		 xor	 eax, eax
  01088	66 89 04 7e	 mov	 WORD PTR [esi+edi*2], ax

; 1600 :             _ASAN_STRING_CREATE(*this);
; 1601 :             return *this;

  0108c	e9 dc 00 00 00	 jmp	 $LN888@Update
$LN873@Update:

; 2962 :         if (_New_size > max_size()) {

  01091	81 ff fe ff ff
	7f		 cmp	 edi, 2147483646		; 7ffffffeH
  01097	0f 87 1f 06 00
	00		 ja	 $LN1016@Update

; 2963 :             _Xlen_string(); // result too long
; 2964 :         }
; 2965 : 
; 2966 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0109d	8b f7		 mov	 esi, edi
  0109f	83 ce 07	 or	 esi, 7

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  010a2	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  010a8	77 2d		 ja	 SHORT $LN1116@Update

; 2944 :             return _Max;
; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  010aa	8b ca		 mov	 ecx, edx
  010ac	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  010b1	d1 e9		 shr	 ecx, 1
  010b3	2b c1		 sub	 eax, ecx
  010b5	3b d0		 cmp	 edx, eax
  010b7	77 1e		 ja	 SHORT $LN1116@Update

; 2948 :             return _Max;
; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  010b9	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  010bc	3b f0		 cmp	 esi, eax
  010be	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  010c1	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  010c4	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  010c9	0f 87 e8 05 00
	00		 ja	 $LN1017@Update

; 118  :             _Throw_bad_array_new_length(); // multiply overflow
; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  010cf	03 c0		 add	 eax, eax

; 227  :     if (_Bytes == 0) {

  010d1	75 10		 jne	 SHORT $LN912@Update

; 228  :         return nullptr;

  010d3	33 ff		 xor	 edi, edi
  010d5	eb 25		 jmp	 SHORT $LN911@Update
$LN1116@Update:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  010d7	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  010dc	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  010e1	03 c0		 add	 eax, eax
$LN912@Update:
  010e3	50		 push	 eax
  010e4	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  010e9	72 07		 jb	 SHORT $LN913@Update

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  010eb	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  010f0	eb 05		 jmp	 SHORT $LN1117@Update
$LN913@Update:

; 136  :         return ::operator new(_Bytes);

  010f2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN1117@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  010f7	8b f8		 mov	 edi, eax
  010f9	83 c4 04	 add	 esp, 4
$LN911@Update:
  010fc	8b 85 64 fa ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  01102	89 b5 88 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$13[ebp+24], esi
  01108	89 85 84 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$13[ebp+20], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0110e	8d 34 00	 lea	 esi, DWORD PTR [eax+eax]
  01111	56		 push	 esi
  01112	ff b5 38 fa ff
	ff		 push	 DWORD PTR __Result$2$[ebp]
  01118	57		 push	 edi
  01119	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  0111e	8b 8d 50 fa ff
	ff		 mov	 ecx, DWORD PTR __Old_capacity$1$[ebp]

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  01124	33 c0		 xor	 eax, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  01126	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  01129	66 89 04 3e	 mov	 WORD PTR [esi+edi], ax

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  0112d	83 f9 07	 cmp	 ecx, 7
  01130	76 35		 jbe	 SHORT $LN887@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01132	8b 95 74 fa ff
	ff		 mov	 edx, DWORD PTR _kHyperlink$13[ebp+4]
  01138	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  0113f	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  01141	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  01147	72 14		 jb	 SHORT $LN944@Update

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  01149	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0114c	83 c1 23	 add	 ecx, 35			; 00000023H
  0114f	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01151	83 c0 fc	 add	 eax, -4			; fffffffcH
  01154	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01157	0f 87 64 05 00
	00		 ja	 $LN167@Update
$LN944@Update:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0115d	51		 push	 ecx
  0115e	52		 push	 edx
  0115f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01164	83 c4 08	 add	 esp, 8
$LN887@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  01167	89 bd 74 fa ff
	ff		 mov	 DWORD PTR _kHyperlink$13[ebp+4], edi
$LN888@Update:
  0116d	8b b5 60 fa ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  01173	8d 8d 70 fa ff
	ff		 lea	 ecx, DWORD PTR _kHyperlink$13[ebp]
  01179	83 c6 64	 add	 esi, 100		; 00000064H
  0117c	51		 push	 ecx
  0117d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  01180	50		 push	 eax
  01181	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  01184	74 0f		 je	 SHORT $LN953@Update

; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  01186	56		 push	 esi
  01187	e8 00 00 00 00	 call	 ??$construct@USHyperlink@CGraphicTextInstance@@ABU12@@?$_Default_allocator_traits@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@SAXAAV?$allocator@USHyperlink@CGraphicTextInstance@@@1@QAUSHyperlink@CGraphicTextInstance@@ABU34@@Z ; std::_Default_allocator_traits<std::allocator<CGraphicTextInstance::SHyperlink> >::construct<CGraphicTextInstance::SHyperlink,CGraphicTextInstance::SHyperlink const &>
  0118c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  0118f	83 46 04 1c	 add	 DWORD PTR [esi+4], 28	; 0000001cH

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  01193	eb 07		 jmp	 SHORT $LN952@Update
$LN953@Update:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  01195	8b ce		 mov	 ecx, esi
  01197	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSHyperlink@CGraphicTextInstance@@@?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@AAEPAUSHyperlink@CGraphicTextInstance@@QAU23@ABU23@@Z ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::_Emplace_reallocate<CGraphicTextInstance::SHyperlink const &>
$LN952@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0119c	6a 00		 push	 0
  0119e	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  011a3	8d 8d a4 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$15[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 503  : 								hyperlinkStep = 0;

  011a9	c7 85 58 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _hyperlinkStep$1$[ebp], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  011b3	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 506  : 						}

  011b8	66 8b bd 72 fa
	ff ff		 mov	 di, WORD PTR _kHyperlink$13[ebp+2]
  011bf	8b 85 88 fa ff
	ff		 mov	 eax, DWORD PTR _kHyperlink$13[ebp+24]
  011c5	8b b5 68 fa ff
	ff		 mov	 esi, DWORD PTR _dwColor$1$[ebp]
  011cb	89 85 50 fa ff
	ff		 mov	 DWORD PTR __Old_capacity$1$[ebp], eax
  011d1	89 bd 48 fa ff
	ff		 mov	 DWORD PTR tv4327[ebp], edi
  011d7	e9 49 03 00 00	 jmp	 $LN100@Update
$LN107@Update:

; 507  : #ifdef ENABLE_EMOJI_SYSTEM
; 508  : 						else if (ret == TEXT_TAG_EMOJI_START)

  011dc	83 f8 06	 cmp	 eax, 6
  011df	75 21		 jne	 SHORT $LN111@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  011e1	6a 00		 push	 0
  011e3	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  011e8	8d 8d 8c fa ff
	ff		 lea	 ecx, DWORD PTR _emojiBuffer$14[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 510  : 							emojiStep = 1;

  011ee	c7 85 5c fa ff
	ff 01 00 00 00	 mov	 DWORD PTR _emojiStep$1$[ebp], 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  011f8	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 512  : 						}

  011fd	e9 23 03 00 00	 jmp	 $LN100@Update
$LN111@Update:

; 513  : 
; 514  : 						else if (ret == TEXT_TAG_EMOJI_END)

  01202	83 f8 07	 cmp	 eax, 7
  01205	0f 85 1a 03 00
	00		 jne	 $LN100@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0120b	83 bd a0 fa ff
	ff 07		 cmp	 DWORD PTR _emojiBuffer$14[ebp+20], 7

; 425  :         const value_type* _Result = _Bx._Buf;

  01212	8d bd 8c fa ff
	ff		 lea	 edi, DWORD PTR _emojiBuffer$14[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 516  : 							kEmoji.x = x;

  01218	8b 85 44 fa ff
	ff		 mov	 eax, DWORD PTR _x$1$[ebp]

; 517  : 
; 518  : 							char retBuf[1024];
; 519  : 							int retLen = Ymir_WideCharToMultiByte(GetDefaultCodePage(), 0, emojiBuffer.c_str(), emojiBuffer.length(), retBuf, sizeof(retBuf) - 1, NULL, NULL);

  0121e	8b b5 9c fa ff
	ff		 mov	 esi, DWORD PTR _emojiBuffer$14[ebp+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  01224	0f 47 bd 8c fa
	ff ff		 cmova	 edi, DWORD PTR _emojiBuffer$14[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 516  : 							kEmoji.x = x;

  0122b	66 89 85 1c fa
	ff ff		 mov	 WORD PTR _kEmoji$7[ebp], ax

; 517  : 
; 518  : 							char retBuf[1024];
; 519  : 							int retLen = Ymir_WideCharToMultiByte(GetDefaultCodePage(), 0, emojiBuffer.c_str(), emojiBuffer.length(), retBuf, sizeof(retBuf) - 1, NULL, NULL);

  01232	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
  01237	6a 00		 push	 0
  01239	6a 00		 push	 0
  0123b	68 ff 03 00 00	 push	 1023			; 000003ffH
  01240	8d 8d f0 fa ff
	ff		 lea	 ecx, DWORD PTR _retBuf$18[ebp]
  01246	51		 push	 ecx
  01247	56		 push	 esi
  01248	57		 push	 edi
  01249	6a 00		 push	 0
  0124b	50		 push	 eax
  0124c	e8 00 00 00 00	 call	 ?Ymir_WideCharToMultiByte@@YAHIKPB_WHPADHPBDPAH@Z ; Ymir_WideCharToMultiByte
  01251	83 c4 20	 add	 esp, 32			; 00000020H

; 520  : 							retBuf[retLen] = '\0';

  01254	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  01259	0f 83 53 04 00
	00		 jae	 $LN121@Update

; 521  : 
; 522  : 							char szPath[255]{};

  0125f	68 ff 00 00 00	 push	 255			; 000000ffH
  01264	c6 84 05 f0 fa
	ff ff 00	 mov	 BYTE PTR _retBuf$18[ebp+eax], 0
  0126c	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szPath$19[ebp]
  01272	6a 00		 push	 0
  01274	50		 push	 eax
  01275	e8 00 00 00 00	 call	 _memset
  0127a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 523  : 							static const char * pathList[] = {"icon/%s.tga", "icon/emoji/%s.png", "%s"};
; 524  : 							for (auto & pathElem : pathList)

  0127d	be 00 00 00 00	 mov	 esi, OFFSET ?pathList@?KJ@??Update@CGraphicTextInstance@@QAEXXZ@4PAPBDA
$LL36@Update:

; 525  : 							{
; 526  : 								snprintf(szPath, sizeof(szPath), pathElem, retBuf);

  01282	8d 85 f0 fa ff
	ff		 lea	 eax, DWORD PTR _retBuf$18[ebp]
  01288	50		 push	 eax
  01289	ff 36		 push	 DWORD PTR [esi]
  0128b	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szPath$19[ebp]
  01291	68 ff 00 00 00	 push	 255			; 000000ffH
  01296	50		 push	 eax
  01297	e8 00 00 00 00	 call	 _snprintf

; 527  : 								// TraceError("trying to load %s", szPath);
; 528  : 
; 529  : 								if (CResourceManager::Instance().IsFileExist(szPath))

  0129c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  012a2	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szPath$19[ebp]
  012a8	83 c4 10	 add	 esp, 16			; 00000010H
  012ab	50		 push	 eax
  012ac	e8 00 00 00 00	 call	 ?IsFileExist@CResourceManager@@QAE_NPBD@Z ; CResourceManager::IsFileExist
  012b1	84 c0		 test	 al, al
  012b3	75 32		 jne	 SHORT $LN1018@Update

; 523  : 							static const char * pathList[] = {"icon/%s.tga", "icon/emoji/%s.png", "%s"};
; 524  : 							for (auto & pathElem : pathList)

  012b5	83 c6 04	 add	 esi, 4
  012b8	81 fe 0c 00 00
	00		 cmp	 esi, OFFSET ?pathList@?KJ@??Update@CGraphicTextInstance@@QAEXXZ@4PAPBDA+12
  012be	75 c2		 jne	 SHORT $LL36@Update
$LN1097@Update:

; 546  : 							emojiStep = 0;

  012c0	8b b5 68 fa ff
	ff		 mov	 esi, DWORD PTR _dwColor$1$[ebp]
$LN115@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  012c6	6a 00		 push	 0
  012c8	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  012cd	8d 8d 8c fa ff
	ff		 lea	 ecx, DWORD PTR _emojiBuffer$14[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 546  : 							emojiStep = 0;

  012d3	c7 85 5c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _emojiStep$1$[ebp], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  012dd	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  012e2	e9 3e 02 00 00	 jmp	 $LN100@Update
$LN1018@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 531  : 									CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(szPath);

  012e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  012ed	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _szPath$19[ebp]
  012f3	50		 push	 eax
  012f4	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  012f9	8b f8		 mov	 edi, eax
  012fb	89 bd 38 fa ff
	ff		 mov	 DWORD PTR _pImage$1$[ebp], edi

; 532  : 									kEmoji.pInstance = CGraphicImageInstance::New();

  01301	e8 00 00 00 00	 call	 ?New@CGraphicImageInstance@@SAPAV1@XZ ; CGraphicImageInstance::New
  01306	8b f0		 mov	 esi, eax

; 533  : 									kEmoji.pInstance->SetImagePointer(pImage);

  01308	57		 push	 edi
  01309	8b ce		 mov	 ecx, esi
  0130b	89 b5 20 fa ff
	ff		 mov	 DWORD PTR _kEmoji$7[ebp+4], esi
  01311	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  01316	8b 95 18 fa ff
	ff		 mov	 edx, DWORD PTR __My_data$1$[ebp]
  0131c	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0131f	3b 4a 08	 cmp	 ecx, DWORD PTR [edx+8]
  01322	74 11		 je	 SHORT $LN976@Update

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  01324	8b 85 1c fa ff
	ff		 mov	 eax, DWORD PTR _kEmoji$7[ebp]
  0132a	89 01		 mov	 DWORD PTR [ecx], eax
  0132c	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  0132f	83 42 04 08	 add	 DWORD PTR [edx+4], 8

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  01333	eb 0f		 jmp	 SHORT $LN975@Update
$LN976@Update:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  01335	8d 85 1c fa ff
	ff		 lea	 eax, DWORD PTR _kEmoji$7[ebp]
  0133b	50		 push	 eax
  0133c	51		 push	 ecx
  0133d	8b ca		 mov	 ecx, edx
  0133f	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSEmoji@CGraphicTextInstance@@@?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@AAEPAUSEmoji@CGraphicTextInstance@@QAU23@ABU23@@Z ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::_Emplace_reallocate<CGraphicTextInstance::SEmoji const &>
$LN975@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 538  : 									for (int i = 0; i < pImage->GetWidth() / (pSpaceInfo->width-1); ++i)

  01344	8b 85 2c fa ff
	ff		 mov	 eax, DWORD PTR _pSpaceInfo$1$[ebp]
  0134a	33 c9		 xor	 ecx, ecx
  0134c	0f 57 c0	 xorps	 xmm0, xmm0
  0134f	89 8d 5c fa ff
	ff		 mov	 DWORD PTR _i$1$[ebp], ecx
  01355	8b cf		 mov	 ecx, edi
  01357	66 0f 13 85 1c
	fa ff ff	 movlpd	 QWORD PTR _kEmoji$7[ebp], xmm0
  0135f	0f bf 70 02	 movsx	 esi, WORD PTR [eax+2]
  01363	4e		 dec	 esi
  01364	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImage@@QBEHXZ ; CGraphicImage::GetWidth
  01369	99		 cdq
  0136a	f7 fe		 idiv	 esi
  0136c	85 c0		 test	 eax, eax
  0136e	7e 63		 jle	 SHORT $LN1062@Update
  01370	8b 85 40 fa ff
	ff		 mov	 eax, DWORD PTR _dataCodePage$1$[ebp]
  01376	8b bd 68 fa ff
	ff		 mov	 edi, DWORD PTR _dwColor$1$[ebp]
  0137c	0f b7 c0	 movzx	 eax, ax
  0137f	89 85 64 fa ff
	ff		 mov	 DWORD PTR tv4439[ebp], eax
$LL39@Update:

; 539  : 										x += __DrawCharacter(pFontTexture, dataCodePage, ' ', dwColor);

  01385	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  0138b	57		 push	 edi
  0138c	6a 20		 push	 32			; 00000020H
  0138e	50		 push	 eax
  0138f	ff b5 3c fa ff
	ff		 push	 DWORD PTR _pFontTexture$1$[ebp]
  01395	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
  0139a	01 85 44 fa ff
	ff		 add	 DWORD PTR _x$1$[ebp], eax
  013a0	8b 85 2c fa ff
	ff		 mov	 eax, DWORD PTR _pSpaceInfo$1$[ebp]
  013a6	8b 8d 38 fa ff
	ff		 mov	 ecx, DWORD PTR _pImage$1$[ebp]
  013ac	ff 85 5c fa ff
	ff		 inc	 DWORD PTR _i$1$[ebp]
  013b2	0f bf 70 02	 movsx	 esi, WORD PTR [eax+2]
  013b6	4e		 dec	 esi
  013b7	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImage@@QBEHXZ ; CGraphicImage::GetWidth
  013bc	99		 cdq
  013bd	f7 fe		 idiv	 esi
  013bf	39 85 5c fa ff
	ff		 cmp	 DWORD PTR _i$1$[ebp], eax
  013c5	8b 85 64 fa ff
	ff		 mov	 eax, DWORD PTR tv4439[ebp]
  013cb	7c b8		 jl	 SHORT $LL39@Update
  013cd	8b bd 38 fa ff
	ff		 mov	 edi, DWORD PTR _pImage$1$[ebp]
$LN1062@Update:

; 540  : 									if (pImage->GetWidth() % (pSpaceInfo->width - 1) > 1)

  013d3	8b 85 2c fa ff
	ff		 mov	 eax, DWORD PTR _pSpaceInfo$1$[ebp]
  013d9	8b cf		 mov	 ecx, edi
  013db	0f bf 70 02	 movsx	 esi, WORD PTR [eax+2]
  013df	4e		 dec	 esi
  013e0	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImage@@QBEHXZ ; CGraphicImage::GetWidth
  013e5	99		 cdq
  013e6	f7 fe		 idiv	 esi
  013e8	83 fa 01	 cmp	 edx, 1
  013eb	0f 8e cf fe ff
	ff		 jle	 $LN1097@Update

; 541  : 										x += __DrawCharacter(pFontTexture, dataCodePage, ' ', dwColor);

  013f1	8b b5 68 fa ff
	ff		 mov	 esi, DWORD PTR _dwColor$1$[ebp]
  013f7	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  013fd	56		 push	 esi
  013fe	6a 20		 push	 32			; 00000020H
  01400	ff b5 40 fa ff
	ff		 push	 DWORD PTR _dataCodePage$1$[ebp]
  01406	ff b5 3c fa ff
	ff		 push	 DWORD PTR _pFontTexture$1$[ebp]
  0140c	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter
  01411	01 85 44 fa ff
	ff		 add	 DWORD PTR _x$1$[ebp], eax
  01417	e9 aa fe ff ff	 jmp	 $LN115@Update
$LN96@Update:

; 466  : 					{
; 467  : 						if (hyperlinkStep == 1)

  0141c	83 bd 58 fa ff
	ff 01		 cmp	 DWORD PTR _hyperlinkStep$1$[ebp], 1
  01423	75 63		 jne	 SHORT $LN97@Update

; 468  : 							hyperlinkBuffer.append(1, wText[i]);

  01425	0f b7 17	 movzx	 edx, WORD PTR [edi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1515 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  01428	8b bd b8 fa ff
	ff		 mov	 edi, DWORD PTR _hyperlinkBuffer$15[ebp+20]
  0142e	8b c7		 mov	 eax, edi
  01430	8b 8d b4 fa ff
	ff		 mov	 ecx, DWORD PTR _hyperlinkBuffer$15[ebp+16]
  01436	2b c1		 sub	 eax, ecx

; 1516 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  01438	83 f8 01	 cmp	 eax, 1
  0143b	72 29		 jb	 SHORT $LN399@Update

; 1517 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1518 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0143d	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 434  :         return _Myres > _Small_string_capacity;

  01440	83 ff 07	 cmp	 edi, 7

; 1518 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  01443	89 85 b4 fa ff
	ff		 mov	 DWORD PTR _hyperlinkBuffer$15[ebp+16], eax

; 416  :         value_type* _Result = _Bx._Buf;

  01449	8d 85 a4 fa ff
	ff		 lea	 eax, DWORD PTR _hyperlinkBuffer$15[ebp]

; 417  :         if (_Large_mode_engaged()) {

  0144f	0f 47 85 a4 fa
	ff ff		 cmova	 eax, DWORD PTR _hyperlinkBuffer$15[ebp]
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 513  :             *_Su = _C;

  01456	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1521 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0145a	33 d2		 xor	 edx, edx
  0145c	66 89 54 48 02	 mov	 WORD PTR [eax+ecx*2+2], dx

; 1522 :             return *this;

  01461	e9 bf 00 00 00	 jmp	 $LN100@Update
$LN399@Update:

; 1523 :         }
; 1524 : 
; 1525 :         return _Reallocate_grow_by(

  01466	52		 push	 edx
  01467	6a 01		 push	 1
  01469	c6 85 04 fa ff
	ff 00		 mov	 BYTE PTR $T4[ebp], 0
  01470	8d 8d a4 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$15[ebp]
  01476	ff b5 04 fa ff
	ff		 push	 DWORD PTR $T4[ebp]
  0147c	6a 01		 push	 1
  0147e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 468  : 							hyperlinkBuffer.append(1, wText[i]);

  01483	e9 9d 00 00 00	 jmp	 $LN100@Update
$LN97@Update:

; 469  : #ifdef ENABLE_EMOJI_SYSTEM
; 470  : 						else if (emojiStep == 1)

  01488	83 bd 5c fa ff
	ff 01		 cmp	 DWORD PTR _emojiStep$1$[ebp], 1
  0148f	0f b7 07	 movzx	 eax, WORD PTR [edi]
  01492	75 5c		 jne	 SHORT $LN99@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1515 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  01494	8b bd a0 fa ff
	ff		 mov	 edi, DWORD PTR _emojiBuffer$14[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 471  : 							emojiBuffer.append(1, wText[i]);

  0149a	8b d0		 mov	 edx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1515 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0149c	8b 8d 9c fa ff
	ff		 mov	 ecx, DWORD PTR _emojiBuffer$14[ebp+16]
  014a2	8b c7		 mov	 eax, edi
  014a4	2b c1		 sub	 eax, ecx

; 1516 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  014a6	83 f8 01	 cmp	 eax, 1
  014a9	72 26		 jb	 SHORT $LN545@Update

; 1517 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1518 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  014ab	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 434  :         return _Myres > _Small_string_capacity;

  014ae	83 ff 07	 cmp	 edi, 7

; 1518 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  014b1	89 85 9c fa ff
	ff		 mov	 DWORD PTR _emojiBuffer$14[ebp+16], eax

; 416  :         value_type* _Result = _Bx._Buf;

  014b7	8d 85 8c fa ff
	ff		 lea	 eax, DWORD PTR _emojiBuffer$14[ebp]

; 417  :         if (_Large_mode_engaged()) {

  014bd	0f 47 85 8c fa
	ff ff		 cmova	 eax, DWORD PTR _emojiBuffer$14[ebp]
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\wchar.h

; 513  :             *_Su = _C;

  014c4	66 89 14 48	 mov	 WORD PTR [eax+ecx*2], dx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1521 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  014c8	33 d2		 xor	 edx, edx
  014ca	66 89 54 48 02	 mov	 WORD PTR [eax+ecx*2+2], dx

; 1522 :             return *this;

  014cf	eb 54		 jmp	 SHORT $LN100@Update
$LN545@Update:

; 1523 :         }
; 1524 : 
; 1525 :         return _Reallocate_grow_by(

  014d1	52		 push	 edx
  014d2	6a 01		 push	 1
  014d4	c6 85 00 fa ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
  014db	8d 8d 8c fa ff
	ff		 lea	 ecx, DWORD PTR _emojiBuffer$14[ebp]
  014e1	ff b5 00 fa ff
	ff		 push	 DWORD PTR $T3[ebp]
  014e7	6a 01		 push	 1
  014e9	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 471  : 							emojiBuffer.append(1, wText[i]);

  014ee	eb 35		 jmp	 SHORT $LN100@Update
$LN99@Update:

; 472  : #endif
; 473  : 						else
; 474  : 						{
; 475  : 							int charWidth = __DrawCharacter(pFontTexture, dataCodePage, wText[i], dwColor);

  014f0	8b 8d 60 fa ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  014f6	56		 push	 esi
  014f7	50		 push	 eax
  014f8	ff b5 40 fa ff
	ff		 push	 DWORD PTR _dataCodePage$1$[ebp]
  014fe	ff b5 3c fa ff
	ff		 push	 DWORD PTR _pFontTexture$1$[ebp]
  01504	e8 00 00 00 00	 call	 ?__DrawCharacter@CGraphicTextInstance@@IAEHPAVCGraphicFontTexture@@G_WK@Z ; CGraphicTextInstance::__DrawCharacter

; 476  : 							kHyperlink.ex += charWidth;

  01509	8b 8d 48 fa ff
	ff		 mov	 ecx, DWORD PTR tv4327[ebp]
  0150f	66 03 c8	 add	 cx, ax

; 477  : 							x += charWidth;

  01512	01 85 44 fa ff
	ff		 add	 DWORD PTR _x$1$[ebp], eax
  01518	89 8d 48 fa ff
	ff		 mov	 DWORD PTR tv4327[ebp], ecx
  0151e	66 89 8d 72 fa
	ff ff		 mov	 WORD PTR _kHyperlink$13[ebp+2], cx
$LN100@Update:

; 547  : 							emojiBuffer = L"";
; 548  : 						}
; 549  : #endif
; 550  : 					}
; 551  : 					i += len;

  01525	8b 85 54 fa ff
	ff		 mov	 eax, DWORD PTR _i$1$[ebp]
  0152b	03 85 fc f9 ff
	ff		 add	 eax, DWORD PTR _len$2[ebp]
  01531	8b 95 4c fa ff
	ff		 mov	 edx, DWORD PTR _wTextLen$1$[ebp]
  01537	89 85 54 fa ff
	ff		 mov	 DWORD PTR _i$1$[ebp], eax
  0153d	3b c2		 cmp	 eax, edx
  0153f	0f 8c ab f9 ff
	ff		 jl	 $LL33@Update
  01545	8b 8d a0 fa ff
	ff		 mov	 ecx, DWORD PTR _emojiBuffer$14[ebp+20]
$LN1090@Update:

; 553  : 			}

  0154b	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0154f	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  01552	76 35		 jbe	 SHORT $LN296@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01554	8b 95 8c fa ff
	ff		 mov	 edx, DWORD PTR _emojiBuffer$14[ebp]
  0155a	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  01561	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  01563	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  01569	72 14		 jb	 SHORT $LN307@Update

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0156b	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0156e	83 c1 23	 add	 ecx, 35			; 00000023H
  01571	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  01573	83 c0 fc	 add	 eax, -4			; fffffffcH
  01576	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  01579	0f 87 42 01 00
	00		 ja	 $LN167@Update
$LN307@Update:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0157f	51		 push	 ecx
  01580	52		 push	 edx
  01581	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  01586	83 c4 08	 add	 esp, 8
$LN296@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  01589	8b 8d b8 fa ff
	ff		 mov	 ecx, DWORD PTR _hyperlinkBuffer$15[ebp+20]

; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0158f	33 c0		 xor	 eax, eax
  01591	c7 85 9c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _emojiBuffer$14[ebp+16], 0
  0159b	c7 85 a0 fa ff
	ff 07 00 00 00	 mov	 DWORD PTR _emojiBuffer$14[ebp+20], 7
  015a5	66 89 85 8c fa
	ff ff		 mov	 WORD PTR _emojiBuffer$14[ebp], ax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 553  : 			}

  015ac	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  015b0	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  015b3	76 35		 jbe	 SHORT $LN259@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  015b5	8b 95 a4 fa ff
	ff		 mov	 edx, DWORD PTR _hyperlinkBuffer$15[ebp]
  015bb	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
  015c2	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  015c4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  015ca	72 14		 jb	 SHORT $LN270@Update

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  015cc	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  015cf	83 c1 23	 add	 ecx, 35			; 00000023H
  015d2	2b c2		 sub	 eax, edx

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  015d4	83 c0 fc	 add	 eax, -4			; fffffffcH
  015d7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  015da	0f 87 e1 00 00
	00		 ja	 $LN167@Update
$LN270@Update:

; 289  :         ::operator delete(_Ptr, _Bytes);

  015e0	51		 push	 ecx
  015e1	52		 push	 edx
  015e2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  015e7	83 c4 08	 add	 esp, 8
$LN259@Update:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  015ea	8b 8d 50 fa ff
	ff		 mov	 ecx, DWORD PTR __Old_capacity$1$[ebp]

; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  015f0	33 c0		 xor	 eax, eax
  015f2	c7 85 b4 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR _hyperlinkBuffer$15[ebp+16], 0
  015fc	c7 85 b8 fa ff
	ff 07 00 00 00	 mov	 DWORD PTR _hyperlinkBuffer$15[ebp+20], 7
  01606	66 89 85 a4 fa
	ff ff		 mov	 WORD PTR _hyperlinkBuffer$15[ebp], ax
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 553  : 			}

  0160d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  01614	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  01617	76 35		 jbe	 SHORT $LN338@Update
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  01619	8b 95 74 fa ff
	ff		 mov	 edx, DWORD PTR _kHyperlink$13[ebp+4]
  0161f	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
$LN1120@Update:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 556  : 		if (token < end)

  01626	8b c2		 mov	 eax, edx
  01628	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0162e	72 14		 jb	 SHORT $LN349@Update
  01630	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  01633	83 c1 23	 add	 ecx, 35			; 00000023H
  01636	2b c2		 sub	 eax, edx
  01638	83 c0 fc	 add	 eax, -4			; fffffffcH
  0163b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0163e	0f 87 7d 00 00
	00		 ja	 $LN167@Update
$LN349@Update:
  01644	51		 push	 ecx
  01645	52		 push	 edx
  01646	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0164b	83 c4 08	 add	 esp, 8
$LN338@Update:
  0164e	8b bd f8 f9 ff
	ff		 mov	 edi, DWORD PTR _token$1$[ebp]
  01654	3b bd 34 fa ff
	ff		 cmp	 edi, DWORD PTR _end$1$[ebp]
  0165a	73 20		 jae	 SHORT $LN1040@Update

; 557  : 		{
; 558  : 			int newCodePage = ReadToken(token);

  0165c	57		 push	 edi
  0165d	e8 00 00 00 00	 call	 ?ReadToken@@YAHPBD@Z	; ReadToken
  01662	89 85 40 fa ff
	ff		 mov	 DWORD PTR _dataCodePage$1$[ebp], eax

; 559  : 			dataCodePage = newCodePage;
; 560  : 			begin = token + 5;

  01668	83 c7 05	 add	 edi, 5
  0166b	8b 85 34 fa ff
	ff		 mov	 eax, DWORD PTR _end$1$[ebp]
  01671	83 c4 04	 add	 esp, 4
  01674	3b f8		 cmp	 edi, eax
  01676	0f 82 ec ea ff
	ff		 jb	 $LL5@Update
$LN1040@Update:

; 561  : 		}
; 562  : 		else
; 563  : 		{
; 564  : 			begin = token;
; 565  : 		}
; 566  : 	}
; 567  : 
; 568  : 	pFontTexture->UpdateTexture();

  0167c	8b 8d 3c fa ff
	ff		 mov	 ecx, DWORD PTR _pFontTexture$1$[ebp]
  01682	e8 00 00 00 00	 call	 ?UpdateTexture@CGraphicFontTexture@@QAE_NXZ ; CGraphicFontTexture::UpdateTexture

; 569  : 
; 570  : 	m_isUpdate = true;

  01687	8b 85 60 fa ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  0168d	c6 40 45 01	 mov	 BYTE PTR [eax+69], 1
$LN1@Update:

; 571  : }

  01691	8d a5 ec f9 ff
	ff		 lea	 esp, DWORD PTR [ebp-1556]
  01697	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0169a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  016a1	59		 pop	 ecx
  016a2	5f		 pop	 edi
  016a3	5e		 pop	 esi
  016a4	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  016a7	33 cd		 xor	 ecx, ebp
  016a9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  016ae	8b e5		 mov	 esp, ebp
  016b0	5d		 pop	 ebp
  016b1	c3		 ret	 0
$LN121@Update:

; 520  : 							retBuf[retLen] = '\0';

  016b2	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN1017@Update:

; 571  : }

  016b7	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN1016@Update:
  016bc	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN167@Update:
  016c1	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1107@Update:
  016c6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$0:
  00000	8d 8d bc fa ff
	ff		 lea	 ecx, DWORD PTR _kHyperlink$16[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$1:
  0000b	8d 8d d8 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$17[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$2:
  00016	8d 8d 70 fa ff
	ff		 lea	 ecx, DWORD PTR _kHyperlink$13[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$3:
  00021	8d 8d a4 fa ff
	ff		 lea	 ecx, DWORD PTR _hyperlinkBuffer$15[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?Update@CGraphicTextInstance@@QAEXXZ$4:
  0002c	8d 8d 8c fa ff
	ff		 lea	 ecx, DWORD PTR _emojiBuffer$14[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00037	cc		 int	 3
  00038	cc		 int	 3
  00039	cc		 int	 3
  0003a	cc		 int	 3
  0003b	cc		 int	 3
__ehhandler$?Update@CGraphicTextInstance@@QAEXXZ:
  0003c	90		 npad	 1
  0003d	90		 npad	 1
  0003e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00042	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00045	8b 8a f8 f9 ff
	ff		 mov	 ecx, DWORD PTR [edx-1544]
  0004b	33 c8		 xor	 ecx, eax
  0004d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00052	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00055	33 c8		 xor	 ecx, eax
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Update@CGraphicTextInstance@@QAEXXZ
  00061	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Update@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::Update
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Destroy@CGraphicTextInstance@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CGraphicTextInstance@@QAEXXZ PROC		; CGraphicTextInstance::Destroy, COMDAT
; _this$ = ecx

; 1381 : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00003	6a 00		 push	 0
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1382 : 	m_stText="";

  0000a	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0000d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00012	8b 47 4c	 mov	 eax, DWORD PTR [edi+76]
  00015	3b 47 50	 cmp	 eax, DWORD PTR [edi+80]
  00018	74 03		 je	 SHORT $LN14@Destroy

; 1807 :         _Mylast = _Myfirst;

  0001a	89 47 50	 mov	 DWORD PTR [edi+80], eax
$LN14@Destroy:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0001d	8b 47 58	 mov	 eax, DWORD PTR [edi+88]
  00020	3b 47 5c	 cmp	 eax, DWORD PTR [edi+92]
  00023	74 03		 je	 SHORT $LN18@Destroy

; 1807 :         _Mylast = _Myfirst;

  00025	89 47 5c	 mov	 DWORD PTR [edi+92], eax
$LN18@Destroy:
  00028	53		 push	 ebx

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00029	8b 5f 68	 mov	 ebx, DWORD PTR [edi+104]
  0002c	56		 push	 esi
  0002d	8b 77 64	 mov	 esi, DWORD PTR [edi+100]
  00030	3b f3		 cmp	 esi, ebx
  00032	74 14		 je	 SHORT $LN22@Destroy
$LL29@Destroy:
  00034	8b ce		 mov	 ecx, esi
  00036	e8 00 00 00 00	 call	 ??1SHyperlink@CGraphicTextInstance@@QAE@XZ
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  0003b	83 c6 1c	 add	 esi, 28			; 0000001cH
  0003e	3b f3		 cmp	 esi, ebx
  00040	75 f2		 jne	 SHORT $LL29@Destroy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1807 :         _Mylast = _Myfirst;

  00042	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  00045	89 47 68	 mov	 DWORD PTR [edi+104], eax
$LN22@Destroy:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1388 : 	for (auto & rEmo : m_emojiVector)

  00048	8b 5f 74	 mov	 ebx, DWORD PTR [edi+116]
  0004b	8b 77 70	 mov	 esi, DWORD PTR [edi+112]
  0004e	3b f3		 cmp	 esi, ebx
  00050	74 17		 je	 SHORT $LN3@Destroy
$LL4@Destroy:

; 1389 : 	{
; 1390 : 		if (rEmo.pInstance)

  00052	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00055	85 c0		 test	 eax, eax
  00057	74 09		 je	 SHORT $LN2@Destroy

; 1391 : 			CGraphicImageInstance::Delete(rEmo.pInstance);

  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ?Delete@CGraphicImageInstance@@SAXPAV1@@Z ; CGraphicImageInstance::Delete
  0005f	83 c4 04	 add	 esp, 4
$LN2@Destroy:

; 1388 : 	for (auto & rEmo : m_emojiVector)

  00062	83 c6 08	 add	 esi, 8
  00065	3b f3		 cmp	 esi, ebx
  00067	75 e9		 jne	 SHORT $LL4@Destroy
$LN3@Destroy:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00069	8b 47 70	 mov	 eax, DWORD PTR [edi+112]
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	3b 47 74	 cmp	 eax, DWORD PTR [edi+116]
  00071	74 03		 je	 SHORT $LN38@Destroy

; 1807 :         _Mylast = _Myfirst;

  00073	89 47 74	 mov	 DWORD PTR [edi+116], eax
$LN38@Destroy:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1397 : 	__GraphicTextInstancesList(this, false);

  00076	6a 00		 push	 0
  00078	57		 push	 edi
  00079	e8 00 00 00 00	 call	 ?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z ; __GraphicTextInstancesList
  0007e	83 c4 08	 add	 esp, 8

; 1398 : #endif
; 1399 : 
; 1400 : 	__Initialize();

  00081	8b cf		 mov	 ecx, edi
  00083	5f		 pop	 edi
  00084	e9 00 00 00 00	 jmp	 ?__Initialize@CGraphicTextInstance@@IAEXXZ ; CGraphicTextInstance::__Initialize
?Destroy@CGraphicTextInstance@@QAEXXZ ENDP		; CGraphicTextInstance::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ??1CGraphicTextInstance@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CGraphicTextInstance@@UAE@XZ PROC			; CGraphicTextInstance::~CGraphicTextInstance, COMDAT
; _this$ = ecx

; 1413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGraphicTextInstance@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CGraphicTextInstance@@6B@

; 1414 : 	Destroy();

  0002c	e8 00 00 00 00	 call	 ?Destroy@CGraphicTextInstance@@QAEXXZ ; CGraphicTextInstance::Destroy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00031	8b 4e 70	 mov	 ecx, DWORD PTR [esi+112]
  00034	85 c9		 test	 ecx, ecx
  00036	74 4c		 je	 SHORT $LN8@CGraphicTe

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00038	8b 46 78	 mov	 eax, DWORD PTR [esi+120]
  0003b	2b c1		 sub	 eax, ecx
  0003d	c1 f8 03	 sar	 eax, 3
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00040	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00047	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  0004d	72 16		 jb	 SHORT $LN27@CGraphicTe

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0004f	8b 79 fc	 mov	 edi, DWORD PTR [ecx-4]
  00052	83 c2 23	 add	 edx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00055	2b cf		 sub	 ecx, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00057	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  0005a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005d	0f 87 3c 01 00
	00		 ja	 $LN125@CGraphicTe

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00063	8b cf		 mov	 ecx, edi
$LN27@CGraphicTe:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00065	52		 push	 edx
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0006c	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00073	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00076	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0

; 2082 :             _Myend   = nullptr;

  0007d	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0
$LN8@CGraphicTe:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1415 : }

  00084	8d 4e 64	 lea	 ecx, DWORD PTR [esi+100]
  00087	e8 00 00 00 00	 call	 ??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::~vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0008c	8b 4e 58	 mov	 ecx, DWORD PTR [esi+88]
  0008f	85 c9		 test	 ecx, ecx
  00091	74 4c		 je	 SHORT $LN37@CGraphicTe

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00093	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00096	2b c1		 sub	 eax, ecx
  00098	c1 f8 02	 sar	 eax, 2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0009b	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000a2	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000a8	72 16		 jb	 SHORT $LN56@CGraphicTe

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000aa	8b 79 fc	 mov	 edi, DWORD PTR [ecx-4]
  000ad	83 c2 23	 add	 edx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000b0	2b cf		 sub	 ecx, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b2	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  000b5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000b8	0f 87 e1 00 00
	00		 ja	 $LN125@CGraphicTe

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000be	8b cf		 mov	 ecx, edi
$LN56@CGraphicTe:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000c0	52		 push	 edx
  000c1	51		 push	 ecx
  000c2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  000c7	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000ce	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000d1	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0

; 2082 :             _Myend   = nullptr;

  000d8	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
$LN37@CGraphicTe:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  000df	8b 4e 4c	 mov	 ecx, DWORD PTR [esi+76]
  000e2	85 c9		 test	 ecx, ecx
  000e4	74 4c		 je	 SHORT $LN65@CGraphicTe

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e6	8b 46 54	 mov	 eax, DWORD PTR [esi+84]
  000e9	2b c1		 sub	 eax, ecx
  000eb	c1 f8 02	 sar	 eax, 2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ee	8d 14 85 00 00
	00 00		 lea	 edx, DWORD PTR [eax*4]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000f5	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  000fb	72 16		 jb	 SHORT $LN84@CGraphicTe

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000fd	8b 79 fc	 mov	 edi, DWORD PTR [ecx-4]
  00100	83 c2 23	 add	 edx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00103	2b cf		 sub	 ecx, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00105	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00108	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0010b	0f 87 8e 00 00
	00		 ja	 $LN125@CGraphicTe

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00111	8b cf		 mov	 ecx, edi
$LN84@CGraphicTe:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00113	52		 push	 edx
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0011a	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00121	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00124	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 2082 :             _Myend   = nullptr;

  0012b	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0
$LN65@CGraphicTe:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h

; 53   : 			if (m_pObject)

  00132	8b 4e 48	 mov	 ecx, DWORD PTR [esi+72]

; 37   : 		{

  00135	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 53   : 			if (m_pObject)

  0013c	85 c9		 test	 ecx, ecx
  0013e	74 0c		 je	 SHORT $LN95@CGraphicTe

; 54   : 			{
; 55   : 				m_pObject->Release();

  00140	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 56   : 				m_pObject = NULL;

  00145	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
$LN95@CGraphicTe:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0014c	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  0014f	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00152	76 28		 jbe	 SHORT $LN117@CGraphicTe
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00154	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00157	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00158	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0015e	72 12		 jb	 SHORT $LN128@CGraphicTe

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00160	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00163	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00166	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00168	83 c0 fc	 add	 eax, -4			; fffffffcH
  0016b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0016e	77 2f		 ja	 SHORT $LN125@CGraphicTe

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00170	8b c2		 mov	 eax, edx
$LN128@CGraphicTe:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00172	51		 push	 ecx
  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00179	83 c4 08	 add	 esp, 8
$LN117@CGraphicTe:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  0017c	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00183	c7 46 34 0f 00
	00 00		 mov	 DWORD PTR [esi+52], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0018a	c6 46 20 00	 mov	 BYTE PTR [esi+32], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1415 : }

  0018e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00191	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00198	59		 pop	 ecx
  00199	5f		 pop	 edi
  0019a	5e		 pop	 esi
  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c3		 ret	 0
$LN125@CGraphicTe:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0019f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN135@CGraphicTe:
  001a4	cc		 int	 3
  001a5	cc		 int	 3
  001a6	cc		 int	 3
  001a7	cc		 int	 3
  001a8	cc		 int	 3
  001a9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CGraphicTextInstance@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGraphicTextInstance@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGraphicTextInstance@@UAE@XZ ENDP			; CGraphicTextInstance::~CGraphicTextInstance
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ??0CGraphicTextInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CGraphicTextInstance@@QAE@XZ PROC			; CGraphicTextInstance::CGraphicTextInstance, COMDAT
; _this$ = ecx

; 1404 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CGraphicTextInstance@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CGraphicTextInstance@@6B@
  0002f	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00032	0f 11 46 20	 movups	 XMMWORD PTR [esi+32], xmm0

; 836  :         _My_data._Mysize = 0;

  00036	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0003d	c7 46 34 0f 00
	00 00		 mov	 DWORD PTR [esi+52], 15	; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00044	c6 46 20 00	 mov	 BYTE PTR [esi+32], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1404 : {

  00048	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\Ref.h

; 20   : 		CRef() : m_pObject(NULL)

  0004f	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00056	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  0005d	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0
  00064	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0
  0006b	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  00072	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  00079	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
  00080	c7 46 64 00 00
	00 00		 mov	 DWORD PTR [esi+100], 0
  00087	c7 46 68 00 00
	00 00		 mov	 DWORD PTR [esi+104], 0
  0008e	c7 46 6c 00 00
	00 00		 mov	 DWORD PTR [esi+108], 0
  00095	c7 46 70 00 00
	00 00		 mov	 DWORD PTR [esi+112], 0
  0009c	c7 46 74 00 00
	00 00		 mov	 DWORD PTR [esi+116], 0
  000a3	c7 46 78 00 00
	00 00		 mov	 DWORD PTR [esi+120], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 1404 : {

  000aa	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 1405 : 	__Initialize();

  000ae	e8 00 00 00 00	 call	 ?__Initialize@CGraphicTextInstance@@IAEXXZ ; CGraphicTextInstance::__Initialize

; 1406 : 
; 1407 : #ifdef ENABLE_DYNAMIC_FONTS
; 1408 : 	__GraphicTextInstancesList(this);

  000b3	6a 01		 push	 1
  000b5	56		 push	 esi
  000b6	e8 00 00 00 00	 call	 ?__GraphicTextInstancesList@@YAXPAVCGraphicTextInstance@@_N@Z ; __GraphicTextInstancesList
  000bb	83 c4 08	 add	 esp, 8

; 1409 : #endif
; 1410 : }

  000be	8b c6		 mov	 eax, esi
  000c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ca	59		 pop	 ecx
  000cb	5e		 pop	 esi
  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 20	 add	 ecx, 32			; 00000020H
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 48	 add	 ecx, 72			; 00000048H
  00011	e9 00 00 00 00	 jmp	 ??1?$CRef@VCGraphicText@@@@QAE@XZ ; CRef<CGraphicText>::~CRef<CGraphicText>
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@PAUSCharacterInfomation@CGraphicFontTexture@@V?$allocator@PAUSCharacterInfomation@CGraphicFontTexture@@@std@@@std@@QAE@XZ ; std::vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >::~vector<CGraphicFontTexture::SCharacterInfomation *,std::allocator<CGraphicFontTexture::SCharacterInfomation *> >
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 58	 add	 ecx, 88			; 00000058H
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$4:
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 64	 add	 ecx, 100		; 00000064H
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@USHyperlink@CGraphicTextInstance@@V?$allocator@USHyperlink@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >::~vector<CGraphicTextInstance::SHyperlink,std::allocator<CGraphicTextInstance::SHyperlink> >
__unwindfunclet$??0CGraphicTextInstance@@QAE@XZ$5:
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 70	 add	 ecx, 112		; 00000070H
  0003d	e9 00 00 00 00	 jmp	 ??1?$vector@USEmoji@CGraphicTextInstance@@V?$allocator@USEmoji@CGraphicTextInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >::~vector<CGraphicTextInstance::SEmoji,std::allocator<CGraphicTextInstance::SEmoji> >
  00042	cc		 int	 3
  00043	cc		 int	 3
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
__ehhandler$??0CGraphicTextInstance@@QAE@XZ:
  00047	90		 npad	 1
  00048	90		 npad	 1
  00049	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00050	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00053	33 c8		 xor	 ecx, eax
  00055	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CGraphicTextInstance@@QAE@XZ
  0005f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CGraphicTextInstance@@QAE@XZ ENDP			; CGraphicTextInstance::CGraphicTextInstance
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Hyperlink_GetText@CGraphicTextInstance@@SAHPADH@Z
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_len$ = 12						; size = 4
?Hyperlink_GetText@CGraphicTextInstance@@SAHPADH@Z PROC	; CGraphicTextInstance::Hyperlink_GetText, COMDAT

; 84   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2458 :         return _Mypair._Myval2._Mysize == 0;

  00003	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16, 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 85   : 	if (gs_hyperlinkText.empty())

  0000a	75 04		 jne	 SHORT $LN2@Hyperlink_

; 86   : 		return 0;

  0000c	33 c0		 xor	 eax, eax

; 91   : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN2@Hyperlink_:

; 87   : 
; 88   : 	int codePage = GetDefaultCodePage();

  00010	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00015	83 3d 14 00 00
	00 07		 cmp	 DWORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+20, 7

; 425  :         const value_type* _Result = _Bx._Buf;

  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 90   : 	return Ymir_WideCharToMultiByte(codePage, 0, gs_hyperlinkText.c_str(), gs_hyperlinkText.length(), buf, len, NULL, NULL);

  00021	6a 00		 push	 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  00023	0f 47 0d 00 00
	00 00		 cmova	 ecx, DWORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 90   : 	return Ymir_WideCharToMultiByte(codePage, 0, gs_hyperlinkText.c_str(), gs_hyperlinkText.length(), buf, len, NULL, NULL);

  0002a	6a 00		 push	 0
  0002c	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  0002f	ff 75 08	 push	 DWORD PTR _buf$[ebp]
  00032	ff 35 10 00 00
	00		 push	 DWORD PTR ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16
  00038	51		 push	 ecx
  00039	6a 00		 push	 0
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ?Ymir_WideCharToMultiByte@@YAHIKPB_WHPADHPBDPAH@Z ; Ymir_WideCharToMultiByte
  00041	83 c4 20	 add	 esp, 32			; 00000020H

; 91   : }

  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?Hyperlink_GetText@CGraphicTextInstance@@SAHPADH@Z ENDP	; CGraphicTextInstance::Hyperlink_GetText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp
;	COMDAT ?Hyperlink_UpdateMousePos@CGraphicTextInstance@@SAXHH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?Hyperlink_UpdateMousePos@CGraphicTextInstance@@SAXHH@Z PROC ; CGraphicTextInstance::Hyperlink_UpdateMousePos, COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 78   : 	gs_mx = x;

  00003	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_hyperlinkText@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A
  0000b	6a 00		 push	 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 78   : 	gs_mx = x;

  0000d	a3 00 00 00 00	 mov	 DWORD PTR ?gs_mx@@3HA, eax

; 79   : 	gs_my = y;

  00012	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00015	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 79   : 	gs_my = y;

  0001a	a3 00 00 00 00	 mov	 DWORD PTR ?gs_my@@3HA, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001f	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpTextInstance.cpp

; 81   : }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
?Hyperlink_UpdateMousePos@CGraphicTextInstance@@SAXHH@Z ENDP ; CGraphicTextInstance::Hyperlink_UpdateMousePos
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0SPDTVertex@@QAE@XZ
_TEXT	SEGMENT
??0SPDTVertex@@QAE@XZ PROC				; SPDTVertex::SPDTVertex, COMDAT
; _this$ = ecx
  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0SPDTVertex@@QAE@XZ ENDP				; SPDTVertex::SPDTVertex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Capacity$ = 12					; size = 4
??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>, COMDAT

; 799  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 800  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 801  :         ++_Capacity; // Take null terminator into consideration

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Capacity$[ebp]
  00007	ff 06		 inc	 DWORD PTR [esi]
  00009	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0000b	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00010	77 2b		 ja	 SHORT $LN25@Allocate_f

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  00012	03 c0		 add	 eax, eax

; 227  :     if (_Bytes == 0) {

  00014	75 05		 jne	 SHORT $LN12@Allocate_f
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 821  :         --_Capacity;

  00016	ff 0e		 dec	 DWORD PTR [esi]

; 823  :     }

  00018	5e		 pop	 esi
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
$LN12@Allocate_f:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0001b	50		 push	 eax
  0001c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00021	72 0d		 jb	 SHORT $LN13@Allocate_f

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00023	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 821  :         --_Capacity;

  00028	83 c4 04	 add	 esp, 4
  0002b	ff 0e		 dec	 DWORD PTR [esi]

; 823  :     }

  0002d	5e		 pop	 esi
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
$LN13@Allocate_f:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 136  :         return ::operator new(_Bytes);

  00030	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 821  :         --_Capacity;

  00035	83 c4 04	 add	 esp, 4
  00038	ff 0e		 dec	 DWORD PTR [esi]

; 823  :     }

  0003a	5e		 pop	 esi
  0003b	5d		 pop	 ebp
  0003c	c3		 ret	 0
$LN25@Allocate_f:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0003d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN22@Allocate_f:
  00042	cc		 int	 3
??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z PROC ; std::_Traits_compare<std::char_traits<char> >, COMDAT

; 591  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 411  :         return __builtin_memcmp(_First1, _First2, _Count);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 591  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Left_size$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility

; 101  :     return _Right < _Left ? _Right : _Left;

  0000a	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 591  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  0000c	56		 push	 esi

; 411  :         return __builtin_memcmp(_First1, _First2, _Count);

  0000d	8b 75 10	 mov	 esi, DWORD PTR __Right$[ebp]

; 591  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00010	57		 push	 edi
  00011	8b 7d 14	 mov	 edi, DWORD PTR __Right_size$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\utility

; 101  :     return _Right < _Left ? _Right : _Left;

  00014	3b fb		 cmp	 edi, ebx
  00016	0f 42 cf	 cmovb	 ecx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 411  :         return __builtin_memcmp(_First1, _First2, _Count);

  00019	83 e9 04	 sub	 ecx, 4
  0001c	72 13		 jb	 SHORT $LN15@Traits_com
  0001e	66 90		 npad	 2
$LL16@Traits_com:
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	3b 06		 cmp	 eax, DWORD PTR [esi]
  00024	75 10		 jne	 SHORT $LN14@Traits_com
  00026	83 c2 04	 add	 edx, 4
  00029	83 c6 04	 add	 esi, 4
  0002c	83 e9 04	 sub	 ecx, 4
  0002f	73 ef		 jae	 SHORT $LL16@Traits_com
$LN15@Traits_com:
  00031	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00034	74 34		 je	 SHORT $LN13@Traits_com
$LN14@Traits_com:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	3a 06		 cmp	 al, BYTE PTR [esi]
  0003a	75 27		 jne	 SHORT $LN17@Traits_com
  0003c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0003f	74 29		 je	 SHORT $LN13@Traits_com
  00041	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00044	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00047	75 1a		 jne	 SHORT $LN17@Traits_com
  00049	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0004c	74 1c		 je	 SHORT $LN13@Traits_com
  0004e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00051	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00054	75 0d		 jne	 SHORT $LN17@Traits_com
  00056	83 f9 ff	 cmp	 ecx, -1
  00059	74 0f		 je	 SHORT $LN13@Traits_com
  0005b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0005e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00061	74 07		 je	 SHORT $LN13@Traits_com
$LN17@Traits_com:
  00063	1b c0		 sbb	 eax, eax
  00065	83 c8 01	 or	 eax, 1
  00068	eb 02		 jmp	 SHORT $LN18@Traits_com
$LN13@Traits_com:
  0006a	33 c0		 xor	 eax, eax
$LN18@Traits_com:

; 592  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 593  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));
; 594  : 
; 595  :     if (_Ans != 0) {

  0006c	85 c0		 test	 eax, eax
  0006e	75 10		 jne	 SHORT $LN1@Traits_com

; 596  :         return _Ans;
; 597  :     }
; 598  : 
; 599  :     if (_Left_size < _Right_size) {

  00070	3b fb		 cmp	 edi, ebx
  00072	76 08		 jbe	 SHORT $LN29@Traits_com

; 604  :         return 1;
; 605  :     }
; 606  : 
; 607  :     return 0;
; 608  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	83 c8 ff	 or	 eax, -1
  00079	5b		 pop	 ebx
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN29@Traits_com:

; 600  :         return -1;
; 601  :     }
; 602  : 
; 603  :     if (_Left_size > _Right_size) {

  0007c	1b c0		 sbb	 eax, eax
  0007e	f7 d8		 neg	 eax
$LN1@Traits_com:

; 604  :         return 1;
; 605  :     }
; 606  : 
; 607  :     return 0;
; 608  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ENDP ; std::_Traits_compare<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Result$1$ = 12					; size = 4
$T2 = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 1592 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1593 :         // assign [_Ptr, _Ptr + _Count)
; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0000f	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 36		 ja	 SHORT $LN2@assign

; 416  :         value_type* _Result = _Bx._Buf;

  00016	89 7d 0c	 mov	 DWORD PTR __Result$1$[ebp], edi
  00019	8b c7		 mov	 eax, edi

; 434  :         return _Myres > _Small_string_capacity;

  0001b	83 f9 07	 cmp	 ecx, 7

; 417  :         if (_Large_mode_engaged()) {

  0001e	76 05		 jbe	 SHORT $LN5@assign

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	89 45 0c	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN5@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00025	8d 34 1b	 lea	 esi, DWORD PTR [ebx+ebx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1597 :             _Mypair._Myval2._Mysize = _Count;

  00028	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0002b	56		 push	 esi
  0002c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 _memmove
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00035	8b 45 0c	 mov	 eax, DWORD PTR __Result$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0003b	33 c9		 xor	 ecx, ecx
  0003d	66 89 0c 06	 mov	 WORD PTR [esi+eax], cx

; 1611 :     }

  00041	8b c7		 mov	 eax, edi
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 08 00	 ret	 8
$LN2@assign:

; 2962 :         if (_New_size > max_size()) {

  0004c	81 fb fe ff ff
	7f		 cmp	 ebx, 2147483646		; 7ffffffeH
  00052	0f 87 c4 00 00
	00		 ja	 $LN95@assign

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00058	8b f3		 mov	 esi, ebx
  0005a	83 ce 07	 or	 esi, 7
  0005d	81 fe fe ff ff
	7f		 cmp	 esi, 2147483646		; 7ffffffeH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00063	77 2b		 ja	 SHORT $LN92@assign

; 2944 :             return _Max;
; 2945 :         }
; 2946 : 
; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00065	8b d1		 mov	 edx, ecx
  00067	b8 fe ff ff 7f	 mov	 eax, 2147483646		; 7ffffffeH
  0006c	d1 ea		 shr	 edx, 1
  0006e	2b c2		 sub	 eax, edx
  00070	3b c8		 cmp	 ecx, eax
  00072	77 1c		 ja	 SHORT $LN92@assign

; 2948 :             return _Max;
; 2949 :         }
; 2950 : 
; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00074	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  00077	3b f0		 cmp	 esi, eax
  00079	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0007c	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0007f	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00084	0f 87 97 00 00
	00		 ja	 $LN96@assign

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0008a	03 c0		 add	 eax, eax

; 227  :     if (_Bytes == 0) {

  0008c	75 0e		 jne	 SHORT $LN41@assign

; 228  :         return nullptr;

  0008e	eb 23		 jmp	 SHORT $LN91@assign
$LN92@assign:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00095	be fe ff ff 7f	 mov	 esi, 2147483646		; 7ffffffeH
  0009a	03 c0		 add	 eax, eax
$LN41@assign:
  0009c	50		 push	 eax
  0009d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000a2	72 07		 jb	 SHORT $LN42@assign

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a4	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a9	eb 05		 jmp	 SHORT $LN93@assign
$LN42@assign:

; 136  :         return ::operator new(_Bytes);

  000ab	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN93@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000b0	83 c4 04	 add	 esp, 4
$LN91@assign:

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  000b3	89 77 14	 mov	 DWORD PTR [edi+20], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b6	8d 34 1b	 lea	 esi, DWORD PTR [ebx+ebx]
  000b9	56		 push	 esi
  000ba	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000bd	89 45 0c	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c0	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000c1	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c4	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000c9	8b 5d 0c	 mov	 ebx, DWORD PTR $T2[ebp]
  000cc	33 c0		 xor	 eax, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ce	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000d1	66 89 04 1e	 mov	 WORD PTR [esi+ebx], ax

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  000d5	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  000d8	83 f8 07	 cmp	 eax, 7
  000db	76 2d		 jbe	 SHORT $LN16@assign
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000dd	8d 0c 45 02 00
	00 00		 lea	 ecx, DWORD PTR [eax*2+2]
  000e4	8b 07		 mov	 eax, DWORD PTR [edi]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000e6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000ec	72 12		 jb	 SHORT $LN73@assign

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000ee	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f1	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f4	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000f6	83 c0 fc	 add	 eax, -4			; fffffffcH
  000f9	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000fc	77 19		 ja	 SHORT $LN70@assign

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000fe	8b c2		 mov	 eax, edx
$LN73@assign:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00100	51		 push	 ecx
  00101	50		 push	 eax
  00102	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00107	83 c4 08	 add	 esp, 8
$LN16@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1604 :         return _Reallocate_for(

  0010a	89 1f		 mov	 DWORD PTR [edi], ebx

; 1611 :     }

  0010c	8b c7		 mov	 eax, edi
  0010e	5f		 pop	 edi
  0010f	5e		 pop	 esi
  00110	5b		 pop	 ebx
  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c2 08 00	 ret	 8
$LN70@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00117	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN95@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2963 :             _Xlen_string(); // result too long

  0011c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN96@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00121	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN89@assign:
  00126	cc		 int	 3
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 07	 cmp	 ecx, 7

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 2d		 jbe	 SHORT $LN19@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 12		 jb	 SHORT $LN30@basic_stri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00022	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	77 21		 ja	 SHORT $LN27@basic_stri

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0002c	8b c2		 mov	 eax, edx
$LN30@basic_stri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0002e	51		 push	 ecx
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
$LN19@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00038	33 c0		 xor	 eax, eax
  0003a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00041	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  00048	66 89 06	 mov	 WORD PTR [esi], ax
  0004b	5e		 pop	 esi

; 1366 :     }

  0004c	c3		 ret	 0
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@basic_stri:
  00052	cc		 int	 3
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
$T2 = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1592 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1593 :         // assign [_Ptr, _Ptr + _Count)
; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 416  :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 434  :         return _Myres > _Small_string_capacity;

  00018	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 417  :         if (_Large_mode_engaged()) {

  0001b	76 02		 jbe	 SHORT $LN5@assign

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1597 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 1609 :             },
; 1610 :             _Ptr);
; 1611 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 2962 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 c7 00 00
	00		 ja	 $LN87@assign

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 12		 jbe	 SHORT $LN23@assign

; 2944 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	eb 45		 jmp	 SHORT $LN85@assign
$LN23@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00069	8b d1		 mov	 edx, ecx
  0006b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00070	d1 ea		 shr	 edx, 1
  00072	2b c2		 sub	 eax, edx
  00074	3b c8		 cmp	 ecx, eax
  00076	76 12		 jbe	 SHORT $LN24@assign

; 2948 :             return _Max;

  00078	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0007d	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00088	eb 24		 jmp	 SHORT $LN85@assign
$LN24@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0008a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0008d	3b f8		 cmp	 edi, eax
  0008f	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  00092	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  00095	85 c0		 test	 eax, eax
  00097	74 18		 je	 SHORT $LN84@assign
$LN37@assign:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00099	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0009e	72 08		 jb	 SHORT $LN38@assign

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a6	eb 06		 jmp	 SHORT $LN85@assign
$LN38@assign:

; 136  :         return ::operator new(_Bytes);

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN85@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000ae	83 c4 04	 add	 esp, 4
$LN84@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b1	53		 push	 ebx
  000b2	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000b5	89 45 0c	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b8	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000b9	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  000bc	89 7e 14	 mov	 DWORD PTR [esi+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bf	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000c4	8b 7d 0c	 mov	 edi, DWORD PTR $T2[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  000ca	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000cd	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  000d1	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000d4	76 29		 jbe	 SHORT $LN16@assign

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000d6	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000db	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000e1	72 12		 jb	 SHORT $LN66@assign

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000e3	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000e6	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000e9	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000eb	83 c0 fc	 add	 eax, -4			; fffffffcH
  000ee	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f1	77 19		 ja	 SHORT $LN63@assign

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000f3	8b c2		 mov	 eax, edx
$LN66@assign:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000f5	51		 push	 ecx
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000fc	83 c4 08	 add	 esp, 8
$LN16@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1604 :         return _Reallocate_for(

  000ff	89 3e		 mov	 DWORD PTR [esi], edi

; 1609 :             },
; 1610 :             _Ptr);
; 1611 :     }

  00101	8b c6		 mov	 eax, esi
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 08 00	 ret	 8
$LN63@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN87@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2963 :             _Xlen_string(); // result too long

  00111	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN82@assign:
  00116	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 27		 jbe	 SHORT $LN19@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN30@basic_stri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN27@basic_stri

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN30@basic_stri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN19@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 1366 :     }

  00044	c3		 ret	 0
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 512  :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_snprintf PROC						; COMDAT

; 1927 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1439 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 02	 or	 ecx, 2
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1440 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1441 :             _Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1442 : 
; 1443 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1928 :         int _Result;
; 1929 :         va_list _ArgList;
; 1930 :         __crt_va_start(_ArgList, _Format);
; 1931 :         _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1932 :         __crt_va_end(_ArgList);
; 1933 :         return _Result;
; 1934 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
