; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\EterLib\Distribute\CollisionData.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CPlaneCollisionInstance>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; CDynamicPool<CAABBCollisionInstance>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CAABBCollisionInstance>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; CDynamicPool<COBBCollisionInstance>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<COBBCollisionInstance>::`scalar deleting destructor'
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; CDynamicPool<CSphereCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8 ; CDynamicPool<CSphereCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8 ; CDynamicPool<CCylinderCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8 ; CDynamicPool<CPlaneCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; CDynamicPool<CAABBCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8 ; CDynamicPool<CAABBCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; CDynamicPool<COBBCollisionInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8 ; CDynamicPool<COBBCollisionInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8	; CDynamicPool<COBBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8	; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8 ; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; CDynamicPool<CSphereCollisionInstance>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CSphereCollisionInstance>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; CDynamicPool<CCylinderCollisionInstance>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z ; CDynamicPool<CCylinderCollisionInstance>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; CDynamicPool<CPlaneCollisionInstance>::`vftable'
EXTRN	??_E?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CPlaneCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CAABBCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<COBBCollisionInstance>::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_E?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CSphereCollisionInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CCylinderCollisionInstance>::`vector deleting destructor'
;	COMDAT ??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; CDynamicPool<CPlaneCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; CDynamicPool<CCylinderCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; CDynamicPool<CSphereCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8 ; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCOBBCollisionInstance@@@@8 ; CDynamicPool<COBBCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8 DD 00H	; CDynamicPool<COBBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<COBBCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCOBBCollisionInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<COBBCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCOBBCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCOBBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCAABBCollisionInstance@@@@8 ; CDynamicPool<CAABBCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8 DD 00H	; CDynamicPool<CAABBCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CAABBCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCAABBCollisionInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CAABBCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCAABBCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCAABBCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCPlaneCollisionInstance@@@@8 ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8 DD 00H ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CPlaneCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CPlaneCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCPlaneCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCPlaneCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCCylinderCollisionInstance@@@@8 ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8 DD 00H ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CCylinderCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CCylinderCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCCylinderCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCCylinderCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCSphereCollisionInstance@@@@8 ; CDynamicPool<CSphereCollisionInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8 DD 00H ; CDynamicPool<CSphereCollisionInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CSphereCollisionInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCSphereCollisionInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ DD 00H ; CDynamicPool<CSphereCollisionInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCSphereCollisionInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCSphereCollisionInstance@@@@8
rdata$r	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; CDynamicPool<COBBCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; CDynamicPool<CAABBCollisionInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0D3DXVECTOR3@@QAE@XZ				; D3DXVECTOR3::D3DXVECTOR3
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?DestroyCollisionInstanceSystem@@YAXXZ		; DestroyCollisionInstanceSystem
PUBLIC	?Destroy@CBaseCollisionInstance@@QAEXXZ		; CBaseCollisionInstance::Destroy
PUBLIC	?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z ; CBaseCollisionInstance::BuildCollisionInstance
PUBLIC	?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute
PUBLIC	?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CSphereCollisionInstance::Render
PUBLIC	?OnDestroy@CSphereCollisionInstance@@MAEXXZ	; CSphereCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CSphereCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CSphereCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CSphereCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ ; CPlaneCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ ; CPlaneCollisionInstance::GetAttribute
PUBLIC	?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CPlaneCollisionInstance::Render
PUBLIC	?OnDestroy@CPlaneCollisionInstance@@MAEXXZ	; CPlaneCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CPlaneCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CPlaneCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CPlaneCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ ; CAABBCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ ; CAABBCollisionInstance::GetAttribute
PUBLIC	?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CAABBCollisionInstance::Render
PUBLIC	?OnDestroy@CAABBCollisionInstance@@MAEXXZ	; CAABBCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CAABBCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CAABBCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CAABBCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ ; COBBCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ ; COBBCollisionInstance::GetAttribute
PUBLIC	?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; COBBCollisionInstance::Render
PUBLIC	?OnDestroy@COBBCollisionInstance@@MAEXXZ	; COBBCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; COBBCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; COBBCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; COBBCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ ; CCylinderCollisionInstance::GetAttribute
PUBLIC	?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ ; CCylinderCollisionInstance::GetAttribute
PUBLIC	?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ; CCylinderCollisionInstance::Render
PUBLIC	?OnDestroy@CCylinderCollisionInstance@@MAEXXZ	; CCylinderCollisionInstance::OnDestroy
PUBLIC	?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::OnMovementCollisionDynamicSphere
PUBLIC	?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::OnCollisionDynamicSphere
PUBLIC	?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::OnGetCollisionMovementAdjust
PUBLIC	?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
PUBLIC	?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z ; square_distance_between_linesegment_and_point
PUBLIC	??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>
PUBLIC	?_Xlength@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlength
PUBLIC	??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>
PUBLIC	?_Xlength@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlength
PUBLIC	??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>
PUBLIC	?_Xlength@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlength
PUBLIC	??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>
PUBLIC	?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ ; CDynamicPool<CAABBCollisionInstance>::Alloc
PUBLIC	?_Xlength@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlength
PUBLIC	??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ ; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>
PUBLIC	?_Xlength@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlength
PUBLIC	??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_reallocate<COBBCollisionInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_reallocate<CAABBCollisionInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_reallocate<CPlaneCollisionInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_reallocate<CCylinderCollisionInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_reallocate<CSphereCollisionInstance * const &>
PUBLIC	??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<COBBCollisionInstance * *,COBBCollisionInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAABBCollisionInstance * *,CAABBCollisionInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CSphereCollisionInstance * *,CSphereCollisionInstance * *>
PUBLIC	??$_Copy_memmove_tail@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<COBBCollisionInstance * *>
PUBLIC	??$_Copy_memmove_tail@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CAABBCollisionInstance * *>
PUBLIC	??$_Copy_memmove_tail@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CPlaneCollisionInstance * *>
PUBLIC	??$_Copy_memmove_tail@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CCylinderCollisionInstance * *>
PUBLIC	??$_Copy_memmove_tail@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CSphereCollisionInstance * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_7CBaseCollisionInstance@@6B@			; CBaseCollisionInstance::`vftable'
PUBLIC	??_7CSphereCollisionInstance@@6B@		; CSphereCollisionInstance::`vftable'
PUBLIC	??_7CPlaneCollisionInstance@@6B@		; CPlaneCollisionInstance::`vftable'
PUBLIC	??_7CAABBCollisionInstance@@6B@			; CAABBCollisionInstance::`vftable'
PUBLIC	??_7COBBCollisionInstance@@6B@			; COBBCollisionInstance::`vftable'
PUBLIC	??_7CCylinderCollisionInstance@@6B@		; CCylinderCollisionInstance::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A ; gs_sci
PUBLIC	?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A ; gs_cci
PUBLIC	?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A ; gs_pci
PUBLIC	?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
PUBLIC	?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A ; gs_oci
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CBaseCollisionInstance@@6B@		; CBaseCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCBaseCollisionInstance@@@8		; CBaseCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CBaseCollisionInstance@@8			; CBaseCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CBaseCollisionInstance@@8			; CBaseCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CBaseCollisionInstance@@8		; CBaseCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CSphereCollisionInstance@@6B@		; CSphereCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSphereCollisionInstance@@@8		; CSphereCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CSphereCollisionInstance@@8		; CSphereCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSphereCollisionInstance@@8		; CSphereCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSphereCollisionInstance@@8	; CSphereCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CPlaneCollisionInstance@@6B@		; CPlaneCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCPlaneCollisionInstance@@@8		; CPlaneCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CPlaneCollisionInstance@@8			; CPlaneCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CPlaneCollisionInstance@@8			; CPlaneCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CPlaneCollisionInstance@@8	; CPlaneCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CAABBCollisionInstance@@6B@		; CAABBCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCAABBCollisionInstance@@@8		; CAABBCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CAABBCollisionInstance@@8			; CAABBCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CAABBCollisionInstance@@8			; CAABBCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CAABBCollisionInstance@@8		; CAABBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4COBBCollisionInstance@@6B@			; COBBCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCOBBCollisionInstance@@@8		; COBBCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3COBBCollisionInstance@@8			; COBBCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2COBBCollisionInstance@@8			; COBBCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@COBBCollisionInstance@@8		; COBBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CCylinderCollisionInstance@@6B@		; CCylinderCollisionInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCylinderCollisionInstance@@@8		; CCylinderCollisionInstance `RTTI Type Descriptor'
PUBLIC	??_R3CCylinderCollisionInstance@@8		; CCylinderCollisionInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCylinderCollisionInstance@@8		; CCylinderCollisionInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCylinderCollisionInstance@@8	; CCylinderCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@38d1b717
PUBLIC	__real@3f000000
PUBLIC	__real@3f1a36e2eb1c432d
PUBLIC	__real@3f800000
PUBLIC	__real@40800000
PUBLIC	__real@bf1a36e2eb1c432d
PUBLIC	__xmm@7fffffffffffffff7fffffffffffffff
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_D3DXVec3Normalize@8:PROC
EXTRN	_D3DXVec3TransformCoord@12:PROC
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixTranslation@16:PROC
EXTRN	_D3DXMatrixRotationQuaternion@8:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??0CScreen@@QAE@XZ:PROC				; CScreen::CScreen
EXTRN	??1CScreen@@UAE@XZ:PROC				; CScreen::~CScreen
EXTRN	?RenderBar3d@CScreen@@QAEXPBUD3DXVECTOR3@@@Z:PROC ; CScreen::RenderBar3d
EXTRN	?RenderCube@CScreen@@QAEXMMMMMM@Z:PROC		; CScreen::RenderCube
EXTRN	?RenderCube@CScreen@@QAEXMMMMMMUD3DXMATRIX@@@Z:PROC ; CScreen::RenderCube
EXTRN	?RenderSphere@CScreen@@QAEXPBUD3DXMATRIX@@MMMMW4_D3DFILLMODE@@@Z:PROC ; CScreen::RenderSphere
EXTRN	?RenderCylinder@CScreen@@QAEXPBUD3DXMATRIX@@MMMMMW4_D3DFILLMODE@@@Z:PROC ; CScreen::RenderCylinder
EXTRN	?IntersectLineSegments@@YAXABUD3DXVECTOR3@@000AAU1@1@Z:PROC ; IntersectLineSegments
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	_memmove:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CSphereCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA DD 01H DUP (?) ; `CSphereCollisionInstance::Render'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CPlaneCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA DD 01H DUP (?) ; `CPlaneCollisionInstance::Render'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CCylinderCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA DD 01H DUP (?) ; `CCylinderCollisionInstance::Render'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `CAABBCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA DD 01H DUP (?) ; `CAABBCollisionInstance::Render'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
_BSS	SEGMENT
?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A DD 01H DUP (?) ; `COBBCollisionInstance::Render'::`2'::s
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA DD 01H DUP (?) ; `COBBCollisionInstance::Render'::`2'::$TSS0
_BSS	ENDS
CRT$XCU	SEGMENT
?gs_sci$initializer$@@3P6AXXZA DD FLAT:??__Egs_sci@@YAXXZ ; gs_sci$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@7fffffffffffffff7fffffffffffffff
CONST	SEGMENT
__xmm@7fffffffffffffff7fffffffffffffff DB 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 07fH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH, 07fH
CONST	ENDS
;	COMDAT __real@bf1a36e2eb1c432d
CONST	SEGMENT
__real@bf1a36e2eb1c432d DQ 0bf1a36e2eb1c432dr	; -0.0001
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f1a36e2eb1c432d
CONST	SEGMENT
__real@3f1a36e2eb1c432d DQ 03f1a36e2eb1c432dr	; 0.0001
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@38d1b717
CONST	SEGMENT
__real@38d1b717 DD 038d1b717r			; 0.0001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CCylinderCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCylinderCollisionInstance@@8 DD FLAT:??_R0?AVCCylinderCollisionInstance@@@8 ; CCylinderCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCylinderCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CCylinderCollisionInstance@@8
rdata$r	SEGMENT
??_R2CCylinderCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CCylinderCollisionInstance@@8 ; CCylinderCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CCylinderCollisionInstance@@8
rdata$r	SEGMENT
??_R3CCylinderCollisionInstance@@8 DD 00H		; CCylinderCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CCylinderCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCylinderCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCCylinderCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CCylinderCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCylinderCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CCylinderCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CCylinderCollisionInstance@@6B@ DD 00H		; CCylinderCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCylinderCollisionInstance@@@8
	DD	FLAT:??_R3CCylinderCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@COBBCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@COBBCollisionInstance@@8 DD FLAT:??_R0?AVCOBBCollisionInstance@@@8 ; COBBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3COBBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2COBBCollisionInstance@@8
rdata$r	SEGMENT
??_R2COBBCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@COBBCollisionInstance@@8 ; COBBCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3COBBCollisionInstance@@8
rdata$r	SEGMENT
??_R3COBBCollisionInstance@@8 DD 00H			; COBBCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2COBBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCOBBCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCOBBCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; COBBCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCOBBCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4COBBCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4COBBCollisionInstance@@6B@ DD 00H			; COBBCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCOBBCollisionInstance@@@8
	DD	FLAT:??_R3COBBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CAABBCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAABBCollisionInstance@@8 DD FLAT:??_R0?AVCAABBCollisionInstance@@@8 ; CAABBCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAABBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CAABBCollisionInstance@@8
rdata$r	SEGMENT
??_R2CAABBCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CAABBCollisionInstance@@8 ; CAABBCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CAABBCollisionInstance@@8
rdata$r	SEGMENT
??_R3CAABBCollisionInstance@@8 DD 00H			; CAABBCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CAABBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAABBCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCAABBCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CAABBCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAABBCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CAABBCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CAABBCollisionInstance@@6B@ DD 00H			; CAABBCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCAABBCollisionInstance@@@8
	DD	FLAT:??_R3CAABBCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CPlaneCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CPlaneCollisionInstance@@8 DD FLAT:??_R0?AVCPlaneCollisionInstance@@@8 ; CPlaneCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CPlaneCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CPlaneCollisionInstance@@8
rdata$r	SEGMENT
??_R2CPlaneCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CPlaneCollisionInstance@@8 ; CPlaneCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CPlaneCollisionInstance@@8
rdata$r	SEGMENT
??_R3CPlaneCollisionInstance@@8 DD 00H			; CPlaneCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CPlaneCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCPlaneCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCPlaneCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CPlaneCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCPlaneCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CPlaneCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CPlaneCollisionInstance@@6B@ DD 00H		; CPlaneCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCPlaneCollisionInstance@@@8
	DD	FLAT:??_R3CPlaneCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CSphereCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSphereCollisionInstance@@8 DD FLAT:??_R0?AVCSphereCollisionInstance@@@8 ; CSphereCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSphereCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CSphereCollisionInstance@@8
rdata$r	SEGMENT
??_R2CSphereCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CSphereCollisionInstance@@8 ; CSphereCollisionInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CSphereCollisionInstance@@8
rdata$r	SEGMENT
??_R3CSphereCollisionInstance@@8 DD 00H			; CSphereCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CSphereCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSphereCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCSphereCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CSphereCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSphereCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CSphereCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CSphereCollisionInstance@@6B@ DD 00H		; CSphereCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSphereCollisionInstance@@@8
	DD	FLAT:??_R3CSphereCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CBaseCollisionInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CBaseCollisionInstance@@8 DD FLAT:??_R0?AVCBaseCollisionInstance@@@8 ; CBaseCollisionInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CBaseCollisionInstance@@8
rdata$r	SEGMENT
??_R2CBaseCollisionInstance@@8 DD FLAT:??_R1A@?0A@EA@CBaseCollisionInstance@@8 ; CBaseCollisionInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CBaseCollisionInstance@@8
rdata$r	SEGMENT
??_R3CBaseCollisionInstance@@8 DD 00H			; CBaseCollisionInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCBaseCollisionInstance@@@8
data$rs	SEGMENT
??_R0?AVCBaseCollisionInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CBaseCollisionInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCBaseCollisionInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CBaseCollisionInstance@@6B@
rdata$r	SEGMENT
??_R4CBaseCollisionInstance@@6B@ DD 00H			; CBaseCollisionInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCBaseCollisionInstance@@@8
	DD	FLAT:??_R3CBaseCollisionInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@ ; gs_sci
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@ ; gs_cci
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@ ; gs_pci
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@ ; gs_aci
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A DD FLAT:??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@ ; gs_oci
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_7CCylinderCollisionInstance@@6B@
CONST	SEGMENT
??_7CCylinderCollisionInstance@@6B@ DD FLAT:??_R4CCylinderCollisionInstance@@6B@ ; CCylinderCollisionInstance::`vftable'
	DD	FLAT:?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CCylinderCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7COBBCollisionInstance@@6B@
CONST	SEGMENT
??_7COBBCollisionInstance@@6B@ DD FLAT:??_R4COBBCollisionInstance@@6B@ ; COBBCollisionInstance::`vftable'
	DD	FLAT:?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@COBBCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CAABBCollisionInstance@@6B@
CONST	SEGMENT
??_7CAABBCollisionInstance@@6B@ DD FLAT:??_R4CAABBCollisionInstance@@6B@ ; CAABBCollisionInstance::`vftable'
	DD	FLAT:?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CAABBCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CPlaneCollisionInstance@@6B@
CONST	SEGMENT
??_7CPlaneCollisionInstance@@6B@ DD FLAT:??_R4CPlaneCollisionInstance@@6B@ ; CPlaneCollisionInstance::`vftable'
	DD	FLAT:?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CPlaneCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CSphereCollisionInstance@@6B@
CONST	SEGMENT
??_7CSphereCollisionInstance@@6B@ DD FLAT:??_R4CSphereCollisionInstance@@6B@ ; CSphereCollisionInstance::`vftable'
	DD	FLAT:?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	FLAT:?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
	DD	FLAT:?OnDestroy@CSphereCollisionInstance@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7CBaseCollisionInstance@@6B@
CONST	SEGMENT
??_7CBaseCollisionInstance@@6B@ DD FLAT:??_R4CBaseCollisionInstance@@6B@ ; CBaseCollisionInstance::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0
__ehfuncinfo$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?gs_cci$initializer$@@3P6AXXZA DD FLAT:??__Egs_cci@@YAXXZ ; gs_cci$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gs_pci$initializer$@@3P6AXXZA DD FLAT:??__Egs_pci@@YAXXZ ; gs_pci$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gs_aci$initializer$@@3P6AXXZA DD FLAT:??__Egs_aci@@YAXXZ ; gs_aci$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gs_oci$initializer$@@3P6AXXZA DD FLAT:??__Egs_oci@@YAXXZ ; gs_oci$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@QBDQAPAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@QBDQAPAV1@II@Z PROC ; std::_Copy_memmove_tail<CSphereCollisionInstance * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@QBDQAPAV1@II@Z ENDP ; std::_Copy_memmove_tail<CSphereCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@QBDQAPAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@QBDQAPAV1@II@Z PROC ; std::_Copy_memmove_tail<CCylinderCollisionInstance * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@QBDQAPAV1@II@Z ENDP ; std::_Copy_memmove_tail<CCylinderCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@QBDQAPAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@QBDQAPAV1@II@Z PROC ; std::_Copy_memmove_tail<CPlaneCollisionInstance * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@QBDQAPAV1@II@Z ENDP ; std::_Copy_memmove_tail<CPlaneCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@QBDQAPAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@QBDQAPAV1@II@Z PROC ; std::_Copy_memmove_tail<CAABBCollisionInstance * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@QBDQAPAV1@II@Z ENDP ; std::_Copy_memmove_tail<CAABBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove_tail@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@QBDQAPAV1@II@Z
_TEXT	SEGMENT
__First_ch$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Byte_count$ = 16					; size = 4
__Object_count$ = 20					; size = 4
??$_Copy_memmove_tail@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@QBDQAPAV1@II@Z PROC ; std::_Copy_memmove_tail<COBBCollisionInstance * *>, COMDAT

; 4763 :     const char* const _First_ch, const _OutCtgIt _Dest, const size_t _Byte_count, const size_t _Object_count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 4764 :     _STL_INTERNAL_CHECK(_Byte_count == _Object_count * sizeof(*_Dest));
; 4765 :     const auto _Dest_ptr = _STD _To_address(_Dest);
; 4766 :     const auto _Dest_ch  = const_cast<char*>(reinterpret_cast<const volatile char*>(_Dest_ptr));
; 4767 :     _CSTD memmove(_Dest_ch, _First_ch, _Byte_count);

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 10	 mov	 edi, DWORD PTR __Byte_count$[ebp]
  0000b	57		 push	 edi
  0000c	ff 75 08	 push	 DWORD PTR __First_ch$[ebp]
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4768 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4769 :         (void) _Object_count;
; 4770 :         // CodeQL [SM02986] This cast is correct: we're bypassing pointer arithmetic for performance.
; 4771 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Byte_count);

  00018	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi

; 4772 :     } else {
; 4773 :         return _Dest + static_cast<_Iter_diff_t<_OutCtgIt>>(_Object_count);
; 4774 :     }
; 4775 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Copy_memmove_tail@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@QBDQAPAV1@II@Z ENDP ; std::_Copy_memmove_tail<COBBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CSphereCollisionInstance * *,CSphereCollisionInstance * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCSphereCollisionInstance@@@std@@YAPAPAVCSphereCollisionInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CSphereCollisionInstance * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CSphereCollisionInstance * *,CSphereCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCCylinderCollisionInstance@@@std@@YAPAPAVCCylinderCollisionInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CCylinderCollisionInstance * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCPlaneCollisionInstance@@@std@@YAPAPAVCPlaneCollisionInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CPlaneCollisionInstance * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CAABBCollisionInstance * *,CAABBCollisionInstance * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCAABBCollisionInstance@@@std@@YAPAPAVCAABBCollisionInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<CAABBCollisionInstance * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CAABBCollisionInstance * *,CAABBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<COBBCollisionInstance * *,COBBCollisionInstance * *>, COMDAT

; 4778 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4779 :     _STL_INTERNAL_CHECK(_First <= _Last);
; 4780 :     const auto _First_ptr    = _STD _To_address(_First);
; 4781 :     const auto _Last_ptr     = _STD _To_address(_Last);
; 4782 :     const auto _Object_count = static_cast<size_t>(_Last_ptr - _First_ptr);

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	8b c1		 mov	 eax, ecx
  0000d	c1 f8 02	 sar	 eax, 2

; 4783 :     const auto _First_ch     = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First_ptr));
; 4784 :     const auto _Last_ch      = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last_ptr));
; 4785 :     const auto _Byte_count   = static_cast<size_t>(_Last_ch - _First_ch);
; 4786 :     return _STD _Copy_memmove_tail(_First_ch, _STD move(_Dest), _Byte_count, _Object_count);

  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ??$_Copy_memmove_tail@PAPAVCOBBCollisionInstance@@@std@@YAPAPAVCOBBCollisionInstance@@QBDQAPAV1@II@Z ; std::_Copy_memmove_tail<COBBCollisionInstance * *>
  0001b	83 c4 10	 add	 esp, 16			; 00000010H

; 4787 : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<COBBCollisionInstance * *,COBBCollisionInstance * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv652 = -8						; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_reallocate<CSphereCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 09 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004a	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv652[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00069	0f 87 c7 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00076	89 45 f8	 mov	 DWORD PTR tv652[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a1	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv650[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	3b d8		 cmp	 ebx, eax
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CSphereCollisionInstance * *,CSphereCollisionInstance * *>
  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCSphereCollisionInstance@@PAPAV1@@std@@YAPAPAVCSphereCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CSphereCollisionInstance * *,CSphereCollisionInstance * *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00116	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00118	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR tv652[ebp]
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_reallocate<CSphereCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv652 = -8						; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_reallocate<CCylinderCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 09 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004a	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv652[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00069	0f 87 c7 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00076	89 45 f8	 mov	 DWORD PTR tv652[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a1	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv650[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	3b d8		 cmp	 ebx, eax
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>
  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCCylinderCollisionInstance@@PAPAV1@@std@@YAPAPAVCCylinderCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CCylinderCollisionInstance * *,CCylinderCollisionInstance * *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00116	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00118	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR tv652[ebp]
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_reallocate<CCylinderCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv652 = -8						; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_reallocate<CPlaneCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 09 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004a	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv652[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00069	0f 87 c7 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00076	89 45 f8	 mov	 DWORD PTR tv652[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a1	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv650[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	3b d8		 cmp	 ebx, eax
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>
  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCPlaneCollisionInstance@@PAPAV1@@std@@YAPAPAVCPlaneCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CPlaneCollisionInstance * *,CPlaneCollisionInstance * *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00116	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00118	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR tv652[ebp]
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_reallocate<CPlaneCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv652 = -8						; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_reallocate<CAABBCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 09 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004a	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv652[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00069	0f 87 c7 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00076	89 45 f8	 mov	 DWORD PTR tv652[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a1	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv650[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	3b d8		 cmp	 ebx, eax
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAABBCollisionInstance * *,CAABBCollisionInstance * *>
  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCAABBCollisionInstance@@PAPAV1@@std@@YAPAPAVCAABBCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAABBCollisionInstance * *,CAABBCollisionInstance * *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00116	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00118	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR tv652[ebp]
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_reallocate<CAABBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv652 = -8						; size = 4
tv650 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_reallocate<COBBCollisionInstance * const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 09 01 00
	00		 je	 $LN123@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 14		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0004a	c7 45 f8 fc ff
	ff ff		 mov	 DWORD PTR tv652[ebp], -4 ; fffffffcH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00057	eb 3d		 jmp	 SHORT $LN121@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00059	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  0005c	8b cf		 mov	 ecx, edi
  0005e	3b c7		 cmp	 eax, edi
  00060	0f 43 c8	 cmovae	 ecx, eax
  00063	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  00069	0f 87 c7 00 00
	00		 ja	 $LN124@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0006f	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00076	89 45 f8	 mov	 DWORD PTR tv652[ebp], eax

; 227  :     if (_Bytes == 0) {

  00079	85 c0		 test	 eax, eax
  0007b	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  0007d	33 ff		 xor	 edi, edi
  0007f	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00081	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00086	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0008e	eb 06		 jmp	 SHORT $LN121@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN121@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00096	8b f8		 mov	 edi, eax
  00098	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  0009b	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0009e	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a1	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000a4	89 4d fc	 mov	 DWORD PTR tv650[ebp], ecx
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
  000ab	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b0	3b d8		 cmp	 ebx, eax
  000b2	75 07		 jne	 SHORT $LN3@Emplace_re

; 894  :         } else { // provide basic guarantee

  000b4	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000b7	8b d7		 mov	 edx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 894  :         } else { // provide basic guarantee

  000b9	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN3@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000bb	57		 push	 edi
  000bc	53		 push	 ebx
  000bd	51		 push	 ecx
  000be	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<COBBCollisionInstance * *,COBBCollisionInstance * *>
  000c3	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000c6	8b cb		 mov	 ecx, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000c8	8b 5d fc	 mov	 ebx, DWORD PTR tv650[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));

  000cb	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000d1	52		 push	 edx
  000d2	50		 push	 eax
  000d3	51		 push	 ecx
  000d4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCOBBCollisionInstance@@PAPAV1@@std@@YAPAPAVCOBBCollisionInstance@@PAPAV1@00@Z ; std::_Copy_memmove<COBBCollisionInstance * *,COBBCollisionInstance * *>

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  000de	85 c0		 test	 eax, eax
  000e0	74 2c		 je	 SHORT $LN72@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e2	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000e5	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e7	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f0	72 12		 jb	 SHORT $LN83@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000f5	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  000fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00100	77 2a		 ja	 SHORT $LN80@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00102	8b c2		 mov	 eax, edx
$LN83@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00104	51		 push	 ecx
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0010b	83 c4 08	 add	 esp, 8
$LN72@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  0010e	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00111	89 3e		 mov	 DWORD PTR [esi], edi
  00113	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  00116	8b c3		 mov	 eax, ebx

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00118	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0011b	8b 4d f8	 mov	 ecx, DWORD PTR tv652[ebp]
  0011e	03 cf		 add	 ecx, edi

; 903  :     }

  00120	5f		 pop	 edi

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  00121	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  00124	5e		 pop	 esi
  00125	5b		 pop	 ebx
  00126	8b e5		 mov	 esp, ebp
  00128	5d		 pop	 ebp
  00129	c2 08 00	 ret	 8
$LN80@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0012c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN123@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  00131	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@CAXXZ ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlength
$LN124@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00136	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN120@Emplace_re:
  0013b	cc		 int	 3
??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_reallocate<COBBCollisionInstance * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `COBBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00005	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `COBBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CAABBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00005	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CAABBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CCylinderCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00005	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CCylinderCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CPlaneCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00005	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CPlaneCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ
text$yd	SEGMENT
??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ PROC ; `CSphereCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00005	e9 00 00 00 00	 jmp	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ENDP ; `CSphereCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
text$yd	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fgs_oci@@YAXXZ
text$yd	SEGMENT
??__Fgs_oci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_oci'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A ; gs_oci
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ ; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>
??__Fgs_oci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_oci''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ??__Egs_oci@@YAXXZ
text$di	SEGMENT
??__Egs_oci@@YAXXZ PROC					; `dynamic initializer for 'gs_oci'', COMDAT

; 22   : CDynamicPool<COBBCollisionInstance> gs_oci;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_oci@@YAXXZ ; `dynamic atexit destructor for 'gs_oci''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_oci@@YAXXZ ENDP					; `dynamic initializer for 'gs_oci''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<COBBCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ ; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCOBBCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<COBBCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ PROC	; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCOBBCollisionInstance@@@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN37@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN56@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN56@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 2082 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN37@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN53@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN67@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@VCOBBCollisionInstance@@@@UAE@XZ ENDP	; CDynamicPool<COBBCollisionInstance>::~CDynamicPool<COBBCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fgs_aci@@YAXXZ
text$yd	SEGMENT
??__Fgs_aci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_aci'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>
??__Fgs_aci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_aci''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ??__Egs_aci@@YAXXZ
text$di	SEGMENT
??__Egs_aci@@YAXXZ PROC					; `dynamic initializer for 'gs_aci'', COMDAT

; 21   : CDynamicPool<CAABBCollisionInstance> gs_aci;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_aci@@YAXXZ ; `dynamic atexit destructor for 'gs_aci''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_aci@@YAXXZ ENDP					; `dynamic initializer for 'gs_aci''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CAABBCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCAABBCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CAABBCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ
_TEXT	SEGMENT
_pkNewData$1 = -4					; size = 4
$T2 = -4						; size = 4
?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ PROC ; CDynamicPool<CAABBCollisionInstance>::Alloc, COMDAT
; _this$ = ecx

; 63   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00007	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000a	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 64   : 			if (m_kVct_pkFree.empty())

  0000d	75 4c		 jne	 SHORT $LN2@Alloc

; 66   : 				T* pkNewData=new T;

  0000f	6a 1c		 push	 28			; 0000001cH
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4
  00019	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  0001c	85 c0		 test	 eax, eax
  0001e	74 08		 je	 SHORT $LN4@Alloc
  00020	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAABBCollisionInstance@@6B@
  00026	eb 02		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00028	33 c0		 xor	 eax, eax
$LN5@Alloc:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0002a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 66   : 				T* pkNewData=new T;

  0002d	89 45 fc	 mov	 DWORD PTR _pkNewData$1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00030	3b 4e 0c	 cmp	 ecx, DWORD PTR [esi+12]
  00033	74 0e		 je	 SHORT $LN18@Alloc

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00035	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00037	83 46 08 04	 add	 DWORD PTR [esi+8], 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  0003b	ff 46 20	 inc	 DWORD PTR [esi+32]
  0003e	5e		 pop	 esi

; 75   : 		}

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
$LN18@Alloc:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00043	8d 45 fc	 lea	 eax, DWORD PTR _pkNewData$1[ebp]
  00046	50		 push	 eax
  00047	51		 push	 ecx
  00048	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0004b	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_reallocate<CAABBCollisionInstance * const &>
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  00050	ff 46 20	 inc	 DWORD PTR [esi+32]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00053	8b 45 fc	 mov	 eax, DWORD PTR _pkNewData$1[ebp]
  00056	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 75   : 		}

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN2@Alloc:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1974 :         return _My_data._Mylast[-1];

  0005b	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0005e	83 c0 fc	 add	 eax, -4			; fffffffcH
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 72   : 			T* pkFreeData=m_kVct_pkFree.back();

  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1744 :         --_Mylast;

  00063	89 46 14	 mov	 DWORD PTR [esi+20], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 74   : 			return pkFreeData;

  00066	8b c1		 mov	 eax, ecx
  00068	5e		 pop	 esi

; 75   : 		}

  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c3		 ret	 0
?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ ENDP ; CDynamicPool<CAABBCollisionInstance>::Alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCAABBCollisionInstance@@@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN37@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN56@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN56@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 2082 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN37@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN53@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN67@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@VCAABBCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CAABBCollisionInstance>::~CDynamicPool<CAABBCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fgs_pci@@YAXXZ
text$yd	SEGMENT
??__Fgs_pci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_pci'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A ; gs_pci
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>
??__Fgs_pci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_pci''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ??__Egs_pci@@YAXXZ
text$di	SEGMENT
??__Egs_pci@@YAXXZ PROC					; `dynamic initializer for 'gs_pci'', COMDAT

; 20   : CDynamicPool<CPlaneCollisionInstance> gs_pci;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_pci@@YAXXZ ; `dynamic atexit destructor for 'gs_pci''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_pci@@YAXXZ ENDP					; `dynamic initializer for 'gs_pci''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CPlaneCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCPlaneCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CPlaneCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCPlaneCollisionInstance@@@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN37@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN56@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN56@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 2082 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN37@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN53@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN67@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@VCPlaneCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CPlaneCollisionInstance>::~CDynamicPool<CPlaneCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fgs_cci@@YAXXZ
text$yd	SEGMENT
??__Fgs_cci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_cci'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A ; gs_cci
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>
??__Fgs_cci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_cci''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ??__Egs_cci@@YAXXZ
text$di	SEGMENT
??__Egs_cci@@YAXXZ PROC					; `dynamic initializer for 'gs_cci'', COMDAT

; 19   : CDynamicPool<CCylinderCollisionInstance> gs_cci;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_cci@@YAXXZ ; `dynamic atexit destructor for 'gs_cci''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_cci@@YAXXZ ENDP					; `dynamic initializer for 'gs_cci''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CCylinderCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCCylinderCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CCylinderCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCCylinderCollisionInstance@@@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN37@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN56@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN56@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 2082 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN37@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN53@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN67@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@VCCylinderCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CCylinderCollisionInstance>::~CDynamicPool<CCylinderCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fgs_sci@@YAXXZ
text$yd	SEGMENT
??__Fgs_sci@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_sci'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A ; gs_sci
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>
??__Fgs_sci@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_sci''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ??__Egs_sci@@YAXXZ
text$di	SEGMENT
??__Egs_sci@@YAXXZ PROC					; `dynamic initializer for 'gs_sci'', COMDAT

; 18   : CDynamicPool<CSphereCollisionInstance> gs_sci;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fgs_sci@@YAXXZ ; `dynamic atexit destructor for 'gs_sci''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Egs_sci@@YAXXZ ENDP					; `dynamic initializer for 'gs_sci''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CSphereCollisionInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCSphereCollisionInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CSphereCollisionInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ PROC ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCSphereCollisionInstance@@@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN37@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN56@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN56@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 2082 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN37@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN53@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN67@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@VCSphereCollisionInstance@@@@UAE@XZ ENDP ; CDynamicPool<CSphereCollisionInstance>::~CDynamicPool<CSphereCollisionInstance>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
;	COMDAT ?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z
_TEXT	SEGMENT
_l$1$ = -8						; size = 4
tv863 = -4						; size = 4
_p1$ = 8						; size = 4
tv866 = 8						; size = 4
_p2$ = 12						; size = 4
tv869 = 12						; size = 4
tv884 = 12						; size = 4
tv908 = 12						; size = 4
tv924 = 12						; size = 4
_x$ = 16						; size = 4
?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z PROC ; square_distance_between_linesegment_and_point, COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00006	8b 45 08	 mov	 eax, DWORD PTR _p1$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR _p2$[ebp]
  0000c	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  00011	f3 0f 10 41 04	 movss	 xmm0, DWORD PTR [ecx+4]
  00016	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  0001a	f3 0f 5c c2	 subss	 xmm0, xmm2
  0001e	f3 0f 10 29	 movss	 xmm5, DWORD PTR [ecx]
  00022	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00027	f3 0f 5c eb	 subss	 xmm5, xmm3
  0002b	f3 0f 10 71 08	 movss	 xmm6, DWORD PTR [ecx+8]
  00030	8b 45 10	 mov	 eax, DWORD PTR _x$[ebp]
  00033	f3 0f 5c f1	 subss	 xmm6, xmm1

; 182  :     z = fz;

  00037	0f 28 e0	 movaps	 xmm4, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0003a	f3 0f 11 45 08	 movss	 DWORD PTR tv866[ebp], xmm0

; 182  :     z = fz;

  0003f	f3 0f 59 e0	 mulss	 xmm4, xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00043	0f 28 c5	 movaps	 xmm0, xmm5

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00046	f3 0f 11 6d fc	 movss	 DWORD PTR tv863[ebp], xmm5

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0004b	f3 0f 59 c5	 mulss	 xmm0, xmm5

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0004f	f3 0f 10 68 04	 movss	 xmm5, DWORD PTR [eax+4]
  00054	f3 0f 10 78 08	 movss	 xmm7, DWORD PTR [eax+8]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00059	f3 0f 58 e0	 addss	 xmm4, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0005d	f3 0f 11 75 0c	 movss	 DWORD PTR tv869[ebp], xmm6

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00062	0f 28 c6	 movaps	 xmm0, xmm6
  00065	f3 0f 59 c6	 mulss	 xmm0, xmm6

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00069	f3 0f 10 30	 movss	 xmm6, DWORD PTR [eax]

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0006d	f3 0f 58 e0	 addss	 xmm4, xmm0
  00071	f3 0f 11 65 f8	 movss	 DWORD PTR _l$1$[ebp], xmm4

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00076	0f 28 e6	 movaps	 xmm4, xmm6
  00079	f3 0f 5c e3	 subss	 xmm4, xmm3
  0007d	0f 28 dd	 movaps	 xmm3, xmm5
  00080	f3 0f 5c da	 subss	 xmm3, xmm2
  00084	0f 28 d7	 movaps	 xmm2, xmm7
  00087	f3 0f 5c d1	 subss	 xmm2, xmm1

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0008b	0f 28 c4	 movaps	 xmm0, xmm4
  0008e	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR tv863[ebp]

; 182  :     z = fz;

  00093	0f 28 cb	 movaps	 xmm1, xmm3
  00096	f3 0f 59 4d 08	 mulss	 xmm1, DWORD PTR tv866[ebp]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0009b	f3 0f 58 c8	 addss	 xmm1, xmm0
  0009f	0f 28 c2	 movaps	 xmm0, xmm2
  000a2	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR tv869[ebp]
  000a7	f3 0f 58 c8	 addss	 xmm1, xmm0
  000ab	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 87   : 	if (d <= 0.0f)

  000ae	0f 2f c1	 comiss	 xmm0, xmm1
  000b1	72 20		 jb	 SHORT $LN2@square_dis
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000b3	f3 0f 59 db	 mulss	 xmm3, xmm3
  000b7	f3 0f 59 e4	 mulss	 xmm4, xmm4
  000bb	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000bf	f3 0f 58 dc	 addss	 xmm3, xmm4
  000c3	f3 0f 58 da	 addss	 xmm3, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 89   : 		return D3DXVec3LengthSq(&(v2));

  000c7	f3 0f 11 5d 0c	 movss	 DWORD PTR tv924[ebp], xmm3
  000cc	d9 45 0c	 fld	 DWORD PTR tv924[ebp]

; 100  : 	}
; 101  : }

  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c3		 ret	 0
$LN2@square_dis:

; 90   : 	}
; 91   : 	else if (d >= l)

  000d3	0f 2f 4d f8	 comiss	 xmm1, DWORD PTR _l$1$[ebp]
  000d7	72 2e		 jb	 SHORT $LN4@square_dis
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000d9	f3 0f 5c 69 04	 subss	 xmm5, DWORD PTR [ecx+4]
  000de	f3 0f 5c 31	 subss	 xmm6, DWORD PTR [ecx]
  000e2	f3 0f 5c 79 08	 subss	 xmm7, DWORD PTR [ecx+8]

; 182  :     z = fz;

  000e7	f3 0f 59 ed	 mulss	 xmm5, xmm5

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000eb	f3 0f 59 f6	 mulss	 xmm6, xmm6
  000ef	f3 0f 59 ff	 mulss	 xmm7, xmm7
  000f3	f3 0f 58 ee	 addss	 xmm5, xmm6
  000f7	f3 0f 58 ef	 addss	 xmm5, xmm7
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 94   : 		return D3DXVec3LengthSq(&(v4));

  000fb	f3 0f 11 6d 0c	 movss	 DWORD PTR tv908[ebp], xmm5
  00100	d9 45 0c	 fld	 DWORD PTR tv908[ebp]

; 100  : 	}
; 101  : }

  00103	8b e5		 mov	 esp, ebp
  00105	5d		 pop	 ebp
  00106	c3		 ret	 0
$LN4@square_dis:
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00107	0f 28 c2	 movaps	 xmm0, xmm2
  0010a	0f 28 cb	 movaps	 xmm1, xmm3
  0010d	f3 0f 59 4d 0c	 mulss	 xmm1, DWORD PTR tv869[ebp]
  00112	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR tv866[ebp]
  00117	f3 0f 59 55 fc	 mulss	 xmm2, DWORD PTR tv863[ebp]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0011c	f3 0f 59 5d fc	 mulss	 xmm3, DWORD PTR tv863[ebp]
  00121	f3 0f 5c c8	 subss	 xmm1, xmm0
  00125	0f 28 c4	 movaps	 xmm0, xmm4
  00128	f3 0f 59 65 08	 mulss	 xmm4, DWORD PTR tv866[ebp]
  0012d	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR tv869[ebp]
  00132	f3 0f 5c e3	 subss	 xmm4, xmm3

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00136	f3 0f 59 c9	 mulss	 xmm1, xmm1

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0013a	f3 0f 5c d0	 subss	 xmm2, xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0013e	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00142	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00146	f3 0f 58 d1	 addss	 xmm2, xmm1
  0014a	f3 0f 58 d4	 addss	 xmm2, xmm4
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 99   : 		return D3DXVec3LengthSq(D3DXVec3Cross(&c, &(v2), &(v3))) / l;

  0014e	f3 0f 5e 55 f8	 divss	 xmm2, DWORD PTR _l$1$[ebp]
  00153	f3 0f 11 55 0c	 movss	 DWORD PTR tv884[ebp], xmm2
  00158	d9 45 0c	 fld	 DWORD PTR tv884[ebp]

; 100  : 	}
; 101  : }

  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c3		 ret	 0
?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z ENDP ; square_distance_between_linesegment_and_point
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_ob$ = -40						; size = 12
_oa$ = -28						; size = 12
$T1 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_c_rattribute$ = 8					; size = 4
_s$ = 12						; size = 4
?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere, COMDAT
; _this$ = ecx

; 483  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	8b 75 08	 mov	 esi, DWORD PTR _c_rattribute$[ebp]
  00014	57		 push	 edi
  00015	8b 7d 0c	 mov	 edi, DWORD PTR _s$[ebp]

; 484  : 	if (s.v3Position.z + s.fRadius < c_rattribute.v3Position.z)

  00018	f3 0f 10 4e 08	 movss	 xmm1, DWORD PTR [esi+8]
  0001d	f3 0f 10 57 08	 movss	 xmm2, DWORD PTR [edi+8]
  00022	f3 0f 10 5f 18	 movss	 xmm3, DWORD PTR [edi+24]
  00027	0f 28 c2	 movaps	 xmm0, xmm2
  0002a	f3 0f 58 c3	 addss	 xmm0, xmm3
  0002e	0f 2f c8	 comiss	 xmm1, xmm0
  00031	0f 87 9c 00 00
	00		 ja	 $LN13@CollideCyl

; 485  : 		return false;
; 486  : 
; 487  : 	if (s.v3Position.z - s.fRadius > c_rattribute.v3Position.z + c_rattribute.fHeight)

  00037	f3 0f 58 4e 10	 addss	 xmm1, DWORD PTR [esi+16]
  0003c	f3 0f 5c d3	 subss	 xmm2, xmm3
  00040	0f 2f d1	 comiss	 xmm2, xmm1
  00043	0f 87 8a 00 00
	00		 ja	 $LN13@CollideCyl
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00049	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 497  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x, c_rattribute.v3Position.y, c_rattribute.v3Position.z + c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  0004d	8d 45 d8	 lea	 eax, DWORD PTR _ob$[ebp]
  00050	50		 push	 eax
  00051	8d 45 e4	 lea	 eax, DWORD PTR _oa$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00054	f3 0f 11 45 f0	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  00059	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 497  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x, c_rattribute.v3Position.y, c_rattribute.v3Position.z + c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  0005e	50		 push	 eax
  0005f	57		 push	 edi
  00060	8d 47 0c	 lea	 eax, DWORD PTR [edi+12]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00063	f3 0f 11 45 f4	 movss	 DWORD PTR $T1[ebp+4], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 497  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x, c_rattribute.v3Position.y, c_rattribute.v3Position.z + c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  00068	50		 push	 eax
  00069	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  0006c	f3 0f 11 4d f8	 movss	 DWORD PTR $T1[ebp+8], xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 497  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x, c_rattribute.v3Position.y, c_rattribute.v3Position.z + c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  00071	50		 push	 eax
  00072	56		 push	 esi
  00073	e8 00 00 00 00	 call	 ?IntersectLineSegments@@YAXABUD3DXVECTOR3@@000AAU1@1@Z ; IntersectLineSegments
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00078	f3 0f 10 55 e4	 movss	 xmm2, DWORD PTR _oa$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 497  : 	IntersectLineSegments(c_rattribute.v3Position, D3DXVECTOR3(c_rattribute.v3Position.x, c_rattribute.v3Position.y, c_rattribute.v3Position.z + c_rattribute.fHeight), s.v3LastPosition, s.v3Position, oa, ob);

  0007d	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00080	f3 0f 10 5d e8	 movss	 xmm3, DWORD PTR _oa$[ebp+4]
  00085	f3 0f 5c 5d dc	 subss	 xmm3, DWORD PTR _ob$[ebp+4]
  0008a	f3 0f 5c 55 d8	 subss	 xmm2, DWORD PTR _ob$[ebp]
  0008f	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _oa$[ebp+8]
  00094	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _ob$[ebp+8]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 499  : 	return (D3DXVec3LengthSq(&vv) <= (c_rattribute.fRadius + s.fRadius) * (c_rattribute.fRadius + s.fRadius));

  00099	f3 0f 10 4e 0c	 movss	 xmm1, DWORD PTR [esi+12]
  0009e	f3 0f 58 4f 18	 addss	 xmm1, DWORD PTR [edi+24]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  000a3	f3 0f 59 db	 mulss	 xmm3, xmm3
  000a7	5f		 pop	 edi

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000a8	f3 0f 59 d2	 mulss	 xmm2, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 500  : }

  000ac	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000ad	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000b1	f3 0f 58 da	 addss	 xmm3, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 499  : 	return (D3DXVec3LengthSq(&vv) <= (c_rattribute.fRadius + s.fRadius) * (c_rattribute.fRadius + s.fRadius));

  000b5	f3 0f 59 c9	 mulss	 xmm1, xmm1
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  000b9	f3 0f 58 d8	 addss	 xmm3, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 499  : 	return (D3DXVec3LengthSq(&vv) <= (c_rattribute.fRadius + s.fRadius) * (c_rattribute.fRadius + s.fRadius));

  000bd	0f 2f cb	 comiss	 xmm1, xmm3
  000c0	0f 93 c0	 setae	 al

; 500  : }

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c6	33 cd		 xor	 ecx, ebp
  000c8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c2 08 00	 ret	 8
$LN13@CollideCyl:
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	32 c0		 xor	 al, al
  000d8	5f		 pop	 edi
  000d9	33 cd		 xor	 ecx, ebp
  000db	5e		 pop	 esi
  000dc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 08 00	 ret	 8
?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
tv933 = -28						; size = 4
tv934 = -24						; size = 4
tv936 = -20						; size = 4
tv942 = -16						; size = 4
_sum$1$ = -16						; size = 4
_v3Position$ = -12					; size = 12
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 546  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 548  : 	v3Position.z = s.v3Position.z;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  0000c	f3 0f 7e 41 04	 movq	 xmm0, QWORD PTR [ecx+4]
  00011	66 0f d6 44 24
	10		 movq	 QWORD PTR _v3Position$[esp+28], xmm0
  00017	56		 push	 esi
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00018	f3 0f 10 70 04	 movss	 xmm6, DWORD PTR [eax+4]
  0001d	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00021	0f 28 c6	 movaps	 xmm0, xmm6
  00024	f3 0f 5c 44 24
	18		 subss	 xmm0, DWORD PTR _v3Position$[esp+36]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 548  : 	v3Position.z = s.v3Position.z;

  0002a	f3 0f 10 68 08	 movss	 xmm5, DWORD PTR [eax+8]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0002f	0f 28 fa	 movaps	 xmm7, xmm2
  00032	f3 0f 5c 7c 24
	14		 subss	 xmm7, DWORD PTR _v3Position$[esp+32]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 550  : 	if (D3DXVec3LengthSq(&vv) >= (s.fRadius + m_attribute.fRadius) * (m_attribute.fRadius + s.fRadius))

  00038	f3 0f 10 58 18	 movss	 xmm3, DWORD PTR [eax+24]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0003d	0f 28 cd	 movaps	 xmm1, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 550  : 	if (D3DXVec3LengthSq(&vv) >= (s.fRadius + m_attribute.fRadius) * (m_attribute.fRadius + s.fRadius))

  00040	f3 0f 58 59 10	 addss	 xmm3, DWORD PTR [ecx+16]
  00045	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00048	f3 0f 5c cd	 subss	 xmm1, xmm5

; 182  :     z = fz;

  0004c	0f 28 e0	 movaps	 xmm4, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0004f	f3 0f 11 44 24
	10		 movss	 DWORD PTR tv942[esp+32], xmm0

; 182  :     z = fz;

  00055	f3 0f 59 e0	 mulss	 xmm4, xmm0

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00059	0f 28 c7	 movaps	 xmm0, xmm7
  0005c	f3 0f 59 c7	 mulss	 xmm0, xmm7
  00060	f3 0f 59 c9	 mulss	 xmm1, xmm1
  00064	f3 0f 58 e0	 addss	 xmm4, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 550  : 	if (D3DXVec3LengthSq(&vv) >= (s.fRadius + m_attribute.fRadius) * (m_attribute.fRadius + s.fRadius))

  00068	f3 0f 59 db	 mulss	 xmm3, xmm3
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0006c	f3 0f 58 e1	 addss	 xmm4, xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 550  : 	if (D3DXVec3LengthSq(&vv) >= (s.fRadius + m_attribute.fRadius) * (m_attribute.fRadius + s.fRadius))

  00070	0f 2f e3	 comiss	 xmm4, xmm3
  00073	0f 83 53 01 00
	00		 jae	 $LN41@OnGetColli
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00079	f3 0f 5c 70 10	 subss	 xmm6, DWORD PTR [eax+16]
  0007e	f3 0f 5c 50 0c	 subss	 xmm2, DWORD PTR [eax+12]
  00083	0f 57 c9	 xorps	 xmm1, xmm1

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00086	f3 0f 5c ed	 subss	 xmm5, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 560  : 	float mul = (s.fRadius + m_attribute.fRadius) * (s.fRadius + m_attribute.fRadius) - D3DXVec3LengthSq(&svsvs);

  0008a	f3 0f 5c dc	 subss	 xmm3, xmm4
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0008e	0f 28 c6	 movaps	 xmm0, xmm6

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00091	f3 0f 59 35 00
	00 00 00	 mulss	 xmm6, DWORD PTR __real@00000000
  00099	f3 0f 5c c1	 subss	 xmm0, xmm1
  0009d	f3 0f 5c ca	 subss	 xmm1, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 562  : 	if (sum * sum - 4 * mul <= 0)

  000a1	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@40800000
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  000a9	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@00000000
  000b1	f3 0f 11 44 24
	04		 movss	 DWORD PTR tv933[esp+32], xmm0
  000b7	f3 0f 11 4c 24
	08		 movss	 DWORD PTR tv934[esp+32], xmm1

; 182  :     z = fz;

  000bd	f3 0f 59 4c 24
	10		 mulss	 xmm1, DWORD PTR tv942[esp+32]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  000c3	f3 0f 5c d6	 subss	 xmm2, xmm6

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000c7	f3 0f 59 c7	 mulss	 xmm0, xmm7
  000cb	f3 0f 59 ea	 mulss	 xmm5, xmm2
  000cf	f3 0f 58 c8	 addss	 xmm1, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  000d3	f3 0f 11 54 24
	0c		 movss	 DWORD PTR tv936[esp+32], xmm2

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000d9	f3 0f 58 cd	 addss	 xmm1, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 559  : 	float sum = -D3DXVec3Dot(&c, &svsvs);

  000dd	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000

; 562  : 	if (sum * sum - 4 * mul <= 0)

  000e4	0f 28 c1	 movaps	 xmm0, xmm1
  000e7	f3 0f 11 4c 24
	10		 movss	 DWORD PTR _sum$1$[esp+32], xmm1
  000ed	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000f1	0f 57 c9	 xorps	 xmm1, xmm1
  000f4	f3 0f 5c c3	 subss	 xmm0, xmm3
  000f8	0f 2f c8	 comiss	 xmm1, xmm0
  000fb	0f 83 cb 00 00
	00		 jae	 $LN41@OnGetColli

; 564  : 	float sq = sqrt(sum * sum - 4 * mul);

  00101	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  00105	66 0f 2e c8	 ucomisd xmm1, xmm0
  00109	77 06		 ja	 SHORT $LN43@OnGetColli
  0010b	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  0010f	eb 05		 jmp	 SHORT $LN44@OnGetColli
$LN43@OnGetColli:
  00111	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
$LN44@OnGetColli:

; 565  : 	float t1 = -sum - sq, t2 = -sum + sq;

  00116	f3 0f 10 5c 24
	10		 movss	 xmm3, DWORD PTR _sum$1$[esp+32]
  0011c	0f 57 e4	 xorps	 xmm4, xmm4
  0011f	0f 57 1d 00 00
	00 00		 xorps	 xmm3, DWORD PTR __xmm@80000000800000008000000080000000

; 566  : 	t1 *= 0.5f;
; 567  : 	t2 *= 0.5f;
; 568  : 
; 569  : 
; 570  : 	if (fabs(t1) <= fabs(t2))

  00126	0f 57 d2	 xorps	 xmm2, xmm2
  00129	f3 0f 10 2d 00
	00 00 00	 movss	 xmm5, DWORD PTR __real@3f000000
  00131	8b c6		 mov	 eax, esi
  00133	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  0013b	f2 0f 5a e0	 cvtsd2ss xmm4, xmm0
  0013f	f3 0f 5c dc	 subss	 xmm3, xmm4
  00143	f3 0f 5c 64 24
	10		 subss	 xmm4, DWORD PTR _sum$1$[esp+32]
  00149	f3 0f 59 dd	 mulss	 xmm3, xmm5
  0014d	f3 0f 59 e5	 mulss	 xmm4, xmm5
  00151	f3 0f 5a d3	 cvtss2sd xmm2, xmm3
  00155	0f 5a c4	 cvtps2pd xmm0, xmm4
  00158	0f 54 d1	 andps	 xmm2, xmm1
  0015b	0f 54 c1	 andps	 xmm0, xmm1
  0015e	66 0f 2f c2	 comisd	 xmm0, xmm2
  00162	f3 0f 10 44 24
	04		 movss	 xmm0, DWORD PTR tv933[esp+32]
  00168	72 31		 jb	 SHORT $LN4@OnGetColli

; 571  : 	{
; 572  : 		return (gc_fReduceMove * t1) * c;

  0016a	f3 0f 59 dd	 mulss	 xmm3, xmm5
  0016e	f3 0f 59 c3	 mulss	 xmm0, xmm3
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00172	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
  00176	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR tv934[esp+32]
  0017c	f3 0f 59 c3	 mulss	 xmm0, xmm3

; 181  :     y = fy;

  00180	f3 0f 11 46 04	 movss	 DWORD PTR [esi+4], xmm0
  00185	f3 0f 10 44 24
	0c		 movss	 xmm0, DWORD PTR tv936[esp+32]
  0018b	f3 0f 59 c3	 mulss	 xmm0, xmm3

; 182  :     z = fz;

  0018f	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 588  : }

  00194	5e		 pop	 esi
  00195	8b e5		 mov	 esp, ebp
  00197	5d		 pop	 ebp
  00198	c2 08 00	 ret	 8
$LN4@OnGetColli:

; 573  : 	}
; 574  : 	else
; 575  : 		return (gc_fReduceMove * t2) * c;

  0019b	f3 0f 59 e5	 mulss	 xmm4, xmm5
  0019f	f3 0f 59 c4	 mulss	 xmm0, xmm4
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  001a3	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
  001a7	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR tv934[esp+32]
  001ad	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 181  :     y = fy;

  001b1	f3 0f 11 46 04	 movss	 DWORD PTR [esi+4], xmm0
  001b6	f3 0f 10 44 24
	0c		 movss	 xmm0, DWORD PTR tv936[esp+32]
  001bc	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 182  :     z = fz;

  001c0	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 588  : }

  001c5	5e		 pop	 esi
  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c2 08 00	 ret	 8
$LN41@OnGetColli:
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  001cc	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 563  : 		return D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  001d2	8b c6		 mov	 eax, esi
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  001d4	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 182  :     z = fz;

  001db	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 588  : }

  001e2	5e		 pop	 esi
  001e3	8b e5		 mov	 esp, ebp
  001e5	5d		 pop	 ebp
  001e6	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CCylinderCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 539  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 540  : 	//Tracef("OnCollisionDynamicSphere\n");
; 541  : 
; 542  : 	return (CollideCylinderVSDynamicSphere(m_attribute, s));

  00003	ff 75 08	 push	 DWORD PTR _s$[ebp]
  00006	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere

; 543  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v3Step$1$sroa$298$1$ = -40				; size = 4
_v3Step$1$sroa$297$1$ = -36				; size = 4
_v3Step$1$sroa$296$1$ = -32				; size = 4
_iStep$1$ = -28						; size = 4
_cylinder$2 = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CCylinderCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 504  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c4		 xor	 eax, esp
  00010	89 44 24 28	 mov	 DWORD PTR __$ArrayPad$[esp+44], eax
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	8b d9		 mov	 ebx, ecx
  00018	57		 push	 edi
  00019	8b 7d 08	 mov	 edi, DWORD PTR _s$[ebp]

; 505  : 	if (CollideCylinderVSDynamicSphere(m_attribute, s))

  0001c	57		 push	 edi
  0001d	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
  00026	84 c0		 test	 al, al
  00028	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  0002b	74 47		 je	 SHORT $LN33@OnMovement
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0002d	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  00031	f3 0f 10 27	 movss	 xmm4, DWORD PTR [edi]
  00035	f3 0f 10 57 10	 movss	 xmm2, DWORD PTR [edi+16]
  0003a	f3 0f 10 4f 0c	 movss	 xmm1, DWORD PTR [edi+12]
  0003f	f3 0f 5c 63 04	 subss	 xmm4, DWORD PTR [ebx+4]
  00044	f3 0f 5c 4b 04	 subss	 xmm1, DWORD PTR [ebx+4]
  00049	f3 0f 5c 5b 08	 subss	 xmm3, DWORD PTR [ebx+8]
  0004e	f3 0f 5c 53 08	 subss	 xmm2, DWORD PTR [ebx+8]
  00053	f3 0f 59 e4	 mulss	 xmm4, xmm4
  00057	f3 0f 59 db	 mulss	 xmm3, xmm3
  0005b	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0005f	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00063	f3 0f 58 e3	 addss	 xmm4, xmm3
  00067	f3 0f 58 ca	 addss	 xmm1, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 507  : 		if (GetVector3Distance(s.v3Position, m_attribute.v3Position) <

  0006b	0f 2f cc	 comiss	 xmm1, xmm4
  0006e	0f 87 78 01 00
	00		 ja	 $LN30@OnMovement
$LN33@OnMovement:
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00074	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00078	f3 0f 5c 47 10	 subss	 xmm0, DWORD PTR [edi+16]
  0007d	f3 0f 10 17	 movss	 xmm2, DWORD PTR [edi]
  00081	f3 0f 5c 57 0c	 subss	 xmm2, DWORD PTR [edi+12]
  00086	f3 0f 10 5f 08	 movss	 xmm3, DWORD PTR [edi+8]
  0008b	f3 0f 5c 5f 14	 subss	 xmm3, DWORD PTR [edi+20]

; 182  :     z = fz;

  00090	0f 28 c8	 movaps	 xmm1, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00093	f3 0f 11 44 24
	14		 movss	 DWORD PTR _v3Step$1$sroa$297$1$[esp+56], xmm0

; 182  :     z = fz;

  00099	f3 0f 59 c8	 mulss	 xmm1, xmm0

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  0009d	0f 28 c2	 movaps	 xmm0, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000a0	f3 0f 11 54 24
	10		 movss	 DWORD PTR _v3Step$1$sroa$298$1$[esp+56], xmm2

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000a6	f3 0f 59 c2	 mulss	 xmm0, xmm2

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000aa	f3 0f 11 5c 24
	18		 movss	 DWORD PTR _v3Step$1$sroa$296$1$[esp+56], xmm3

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  000b0	f3 0f 58 c8	 addss	 xmm1, xmm0
  000b4	0f 28 c3	 movaps	 xmm0, xmm3
  000b7	f3 0f 59 c3	 mulss	 xmm0, xmm3
  000bb	f3 0f 58 c8	 addss	 xmm1, xmm0
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 808  :             return (float)sqrt(_X);

  000bf	0f 5a c1	 cvtps2pd xmm0, xmm1
  000c2	0f 57 c9	 xorps	 xmm1, xmm1
  000c5	66 0f 2e c8	 ucomisd xmm1, xmm0
  000c9	77 06		 ja	 SHORT $LN38@OnMovement
  000cb	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  000cf	eb 05		 jmp	 SHORT $LN39@OnMovement
$LN38@OnMovement:
  000d1	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
$LN39@OnMovement:
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 515  : 	if (s.fRadius<=0.0001f)

  000d6	f3 0f 10 4f 18	 movss	 xmm1, DWORD PTR [edi+24]
; File D:\Windows Kits\10\Include\10.0.26100.0\ucrt\corecrt_math.h

; 808  :             return (float)sqrt(_X);

  000db	0f 57 d2	 xorps	 xmm2, xmm2
  000de	f2 0f 5a d0	 cvtsd2ss xmm2, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 515  : 	if (s.fRadius<=0.0001f)

  000e2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@38d1b717
  000ea	0f 2f c1	 comiss	 xmm0, xmm1
  000ed	0f 83 e3 00 00
	00		 jae	 $LN3@OnMovement

; 516  : 		return false;
; 517  : 	if (fDistance >= s.fRadius*2.0f)

  000f3	0f 28 c1	 movaps	 xmm0, xmm1
  000f6	f3 0f 58 c1	 addss	 xmm0, xmm1
  000fa	0f 2f d0	 comiss	 xmm2, xmm0
  000fd	0f 82 d3 00 00
	00		 jb	 $LN3@OnMovement

; 523  : 		int iStep = fDistance / s.fRadius*2.0f;

  00103	f3 0f 5e d1	 divss	 xmm2, xmm1
  00107	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]

; 526  : 		for (int i = 0; i < iStep; ++i)

  0010a	33 f6		 xor	 esi, esi
  0010c	89 44 24 30	 mov	 DWORD PTR _cylinder$2[esp+72], eax
  00110	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  00113	0f 10 43 04	 movups	 xmm0, XMMWORD PTR [ebx+4]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 275  :     FLOAT fInv = 1.0f / f;

  00117	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 523  : 		int iStep = fDistance / s.fRadius*2.0f;

  0011f	f3 0f 58 d2	 addss	 xmm2, xmm2
  00123	0f 11 44 24 20	 movups	 XMMWORD PTR _cylinder$2[esp+56], xmm0
  00128	89 44 24 28	 mov	 DWORD PTR _cylinder$2[esp+64], eax
  0012c	f3 0f 7e 47 0c	 movq	 xmm0, QWORD PTR [edi+12]
  00131	66 0f d6 44 24
	20		 movq	 QWORD PTR _cylinder$2[esp+56], xmm0
  00137	f3 0f 2c c2	 cvttss2si eax, xmm2
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  0013b	f3 0f 10 54 24
	14		 movss	 xmm2, DWORD PTR _v3Step$1$sroa$297$1$[esp+56]

; 181  :     y = fy;

  00141	f3 0f 10 5c 24
	18		 movss	 xmm3, DWORD PTR _v3Step$1$sroa$296$1$[esp+56]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 523  : 		int iStep = fDistance / s.fRadius*2.0f;

  00147	89 44 24 1c	 mov	 DWORD PTR _iStep$1$[esp+56], eax
  0014b	66 0f 6e c0	 movd	 xmm0, eax

; 524  : 		D3DXVECTOR3 v3Step = v3Distance / float(iStep);

  0014f	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 275  :     FLOAT fInv = 1.0f / f;

  00152	f3 0f 5e c8	 divss	 xmm1, xmm0
  00156	f3 0f 10 44 24
	10		 movss	 xmm0, DWORD PTR _v3Step$1$sroa$298$1$[esp+56]
  0015c	f3 0f 59 c1	 mulss	 xmm0, xmm1

; 180  :     x = fx;

  00160	f3 0f 59 d1	 mulss	 xmm2, xmm1

; 181  :     y = fy;

  00164	f3 0f 59 d9	 mulss	 xmm3, xmm1

; 275  :     FLOAT fInv = 1.0f / f;

  00168	f3 0f 11 44 24
	10		 movss	 DWORD PTR _v3Step$1$sroa$298$1$[esp+56], xmm0

; 180  :     x = fx;

  0016e	f3 0f 11 54 24
	14		 movss	 DWORD PTR _v3Step$1$sroa$297$1$[esp+56], xmm2

; 181  :     y = fy;

  00174	f3 0f 11 5c 24
	18		 movss	 DWORD PTR _v3Step$1$sroa$296$1$[esp+56], xmm3
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 526  : 		for (int i = 0; i < iStep; ++i)

  0017a	85 c0		 test	 eax, eax
  0017c	7e 58		 jle	 SHORT $LN3@OnMovement
  0017e	66 90		 npad	 2
$LL4@OnMovement:
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  00180	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR _cylinder$2[esp+56]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 529  : 			if (CollideCylinderVSDynamicSphere(cylinder, s))

  00186	57		 push	 edi
  00187	8d 44 24 24	 lea	 eax, DWORD PTR _cylinder$2[esp+60]
  0018b	8b cb		 mov	 ecx, ebx
  0018d	50		 push	 eax
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 204  :     x += v.x;

  0018e	f3 0f 11 44 24
	28		 movss	 DWORD PTR _cylinder$2[esp+64], xmm0

; 205  :     y += v.y;

  00194	f3 0f 10 44 24
	2c		 movss	 xmm0, DWORD PTR _cylinder$2[esp+68]
  0019a	f3 0f 58 c2	 addss	 xmm0, xmm2
  0019e	f3 0f 11 44 24
	2c		 movss	 DWORD PTR _cylinder$2[esp+68], xmm0

; 206  :     z += v.z;

  001a4	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR _cylinder$2[esp+72]
  001aa	f3 0f 58 c3	 addss	 xmm0, xmm3
  001ae	f3 0f 11 44 24
	30		 movss	 DWORD PTR _cylinder$2[esp+72], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 529  : 			if (CollideCylinderVSDynamicSphere(cylinder, s))

  001b4	e8 00 00 00 00	 call	 ?CollideCylinderVSDynamicSphere@CCylinderCollisionInstance@@IBE_NABUSCylinderData@@ABUCDynamicSphereInstance@@@Z ; CCylinderCollisionInstance::CollideCylinderVSDynamicSphere
  001b9	84 c0		 test	 al, al
  001bb	75 2f		 jne	 SHORT $LN30@OnMovement

; 526  : 		for (int i = 0; i < iStep; ++i)

  001bd	f3 0f 10 44 24
	10		 movss	 xmm0, DWORD PTR _v3Step$1$sroa$298$1$[esp+56]
  001c3	46		 inc	 esi
  001c4	f3 0f 10 54 24
	14		 movss	 xmm2, DWORD PTR _v3Step$1$sroa$297$1$[esp+56]
  001ca	f3 0f 10 5c 24
	18		 movss	 xmm3, DWORD PTR _v3Step$1$sroa$296$1$[esp+56]
  001d0	3b 74 24 1c	 cmp	 esi, DWORD PTR _iStep$1$[esp+56]
  001d4	7c aa		 jl	 SHORT $LL4@OnMovement
$LN3@OnMovement:

; 530  : 				return true;
; 531  : 
; 532  : 		}
; 533  : 	}
; 534  : 
; 535  : 	return false;

  001d6	32 c0		 xor	 al, al

; 536  : }

  001d8	5f		 pop	 edi
  001d9	5e		 pop	 esi
  001da	5b		 pop	 ebx
  001db	8b 4c 24 28	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+44]
  001df	33 cc		 xor	 ecx, esp
  001e1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e6	8b e5		 mov	 esp, ebp
  001e8	5d		 pop	 ebp
  001e9	c2 04 00	 ret	 4
$LN30@OnMovement:
  001ec	8b 4c 24 34	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+56]
  001f0	b0 01		 mov	 al, 1
  001f2	5f		 pop	 edi
  001f3	5e		 pop	 esi
  001f4	5b		 pop	 ebx
  001f5	33 cc		 xor	 ecx, esp
  001f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001fc	8b e5		 mov	 esp, ebp
  001fe	5d		 pop	 ebp
  001ff	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CCylinderCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CCylinderCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnDestroy@CCylinderCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
?OnDestroy@CCylinderCollisionInstance@@MAEXXZ PROC	; CCylinderCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 598  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00004	a1 14 00 00 00	 mov	 eax, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+20
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 599  : 	gs_cci.Free(this);

  00009	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0000c	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+24
  00012	74 0d		 je	 SHORT $LN8@OnDestroy

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00016	83 05 14 00 00
	00 04		 add	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+20, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 600  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN8@OnDestroy:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00021	8d 4d fc	 lea	 ecx, DWORD PTR _pkData$[ebp]
  00024	51		 push	 ecx
  00025	50		 push	 eax
  00026	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+16
  0002b	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_reallocate<CCylinderCollisionInstance * const &>
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 600  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?OnDestroy@CCylinderCollisionInstance@@MAEXXZ ENDP	; CCylinderCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CCylinderCollisionInstance::Render, COMDAT
; _this$ = ecx

; 591  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 592  : 	static CScreen s;

  00025	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __tls_index
  00031	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00039	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0003f	7f 71		 jg	 SHORT $LN7@Render
$LN2@Render:

; 593  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00047	6a ff		 push	 -1
  00049	6a 3c		 push	 60			; 0000003cH
  0004b	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 594  : 	s.RenderCylinder(NULL, m_attribute.v3Position.x, m_attribute.v3Position.y, m_attribute.v3Position.z+m_attribute.fHeight/2, m_attribute.fRadius, m_attribute.fHeight, d3dFillMode);

  00050	ff 75 08	 push	 DWORD PTR _d3dFillMode$[ebp]
  00053	f3 0f 10 4e 14	 movss	 xmm1, DWORD PTR [esi+20]
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0005d	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  00062	83 ec 14	 sub	 esp, 20			; 00000014H
  00065	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [esp+16], xmm1
  0006b	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  00073	f3 0f 11 44 24
	0c		 movss	 DWORD PTR [esp+12], xmm0
  00079	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  0007e	f3 0f 58 4e 0c	 addss	 xmm1, DWORD PTR [esi+12]
  00083	f3 0f 11 4c 24
	08		 movss	 DWORD PTR [esp+8], xmm1
  00089	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0008f	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  00094	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00099	6a 00		 push	 0
  0009b	e8 00 00 00 00	 call	 ?RenderCylinder@CScreen@@QAEXPBUD3DXMATRIX@@MMMMMW4_D3DFILLMODE@@@Z ; CScreen::RenderCylinder

; 595  : }

  000a0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000aa	59		 pop	 ecx
  000ab	5e		 pop	 esi
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 04 00	 ret	 4
$LN7@Render:

; 592  : 	static CScreen s;

  000b2	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  000b7	e8 00 00 00 00	 call	 __Init_thread_header
  000bc	83 c4 04	 add	 esp, 4
  000bf	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA, -1
  000c6	0f 85 75 ff ff
	ff		 jne	 $LN2@Render
  000cc	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  000d1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d8	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  000dd	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CCylinderCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  000e2	e8 00 00 00 00	 call	 _atexit
  000e7	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  000ec	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f3	e8 00 00 00 00	 call	 __Init_thread_footer
  000f8	83 c4 08	 add	 esp, 8
  000fb	e9 41 ff ff ff	 jmp	 $LN2@Render
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CCylinderCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CCylinderCollisionInstance::Render
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ
_TEXT	SEGMENT
?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ PROC ; CCylinderCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 479  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 480  : }

  00003	c3		 ret	 0
?GetAttribute@CCylinderCollisionInstance@@QBEABUSCylinderData@@XZ ENDP ; CCylinderCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ
_TEXT	SEGMENT
?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ PROC ; CCylinderCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 474  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 475  : }

  00003	c3		 ret	 0
?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ ENDP ; CCylinderCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; COBBCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 847  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00006	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 181  :     y = fy;

  0000c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 182  :     z = fz;

  00013	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 851  : }

  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@COBBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; COBBCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v3Point$ = -44						; size = 12
_v3Sphere$1$ = -32					; size = 4
_v3Center$$sroa$672$1$ = -28				; size = 4
_v3Sphere$4$ = -24					; size = 4
_v3Sphere$2$ = -20					; size = 4
_v3Sphere$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; COBBCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 811  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00010	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 815  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00018	8d 45 f0	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	8b f1		 mov	 esi, ecx
  0001f	57		 push	 edi
  00020	8b 7d 08	 mov	 edi, DWORD PTR _s$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00023	f3 0f 10 56 10	 movss	 xmm2, DWORD PTR [esi+16]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 815  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00028	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0002b	f3 0f 58 56 04	 addss	 xmm2, DWORD PTR [esi+4]
  00030	f3 0f 10 4e 08	 movss	 xmm1, DWORD PTR [esi+8]
  00035	f3 0f 10 5e 0c	 movss	 xmm3, DWORD PTR [esi+12]
  0003a	f3 0f 58 4e 14	 addss	 xmm1, DWORD PTR [esi+20]
  0003f	f3 0f 58 5e 18	 addss	 xmm3, DWORD PTR [esi+24]

; 182  :     z = fz;

  00044	f3 0f 59 d0	 mulss	 xmm2, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 815  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00048	53		 push	 ebx
  00049	50		 push	 eax
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  0004a	f3 0f 59 c8	 mulss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 815  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0004e	50		 push	 eax
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  0004f	f3 0f 59 d8	 mulss	 xmm3, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00053	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  00057	f3 0f 5c c2	 subss	 xmm0, xmm2

; 182  :     z = fz;

  0005b	f3 0f 11 55 ec	 movss	 DWORD PTR _v3Sphere$2$[ebp], xmm2

; 180  :     x = fx;

  00060	f3 0f 11 4d e8	 movss	 DWORD PTR _v3Sphere$4$[ebp], xmm1

; 181  :     y = fy;

  00065	f3 0f 11 5d e4	 movss	 DWORD PTR _v3Center$$sroa$672$1$[ebp], xmm3

; 180  :     x = fx;

  0006a	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Sphere$[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0006f	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [edi+4]
  00074	f3 0f 5c c1	 subss	 xmm0, xmm1

; 181  :     y = fy;

  00078	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Sphere$[ebp+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0007d	f3 0f 10 47 08	 movss	 xmm0, DWORD PTR [edi+8]
  00082	f3 0f 5c c3	 subss	 xmm0, xmm3

; 182  :     z = fz;

  00086	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Sphere$[ebp+8], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 815  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0008b	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00090	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+8]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 815  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00095	f3 0f 10 75 ec	 movss	 xmm6, DWORD PTR _v3Sphere$2$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  0009a	f3 0f 10 7d e4	 movss	 xmm7, DWORD PTR _v3Center$$sroa$672$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 815  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0009f	0f 28 e6	 movaps	 xmm4, xmm6
  000a2	f3 0f 58 65 f0	 addss	 xmm4, DWORD PTR _v3Sphere$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  000a7	f3 0f 10 6d f4	 movss	 xmm5, DWORD PTR _v3Sphere$[ebp+4]

; 181  :     y = fy;

  000ac	f3 0f 58 c7	 addss	 xmm0, xmm7
  000b0	f3 0f 10 5d e8	 movss	 xmm3, DWORD PTR _v3Sphere$4$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 819  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  000b5	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [esi+4]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  000ba	f3 0f 58 eb	 addss	 xmm5, xmm3
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 819  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  000be	0f 2f d4	 comiss	 xmm2, xmm4
  000c1	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Sphere$[ebp+8], xmm0
  000c6	0f 28 cc	 movaps	 xmm1, xmm4
  000c9	0f 28 c4	 movaps	 xmm0, xmm4
  000cc	f3 0f 11 65 e0	 movss	 DWORD PTR _v3Sphere$1$[ebp], xmm4
  000d1	0f 14 c5	 unpcklps xmm0, xmm5
  000d4	66 0f d6 45 f0	 movq	 QWORD PTR _v3Sphere$[ebp], xmm0
  000d9	66 0f d6 45 d4	 movq	 QWORD PTR _v3Point$[ebp], xmm0
  000de	76 05		 jbe	 SHORT $LN47@OnCollisio
  000e0	0f 28 ca	 movaps	 xmm1, xmm2
  000e3	eb 05		 jmp	 SHORT $LN2@OnCollisio
$LN47@OnCollisio:
  000e5	f3 0f 10 55 d4	 movss	 xmm2, DWORD PTR _v3Point$[ebp]
$LN2@OnCollisio:

; 820  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  000ea	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  000ef	0f 2f c8	 comiss	 xmm1, xmm0
  000f2	76 03		 jbe	 SHORT $LN3@OnCollisio
  000f4	0f 28 d0	 movaps	 xmm2, xmm0
$LN3@OnCollisio:

; 821  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  000f7	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  000fc	0f 28 e5	 movaps	 xmm4, xmm5
  000ff	0f 2f c5	 comiss	 xmm0, xmm5
  00102	0f 28 cd	 movaps	 xmm1, xmm5
  00105	76 06		 jbe	 SHORT $LN4@OnCollisio
  00107	0f 28 e0	 movaps	 xmm4, xmm0
  0010a	0f 28 c8	 movaps	 xmm1, xmm0
$LN4@OnCollisio:

; 822  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  0010d	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  00112	0f 2f e0	 comiss	 xmm4, xmm0
  00115	76 06		 jbe	 SHORT $LN5@OnCollisio
  00117	0f 28 e0	 movaps	 xmm4, xmm0
  0011a	0f 28 c8	 movaps	 xmm1, xmm0
$LN5@OnCollisio:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0011d	f3 0f 5c 55 e0	 subss	 xmm2, DWORD PTR _v3Sphere$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 826  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  00122	f3 0f 10 47 18	 movss	 xmm0, DWORD PTR [edi+24]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00127	f3 0f 5c cd	 subss	 xmm1, xmm5
  0012b	f3 0f 5c e5	 subss	 xmm4, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 826  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0012f	f3 0f 59 c0	 mulss	 xmm0, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00133	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00137	f3 0f 59 cc	 mulss	 xmm1, xmm4
  0013b	f3 0f 58 ca	 addss	 xmm1, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 826  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0013f	0f 2f c1	 comiss	 xmm0, xmm1
  00142	0f 83 d8 00 00
	00		 jae	 $LN45@OnCollisio
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00148	f3 0f 10 47 0c	 movss	 xmm0, DWORD PTR [edi+12]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 829  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0014d	8d 45 f0	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00150	f3 0f 5c c6	 subss	 xmm0, xmm6
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 829  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00154	53		 push	 ebx
  00155	50		 push	 eax
  00156	50		 push	 eax
  00157	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Sphere$[ebp], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0015c	f3 0f 10 47 10	 movss	 xmm0, DWORD PTR [edi+16]
  00161	f3 0f 5c c3	 subss	 xmm0, xmm3
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 828  : 	v3Sphere = s.v3LastPosition - v3Center;

  00165	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Sphere$[ebp+4], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0016a	f3 0f 10 47 14	 movss	 xmm0, DWORD PTR [edi+20]
  0016f	f3 0f 5c c7	 subss	 xmm0, xmm7
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 828  : 	v3Sphere = s.v3LastPosition - v3Center;

  00173	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Sphere$[ebp+8], xmm0

; 829  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00178	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0017d	f3 0f 10 6d ec	 movss	 xmm5, DWORD PTR _v3Sphere$2$[ebp]
  00182	f3 0f 58 6d f0	 addss	 xmm5, DWORD PTR _v3Sphere$[ebp]
  00187	f3 0f 10 65 e8	 movss	 xmm4, DWORD PTR _v3Sphere$4$[ebp]
  0018c	f3 0f 58 65 f4	 addss	 xmm4, DWORD PTR _v3Sphere$[ebp+4]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 833  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  00191	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [esi+4]
  00196	0f 2f d5	 comiss	 xmm2, xmm5
  00199	0f 28 c5	 movaps	 xmm0, xmm5
  0019c	0f 28 cd	 movaps	 xmm1, xmm5
  0019f	0f 14 c4	 unpcklps xmm0, xmm4
  001a2	66 0f d6 45 d4	 movq	 QWORD PTR _v3Point$[ebp], xmm0
  001a7	76 05		 jbe	 SHORT $LN48@OnCollisio
  001a9	0f 28 ca	 movaps	 xmm1, xmm2
  001ac	eb 05		 jmp	 SHORT $LN9@OnCollisio
$LN48@OnCollisio:
  001ae	f3 0f 10 55 d4	 movss	 xmm2, DWORD PTR _v3Point$[ebp]
$LN9@OnCollisio:

; 834  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  001b3	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  001b8	0f 2f c8	 comiss	 xmm1, xmm0
  001bb	76 03		 jbe	 SHORT $LN10@OnCollisio
  001bd	0f 28 d0	 movaps	 xmm2, xmm0
$LN10@OnCollisio:

; 835  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  001c0	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  001c5	0f 28 dc	 movaps	 xmm3, xmm4
  001c8	0f 2f c4	 comiss	 xmm0, xmm4
  001cb	0f 28 cc	 movaps	 xmm1, xmm4
  001ce	76 06		 jbe	 SHORT $LN11@OnCollisio
  001d0	0f 28 d8	 movaps	 xmm3, xmm0
  001d3	0f 28 c8	 movaps	 xmm1, xmm0
$LN11@OnCollisio:

; 836  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  001d6	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  001db	0f 2f d8	 comiss	 xmm3, xmm0
  001de	76 06		 jbe	 SHORT $LN12@OnCollisio
  001e0	0f 28 d8	 movaps	 xmm3, xmm0
  001e3	0f 28 c8	 movaps	 xmm1, xmm0
$LN12@OnCollisio:

; 840  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  001e6	f3 0f 10 47 18	 movss	 xmm0, DWORD PTR [edi+24]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001eb	f3 0f 5c cc	 subss	 xmm1, xmm4
  001ef	f3 0f 5c d5	 subss	 xmm2, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 840  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  001f3	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001f7	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001f8	f3 0f 5c dc	 subss	 xmm3, xmm4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 844  : }

  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001fe	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00202	f3 0f 59 cb	 mulss	 xmm1, xmm3
  00206	f3 0f 58 ca	 addss	 xmm1, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 840  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0020a	0f 2f c1	 comiss	 xmm0, xmm1
  0020d	0f 93 c0	 setae	 al

; 844  : }

  00210	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00213	33 cd		 xor	 ecx, ebp
  00215	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021a	8b e5		 mov	 esp, ebp
  0021c	5d		 pop	 ebp
  0021d	c2 04 00	 ret	 4
$LN45@OnCollisio:
  00220	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00223	b0 01		 mov	 al, 1
  00225	5f		 pop	 edi
  00226	5e		 pop	 esi
  00227	33 cd		 xor	 ecx, ebp
  00229	5b		 pop	 ebx
  0022a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; COBBCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v3Point$ = -44						; size = 12
_v3Sphere$1$ = -32					; size = 4
_v3Center$$sroa$672$1$ = -28				; size = 4
_v3Sphere$4$ = -24					; size = 4
_v3Sphere$2$ = -20					; size = 4
_v3Sphere$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; COBBCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 777  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00010	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00018	8d 45 f0	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
  0001b	53		 push	 ebx
  0001c	56		 push	 esi
  0001d	8b f1		 mov	 esi, ecx
  0001f	57		 push	 edi
  00020	8b 7d 08	 mov	 edi, DWORD PTR _s$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00023	f3 0f 10 56 10	 movss	 xmm2, DWORD PTR [esi+16]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00028	8d 5e 1c	 lea	 ebx, DWORD PTR [esi+28]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0002b	f3 0f 58 56 04	 addss	 xmm2, DWORD PTR [esi+4]
  00030	f3 0f 10 4e 08	 movss	 xmm1, DWORD PTR [esi+8]
  00035	f3 0f 10 5e 0c	 movss	 xmm3, DWORD PTR [esi+12]
  0003a	f3 0f 58 4e 14	 addss	 xmm1, DWORD PTR [esi+20]
  0003f	f3 0f 58 5e 18	 addss	 xmm3, DWORD PTR [esi+24]

; 182  :     z = fz;

  00044	f3 0f 59 d0	 mulss	 xmm2, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00048	53		 push	 ebx
  00049	50		 push	 eax
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  0004a	f3 0f 59 c8	 mulss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0004e	50		 push	 eax
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  0004f	f3 0f 59 d8	 mulss	 xmm3, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00053	f3 0f 10 07	 movss	 xmm0, DWORD PTR [edi]
  00057	f3 0f 5c c2	 subss	 xmm0, xmm2

; 182  :     z = fz;

  0005b	f3 0f 11 55 ec	 movss	 DWORD PTR _v3Sphere$2$[ebp], xmm2

; 180  :     x = fx;

  00060	f3 0f 11 4d e8	 movss	 DWORD PTR _v3Sphere$4$[ebp], xmm1

; 181  :     y = fy;

  00065	f3 0f 11 5d e4	 movss	 DWORD PTR _v3Center$$sroa$672$1$[ebp], xmm3

; 180  :     x = fx;

  0006a	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Sphere$[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0006f	f3 0f 10 47 04	 movss	 xmm0, DWORD PTR [edi+4]
  00074	f3 0f 5c c1	 subss	 xmm0, xmm1

; 181  :     y = fy;

  00078	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Sphere$[ebp+4], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0007d	f3 0f 10 47 08	 movss	 xmm0, DWORD PTR [edi+8]
  00082	f3 0f 5c c3	 subss	 xmm0, xmm3

; 182  :     z = fz;

  00086	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Sphere$[ebp+8], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0008b	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  00090	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Sphere$[ebp+8]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00095	f3 0f 10 75 ec	 movss	 xmm6, DWORD PTR _v3Sphere$2$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  0009a	f3 0f 10 7d e4	 movss	 xmm7, DWORD PTR _v3Center$$sroa$672$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 780  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0009f	0f 28 e6	 movaps	 xmm4, xmm6
  000a2	f3 0f 58 65 f0	 addss	 xmm4, DWORD PTR _v3Sphere$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  000a7	f3 0f 10 6d f4	 movss	 xmm5, DWORD PTR _v3Sphere$[ebp+4]

; 181  :     y = fy;

  000ac	f3 0f 58 c7	 addss	 xmm0, xmm7
  000b0	f3 0f 10 5d e8	 movss	 xmm3, DWORD PTR _v3Sphere$4$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 784  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  000b5	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [esi+4]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  000ba	f3 0f 58 eb	 addss	 xmm5, xmm3
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 784  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  000be	0f 2f d4	 comiss	 xmm2, xmm4
  000c1	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Sphere$[ebp+8], xmm0
  000c6	0f 28 cc	 movaps	 xmm1, xmm4
  000c9	0f 28 c4	 movaps	 xmm0, xmm4
  000cc	f3 0f 11 65 e0	 movss	 DWORD PTR _v3Sphere$1$[ebp], xmm4
  000d1	0f 14 c5	 unpcklps xmm0, xmm5
  000d4	66 0f d6 45 f0	 movq	 QWORD PTR _v3Sphere$[ebp], xmm0
  000d9	66 0f d6 45 d4	 movq	 QWORD PTR _v3Point$[ebp], xmm0
  000de	76 05		 jbe	 SHORT $LN47@OnMovement
  000e0	0f 28 ca	 movaps	 xmm1, xmm2
  000e3	eb 05		 jmp	 SHORT $LN2@OnMovement
$LN47@OnMovement:
  000e5	f3 0f 10 55 d4	 movss	 xmm2, DWORD PTR _v3Point$[ebp]
$LN2@OnMovement:

; 785  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  000ea	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  000ef	0f 2f c8	 comiss	 xmm1, xmm0
  000f2	76 03		 jbe	 SHORT $LN3@OnMovement
  000f4	0f 28 d0	 movaps	 xmm2, xmm0
$LN3@OnMovement:

; 786  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  000f7	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  000fc	0f 28 e5	 movaps	 xmm4, xmm5
  000ff	0f 2f c5	 comiss	 xmm0, xmm5
  00102	0f 28 cd	 movaps	 xmm1, xmm5
  00105	76 06		 jbe	 SHORT $LN4@OnMovement
  00107	0f 28 e0	 movaps	 xmm4, xmm0
  0010a	0f 28 c8	 movaps	 xmm1, xmm0
$LN4@OnMovement:

; 787  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  0010d	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  00112	0f 2f e0	 comiss	 xmm4, xmm0
  00115	76 06		 jbe	 SHORT $LN5@OnMovement
  00117	0f 28 e0	 movaps	 xmm4, xmm0
  0011a	0f 28 c8	 movaps	 xmm1, xmm0
$LN5@OnMovement:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0011d	f3 0f 5c 55 e0	 subss	 xmm2, DWORD PTR _v3Sphere$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 791  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  00122	f3 0f 10 47 18	 movss	 xmm0, DWORD PTR [edi+24]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00127	f3 0f 5c cd	 subss	 xmm1, xmm5
  0012b	f3 0f 5c e5	 subss	 xmm4, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 791  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0012f	f3 0f 59 c0	 mulss	 xmm0, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00133	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00137	f3 0f 59 cc	 mulss	 xmm1, xmm4
  0013b	f3 0f 58 ca	 addss	 xmm1, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 791  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0013f	0f 2f c1	 comiss	 xmm0, xmm1
  00142	0f 83 d8 00 00
	00		 jae	 $LN45@OnMovement
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00148	f3 0f 10 47 0c	 movss	 xmm0, DWORD PTR [edi+12]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 794  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  0014d	8d 45 f0	 lea	 eax, DWORD PTR _v3Sphere$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00150	f3 0f 5c c6	 subss	 xmm0, xmm6
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 794  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00154	53		 push	 ebx
  00155	50		 push	 eax
  00156	50		 push	 eax
  00157	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Sphere$[ebp], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0015c	f3 0f 10 47 10	 movss	 xmm0, DWORD PTR [edi+16]
  00161	f3 0f 5c c3	 subss	 xmm0, xmm3
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 793  : 	v3Sphere = s.v3LastPosition - v3Center;

  00165	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Sphere$[ebp+4], xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0016a	f3 0f 10 47 14	 movss	 xmm0, DWORD PTR [edi+20]
  0016f	f3 0f 5c c7	 subss	 xmm0, xmm7
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 793  : 	v3Sphere = s.v3LastPosition - v3Center;

  00173	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Sphere$[ebp+8], xmm0

; 794  : 	D3DXVec3TransformCoord(&v3Sphere, &v3Sphere, &m_attribute.matRot);

  00178	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0017d	f3 0f 10 6d ec	 movss	 xmm5, DWORD PTR _v3Sphere$2$[ebp]
  00182	f3 0f 58 6d f0	 addss	 xmm5, DWORD PTR _v3Sphere$[ebp]
  00187	f3 0f 10 65 e8	 movss	 xmm4, DWORD PTR _v3Sphere$4$[ebp]
  0018c	f3 0f 58 65 f4	 addss	 xmm4, DWORD PTR _v3Sphere$[ebp+4]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 798  : 	if(v3Point.x < m_attribute.v3Min.x) { v3Point.x = m_attribute.v3Min.x; }

  00191	f3 0f 10 56 04	 movss	 xmm2, DWORD PTR [esi+4]
  00196	0f 2f d5	 comiss	 xmm2, xmm5
  00199	0f 28 c5	 movaps	 xmm0, xmm5
  0019c	0f 28 cd	 movaps	 xmm1, xmm5
  0019f	0f 14 c4	 unpcklps xmm0, xmm4
  001a2	66 0f d6 45 d4	 movq	 QWORD PTR _v3Point$[ebp], xmm0
  001a7	76 05		 jbe	 SHORT $LN48@OnMovement
  001a9	0f 28 ca	 movaps	 xmm1, xmm2
  001ac	eb 05		 jmp	 SHORT $LN9@OnMovement
$LN48@OnMovement:
  001ae	f3 0f 10 55 d4	 movss	 xmm2, DWORD PTR _v3Point$[ebp]
$LN9@OnMovement:

; 799  : 	if(v3Point.x > m_attribute.v3Max.x) { v3Point.x = m_attribute.v3Max.x; }

  001b3	f3 0f 10 46 10	 movss	 xmm0, DWORD PTR [esi+16]
  001b8	0f 2f c8	 comiss	 xmm1, xmm0
  001bb	76 03		 jbe	 SHORT $LN10@OnMovement
  001bd	0f 28 d0	 movaps	 xmm2, xmm0
$LN10@OnMovement:

; 800  : 	if(v3Point.y < m_attribute.v3Min.y) { v3Point.y = m_attribute.v3Min.y; }

  001c0	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  001c5	0f 28 dc	 movaps	 xmm3, xmm4
  001c8	0f 2f c4	 comiss	 xmm0, xmm4
  001cb	0f 28 cc	 movaps	 xmm1, xmm4
  001ce	76 06		 jbe	 SHORT $LN11@OnMovement
  001d0	0f 28 d8	 movaps	 xmm3, xmm0
  001d3	0f 28 c8	 movaps	 xmm1, xmm0
$LN11@OnMovement:

; 801  : 	if(v3Point.y > m_attribute.v3Max.y) { v3Point.y = m_attribute.v3Max.y; }

  001d6	f3 0f 10 46 14	 movss	 xmm0, DWORD PTR [esi+20]
  001db	0f 2f d8	 comiss	 xmm3, xmm0
  001de	76 06		 jbe	 SHORT $LN12@OnMovement
  001e0	0f 28 d8	 movaps	 xmm3, xmm0
  001e3	0f 28 c8	 movaps	 xmm1, xmm0
$LN12@OnMovement:

; 805  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  001e6	f3 0f 10 47 18	 movss	 xmm0, DWORD PTR [edi+24]
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001eb	f3 0f 5c cc	 subss	 xmm1, xmm4
  001ef	f3 0f 5c d5	 subss	 xmm2, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 805  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  001f3	f3 0f 59 c0	 mulss	 xmm0, xmm0
  001f7	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001f8	f3 0f 5c dc	 subss	 xmm3, xmm4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 808  : }

  001fc	5e		 pop	 esi
  001fd	5b		 pop	 ebx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  001fe	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00202	f3 0f 59 cb	 mulss	 xmm1, xmm3
  00206	f3 0f 58 ca	 addss	 xmm1, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 805  : 	if(GetVector3Distance(v3Point, v3Sphere) <= s.fRadius * s.fRadius) { return true; }

  0020a	0f 2f c1	 comiss	 xmm0, xmm1
  0020d	0f 93 c0	 setae	 al

; 808  : }

  00210	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00213	33 cd		 xor	 ecx, ebp
  00215	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0021a	8b e5		 mov	 esp, ebp
  0021c	5d		 pop	 ebp
  0021d	c2 04 00	 ret	 4
$LN45@OnMovement:
  00220	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00223	b0 01		 mov	 al, 1
  00225	5f		 pop	 edi
  00226	5e		 pop	 esi
  00227	33 cd		 xor	 ecx, ebp
  00229	5b		 pop	 ebx
  0022a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0022f	8b e5		 mov	 esp, ebp
  00231	5d		 pop	 ebp
  00232	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@COBBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; COBBCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnDestroy@COBBCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
?OnDestroy@COBBCollisionInstance@@MAEXXZ PROC		; COBBCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 862  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00004	a1 14 00 00 00	 mov	 eax, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+20
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 863  : 	gs_oci.Free(this);

  00009	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0000c	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+24
  00012	74 0d		 je	 SHORT $LN8@OnDestroy

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00016	83 05 14 00 00
	00 04		 add	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+20, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 864  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN8@OnDestroy:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00021	8d 4d fc	 lea	 ecx, DWORD PTR _pkData$[ebp]
  00024	51		 push	 ecx
  00025	50		 push	 eax
  00026	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16
  0002b	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_reallocate<COBBCollisionInstance * const &>
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 864  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?OnDestroy@COBBCollisionInstance@@MAEXXZ ENDP		; COBBCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; COBBCollisionInstance::Render, COMDAT
; _this$ = ecx

; 854  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 855  : 	static CScreen s;

  00025	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __tls_index
  00031	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00039	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0003f	7f 70		 jg	 SHORT $LN7@Render
$LN2@Render:

; 856  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00047	6a ff		 push	 -1
  00049	6a 3c		 push	 60			; 0000003cH
  0004b	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 857  : 	s.RenderCube(m_attribute.v3Min.x, m_attribute.v3Min.y, m_attribute.v3Min.z, m_attribute.v3Max.x, m_attribute.v3Max.y, m_attribute.v3Max.z, m_attribute.matRot);

  00050	0f 10 46 1c	 movups	 xmm0, XMMWORD PTR [esi+28]
  00054	83 ec 40	 sub	 esp, 64			; 00000040H
  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0005c	8b c4		 mov	 eax, esp
  0005e	83 ec 18	 sub	 esp, 24			; 00000018H
  00061	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00064	0f 10 46 2c	 movups	 xmm0, XMMWORD PTR [esi+44]
  00068	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  0006c	0f 10 46 3c	 movups	 xmm0, XMMWORD PTR [esi+60]
  00070	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  00074	0f 10 46 4c	 movups	 xmm0, XMMWORD PTR [esi+76]
  00078	0f 11 40 30	 movups	 XMMWORD PTR [eax+48], xmm0
  0007c	0f 10 46 0c	 movups	 xmm0, XMMWORD PTR [esi+12]
  00080	0f 11 44 24 08	 movups	 XMMWORD PTR [esp+8], xmm0
  00085	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  0008a	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00090	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  00095	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009a	e8 00 00 00 00	 call	 ?RenderCube@CScreen@@QAEXMMMMMMUD3DXMATRIX@@@Z ; CScreen::RenderCube

; 858  : 	return;
; 859  : }

  0009f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a9	59		 pop	 ecx
  000aa	5e		 pop	 esi
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
$LN7@Render:

; 855  : 	static CScreen s;

  000b1	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  000b6	e8 00 00 00 00	 call	 __Init_thread_header
  000bb	83 c4 04	 add	 esp, 4
  000be	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA, -1
  000c5	0f 85 76 ff ff
	ff		 jne	 $LN2@Render
  000cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  000d0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d7	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  000dc	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `COBBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  000e1	e8 00 00 00 00	 call	 _atexit
  000e6	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  000eb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f2	e8 00 00 00 00	 call	 __Init_thread_footer
  000f7	83 c4 08	 add	 esp, 8
  000fa	e9 42 ff ff ff	 jmp	 $LN2@Render
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@COBBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; COBBCollisionInstance::Render
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ
_TEXT	SEGMENT
?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ PROC ; COBBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 772  : 
; 773  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 774  : }

  00003	c3		 ret	 0
?GetAttribute@COBBCollisionInstance@@QBEABUSOBBData@@XZ ENDP ; COBBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ
_TEXT	SEGMENT
?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ PROC ; COBBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 767  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 768  : }

  00003	c3		 ret	 0
?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ ENDP ; COBBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
tv751 = 12						; size = 4
tv785 = 12						; size = 4
tv819 = 12						; size = 4
?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CAABBCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 696  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  : 
; 698  : 	//Tracef("OnGetCollisionMovementAdjust	v3Min.x = %f, v3Max.x = %f\n", m_attribute.v3Min.x, m_attribute.v3Max.x);
; 699  : 	/*
; 700  : 	float fARadius = D3DXVec3Length(&(m_attribute.v3Min - m_attribute.v3Max));
; 701  : 	if (D3DXVec3LengthSq(&(s.v3Position-(m_attribute.v3Max + m_attribute.v3Min)))>=(s.fRadius+fARadius)*(fARadius+s.fRadius))
; 702  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);
; 703  : 	D3DXVECTOR3 c;
; 704  : 	D3DXVec3Cross(&c, &(s.v3Position-s.v3LastPosition), &D3DXVECTOR3(0.0f,0.0f,1.0f) );
; 705  : 
; 706  : 	float sum = - D3DXVec3Dot(&c,&(s.v3Position-(m_attribute.v3Max + m_attribute.v3Min)));
; 707  : 	float mul = (s.fRadius+fARadius)*(s.fRadius+fARadius)-D3DXVec3LengthSq(&(s.v3Position-(m_attribute.v3Max + m_attribute.v3Min)));
; 708  : 
; 709  : 	if (sum*sum-4*mul<=0)
; 710  : 		return D3DXVECTOR3(0.0f,0.0f,0.0f);
; 711  : 	float sq = sqrt(sum*sum-4*mul);
; 712  : 	float t1=-sum-sq, t2=-sum+sq;
; 713  : 	t1*=0.5f;
; 714  : 	t2*=0.5f;
; 715  : 
; 716  : 	if (fabs(t1)<=fabs(t2))
; 717  : 	{
; 718  : 		return (gc_fReduceMove*t1)*c;
; 719  : 	}
; 720  : 	else
; 721  : 		return (gc_fReduceMove*t2)*c;
; 722  : 	*/
; 723  : 
; 724  : 	D3DXVECTOR3 v3Temp;
; 725  : 	if(s.v3Position.x + s.fRadius <= m_attribute.v3Min.x)		{ v3Temp.x = m_attribute.v3Min.x; }

  00003	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00006	f3 0f 10 61 04	 movss	 xmm4, DWORD PTR [ecx+4]
  0000b	f3 0f 10 08	 movss	 xmm1, DWORD PTR [eax]
  0000f	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00014	0f 28 d9	 movaps	 xmm3, xmm1
  00017	f3 0f 58 d8	 addss	 xmm3, xmm0
  0001b	0f 2f e3	 comiss	 xmm4, xmm3
  0001e	73 09		 jae	 SHORT $LN6@OnGetColli

; 726  : 	else if(s.v3Position.x - s.fRadius >= m_attribute.v3Max.x)	{ v3Temp.x = m_attribute.v3Max.x; }

  00020	f3 0f 10 51 10	 movss	 xmm2, DWORD PTR [ecx+16]
  00025	f3 0f 5c c8	 subss	 xmm1, xmm0
$LN6@OnGetColli:

; 727  : 	else if(s.v3Position.x + s.fRadius >= m_attribute.v3Min.x && s.v3Position.x + s.fRadius <= m_attribute.v3Max.x) { v3Temp.x = s.v3Position.x + s.fRadius; }
; 728  : 	else																											{ v3Temp.x = s.v3Position.x - s.fRadius; }
; 729  : 
; 730  : 	if (s.v3Position.y + s.fRadius <= m_attribute.v3Min.y) { v3Temp.y = m_attribute.v3Min.y; }

  00029	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0002e	f3 0f 10 61 08	 movss	 xmm4, DWORD PTR [ecx+8]
  00033	0f 28 d1	 movaps	 xmm2, xmm1
  00036	f3 0f 58 d0	 addss	 xmm2, xmm0
  0003a	0f 2f e2	 comiss	 xmm4, xmm2
  0003d	73 09		 jae	 SHORT $LN12@OnGetColli

; 731  : 	else if (s.v3Position.y - s.fRadius >= m_attribute.v3Max.y) { v3Temp.y = m_attribute.v3Max.y; }

  0003f	f3 0f 10 59 14	 movss	 xmm3, DWORD PTR [ecx+20]
  00044	f3 0f 5c c8	 subss	 xmm1, xmm0
$LN12@OnGetColli:

; 732  : 	else if (s.v3Position.y + s.fRadius >= m_attribute.v3Min.y && s.v3Position.y + s.fRadius <= m_attribute.v3Max.y) { v3Temp.y = s.v3Position.y + s.fRadius; }
; 733  : 	else { v3Temp.y = s.v3Position.y - s.fRadius; }
; 734  : 
; 735  : 	if (s.v3Position.z + s.fRadius <= m_attribute.v3Min.z) { v3Temp.z = m_attribute.v3Min.z; }

  00048	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  0004d	f3 0f 10 61 0c	 movss	 xmm4, DWORD PTR [ecx+12]
  00052	0f 28 d1	 movaps	 xmm2, xmm1
  00055	f3 0f 58 d0	 addss	 xmm2, xmm0
  00059	0f 2f e2	 comiss	 xmm4, xmm2
  0005c	73 09		 jae	 SHORT $LN18@OnGetColli

; 736  : 	else if (s.v3Position.z - s.fRadius >= m_attribute.v3Max.z) { v3Temp.z = m_attribute.v3Max.z; }

  0005e	f3 0f 10 59 18	 movss	 xmm3, DWORD PTR [ecx+24]
  00063	f3 0f 5c c8	 subss	 xmm1, xmm0
$LN18@OnGetColli:

; 737  : 	else if (s.v3Position.z + s.fRadius >= m_attribute.v3Min.z && s.v3Position.z + s.fRadius <= m_attribute.v3Max.z) { v3Temp.z = s.v3Position.z + s.fRadius; }
; 738  : 	else { v3Temp.z = s.v3Position.z - s.fRadius; }
; 739  : 
; 740  : 
; 741  : 	const auto vv = (v3Temp - s.v3Position);
; 742  : 	if (D3DXVec3LengthSq(&vv) < s.fRadius * s.fRadius)

  00067	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0006a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00070	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00077	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 743  : 		return D3DXVECTOR3(.0f, .0f, .0f);
; 744  : 
; 745  : 	return D3DXVECTOR3(.0f, .0f, .0f);
; 746  : 
; 747  : }

  0007e	5d		 pop	 ebp
  0007f	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CAABBCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CAABBCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_s$ = 8							; size = 4
tv821 = 8						; size = 4
?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CAABBCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 655  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 656  : 	D3DXVECTOR3 v;
; 657  : 	memcpy(&v, &s.v3Position, sizeof(D3DXVECTOR3));

  00006	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]

; 658  : 
; 659  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  00009	f3 0f 10 71 04	 movss	 xmm6, DWORD PTR [ecx+4]
  0000e	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00012	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00015	66 0f d6 45 f4	 movq	 QWORD PTR _v$[ebp], xmm0
  0001a	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp]
  0001f	0f 2f f0	 comiss	 xmm6, xmm0
  00022	89 45 fc	 mov	 DWORD PTR _v$[ebp+8], eax
  00025	76 03		 jbe	 SHORT $LN2@OnCollisio
  00027	0f 28 c6	 movaps	 xmm0, xmm6
$LN2@OnCollisio:

; 660  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  0002a	f3 0f 10 59 10	 movss	 xmm3, DWORD PTR [ecx+16]
  0002f	0f 2f c3	 comiss	 xmm0, xmm3
  00032	76 03		 jbe	 SHORT $LN3@OnCollisio
  00034	0f 28 c3	 movaps	 xmm0, xmm3
$LN3@OnCollisio:

; 661  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  00037	f3 0f 10 61 08	 movss	 xmm4, DWORD PTR [ecx+8]
  0003c	f3 0f 10 55 f8	 movss	 xmm2, DWORD PTR _v$[ebp+4]
  00041	0f 2f e2	 comiss	 xmm4, xmm2
  00044	76 03		 jbe	 SHORT $LN4@OnCollisio
  00046	0f 28 c4	 movaps	 xmm0, xmm4
$LN4@OnCollisio:

; 662  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  00049	f3 0f 10 69 14	 movss	 xmm5, DWORD PTR [ecx+20]
  0004e	0f 2f d5	 comiss	 xmm2, xmm5
  00051	76 03		 jbe	 SHORT $LN5@OnCollisio
  00053	0f 28 c5	 movaps	 xmm0, xmm5
$LN5@OnCollisio:

; 663  : 	if(v.z < m_attribute.v3Min.z) v.z = m_attribute.v3Min.z;

  00056	f3 0f 10 79 0c	 movss	 xmm7, DWORD PTR [ecx+12]
  0005b	f3 0f 10 4d fc	 movss	 xmm1, DWORD PTR _v$[ebp+8]
  00060	0f 2f f9	 comiss	 xmm7, xmm1
  00063	76 03		 jbe	 SHORT $LN6@OnCollisio
  00065	0f 28 cf	 movaps	 xmm1, xmm7
$LN6@OnCollisio:

; 664  : 	if(v.z > m_attribute.v3Max.z) v.z = m_attribute.v3Max.z;

  00068	f3 0f 10 79 18	 movss	 xmm7, DWORD PTR [ecx+24]
  0006d	0f 2f cf	 comiss	 xmm1, xmm7
  00070	76 03		 jbe	 SHORT $LN7@OnCollisio
  00072	0f 28 cf	 movaps	 xmm1, xmm7
$LN7@OnCollisio:

; 665  : 
; 666  : 	if(v.x > m_attribute.v3Min.x && v.x < m_attribute.v3Max.x &&
; 667  : 		v.y > m_attribute.v3Min.y && v.y < m_attribute.v3Max.y &&
; 668  : 		v.z > m_attribute.v3Min.z && v.z < m_attribute.v3Max.z) { return true; }

  00075	0f 2f c6	 comiss	 xmm0, xmm6
  00078	76 1e		 jbe	 SHORT $LN8@OnCollisio
  0007a	0f 2f d8	 comiss	 xmm3, xmm0
  0007d	76 19		 jbe	 SHORT $LN8@OnCollisio
  0007f	0f 2f d4	 comiss	 xmm2, xmm4
  00082	76 14		 jbe	 SHORT $LN8@OnCollisio
  00084	0f 2f ea	 comiss	 xmm5, xmm2
  00087	76 0f		 jbe	 SHORT $LN8@OnCollisio
  00089	0f 2f 49 0c	 comiss	 xmm1, DWORD PTR [ecx+12]
  0008d	76 09		 jbe	 SHORT $LN8@OnCollisio
  0008f	0f 2f f9	 comiss	 xmm7, xmm1
  00092	0f 87 cd 00 00
	00		 ja	 $LN23@OnCollisio
$LN8@OnCollisio:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00098	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]
  0009c	f3 0f 5c 52 04	 subss	 xmm2, DWORD PTR [edx+4]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 670  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius) { return true; }

  000a1	f3 0f 10 4a 18	 movss	 xmm1, DWORD PTR [edx+24]
  000a6	f3 0f 59 c9	 mulss	 xmm1, xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  000aa	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000ae	f3 0f 59 d2	 mulss	 xmm2, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 670  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius) { return true; }

  000b2	f3 0f 11 4d 08	 movss	 DWORD PTR tv821[ebp], xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  000b7	f3 0f 58 c2	 addss	 xmm0, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 670  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius) { return true; }

  000bb	0f 2f c8	 comiss	 xmm1, xmm0
  000be	0f 83 a1 00 00
	00		 jae	 $LN23@OnCollisio

; 671  : 
; 672  : 
; 673  : 	memcpy(&v, &s.v3LastPosition, sizeof(D3DXVECTOR3));

  000c4	f3 0f 7e 42 0c	 movq	 xmm0, QWORD PTR [edx+12]
  000c9	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000cc	66 0f d6 45 f4	 movq	 QWORD PTR _v$[ebp], xmm0

; 674  : 
; 675  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  000d1	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp]
  000d6	0f 2f f0	 comiss	 xmm6, xmm0
  000d9	89 45 fc	 mov	 DWORD PTR _v$[ebp+8], eax
  000dc	76 03		 jbe	 SHORT $LN10@OnCollisio
  000de	0f 28 c6	 movaps	 xmm0, xmm6
$LN10@OnCollisio:

; 676  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  000e1	0f 2f c3	 comiss	 xmm0, xmm3
  000e4	76 03		 jbe	 SHORT $LN11@OnCollisio
  000e6	0f 28 c3	 movaps	 xmm0, xmm3
$LN11@OnCollisio:

; 677  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  000e9	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _v$[ebp+4]
  000ee	0f 2f e1	 comiss	 xmm4, xmm1
  000f1	76 03		 jbe	 SHORT $LN12@OnCollisio
  000f3	0f 28 c4	 movaps	 xmm0, xmm4
$LN12@OnCollisio:

; 678  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  000f6	0f 2f cd	 comiss	 xmm1, xmm5
  000f9	76 03		 jbe	 SHORT $LN13@OnCollisio
  000fb	0f 28 c5	 movaps	 xmm0, xmm5
$LN13@OnCollisio:

; 679  : 	if(v.z < m_attribute.v3Min.z) v.z = m_attribute.v3Min.z;

  000fe	f3 0f 10 79 0c	 movss	 xmm7, DWORD PTR [ecx+12]
  00103	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR _v$[ebp+8]
  00108	0f 2f fa	 comiss	 xmm7, xmm2
  0010b	f3 0f 10 79 18	 movss	 xmm7, DWORD PTR [ecx+24]
  00110	76 05		 jbe	 SHORT $LN14@OnCollisio
  00112	f3 0f 10 51 0c	 movss	 xmm2, DWORD PTR [ecx+12]
$LN14@OnCollisio:

; 680  : 	if(v.z > m_attribute.v3Max.z) v.z = m_attribute.v3Max.z;

  00117	0f 2f d7	 comiss	 xmm2, xmm7
  0011a	76 03		 jbe	 SHORT $LN15@OnCollisio
  0011c	0f 28 d7	 movaps	 xmm2, xmm7
$LN15@OnCollisio:

; 681  : 
; 682  : 
; 683  : 
; 684  : 	if(v.x > m_attribute.v3Min.x && v.x < m_attribute.v3Max.x &&
; 685  : 		v.y > m_attribute.v3Min.y && v.y < m_attribute.v3Max.y &&
; 686  : 		v.z > m_attribute.v3Min.z && v.z < m_attribute.v3Max.z) { return true; }

  0011f	0f 2f c6	 comiss	 xmm0, xmm6
  00122	76 1a		 jbe	 SHORT $LN16@OnCollisio
  00124	0f 2f d8	 comiss	 xmm3, xmm0
  00127	76 15		 jbe	 SHORT $LN16@OnCollisio
  00129	0f 2f cc	 comiss	 xmm1, xmm4
  0012c	76 10		 jbe	 SHORT $LN16@OnCollisio
  0012e	0f 2f e9	 comiss	 xmm5, xmm1
  00131	76 0b		 jbe	 SHORT $LN16@OnCollisio
  00133	0f 2f 51 0c	 comiss	 xmm2, DWORD PTR [ecx+12]
  00137	76 05		 jbe	 SHORT $LN16@OnCollisio
  00139	0f 2f fa	 comiss	 xmm7, xmm2
  0013c	77 27		 ja	 SHORT $LN23@OnCollisio
$LN16@OnCollisio:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0013e	f3 0f 5c 4a 10	 subss	 xmm1, DWORD PTR [edx+16]
  00143	f3 0f 5c 42 0c	 subss	 xmm0, DWORD PTR [edx+12]
  00148	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0014c	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00150	f3 0f 58 c1	 addss	 xmm0, xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 688  : 	if(GetVector3Distance(v, s.v3LastPosition) <= s.fRadius * s.fRadius) { return true; }

  00154	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR tv821[ebp]
  00159	0f 2f c8	 comiss	 xmm1, xmm0
  0015c	0f 93 c0	 setae	 al

; 689  : 
; 690  : 
; 691  : 
; 692  : 	return false;
; 693  : }

  0015f	8b e5		 mov	 esp, ebp
  00161	5d		 pop	 ebp
  00162	c2 04 00	 ret	 4
$LN23@OnCollisio:

; 688  : 	if(GetVector3Distance(v, s.v3LastPosition) <= s.fRadius * s.fRadius) { return true; }

  00165	b0 01		 mov	 al, 1

; 689  : 
; 690  : 
; 691  : 
; 692  : 	return false;
; 693  : }

  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CAABBCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_v$ = -12						; size = 12
_s$ = 8							; size = 4
?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CAABBCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 616  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 617  : 	D3DXVECTOR3 v;
; 618  : 	D3DXVECTOR3 v3center = (m_attribute.v3Min + m_attribute.v3Max) * 0.5f;
; 619  : 
; 620  : 	memcpy(&v, &s.v3Position, sizeof(D3DXVECTOR3));

  00006	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]

; 621  : 
; 622  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  00009	f3 0f 10 61 04	 movss	 xmm4, DWORD PTR [ecx+4]
  0000e	f3 0f 7e 02	 movq	 xmm0, QWORD PTR [edx]
  00012	66 0f d6 45 f4	 movq	 QWORD PTR _v$[ebp], xmm0
  00017	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp]
  0001c	0f 2f e0	 comiss	 xmm4, xmm0
  0001f	76 03		 jbe	 SHORT $LN2@OnMovement
  00021	0f 28 c4	 movaps	 xmm0, xmm4
$LN2@OnMovement:

; 623  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  00024	f3 0f 10 49 10	 movss	 xmm1, DWORD PTR [ecx+16]
  00029	0f 2f c1	 comiss	 xmm0, xmm1
  0002c	76 03		 jbe	 SHORT $LN3@OnMovement
  0002e	0f 28 c1	 movaps	 xmm0, xmm1
$LN3@OnMovement:

; 624  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  00031	f3 0f 10 59 08	 movss	 xmm3, DWORD PTR [ecx+8]
  00036	f3 0f 10 6d f8	 movss	 xmm5, DWORD PTR _v$[ebp+4]
  0003b	0f 2f dd	 comiss	 xmm3, xmm5
  0003e	76 03		 jbe	 SHORT $LN4@OnMovement
  00040	0f 28 c3	 movaps	 xmm0, xmm3
$LN4@OnMovement:

; 625  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  00043	f3 0f 10 51 14	 movss	 xmm2, DWORD PTR [ecx+20]
  00048	0f 2f ea	 comiss	 xmm5, xmm2
  0004b	76 03		 jbe	 SHORT $LN5@OnMovement
  0004d	0f 28 c2	 movaps	 xmm0, xmm2
$LN5@OnMovement:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00050	f3 0f 5c 02	 subss	 xmm0, DWORD PTR [edx]
  00054	f3 0f 5c 6a 04	 subss	 xmm5, DWORD PTR [edx+4]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 629  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius)

  00059	f3 0f 10 72 18	 movss	 xmm6, DWORD PTR [edx+24]
  0005e	f3 0f 59 f6	 mulss	 xmm6, xmm6
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00062	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00066	f3 0f 59 ed	 mulss	 xmm5, xmm5
  0006a	f3 0f 58 c5	 addss	 xmm0, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 629  : 	if(GetVector3Distance(v, s.v3Position) <= s.fRadius * s.fRadius)

  0006e	0f 2f f0	 comiss	 xmm6, xmm0
  00071	73 56		 jae	 SHORT $LN29@OnMovement

; 630  : 	{
; 631  : 
; 632  : 		return true;
; 633  : 	}
; 634  : 
; 635  : 
; 636  : 	memcpy(&v, &s.v3LastPosition, sizeof(D3DXVECTOR3));

  00073	f3 0f 7e 42 0c	 movq	 xmm0, QWORD PTR [edx+12]
  00078	66 0f d6 45 f4	 movq	 QWORD PTR _v$[ebp], xmm0

; 637  : 
; 638  : 	if(v.x < m_attribute.v3Min.x) v.x = m_attribute.v3Min.x;

  0007d	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v$[ebp]
  00082	0f 2f e0	 comiss	 xmm4, xmm0
  00085	76 03		 jbe	 SHORT $LN9@OnMovement
  00087	0f 28 c4	 movaps	 xmm0, xmm4
$LN9@OnMovement:

; 639  : 	if(v.x > m_attribute.v3Max.x) v.x = m_attribute.v3Max.x;

  0008a	0f 2f c1	 comiss	 xmm0, xmm1
  0008d	76 03		 jbe	 SHORT $LN10@OnMovement
  0008f	0f 28 c1	 movaps	 xmm0, xmm1
$LN10@OnMovement:

; 640  : 	if(v.y < m_attribute.v3Min.y) v.x = m_attribute.v3Min.y;

  00092	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _v$[ebp+4]
  00097	0f 2f d9	 comiss	 xmm3, xmm1
  0009a	76 03		 jbe	 SHORT $LN11@OnMovement
  0009c	0f 28 c3	 movaps	 xmm0, xmm3
$LN11@OnMovement:

; 641  : 	if(v.y > m_attribute.v3Max.y) v.x = m_attribute.v3Max.y;

  0009f	0f 2f ca	 comiss	 xmm1, xmm2
  000a2	76 03		 jbe	 SHORT $LN12@OnMovement
  000a4	0f 28 c2	 movaps	 xmm0, xmm2
$LN12@OnMovement:
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  000a7	f3 0f 5c 4a 10	 subss	 xmm1, DWORD PTR [edx+16]
  000ac	f3 0f 5c 42 0c	 subss	 xmm0, DWORD PTR [edx+12]
  000b1	f3 0f 59 c9	 mulss	 xmm1, xmm1
  000b5	f3 0f 59 c0	 mulss	 xmm0, xmm0
  000b9	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 645  : 	if(GetVector3Distance(v, s.v3LastPosition) <= s.fRadius * s.fRadius)

  000bd	0f 2f f1	 comiss	 xmm6, xmm1
  000c0	0f 93 c0	 setae	 al

; 649  : 	}
; 650  : 
; 651  : 	return false;
; 652  : }

  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c2 04 00	 ret	 4
$LN29@OnMovement:

; 646  : 	{
; 647  : 
; 648  : 		return true;

  000c9	b0 01		 mov	 al, 1

; 649  : 	}
; 650  : 
; 651  : 	return false;
; 652  : }

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CAABBCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CAABBCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnDestroy@CAABBCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
?OnDestroy@CAABBCollisionInstance@@MAEXXZ PROC		; CAABBCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 758  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00004	a1 14 00 00 00	 mov	 eax, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+20
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 759  : 	gs_aci.Free(this);

  00009	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0000c	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+24
  00012	74 0d		 je	 SHORT $LN8@OnDestroy

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00016	83 05 14 00 00
	00 04		 add	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+20, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 760  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN8@OnDestroy:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00021	8d 4d fc	 lea	 ecx, DWORD PTR _pkData$[ebp]
  00024	51		 push	 ecx
  00025	50		 push	 eax
  00026	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+16
  0002b	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCAABBCollisionInstance@@@?$vector@PAVCAABBCollisionInstance@@V?$allocator@PAVCAABBCollisionInstance@@@std@@@std@@AAEPAPAVCAABBCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAABBCollisionInstance *,std::allocator<CAABBCollisionInstance *> >::_Emplace_reallocate<CAABBCollisionInstance * const &>
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 760  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?OnDestroy@CAABBCollisionInstance@@MAEXXZ ENDP		; CAABBCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CAABBCollisionInstance::Render, COMDAT
; _this$ = ecx

; 750  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 751  : 	static CScreen s;

  00025	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __tls_index
  00031	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00039	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0003f	7f 4c		 jg	 SHORT $LN7@Render
$LN2@Render:

; 752  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00047	6a ff		 push	 -1
  00049	6a 3c		 push	 60			; 0000003cH
  0004b	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 753  : 	s.RenderCube(m_attribute.v3Min.x, m_attribute.v3Min.y, m_attribute.v3Min.z, m_attribute.v3Max.x, m_attribute.v3Max.y, m_attribute.v3Max.z);

  00050	0f 10 46 0c	 movups	 xmm0, XMMWORD PTR [esi+12]
  00054	83 ec 18	 sub	 esp, 24			; 00000018H
  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0005c	0f 11 44 24 08	 movups	 XMMWORD PTR [esp+8], xmm0
  00061	f3 0f 10 46 08	 movss	 xmm0, DWORD PTR [esi+8]
  00066	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  0006c	f3 0f 10 46 04	 movss	 xmm0, DWORD PTR [esi+4]
  00071	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00076	e8 00 00 00 00	 call	 ?RenderCube@CScreen@@QAEXMMMMMM@Z ; CScreen::RenderCube

; 754  : 	return;
; 755  : }

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	5e		 pop	 esi
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 04 00	 ret	 4
$LN7@Render:

; 751  : 	static CScreen s;

  0008d	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00092	e8 00 00 00 00	 call	 __Init_thread_header
  00097	83 c4 04	 add	 esp, 4
  0009a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA, -1
  000a1	75 9e		 jne	 SHORT $LN2@Render
  000a3	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  000a8	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000af	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  000b4	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CAABBCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  000b9	e8 00 00 00 00	 call	 _atexit
  000be	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  000c3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ca	e8 00 00 00 00	 call	 __Init_thread_footer
  000cf	83 c4 08	 add	 esp, 8
  000d2	e9 6a ff ff ff	 jmp	 $LN2@Render
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CAABBCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CAABBCollisionInstance::Render
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ
_TEXT	SEGMENT
?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ PROC ; CAABBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 611  : 
; 612  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 613  : }

  00003	c3		 ret	 0
?GetAttribute@CAABBCollisionInstance@@QBEABUSAABBData@@XZ ENDP ; CAABBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ
_TEXT	SEGMENT
?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ PROC ; CAABBCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 606  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 607  : }

  00003	c3		 ret	 0
?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ ENDP ; CAABBCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
tv889 = -20						; size = 8
tv918 = -12						; size = 4
tv934 = -8						; size = 4
tv921 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CPlaneCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 393  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	8b 55 0c	 mov	 edx, DWORD PTR _s$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00009	f3 0f 10 59 14	 movss	 xmm3, DWORD PTR [ecx+20]
  0000e	f3 0f 10 61 18	 movss	 xmm4, DWORD PTR [ecx+24]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 393  : {

  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00016	f3 0f 10 72 08	 movss	 xmm6, DWORD PTR [edx+8]
  0001b	f3 0f 10 2a	 movss	 xmm5, DWORD PTR [edx]
  0001f	0f 28 d6	 movaps	 xmm2, xmm6
  00022	f3 0f 10 4a 04	 movss	 xmm1, DWORD PTR [edx+4]
  00027	0f 28 c5	 movaps	 xmm0, xmm5
  0002a	f3 0f 5c 42 0c	 subss	 xmm0, DWORD PTR [edx+12]
  0002f	f3 0f 5c 52 14	 subss	 xmm2, DWORD PTR [edx+20]
  00034	0f 28 f9	 movaps	 xmm7, xmm1
  00037	f3 0f 5c 7a 10	 subss	 xmm7, DWORD PTR [edx+16]
  0003c	f3 0f 11 45 f8	 movss	 DWORD PTR tv934[ebp], xmm0
  00041	f3 0f 11 55 fc	 movss	 DWORD PTR tv921[ebp], xmm2

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00046	f3 0f 10 51 10	 movss	 xmm2, DWORD PTR [ecx+16]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0004b	f3 0f 11 7d f4	 movss	 DWORD PTR tv918[ebp], xmm7

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00050	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00054	f3 0f 59 fb	 mulss	 xmm7, xmm3
  00058	f3 0f 58 f8	 addss	 xmm7, xmm0
  0005c	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR tv921[ebp]
  00061	f3 0f 59 c4	 mulss	 xmm0, xmm4
  00065	f3 0f 58 f8	 addss	 xmm7, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 397  : 	if (d >= -0.0001 && d <= 0.0001)

  00069	0f 5a c7	 cvtps2pd xmm0, xmm7
  0006c	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@bf1a36e2eb1c432d
  00074	f2 0f 11 45 ec	 movsd	 QWORD PTR tv889[ebp], xmm0
  00079	72 29		 jb	 SHORT $LN2@OnGetColli
  0007b	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f1a36e2eb1c432d
  00083	66 0f 2f 45 ec	 comisd	 xmm0, QWORD PTR tv889[ebp]
  00088	72 1a		 jb	 SHORT $LN2@OnGetColli
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  0008a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 181  :     y = fy;

  00090	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 182  :     z = fz;

  00097	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 457  : }

  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 08 00	 ret	 8
$LN2@OnGetColli:

; 404  : 	if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)

  000a4	0f 2f 3d 00 00
	00 00		 comiss	 xmm7, DWORD PTR __real@00000000
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000ab	f3 0f 5c 49 08	 subss	 xmm1, DWORD PTR [ecx+8]
  000b0	f3 0f 5c 69 04	 subss	 xmm5, DWORD PTR [ecx+4]
  000b5	f3 0f 5c 71 0c	 subss	 xmm6, DWORD PTR [ecx+12]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 404  : 	if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)

  000ba	f3 0f 10 42 18	 movss	 xmm0, DWORD PTR [edx+24]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000bf	f3 0f 59 cb	 mulss	 xmm1, xmm3
  000c3	f3 0f 59 ea	 mulss	 xmm5, xmm2
  000c7	f3 0f 59 f4	 mulss	 xmm6, xmm4
  000cb	f3 0f 58 cd	 addss	 xmm1, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 404  : 	if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)

  000cf	f3 0f 59 d0	 mulss	 xmm2, xmm0
  000d3	f3 0f 59 d8	 mulss	 xmm3, xmm0
  000d7	f3 0f 59 e0	 mulss	 xmm4, xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000db	f3 0f 58 ce	 addss	 xmm1, xmm6
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 400  : 	float t = -D3DXVec3Dot(&m_attribute.v3Normal, &vv) / d;

  000df	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  000e6	f3 0f 5e cf	 divss	 xmm1, xmm7

; 404  : 	if (D3DXVec3Dot(&m_attribute.v3Normal, &advance)>=0)

  000ea	0f 28 e9	 movaps	 xmm5, xmm1
  000ed	0f 28 f1	 movaps	 xmm6, xmm1
  000f0	f3 0f 59 6d f8	 mulss	 xmm5, DWORD PTR tv934[ebp]
  000f5	f3 0f 59 75 f4	 mulss	 xmm6, DWORD PTR tv918[ebp]
  000fa	f3 0f 59 4d fc	 mulss	 xmm1, DWORD PTR tv921[ebp]
  000ff	72 20		 jb	 SHORT $LN3@OnGetColli
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00101	f3 0f 5c ea	 subss	 xmm5, xmm2
  00105	f3 0f 5c f3	 subss	 xmm6, xmm3
  00109	f3 0f 5c cc	 subss	 xmm1, xmm4

; 180  :     x = fx;

  0010d	f3 0f 11 28	 movss	 DWORD PTR [eax], xmm5

; 181  :     y = fy;

  00111	f3 0f 11 70 04	 movss	 DWORD PTR [eax+4], xmm6

; 182  :     z = fz;

  00116	f3 0f 11 48 08	 movss	 DWORD PTR [eax+8], xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 457  : }

  0011b	8b e5		 mov	 esp, ebp
  0011d	5d		 pop	 ebp
  0011e	c2 08 00	 ret	 8
$LN3@OnGetColli:
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00121	f3 0f 58 d5	 addss	 xmm2, xmm5
  00125	f3 0f 58 de	 addss	 xmm3, xmm6
  00129	f3 0f 58 e1	 addss	 xmm4, xmm1

; 180  :     x = fx;

  0012d	f3 0f 11 10	 movss	 DWORD PTR [eax], xmm2

; 181  :     y = fy;

  00131	f3 0f 11 58 04	 movss	 DWORD PTR [eax+4], xmm3

; 182  :     z = fz;

  00136	f3 0f 11 60 08	 movss	 DWORD PTR [eax+8], xmm4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 457  : }

  0013b	8b e5		 mov	 esp, ebp
  0013d	5d		 pop	 ebp
  0013e	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CPlaneCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CPlaneCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
_fPosition2$1$ = -4					; size = 4
_s$ = 8							; size = 4
_fPosition1$1$ = 8					; size = 4
tv986 = 8						; size = 4
?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CPlaneCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00004	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00007	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0000c	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00011	f3 0f 59 41 14	 mulss	 xmm0, DWORD PTR [ecx+20]
  00016	f3 0f 11 45 08	 movss	 DWORD PTR _fPosition1$1$[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0001b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0001f	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00024	f3 0f 10 7d 08	 movss	 xmm7, DWORD PTR _fPosition1$1$[ebp]
  00029	f3 0f 59 41 10	 mulss	 xmm0, DWORD PTR [ecx+16]
  0002e	f3 0f 58 f8	 addss	 xmm7, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00032	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00037	f3 0f 5c 41 0c	 subss	 xmm0, DWORD PTR [ecx+12]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0003c	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
  00041	f3 0f 58 f8	 addss	 xmm7, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00045	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0004a	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0004f	f3 0f 11 7d 08	 movss	 DWORD PTR _fPosition1$1$[ebp], xmm7

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00054	f3 0f 10 78 10	 movss	 xmm7, DWORD PTR [eax+16]
  00059	f3 0f 5c 79 08	 subss	 xmm7, DWORD PTR [ecx+8]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0005e	f3 0f 59 41 10	 mulss	 xmm0, DWORD PTR [ecx+16]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 375  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  00063	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fPosition1$1$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00068	f3 0f 59 79 14	 mulss	 xmm7, DWORD PTR [ecx+20]
  0006d	f3 0f 58 f8	 addss	 xmm7, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00071	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00076	f3 0f 5c 41 0c	 subss	 xmm0, DWORD PTR [ecx+12]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0007b	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
  00080	f3 0f 58 f8	 addss	 xmm7, xmm0
  00084	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 375  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  00087	0f 2f c8	 comiss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0008a	f3 0f 11 7d fc	 movss	 DWORD PTR _fPosition2$1$[ebp], xmm7
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 375  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  0008f	f3 0f 10 78 04	 movss	 xmm7, DWORD PTR [eax+4]
  00094	f3 0f 10 55 fc	 movss	 xmm2, DWORD PTR _fPosition2$1$[ebp]
  00099	76 05		 jbe	 SHORT $LN4@OnCollisio
  0009b	0f 2f c2	 comiss	 xmm0, xmm2
  0009e	77 28		 ja	 SHORT $LN3@OnCollisio
$LN4@OnCollisio:
  000a0	0f 2f c1	 comiss	 xmm0, xmm1
  000a3	76 05		 jbe	 SHORT $LN5@OnCollisio
  000a5	0f 2f d0	 comiss	 xmm2, xmm0
  000a8	77 1e		 ja	 SHORT $LN3@OnCollisio
$LN5@OnCollisio:
  000aa	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000af	0f 2f c1	 comiss	 xmm0, xmm1
  000b2	0f 82 e1 00 00
	00		 jb	 $LN9@OnCollisio
  000b8	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000bf	0f 2f c8	 comiss	 xmm1, xmm0
  000c2	0f 82 d1 00 00
	00		 jb	 $LN9@OnCollisio
$LN3@OnCollisio:
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000c8	f3 0f 10 60 08	 movss	 xmm4, DWORD PTR [eax+8]
  000cd	0f 28 d7	 movaps	 xmm2, xmm7
  000d0	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  000d4	0f 28 c4	 movaps	 xmm0, xmm4
  000d7	f3 0f 5c 41 24	 subss	 xmm0, DWORD PTR [ecx+36]
  000dc	f3 0f 5c 51 20	 subss	 xmm2, DWORD PTR [ecx+32]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 380  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  000e1	f3 0f 10 68 18	 movss	 xmm5, DWORD PTR [eax+24]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000e6	0f 28 f3	 movaps	 xmm6, xmm3
  000e9	f3 0f 5c 71 1c	 subss	 xmm6, DWORD PTR [ecx+28]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 380  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  000ee	0f 57 2d 00 00
	00 00		 xorps	 xmm5, DWORD PTR __xmm@80000000800000008000000080000000
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000f5	f3 0f 5c 59 40	 subss	 xmm3, DWORD PTR [ecx+64]
  000fa	f3 0f 5c 79 44	 subss	 xmm7, DWORD PTR [ecx+68]
  000ff	f3 0f 5c 61 48	 subss	 xmm4, DWORD PTR [ecx+72]
  00104	f3 0f 11 45 08	 movss	 DWORD PTR tv986[ebp], xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00109	0f 28 ca	 movaps	 xmm1, xmm2
  0010c	f3 0f 59 49 50	 mulss	 xmm1, DWORD PTR [ecx+80]
  00111	0f 28 c6	 movaps	 xmm0, xmm6
  00114	f3 0f 59 41 4c	 mulss	 xmm0, DWORD PTR [ecx+76]
  00119	f3 0f 58 c8	 addss	 xmm1, xmm0
  0011d	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR tv986[ebp]
  00122	f3 0f 59 41 54	 mulss	 xmm0, DWORD PTR [ecx+84]
  00127	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 380  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  0012b	0f 2f cd	 comiss	 xmm1, xmm5
  0012e	76 69		 jbe	 SHORT $LN9@OnCollisio
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00130	f3 0f 59 51 5c	 mulss	 xmm2, DWORD PTR [ecx+92]
  00135	f3 0f 59 71 58	 mulss	 xmm6, DWORD PTR [ecx+88]
  0013a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR tv986[ebp]
  0013f	f3 0f 59 41 60	 mulss	 xmm0, DWORD PTR [ecx+96]
  00144	f3 0f 58 d6	 addss	 xmm2, xmm6
  00148	f3 0f 58 d0	 addss	 xmm2, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 381  : 			if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[1]) > -s.fRadius/*0.0f*/)

  0014c	0f 2f d5	 comiss	 xmm2, xmm5
  0014f	76 48		 jbe	 SHORT $LN9@OnCollisio
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00151	0f 28 c3	 movaps	 xmm0, xmm3
  00154	0f 28 cf	 movaps	 xmm1, xmm7
  00157	f3 0f 59 41 64	 mulss	 xmm0, DWORD PTR [ecx+100]
  0015c	f3 0f 59 49 68	 mulss	 xmm1, DWORD PTR [ecx+104]
  00161	f3 0f 58 c8	 addss	 xmm1, xmm0
  00165	0f 28 c4	 movaps	 xmm0, xmm4
  00168	f3 0f 59 41 6c	 mulss	 xmm0, DWORD PTR [ecx+108]
  0016d	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 382  : 				if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[2]) > - s.fRadius/*0.0f*/)

  00171	0f 2f cd	 comiss	 xmm1, xmm5
  00174	76 23		 jbe	 SHORT $LN9@OnCollisio
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00176	f3 0f 59 79 74	 mulss	 xmm7, DWORD PTR [ecx+116]
  0017b	f3 0f 59 59 70	 mulss	 xmm3, DWORD PTR [ecx+112]
  00180	f3 0f 59 61 78	 mulss	 xmm4, DWORD PTR [ecx+120]
  00185	f3 0f 58 fb	 addss	 xmm7, xmm3
  00189	f3 0f 58 fc	 addss	 xmm7, xmm4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 383  : 					if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[3]) > - s.fRadius/*0.0f*/)

  0018d	0f 2f fd	 comiss	 xmm7, xmm5
  00190	0f 97 c0	 seta	 al

; 390  : }

  00193	8b e5		 mov	 esp, ebp
  00195	5d		 pop	 ebp
  00196	c2 04 00	 ret	 4
$LN9@OnCollisio:

; 384  : 					{
; 385  : 						return true;
; 386  : 					}
; 387  : 	}
; 388  : 
; 389  : 	return false;

  00199	32 c0		 xor	 al, al

; 390  : }

  0019b	8b e5		 mov	 esp, ebp
  0019d	5d		 pop	 ebp
  0019e	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CPlaneCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
tv1220 = -8						; size = 4
_fPosition2$1$ = -4					; size = 4
_s$ = 8							; size = 4
_fPosition1$1$ = 8					; size = 4
tv1221 = 8						; size = 4
?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CPlaneCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 335  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00006	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00009	0f 57 c9	 xorps	 xmm1, xmm1
  0000c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00011	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00016	f3 0f 59 41 14	 mulss	 xmm0, DWORD PTR [ecx+20]
  0001b	f3 0f 11 45 08	 movss	 DWORD PTR _fPosition1$1$[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00020	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00024	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00029	f3 0f 10 7d 08	 movss	 xmm7, DWORD PTR _fPosition1$1$[ebp]
  0002e	f3 0f 59 41 10	 mulss	 xmm0, DWORD PTR [ecx+16]
  00033	f3 0f 58 f8	 addss	 xmm7, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00037	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0003c	f3 0f 5c 41 0c	 subss	 xmm0, DWORD PTR [ecx+12]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00041	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
  00046	f3 0f 58 f8	 addss	 xmm7, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0004a	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0004f	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00054	f3 0f 11 7d 08	 movss	 DWORD PTR _fPosition1$1$[ebp], xmm7

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00059	f3 0f 10 78 10	 movss	 xmm7, DWORD PTR [eax+16]
  0005e	f3 0f 5c 79 08	 subss	 xmm7, DWORD PTR [ecx+8]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00063	f3 0f 59 41 10	 mulss	 xmm0, DWORD PTR [ecx+16]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 343  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  00068	f3 0f 10 6d 08	 movss	 xmm5, DWORD PTR _fPosition1$1$[ebp]
  0006d	0f 2f e9	 comiss	 xmm5, xmm1
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00070	f3 0f 59 79 14	 mulss	 xmm7, DWORD PTR [ecx+20]
  00075	f3 0f 58 f8	 addss	 xmm7, xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00079	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0007e	f3 0f 5c 41 0c	 subss	 xmm0, DWORD PTR [ecx+12]

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00083	f3 0f 59 41 18	 mulss	 xmm0, DWORD PTR [ecx+24]
  00088	f3 0f 58 f8	 addss	 xmm7, xmm0
  0008c	f3 0f 11 7d fc	 movss	 DWORD PTR _fPosition2$1$[ebp], xmm7
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 343  : 		|| (fPosition1) <= s.fRadius && fPosition1 >= -s.fRadius)

  00091	f3 0f 10 78 04	 movss	 xmm7, DWORD PTR [eax+4]
  00096	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fPosition2$1$[ebp]
  0009b	76 05		 jbe	 SHORT $LN4@OnMovement
  0009d	0f 2f c8	 comiss	 xmm1, xmm0
  000a0	77 28		 ja	 SHORT $LN3@OnMovement
$LN4@OnMovement:
  000a2	0f 2f cd	 comiss	 xmm1, xmm5
  000a5	76 05		 jbe	 SHORT $LN5@OnMovement
  000a7	0f 2f c1	 comiss	 xmm0, xmm1
  000aa	77 1e		 ja	 SHORT $LN3@OnMovement
$LN5@OnMovement:
  000ac	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000b1	0f 2f c5	 comiss	 xmm0, xmm5
  000b4	0f 82 0b 01 00
	00		 jb	 $LN10@OnMovement
  000ba	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000c1	0f 2f e8	 comiss	 xmm5, xmm0
  000c4	0f 82 fb 00 00
	00		 jb	 $LN10@OnMovement
$LN3@OnMovement:
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000ca	f3 0f 10 60 08	 movss	 xmm4, DWORD PTR [eax+8]
  000cf	0f 28 d7	 movaps	 xmm2, xmm7
  000d2	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  000d6	0f 28 cc	 movaps	 xmm1, xmm4
  000d9	f3 0f 5c 49 24	 subss	 xmm1, DWORD PTR [ecx+36]
  000de	f3 0f 5c 51 20	 subss	 xmm2, DWORD PTR [ecx+32]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 348  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  000e3	f3 0f 10 70 18	 movss	 xmm6, DWORD PTR [eax+24]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000e8	0f 28 c3	 movaps	 xmm0, xmm3
  000eb	f3 0f 5c 41 1c	 subss	 xmm0, DWORD PTR [ecx+28]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 348  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  000f0	0f 57 35 00 00
	00 00		 xorps	 xmm6, DWORD PTR __xmm@80000000800000008000000080000000
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000f7	f3 0f 5c 59 40	 subss	 xmm3, DWORD PTR [ecx+64]
  000fc	f3 0f 5c 79 44	 subss	 xmm7, DWORD PTR [ecx+68]
  00101	f3 0f 5c 61 48	 subss	 xmm4, DWORD PTR [ecx+72]
  00106	f3 0f 11 4d 08	 movss	 DWORD PTR tv1221[ebp], xmm1

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0010b	0f 28 ca	 movaps	 xmm1, xmm2
  0010e	f3 0f 59 49 50	 mulss	 xmm1, DWORD PTR [ecx+80]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00113	f3 0f 11 45 f8	 movss	 DWORD PTR tv1220[ebp], xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00118	f3 0f 59 41 4c	 mulss	 xmm0, DWORD PTR [ecx+76]
  0011d	f3 0f 58 c8	 addss	 xmm1, xmm0
  00121	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR tv1221[ebp]
  00126	f3 0f 59 41 54	 mulss	 xmm0, DWORD PTR [ecx+84]
  0012b	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 348  : 		if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[0]) > - s.fRadius/*0.0f*/)

  0012f	0f 2f ce	 comiss	 xmm1, xmm6
  00132	0f 86 8d 00 00
	00		 jbe	 $LN10@OnMovement
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00138	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv1220[ebp]
  0013d	f3 0f 59 41 58	 mulss	 xmm0, DWORD PTR [ecx+88]
  00142	f3 0f 59 51 5c	 mulss	 xmm2, DWORD PTR [ecx+92]
  00147	f3 0f 58 d0	 addss	 xmm2, xmm0
  0014b	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR tv1221[ebp]
  00150	f3 0f 59 41 60	 mulss	 xmm0, DWORD PTR [ecx+96]
  00155	f3 0f 58 d0	 addss	 xmm2, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 349  : 			if (D3DXVec3Dot(&v3QuadPosition1, &m_attribute.v3InsideVector[1]) > -s.fRadius/*0.0f*/)

  00159	0f 2f d6	 comiss	 xmm2, xmm6
  0015c	76 67		 jbe	 SHORT $LN10@OnMovement
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0015e	0f 28 c3	 movaps	 xmm0, xmm3
  00161	0f 28 cf	 movaps	 xmm1, xmm7
  00164	f3 0f 59 41 64	 mulss	 xmm0, DWORD PTR [ecx+100]
  00169	f3 0f 59 49 68	 mulss	 xmm1, DWORD PTR [ecx+104]
  0016e	f3 0f 58 c8	 addss	 xmm1, xmm0
  00172	0f 28 c4	 movaps	 xmm0, xmm4
  00175	f3 0f 59 41 6c	 mulss	 xmm0, DWORD PTR [ecx+108]
  0017a	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 350  : 				if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[2]) > - s.fRadius/*0.0f*/)

  0017e	0f 2f ce	 comiss	 xmm1, xmm6
  00181	76 42		 jbe	 SHORT $LN10@OnMovement
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  00183	f3 0f 59 79 74	 mulss	 xmm7, DWORD PTR [ecx+116]
  00188	f3 0f 59 59 70	 mulss	 xmm3, DWORD PTR [ecx+112]
  0018d	f3 0f 59 61 78	 mulss	 xmm4, DWORD PTR [ecx+120]
  00192	f3 0f 58 fb	 addss	 xmm7, xmm3
  00196	f3 0f 58 fc	 addss	 xmm7, xmm4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 351  : 					if (D3DXVec3Dot(&v3QuadPosition2, &m_attribute.v3InsideVector[3]) > -s.fRadius/*0.0f*/)

  0019a	0f 2f fe	 comiss	 xmm7, xmm6
  0019d	76 26		 jbe	 SHORT $LN10@OnMovement

; 352  : 					{
; 353  : 						// NOTE :   .. - [levites]
; 354  : 						const auto _vv__3 = (s.v3Position - m_attribute.v3Position);
; 355  : 						const auto _vv__4 = (s.v3LastPosition - m_attribute.v3Position);
; 356  : 						if (fabs(D3DXVec3Dot(&_vv__3, &m_attribute.v3Normal)) <

  0019f	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fPosition2$1$[ebp]
  001a4	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  001ac	0f 5a d5	 cvtps2pd xmm2, xmm5
  001af	0f 5a c0	 cvtps2pd xmm0, xmm0
  001b2	0f 54 d1	 andps	 xmm2, xmm1
  001b5	0f 54 c1	 andps	 xmm0, xmm1
  001b8	66 0f 2f c2	 comisd	 xmm0, xmm2
  001bc	0f 97 c0	 seta	 al

; 363  : }

  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c2 04 00	 ret	 4
$LN10@OnMovement:

; 357  : 							fabs(D3DXVec3Dot(&_vv__4, &m_attribute.v3Normal)))
; 358  : 							return true;
; 359  : 					}
; 360  : 	}
; 361  : 
; 362  : 	return false;

  001c5	32 c0		 xor	 al, al

; 363  : }

  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CPlaneCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CPlaneCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnDestroy@CPlaneCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
?OnDestroy@CPlaneCollisionInstance@@MAEXXZ PROC		; CPlaneCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 466  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00004	a1 14 00 00 00	 mov	 eax, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+20
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 467  : 	gs_pci.Free(this);

  00009	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0000c	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+24
  00012	74 0d		 je	 SHORT $LN8@OnDestroy

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00016	83 05 14 00 00
	00 04		 add	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+20, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 468  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN8@OnDestroy:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00021	8d 4d fc	 lea	 ecx, DWORD PTR _pkData$[ebp]
  00024	51		 push	 ecx
  00025	50		 push	 eax
  00026	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+16
  0002b	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_reallocate<CPlaneCollisionInstance * const &>
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 468  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?OnDestroy@CPlaneCollisionInstance@@MAEXXZ ENDP		; CPlaneCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CPlaneCollisionInstance::Render, COMDAT
; _this$ = ecx

; 460  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 461  : 	static CScreen s;

  00025	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __tls_index
  00031	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00039	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0003f	7f 20		 jg	 SHORT $LN7@Render
$LN2@Render:

; 462  : 	s.RenderBar3d(m_attribute.v3QuadPosition);

  00041	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ?RenderBar3d@CScreen@@QAEXPBUD3DXVECTOR3@@@Z ; CScreen::RenderBar3d

; 463  : }

  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00059	59		 pop	 ecx
  0005a	5e		 pop	 esi
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c2 04 00	 ret	 4
$LN7@Render:

; 461  : 	static CScreen s;

  00061	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00066	e8 00 00 00 00	 call	 __Init_thread_header
  0006b	83 c4 04	 add	 esp, 4
  0006e	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA, -1
  00075	75 ca		 jne	 SHORT $LN2@Render
  00077	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0007c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00083	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  00088	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CPlaneCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  0008d	e8 00 00 00 00	 call	 _atexit
  00092	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00097	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009e	e8 00 00 00 00	 call	 __Init_thread_footer
  000a3	83 c4 08	 add	 esp, 8
  000a6	eb 99		 jmp	 SHORT $LN2@Render
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CPlaneCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CPlaneCollisionInstance::Render
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ
_TEXT	SEGMENT
?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ PROC ; CPlaneCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 331  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 332  : }

  00003	c3		 ret	 0
?GetAttribute@CPlaneCollisionInstance@@QBEABUSPlaneData@@XZ ENDP ; CPlaneCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ
_TEXT	SEGMENT
?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ PROC ; CPlaneCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 326  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 327  : }

  00003	c3		 ret	 0
?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ ENDP ; CPlaneCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
tv908 = -16						; size = 4
tv909 = -12						; size = 4
tv880 = -8						; size = 4
tv910 = -8						; size = 4
_sum$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z PROC ; CSphereCollisionInstance::OnGetCollisionMovementAdjust, COMDAT
; _this$ = ecx

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 281  : {

  00009	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0000c	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00010	f3 0f 10 70 04	 movss	 xmm6, DWORD PTR [eax+4]
  00015	0f 28 ea	 movaps	 xmm5, xmm2
  00018	f3 0f 5c 69 04	 subss	 xmm5, DWORD PTR [ecx+4]
  0001d	f3 0f 5c 71 08	 subss	 xmm6, DWORD PTR [ecx+8]
  00022	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 283  : 	if (D3DXVec3LengthSq(&_vv__) >= (s.fRadius + m_attribute.fRadius) * (m_attribute.fRadius + s.fRadius))

  00027	f3 0f 10 58 18	 movss	 xmm3, DWORD PTR [eax+24]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0002c	0f 28 f9	 movaps	 xmm7, xmm1
  0002f	f3 0f 5c 79 0c	 subss	 xmm7, DWORD PTR [ecx+12]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 283  : 	if (D3DXVec3LengthSq(&_vv__) >= (s.fRadius + m_attribute.fRadius) * (m_attribute.fRadius + s.fRadius))

  00034	f3 0f 58 59 10	 addss	 xmm3, DWORD PTR [ecx+16]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  00039	0f 28 c5	 movaps	 xmm0, xmm5

; 182  :     z = fz;

  0003c	0f 28 e6	 movaps	 xmm4, xmm6

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0003f	f3 0f 59 c5	 mulss	 xmm0, xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 281  : {

  00043	56		 push	 esi

; 283  : 	if (D3DXVec3LengthSq(&_vv__) >= (s.fRadius + m_attribute.fRadius) * (m_attribute.fRadius + s.fRadius))

  00044	8b 75 08	 mov	 esi, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 182  :     z = fz;

  00047	f3 0f 59 e6	 mulss	 xmm4, xmm6
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 283  : 	if (D3DXVec3LengthSq(&_vv__) >= (s.fRadius + m_attribute.fRadius) * (m_attribute.fRadius + s.fRadius))

  0004b	f3 0f 59 db	 mulss	 xmm3, xmm3
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1253 :     return pV->x * pV->x + pV->y * pV->y + pV->z * pV->z;

  0004f	f3 0f 58 e0	 addss	 xmm4, xmm0
  00053	0f 28 c7	 movaps	 xmm0, xmm7
  00056	f3 0f 59 c7	 mulss	 xmm0, xmm7
  0005a	f3 0f 58 e0	 addss	 xmm4, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 283  : 	if (D3DXVec3LengthSq(&_vv__) >= (s.fRadius + m_attribute.fRadius) * (m_attribute.fRadius + s.fRadius))

  0005e	0f 2f e3	 comiss	 xmm4, xmm3
  00061	0f 83 6e 01 00
	00		 jae	 $LN37@OnGetColli
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00067	f3 0f 5c 48 14	 subss	 xmm1, DWORD PTR [eax+20]
  0006c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 291  : 	float mul = (s.fRadius + m_attribute.fRadius) * (s.fRadius + m_attribute.fRadius) - D3DXVec3LengthSq(&_vv__);

  00071	f3 0f 5c dc	 subss	 xmm3, xmm4
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00075	f3 0f 5c 40 10	 subss	 xmm0, DWORD PTR [eax+16]
  0007a	f3 0f 5c 50 0c	 subss	 xmm2, DWORD PTR [eax+12]

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0007f	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@00000000

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00087	f3 0f 11 44 24
	10		 movss	 DWORD PTR tv880[esp+24], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 293  : 	if (sum * sum - 4 * mul <= 0)

  0008d	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@40800000
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00095	f3 0f 5c c1	 subss	 xmm0, xmm1

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00099	f3 0f 5c ca	 subss	 xmm1, xmm2
  0009d	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@00000000
  000a5	f3 0f 11 44 24
	08		 movss	 DWORD PTR tv908[esp+24], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  000ab	f3 0f 10 44 24
	10		 movss	 xmm0, DWORD PTR tv880[esp+24]
  000b1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@00000000
  000b9	f3 0f 11 4c 24
	0c		 movss	 DWORD PTR tv909[esp+24], xmm1

; 1280 : 
; 1281 :     *pOut = v;

  000bf	f3 0f 59 ce	 mulss	 xmm1, xmm6
  000c3	f3 0f 5c d0	 subss	 xmm2, xmm0

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000c7	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR tv908[esp+24]
  000cd	f3 0f 59 c5	 mulss	 xmm0, xmm5
  000d1	f3 0f 58 c8	 addss	 xmm1, xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  000d5	f3 0f 11 54 24
	10		 movss	 DWORD PTR tv910[esp+24], xmm2

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  000db	0f 28 c2	 movaps	 xmm0, xmm2
  000de	f3 0f 59 c7	 mulss	 xmm0, xmm7
  000e2	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 290  : 	float sum = -D3DXVec3Dot(&c, &_vv__);

  000e6	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000

; 293  : 	if (sum * sum - 4 * mul <= 0)

  000ed	0f 28 c1	 movaps	 xmm0, xmm1
  000f0	f3 0f 11 4c 24
	14		 movss	 DWORD PTR _sum$1$[esp+24], xmm1
  000f6	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000fa	0f 57 c9	 xorps	 xmm1, xmm1
  000fd	f3 0f 5c c3	 subss	 xmm0, xmm3
  00101	0f 2f c8	 comiss	 xmm1, xmm0
  00104	0f 83 cb 00 00
	00		 jae	 $LN37@OnGetColli

; 295  : 	float sq = sqrt(sum * sum - 4 * mul);

  0010a	f3 0f 5a c0	 cvtss2sd xmm0, xmm0
  0010e	66 0f 2e c8	 ucomisd xmm1, xmm0
  00112	77 06		 ja	 SHORT $LN39@OnGetColli
  00114	f2 0f 51 c0	 sqrtsd	 xmm0, xmm0
  00118	eb 05		 jmp	 SHORT $LN40@OnGetColli
$LN39@OnGetColli:
  0011a	e8 00 00 00 00	 call	 __libm_sse2_sqrt_precise
$LN40@OnGetColli:

; 296  : 	float t1 = -sum - sq, t2 = -sum + sq;

  0011f	f3 0f 10 5c 24
	14		 movss	 xmm3, DWORD PTR _sum$1$[esp+24]
  00125	0f 57 e4	 xorps	 xmm4, xmm4
  00128	0f 57 1d 00 00
	00 00		 xorps	 xmm3, DWORD PTR __xmm@80000000800000008000000080000000

; 297  : 	t1 *= 0.5f;
; 298  : 	t2 *= 0.5f;
; 299  : 
; 300  : 	if (fabs(t1) <= fabs(t2))

  0012f	0f 57 d2	 xorps	 xmm2, xmm2
  00132	f3 0f 10 2d 00
	00 00 00	 movss	 xmm5, DWORD PTR __real@3f000000
  0013a	8b c6		 mov	 eax, esi
  0013c	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __xmm@7fffffffffffffff7fffffffffffffff
  00144	f2 0f 5a e0	 cvtsd2ss xmm4, xmm0
  00148	f3 0f 5c dc	 subss	 xmm3, xmm4
  0014c	f3 0f 5c 64 24
	14		 subss	 xmm4, DWORD PTR _sum$1$[esp+24]
  00152	f3 0f 59 dd	 mulss	 xmm3, xmm5
  00156	f3 0f 59 e5	 mulss	 xmm4, xmm5
  0015a	f3 0f 5a d3	 cvtss2sd xmm2, xmm3
  0015e	0f 5a c4	 cvtps2pd xmm0, xmm4
  00161	0f 54 d1	 andps	 xmm2, xmm1
  00164	0f 54 c1	 andps	 xmm0, xmm1
  00167	66 0f 2f c2	 comisd	 xmm0, xmm2
  0016b	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR tv908[esp+24]
  00171	72 31		 jb	 SHORT $LN4@OnGetColli

; 301  : 	{
; 302  : 		return (gc_fReduceMove * t1) * c;

  00173	f3 0f 59 dd	 mulss	 xmm3, xmm5
  00177	f3 0f 59 c3	 mulss	 xmm0, xmm3
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  0017b	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
  0017f	f3 0f 10 44 24
	0c		 movss	 xmm0, DWORD PTR tv909[esp+24]
  00185	f3 0f 59 c3	 mulss	 xmm0, xmm3

; 181  :     y = fy;

  00189	f3 0f 11 46 04	 movss	 DWORD PTR [esi+4], xmm0
  0018e	f3 0f 10 44 24
	10		 movss	 xmm0, DWORD PTR tv910[esp+24]
  00194	f3 0f 59 c3	 mulss	 xmm0, xmm3

; 182  :     z = fz;

  00198	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 320  : }

  0019d	5e		 pop	 esi
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c2 08 00	 ret	 8
$LN4@OnGetColli:

; 303  : 	}
; 304  : 	else
; 305  : 		return (gc_fReduceMove * t2) * c;

  001a4	f3 0f 59 e5	 mulss	 xmm4, xmm5
  001a8	f3 0f 59 c4	 mulss	 xmm0, xmm4
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  001ac	f3 0f 11 06	 movss	 DWORD PTR [esi], xmm0
  001b0	f3 0f 10 44 24
	0c		 movss	 xmm0, DWORD PTR tv909[esp+24]
  001b6	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 181  :     y = fy;

  001ba	f3 0f 11 46 04	 movss	 DWORD PTR [esi+4], xmm0
  001bf	f3 0f 10 44 24
	10		 movss	 xmm0, DWORD PTR tv910[esp+24]
  001c5	f3 0f 59 c4	 mulss	 xmm0, xmm4

; 182  :     z = fz;

  001c9	f3 0f 11 46 08	 movss	 DWORD PTR [esi+8], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 320  : }

  001ce	5e		 pop	 esi
  001cf	8b e5		 mov	 esp, ebp
  001d1	5d		 pop	 ebp
  001d2	c2 08 00	 ret	 8
$LN37@OnGetColli:
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 180  :     x = fx;

  001d5	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 294  : 		return D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  001db	8b c6		 mov	 eax, esi
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 181  :     y = fy;

  001dd	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 182  :     z = fz;

  001e4	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 320  : }

  001eb	5e		 pop	 esi
  001ec	8b e5		 mov	 esp, ebp
  001ee	5d		 pop	 ebp
  001ef	c2 08 00	 ret	 8
?OnGetCollisionMovementAdjust@CSphereCollisionInstance@@MBE?AUD3DXVECTOR3@@ABUCDynamicSphereInstance@@@Z ENDP ; CSphereCollisionInstance::OnGetCollisionMovementAdjust
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
tv139 = -4						; size = 4
_s$ = 8							; size = 4
tv131 = 8						; size = 4
?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CSphereCollisionInstance::OnCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 270  : 	//Tracef("OnCollisionDynamicSphere\n");
; 271  : 
; 272  : 	if (square_distance_between_linesegment_and_point(s.v3LastPosition,s.v3Position,m_attribute.v3Position)<(m_attribute.fRadius+s.fRadius)*(m_attribute.fRadius+s.fRadius))

  00004	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00007	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  0000a	50		 push	 eax
  0000b	52		 push	 edx
  0000c	f3 0f 10 42 18	 movss	 xmm0, DWORD PTR [edx+24]
  00011	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00014	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  00019	50		 push	 eax
  0001a	f3 0f 11 45 08	 movss	 DWORD PTR tv131[ebp], xmm0
  0001f	e8 00 00 00 00	 call	 ?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z ; square_distance_between_linesegment_and_point
  00024	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR tv131[ebp]
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00030	d9 5d fc	 fstp	 DWORD PTR tv139[ebp]
  00033	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR tv139[ebp]
  00037	0f 97 c0	 seta	 al

; 273  : 	{
; 274  : 		return true;
; 275  : 	}
; 276  : 
; 277  : 	return false;
; 278  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
?OnCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CSphereCollisionInstance::OnCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z
_TEXT	SEGMENT
tv321 = -4						; size = 4
_s$ = 8							; size = 4
tv271 = 8						; size = 4
?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z PROC ; CSphereCollisionInstance::OnMovementCollisionDynamicSphere, COMDAT
; _this$ = ecx

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 258  : 	if (square_distance_between_linesegment_and_point(s.v3LastPosition,s.v3Position,m_attribute.v3Position) < (m_attribute.fRadius+s.fRadius)*(m_attribute.fRadius+s.fRadius))

  00006	8b 75 08	 mov	 esi, DWORD PTR _s$[ebp]
  00009	57		 push	 edi
  0000a	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  0000d	57		 push	 edi
  0000e	f3 0f 10 46 18	 movss	 xmm0, DWORD PTR [esi+24]
  00013	8d 5e 0c	 lea	 ebx, DWORD PTR [esi+12]
  00016	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  0001b	56		 push	 esi
  0001c	53		 push	 ebx
  0001d	f3 0f 11 45 08	 movss	 DWORD PTR tv271[ebp], xmm0
  00022	e8 00 00 00 00	 call	 ?square_distance_between_linesegment_and_point@@YAMABUD3DXVECTOR3@@00@Z ; square_distance_between_linesegment_and_point
  00027	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR tv271[ebp]
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	f3 0f 59 c0	 mulss	 xmm0, xmm0
  00033	d9 5d fc	 fstp	 DWORD PTR tv321[ebp]
  00036	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR tv321[ebp]
  0003a	76 4b		 jbe	 SHORT $LN3@OnMovement
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0003c	f3 0f 10 5e 04	 movss	 xmm3, DWORD PTR [esi+4]
  00041	f3 0f 10 26	 movss	 xmm4, DWORD PTR [esi]
  00045	f3 0f 10 53 04	 movss	 xmm2, DWORD PTR [ebx+4]
  0004a	f3 0f 10 0b	 movss	 xmm1, DWORD PTR [ebx]
  0004e	f3 0f 5c 27	 subss	 xmm4, DWORD PTR [edi]
  00052	f3 0f 5c 0f	 subss	 xmm1, DWORD PTR [edi]
  00056	f3 0f 5c 5f 04	 subss	 xmm3, DWORD PTR [edi+4]
  0005b	f3 0f 5c 57 04	 subss	 xmm2, DWORD PTR [edi+4]
  00060	5f		 pop	 edi
  00061	f3 0f 59 e4	 mulss	 xmm4, xmm4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 266  : }

  00065	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  00066	f3 0f 59 db	 mulss	 xmm3, xmm3
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 266  : }

  0006a	5b		 pop	 ebx
; File C:\Marty 5.5\Src-Client\Client\EterLib\GrpMath.h

; 44   : 	return (c_rv3Source.x-c_rv3Target.x)*(c_rv3Source.x-c_rv3Target.x) + (c_rv3Source.y-c_rv3Target.y)*(c_rv3Source.y-c_rv3Target.y);

  0006b	f3 0f 59 c9	 mulss	 xmm1, xmm1
  0006f	f3 0f 59 d2	 mulss	 xmm2, xmm2
  00073	f3 0f 58 e3	 addss	 xmm4, xmm3
  00077	f3 0f 58 ca	 addss	 xmm1, xmm2
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 260  : 		if (GetVector3Distance(s.v3Position, m_attribute.v3Position) <

  0007b	0f 2f cc	 comiss	 xmm1, xmm4
  0007e	0f 97 c0	 seta	 al

; 266  : }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
$LN3@OnMovement:
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	32 c0		 xor	 al, al
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 04 00	 ret	 4
?OnMovementCollisionDynamicSphere@CSphereCollisionInstance@@MBE_NABUCDynamicSphereInstance@@@Z ENDP ; CSphereCollisionInstance::OnMovementCollisionDynamicSphere
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?OnDestroy@CSphereCollisionInstance@@MAEXXZ
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
?OnDestroy@CSphereCollisionInstance@@MAEXXZ PROC	; CSphereCollisionInstance::OnDestroy, COMDAT
; _this$ = ecx

; 252  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00004	a1 14 00 00 00	 mov	 eax, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+20
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 253  : 	gs_sci.Free(this);

  00009	89 4d fc	 mov	 DWORD PTR _pkData$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0000c	3b 05 18 00 00
	00		 cmp	 eax, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+24
  00012	74 0d		 je	 SHORT $LN8@OnDestroy

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00014	89 08		 mov	 DWORD PTR [eax], ecx

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00016	83 05 14 00 00
	00 04		 add	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+20, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 254  : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
$LN8@OnDestroy:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00021	8d 4d fc	 lea	 ecx, DWORD PTR _pkData$[ebp]
  00024	51		 push	 ecx
  00025	50		 push	 eax
  00026	b9 10 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+16
  0002b	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_reallocate<CSphereCollisionInstance * const &>
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 254  : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?OnDestroy@CSphereCollisionInstance@@MAEXXZ ENDP	; CSphereCollisionInstance::OnDestroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_d3dFillMode$ = 8					; size = 4
?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z PROC ; CSphereCollisionInstance::Render, COMDAT
; _this$ = ecx

; 245  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx

; 246  : 	static CScreen s;

  00025	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  0002b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __tls_index
  00031	8b 14 90	 mov	 edx, DWORD PTR [eax+edx*4]
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00039	3b 82 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[edx]
  0003f	7f 3b		 jg	 SHORT $LN7@Render
$LN2@Render:

; 247  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00047	6a ff		 push	 -1
  00049	6a 3c		 push	 60			; 0000003cH
  0004b	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 248  : 	s.RenderSphere(NULL, m_attribute.v3Position.x, m_attribute.v3Position.y, m_attribute.v3Position.z, m_attribute.fRadius, d3dFillMode);

  00050	ff 75 08	 push	 DWORD PTR _d3dFillMode$[ebp]
  00053	0f 10 46 04	 movups	 xmm0, XMMWORD PTR [esi+4]
  00057	83 ec 10	 sub	 esp, 16			; 00000010H
  0005a	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  0005f	0f 11 04 24	 movups	 XMMWORD PTR [esp], xmm0
  00063	6a 00		 push	 0
  00065	e8 00 00 00 00	 call	 ?RenderSphere@CScreen@@QAEXPBUD3DXMATRIX@@MMMMW4_D3DFILLMODE@@@Z ; CScreen::RenderSphere

; 249  : }

  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	5e		 pop	 esi
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c2 04 00	 ret	 4
$LN7@Render:

; 246  : 	static CScreen s;

  0007c	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00081	e8 00 00 00 00	 call	 __Init_thread_header
  00086	83 c4 04	 add	 esp, 4
  00089	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA, -1
  00090	75 af		 jne	 SHORT $LN2@Render
  00092	b9 00 00 00 00	 mov	 ecx, OFFSET ?s@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4VCScreen@@A
  00097	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0009e	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  000a3	68 00 00 00 00	 push	 OFFSET ??__Fs@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@YAXXZ ; `CSphereCollisionInstance::Render'::`2'::`dynamic atexit destructor for 's''
  000a8	e8 00 00 00 00	 call	 _atexit
  000ad	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  000b2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b9	e8 00 00 00 00	 call	 __Init_thread_footer
  000be	83 c4 08	 add	 esp, 8
  000c1	e9 7b ff ff ff	 jmp	 $LN2@Render
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CSphereCollisionInstance@@UAEXW4_D3DFILLMODE@@@Z ENDP ; CSphereCollisionInstance::Render
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ
_TEXT	SEGMENT
?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ PROC ; CSphereCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 241  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 242  : }

  00003	c3		 ret	 0
?GetAttribute@CSphereCollisionInstance@@QBEABUSSphereData@@XZ ENDP ; CSphereCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ
_TEXT	SEGMENT
?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ PROC ; CSphereCollisionInstance::GetAttribute, COMDAT
; _this$ = ecx

; 236  : 	return m_attribute;

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 237  : }

  00003	c3		 ret	 0
?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ ENDP ; CSphereCollisionInstance::GetAttribute
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z
_TEXT	SEGMENT
tv3740 = -332						; size = 4
tv3854 = -332						; size = 4
tv3702 = -332						; size = 4
tv3741 = -328						; size = 4
tv3703 = -328						; size = 4
tv3685 = -328						; size = 4
tv3704 = -324						; size = 4
_pkNewData$1 = -324					; size = 4
tv3683 = -324						; size = 4
_PlaneData$1$ = -324					; size = 4
$T2 = -320						; size = 4
$T3 = -320						; size = 4
tv3856 = -320						; size = 4
tv3684 = -316						; size = 4
_pMat$GSCopy$1$ = -316					; size = 4
$T4 = -316						; size = 4
$T5 = -316						; size = 4
_pkNewData$6 = -312					; size = 4
_pkNewData$7 = -312					; size = 4
tv3665 = -312						; size = 4
_pkNewData$8 = -312					; size = 4
tv3742 = -312						; size = 4
tv3883 = -312						; size = 4
_c_pCollisionData$GSCopy$1$ = -312			; size = 4
_matTransform$9 = -308					; size = 64
_matTranslationLocal$10 = -308				; size = 64
$T11 = -244						; size = 64
_matRotation$12 = -244					; size = 64
_matTranslationLocal$13 = -180				; size = 64
$T14 = -180						; size = 64
$T15 = -180						; size = 64
_matTranslationLocal$16 = -180				; size = 64
_matTranslationLocal$17 = -180				; size = 64
_matRotation$18 = -116					; size = 64
_matTranslationLocal$19 = -116				; size = 64
_matTransform$20 = -116					; size = 64
_matTransform$21 = -116					; size = 64
_matTranslationLocal$22 = -116				; size = 64
_v3Line1$23 = -52					; size = 12
_v3Line0$24 = -40					; size = 12
_v3Max$25 = -28						; size = 12
_v3Line3$26 = -28					; size = 12
_v3Line2$27 = -16					; size = 12
_v3Min$28 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_c_pCollisionData$ = 8					; size = 4
_pMat$ = 12						; size = 4
?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z PROC ; CBaseCollisionInstance::BuildCollisionInstance, COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	8b 75 08	 mov	 esi, DWORD PTR _c_pCollisionData$[ebp]
  00017	57		 push	 edi
  00018	8b 7d 0c	 mov	 edi, DWORD PTR _pMat$[ebp]
  0001b	89 b5 c8 fe ff
	ff		 mov	 DWORD PTR _c_pCollisionData$GSCopy$1$[ebp], esi

; 37   : 	switch(c_pCollisionData->dwType)

  00021	8b 06		 mov	 eax, DWORD PTR [esi]
  00023	89 bd c4 fe ff
	ff		 mov	 DWORD PTR _pMat$GSCopy$1$[ebp], edi
  00029	83 f8 05	 cmp	 eax, 5
  0002c	0f 87 dd 0b 00
	00		 ja	 $LN2@BuildColli
  00032	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN176@BuildColli[eax*4]
$LN7@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00039	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+20
  0003f	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+16, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 64   : 			if (m_kVct_pkFree.empty())

  00045	75 6f		 jne	 SHORT $LN41@BuildColli

; 66   : 				T* pkNewData=new T;

  00047	6a 7c		 push	 124			; 0000007cH
  00049	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004e	83 c4 04	 add	 esp, 4
  00051	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00057	85 c0		 test	 eax, eax
  00059	74 08		 je	 SHORT $LN43@BuildColli
  0005b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CPlaneCollisionInstance@@6B@
  00061	eb 08		 jmp	 SHORT $LN44@BuildColli
$LN43@BuildColli:
  00063	33 c0		 xor	 eax, eax
  00065	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
$LN44@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0006b	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+8
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 66   : 				T* pkNewData=new T;

  00071	89 85 bc fe ff
	ff		 mov	 DWORD PTR _pkNewData$1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00077	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+12
  0007d	74 11		 je	 SHORT $LN57@BuildColli

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  0007f	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00081	83 05 08 00 00
	00 04		 add	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+8, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  00088	ff 05 20 00 00
	00		 inc	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+32

; 69   : 				return pkNewData;

  0008e	eb 37		 jmp	 SHORT $LN40@BuildColli
$LN57@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00090	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _pkNewData$1[ebp]
  00096	50		 push	 eax
  00097	51		 push	 ecx
  00098	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+4
  0009d	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCPlaneCollisionInstance@@@?$vector@PAVCPlaneCollisionInstance@@V?$allocator@PAVCPlaneCollisionInstance@@@std@@@std@@AAEPAPAVCPlaneCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CPlaneCollisionInstance *,std::allocator<CPlaneCollisionInstance *> >::_Emplace_reallocate<CPlaneCollisionInstance * const &>
  000a2	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _pkNewData$1[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  000a8	ff 05 20 00 00
	00		 inc	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+32
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  000ae	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 69   : 				return pkNewData;

  000b4	eb 11		 jmp	 SHORT $LN40@BuildColli
$LN41@BuildColli:

; 70   : 			}
; 71   : 
; 72   : 			T* pkFreeData=m_kVct_pkFree.back();

  000b6	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  000b9	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1744 :         --_Mylast;

  000bf	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  000c2	a3 14 00 00 00	 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+20, eax
$LN40@BuildColli:
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 44   : 				D3DXMatrixRotationQuaternion(&matRotation, &c_pCollisionData->quatRotation);

  000c7	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  000ca	50		 push	 eax
  000cb	8d 45 8c	 lea	 eax, DWORD PTR _matRotation$18[ebp]
  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 _D3DXMatrixRotationQuaternion@8

; 45   : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  000d4	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _c_pCollisionData$GSCopy$1$[ebp]
  000da	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$13[ebp]
  000e0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000e3	83 c6 28	 add	 esi, 40			; 00000028H
  000e6	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  000eb	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  000f1	f3 0f 10 47 2c	 movss	 xmm0, DWORD PTR [edi+44]
  000f6	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  000fc	f3 0f 10 06	 movss	 xmm0, DWORD PTR [esi]
  00100	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  0010b	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$13[ebp]
  00111	50		 push	 eax
  00112	8d 45 8c	 lea	 eax, DWORD PTR _matRotation$18[ebp]
  00115	50		 push	 eax
  00116	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
  00122	ff b5 c4 fe ff
	ff		 push	 DWORD PTR _pMat$GSCopy$1$[ebp]
  00128	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  0012e	50		 push	 eax
  0012f	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _matTransform$9[ebp]
  00135	50		 push	 eax
  00136	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 48   : 				TPlaneData & PlaneData = ppci->GetAttribute();

  0013b	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00141	e8 00 00 00 00	 call	 ?GetAttribute@CPlaneCollisionInstance@@QAEAAUSPlaneData@@XZ ; CPlaneCollisionInstance::GetAttribute

; 49   : 				D3DXVec3TransformCoord(&PlaneData.v3Position, &c_pCollisionData->v3Position, pMat);

  00146	ff b5 c4 fe ff
	ff		 push	 DWORD PTR _pMat$GSCopy$1$[ebp]
  0014c	89 85 bc fe ff
	ff		 mov	 DWORD PTR _PlaneData$1$[ebp], eax
  00152	56		 push	 esi
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 50   : 				float fHalfWidth = c_pCollisionData->fDimensions[0] / 2.0f;

  00159	f3 0f 10 67 34	 movss	 xmm4, DWORD PTR [edi+52]

; 51   : 				float fHalfLength = c_pCollisionData->fDimensions[1] / 2.0f;

  0015e	f3 0f 10 5f 38	 movss	 xmm3, DWORD PTR [edi+56]

; 52   : 
; 53   : 				PlaneData.v3QuadPosition[0].x = -fHalfWidth;

  00163	8b bd bc fe ff
	ff		 mov	 edi, DWORD PTR _PlaneData$1$[ebp]
  00169	f3 0f 59 25 00
	00 00 00	 mulss	 xmm4, DWORD PTR __real@3f000000
  00171	8d 77 18	 lea	 esi, DWORD PTR [edi+24]
  00174	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@3f000000

; 54   : 				PlaneData.v3QuadPosition[0].y = -fHalfLength;
; 55   : 				PlaneData.v3QuadPosition[0].z = 0.0f;

  0017c	c7 47 20 00 00
	00 00		 mov	 DWORD PTR [edi+32], 0
  00183	0f 28 d4	 movaps	 xmm2, xmm4

; 56   : 				PlaneData.v3QuadPosition[1].x = +fHalfWidth;

  00186	f3 0f 11 67 24	 movss	 DWORD PTR [edi+36], xmm4
  0018b	0f 57 15 00 00
	00 00		 xorps	 xmm2, DWORD PTR __xmm@80000000800000008000000080000000
  00192	0f 28 cb	 movaps	 xmm1, xmm3

; 57   : 				PlaneData.v3QuadPosition[1].y = -fHalfLength;
; 58   : 				PlaneData.v3QuadPosition[1].z = 0.0f;

  00195	c7 47 2c 00 00
	00 00		 mov	 DWORD PTR [edi+44], 0
  0019c	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  001a3	f3 0f 11 4f 1c	 movss	 DWORD PTR [edi+28], xmm1
  001a8	f3 0f 11 4f 28	 movss	 DWORD PTR [edi+40], xmm1

; 59   : 				PlaneData.v3QuadPosition[2].x = -fHalfWidth;

  001ad	f3 0f 11 57 30	 movss	 DWORD PTR [edi+48], xmm2

; 60   : 				PlaneData.v3QuadPosition[2].y = +fHalfLength;

  001b2	f3 0f 11 5f 34	 movss	 DWORD PTR [edi+52], xmm3

; 61   : 				PlaneData.v3QuadPosition[2].z = 0.0f;

  001b7	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0

; 62   : 				PlaneData.v3QuadPosition[3].x = +fHalfWidth;

  001be	f3 0f 11 67 3c	 movss	 DWORD PTR [edi+60], xmm4

; 63   : 				PlaneData.v3QuadPosition[3].y = +fHalfLength;

  001c3	f3 0f 11 5f 40	 movss	 DWORD PTR [edi+64], xmm3

; 64   : 				PlaneData.v3QuadPosition[3].z = 0.0f;

  001c8	c7 47 44 00 00
	00 00		 mov	 DWORD PTR [edi+68], 0
  001cf	bf 04 00 00 00	 mov	 edi, 4
  001d4	f3 0f 11 16	 movss	 DWORD PTR [esi], xmm2
$LL6@BuildColli:

; 65   : 				for (DWORD i = 0; i < 4; ++i)
; 66   : 					D3DXVec3TransformCoord(&PlaneData.v3QuadPosition[i], &PlaneData.v3QuadPosition[i], &matTransform);

  001d8	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _matTransform$9[ebp]
  001de	50		 push	 eax
  001df	56		 push	 esi
  001e0	56		 push	 esi
  001e1	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
  001e6	83 c6 0c	 add	 esi, 12			; 0000000cH
  001e9	83 ef 01	 sub	 edi, 1
  001ec	75 ea		 jne	 SHORT $LL6@BuildColli
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001ee	8b bd bc fe ff
	ff		 mov	 edi, DWORD PTR _PlaneData$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 71   : 				D3DXVec3Normalize(&v3Line0, &v3Line0);

  001f4	8d 45 d8	 lea	 eax, DWORD PTR _v3Line0$24[ebp]
  001f7	50		 push	 eax
  001f8	50		 push	 eax
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  001f9	f3 0f 10 57 28	 movss	 xmm2, DWORD PTR [edi+40]
  001fe	f3 0f 5c 57 1c	 subss	 xmm2, DWORD PTR [edi+28]
  00203	f3 0f 10 4f 2c	 movss	 xmm1, DWORD PTR [edi+44]
  00208	f3 0f 5c 4f 20	 subss	 xmm1, DWORD PTR [edi+32]
  0020d	f3 0f 10 47 24	 movss	 xmm0, DWORD PTR [edi+36]
  00212	f3 0f 5c 47 18	 subss	 xmm0, DWORD PTR [edi+24]

; 181  :     y = fy;

  00217	f3 0f 11 55 dc	 movss	 DWORD PTR _v3Line0$24[ebp+4], xmm2

; 182  :     z = fz;

  0021c	f3 0f 11 4d e0	 movss	 DWORD PTR _v3Line0$24[ebp+8], xmm1
  00221	f3 0f 11 45 d8	 movss	 DWORD PTR _v3Line0$24[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00226	f3 0f 10 57 34	 movss	 xmm2, DWORD PTR [edi+52]
  0022b	f3 0f 5c 57 1c	 subss	 xmm2, DWORD PTR [edi+28]
  00230	f3 0f 10 4f 38	 movss	 xmm1, DWORD PTR [edi+56]
  00235	f3 0f 5c 4f 20	 subss	 xmm1, DWORD PTR [edi+32]
  0023a	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  0023f	f3 0f 5c 47 18	 subss	 xmm0, DWORD PTR [edi+24]

; 181  :     y = fy;

  00244	f3 0f 11 55 d0	 movss	 DWORD PTR _v3Line1$23[ebp+4], xmm2

; 182  :     z = fz;

  00249	f3 0f 11 4d d4	 movss	 DWORD PTR _v3Line1$23[ebp+8], xmm1
  0024e	f3 0f 11 45 cc	 movss	 DWORD PTR _v3Line1$23[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00253	f3 0f 10 57 28	 movss	 xmm2, DWORD PTR [edi+40]
  00258	f3 0f 10 4f 2c	 movss	 xmm1, DWORD PTR [edi+44]
  0025d	f3 0f 10 47 24	 movss	 xmm0, DWORD PTR [edi+36]
  00262	f3 0f 5c 57 40	 subss	 xmm2, DWORD PTR [edi+64]
  00267	f3 0f 5c 4f 44	 subss	 xmm1, DWORD PTR [edi+68]
  0026c	f3 0f 5c 47 3c	 subss	 xmm0, DWORD PTR [edi+60]

; 181  :     y = fy;

  00271	f3 0f 11 55 f4	 movss	 DWORD PTR _v3Line2$27[ebp+4], xmm2

; 182  :     z = fz;

  00276	f3 0f 11 4d f8	 movss	 DWORD PTR _v3Line2$27[ebp+8], xmm1
  0027b	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Line2$27[ebp], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00280	f3 0f 10 57 34	 movss	 xmm2, DWORD PTR [edi+52]
  00285	f3 0f 10 4f 38	 movss	 xmm1, DWORD PTR [edi+56]
  0028a	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  0028f	f3 0f 5c 57 40	 subss	 xmm2, DWORD PTR [edi+64]
  00294	f3 0f 5c 4f 44	 subss	 xmm1, DWORD PTR [edi+68]
  00299	f3 0f 5c 47 3c	 subss	 xmm0, DWORD PTR [edi+60]

; 181  :     y = fy;

  0029e	f3 0f 11 55 e8	 movss	 DWORD PTR _v3Line3$26[ebp+4], xmm2

; 182  :     z = fz;

  002a3	f3 0f 11 4d ec	 movss	 DWORD PTR _v3Line3$26[ebp+8], xmm1
  002a8	f3 0f 11 45 e4	 movss	 DWORD PTR _v3Line3$26[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 71   : 				D3DXVec3Normalize(&v3Line0, &v3Line0);

  002ad	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 72   : 				D3DXVec3Normalize(&v3Line1, &v3Line1);

  002b2	8d 45 cc	 lea	 eax, DWORD PTR _v3Line1$23[ebp]
  002b5	50		 push	 eax
  002b6	50		 push	 eax
  002b7	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 73   : 				D3DXVec3Normalize(&v3Line2, &v3Line2);

  002bc	8d 45 f0	 lea	 eax, DWORD PTR _v3Line2$27[ebp]
  002bf	50		 push	 eax
  002c0	50		 push	 eax
  002c1	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8

; 74   : 				D3DXVec3Normalize(&v3Line3, &v3Line3);

  002c6	8d 45 e4	 lea	 eax, DWORD PTR _v3Line3$26[ebp]
  002c9	50		 push	 eax
  002ca	50		 push	 eax
  002cb	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  002d0	f3 0f 10 6d d8	 movss	 xmm5, DWORD PTR _v3Line0$24[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 75   : 				D3DXVec3Cross(&PlaneData.v3Normal, &v3Line0, &v3Line1);

  002d5	8d 77 0c	 lea	 esi, DWORD PTR [edi+12]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  002d8	f3 0f 10 55 cc	 movss	 xmm2, DWORD PTR _v3Line1$23[ebp]
  002dd	0f 28 c5	 movaps	 xmm0, xmm5
  002e0	f3 0f 10 5d d4	 movss	 xmm3, DWORD PTR _v3Line1$23[ebp+8]
  002e5	0f 28 f2	 movaps	 xmm6, xmm2

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  002e8	f3 0f 10 4d d0	 movss	 xmm1, DWORD PTR _v3Line1$23[ebp+4]
  002ed	f3 0f 59 75 e0	 mulss	 xmm6, DWORD PTR _v3Line0$24[ebp+8]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 76   : 				D3DXVec3Normalize(&PlaneData.v3Normal, &PlaneData.v3Normal);

  002f2	56		 push	 esi
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  002f3	f3 0f 59 55 dc	 mulss	 xmm2, DWORD PTR _v3Line0$24[ebp+4]
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 76   : 				D3DXVec3Normalize(&PlaneData.v3Normal, &PlaneData.v3Normal);

  002f8	56		 push	 esi
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  002f9	f3 0f 59 c3	 mulss	 xmm0, xmm3
  002fd	f3 0f 59 5d dc	 mulss	 xmm3, DWORD PTR _v3Line0$24[ebp+4]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00302	f3 0f 59 e9	 mulss	 xmm5, xmm1
  00306	f3 0f 5c f0	 subss	 xmm6, xmm0
  0030a	f3 0f 59 4d e0	 mulss	 xmm1, DWORD PTR _v3Line0$24[ebp+8]
  0030f	f3 0f 5c ea	 subss	 xmm5, xmm2
  00313	f3 0f 5c d9	 subss	 xmm3, xmm1

; 1280 : 
; 1281 :     *pOut = v;

  00317	f3 0f 11 1e	 movss	 DWORD PTR [esi], xmm3
  0031b	f3 0f 11 76 04	 movss	 DWORD PTR [esi+4], xmm6
  00320	f3 0f 11 6e 08	 movss	 DWORD PTR [esi+8], xmm5
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 76   : 				D3DXVec3Normalize(&PlaneData.v3Normal, &PlaneData.v3Normal);

  00325	e8 00 00 00 00	 call	 _D3DXVec3Normalize@8
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  0032a	f3 0f 10 76 08	 movss	 xmm6, DWORD PTR [esi+8]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0032f	f3 0f 10 26	 movss	 xmm4, DWORD PTR [esi]
  00333	0f 28 ee	 movaps	 xmm5, xmm6
  00336	f3 0f 10 7e 04	 movss	 xmm7, DWORD PTR [esi+4]
  0033b	f3 0f 59 6d d8	 mulss	 xmm5, DWORD PTR _v3Line0$24[ebp]
  00340	f3 0f 11 a5 c8
	fe ff ff	 movss	 DWORD PTR tv3665[ebp], xmm4
  00348	f3 0f 59 75 dc	 mulss	 xmm6, DWORD PTR _v3Line0$24[ebp+4]
  0034d	0f 28 c4	 movaps	 xmm0, xmm4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 83   : 				return ppci;

  00350	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00356	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _v3Line0$24[ebp+8]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0035b	f3 0f 59 65 dc	 mulss	 xmm4, DWORD PTR _v3Line0$24[ebp+4]
  00360	f3 0f 5c e8	 subss	 xmm5, xmm0
  00364	0f 28 c7	 movaps	 xmm0, xmm7
  00367	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR _v3Line0$24[ebp]
  0036c	f3 0f 59 7d e0	 mulss	 xmm7, DWORD PTR _v3Line0$24[ebp+8]
  00371	f3 0f 5c e0	 subss	 xmm4, xmm0
  00375	f3 0f 5c fe	 subss	 xmm7, xmm6

; 1280 : 
; 1281 :     *pOut = v;

  00379	f3 0f 11 7f 48	 movss	 DWORD PTR [edi+72], xmm7
  0037e	f3 0f 11 6f 4c	 movss	 DWORD PTR [edi+76], xmm5
  00383	f3 0f 11 67 50	 movss	 DWORD PTR [edi+80], xmm4

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00388	f3 0f 10 bd c8
	fe ff ff	 movss	 xmm7, DWORD PTR tv3665[ebp]
  00390	f3 0f 10 77 14	 movss	 xmm6, DWORD PTR [edi+20]
  00395	0f 28 ef	 movaps	 xmm5, xmm7
  00398	f3 0f 59 6d d4	 mulss	 xmm5, DWORD PTR _v3Line1$23[ebp+8]
  0039d	0f 28 c6	 movaps	 xmm0, xmm6
  003a0	f3 0f 59 45 cc	 mulss	 xmm0, DWORD PTR _v3Line1$23[ebp]
  003a5	f3 0f 10 67 10	 movss	 xmm4, DWORD PTR [edi+16]
  003aa	f3 0f 59 75 d0	 mulss	 xmm6, DWORD PTR _v3Line1$23[ebp+4]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  003af	0f 28 d4	 movaps	 xmm2, xmm4
  003b2	f3 0f 59 65 d4	 mulss	 xmm4, DWORD PTR _v3Line1$23[ebp+8]
  003b7	f3 0f 5c e8	 subss	 xmm5, xmm0
  003bb	f3 0f 59 55 cc	 mulss	 xmm2, DWORD PTR _v3Line1$23[ebp]
  003c0	0f 28 c7	 movaps	 xmm0, xmm7
  003c3	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _v3Line1$23[ebp+4]
  003c8	f3 0f 5c f4	 subss	 xmm6, xmm4
  003cc	f3 0f 5c d0	 subss	 xmm2, xmm0

; 1280 : 
; 1281 :     *pOut = v;

  003d0	f3 0f 11 77 54	 movss	 DWORD PTR [edi+84], xmm6
  003d5	f3 0f 11 6f 58	 movss	 DWORD PTR [edi+88], xmm5

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  003da	0f 28 ef	 movaps	 xmm5, xmm7

; 1281 :     *pOut = v;

  003dd	f3 0f 11 57 5c	 movss	 DWORD PTR [edi+92], xmm2

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  003e2	f3 0f 10 77 14	 movss	 xmm6, DWORD PTR [edi+20]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  003e7	f3 0f 59 6d f8	 mulss	 xmm5, DWORD PTR _v3Line2$27[ebp+8]
  003ec	0f 28 c6	 movaps	 xmm0, xmm6
  003ef	f3 0f 59 45 f0	 mulss	 xmm0, DWORD PTR _v3Line2$27[ebp]
  003f4	f3 0f 10 67 10	 movss	 xmm4, DWORD PTR [edi+16]
  003f9	f3 0f 59 75 f4	 mulss	 xmm6, DWORD PTR _v3Line2$27[ebp+4]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  003fe	0f 28 d4	 movaps	 xmm2, xmm4
  00401	f3 0f 59 65 f8	 mulss	 xmm4, DWORD PTR _v3Line2$27[ebp+8]
  00406	f3 0f 5c e8	 subss	 xmm5, xmm0
  0040a	f3 0f 59 55 f0	 mulss	 xmm2, DWORD PTR _v3Line2$27[ebp]
  0040f	0f 28 c7	 movaps	 xmm0, xmm7
  00412	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _v3Line2$27[ebp+4]
  00417	f3 0f 5c f4	 subss	 xmm6, xmm4
  0041b	f3 0f 5c d0	 subss	 xmm2, xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0041f	0f 28 c7	 movaps	 xmm0, xmm7

; 1281 :     *pOut = v;

  00422	f3 0f 11 77 60	 movss	 DWORD PTR [edi+96], xmm6
  00427	f3 0f 11 6f 64	 movss	 DWORD PTR [edi+100], xmm5
  0042c	f3 0f 11 57 68	 movss	 DWORD PTR [edi+104], xmm2

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00431	f3 0f 10 67 14	 movss	 xmm4, DWORD PTR [edi+20]

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00436	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _v3Line3$26[ebp+8]
  0043b	0f 28 ec	 movaps	 xmm5, xmm4
  0043e	f3 0f 59 6d e4	 mulss	 xmm5, DWORD PTR _v3Line3$26[ebp]
  00443	f3 0f 10 77 10	 movss	 xmm6, DWORD PTR [edi+16]
  00448	f3 0f 59 65 e8	 mulss	 xmm4, DWORD PTR _v3Line3$26[ebp+4]

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  0044d	f3 0f 59 7d e8	 mulss	 xmm7, DWORD PTR _v3Line3$26[ebp+4]
  00452	f3 0f 5c e8	 subss	 xmm5, xmm0
  00456	0f 28 c6	 movaps	 xmm0, xmm6
  00459	f3 0f 59 75 ec	 mulss	 xmm6, DWORD PTR _v3Line3$26[ebp+8]
  0045e	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _v3Line3$26[ebp]
  00463	f3 0f 5c f4	 subss	 xmm6, xmm4
  00467	f3 0f 5c f8	 subss	 xmm7, xmm0

; 1280 : 
; 1281 :     *pOut = v;

  0046b	f3 0f 11 77 6c	 movss	 DWORD PTR [edi+108], xmm6
  00470	f3 0f 11 6f 70	 movss	 DWORD PTR [edi+112], xmm5
  00475	f3 0f 11 7f 74	 movss	 DWORD PTR [edi+116], xmm7
  0047a	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 224  : }

  0047b	5e		 pop	 esi
  0047c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0047f	33 cd		 xor	 ecx, ebp
  00481	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00486	8b e5		 mov	 esp, ebp
  00488	5d		 pop	 ebp
  00489	c3		 ret	 0
$LN8@BuildColli:

; 84   : 			}
; 85   : 			break;
; 86   : 		case COLLISION_TYPE_BOX:
; 87   : 			{
; 88   : 				CAABBCollisionInstance* paci = gs_aci.Alloc();

  0048a	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
  0048f	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ ; CDynamicPool<CAABBCollisionInstance>::Alloc

; 89   : 
; 90   : 				D3DXMATRIX matTranslationLocal;
; 91   : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  00494	f3 0f 10 46 30	 movss	 xmm0, DWORD PTR [esi+48]
  00499	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0049c	8b f8		 mov	 edi, eax
  0049e	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$17[ebp]
  004a4	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  004aa	f3 0f 10 46 2c	 movss	 xmm0, DWORD PTR [esi+44]
  004af	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  004b5	f3 0f 10 46 28	 movss	 xmm0, DWORD PTR [esi+40]
  004ba	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004bf	50		 push	 eax
  004c0	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 92   : 				D3DXMATRIX matTransform = *pMat;

  004c5	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _pMat$GSCopy$1$[ebp]

; 93   : 
; 94   : 				D3DXVECTOR3 v3Pos;
; 95   : 				v3Pos.x = matTranslationLocal._41;
; 96   : 				v3Pos.y = matTranslationLocal._42;
; 97   : 				v3Pos.z = matTranslationLocal._43;
; 98   : 
; 99   : 				float fHalfWidth = c_pCollisionData->fDimensions[0] / 2.0f;
; 100  : 				float fHalfHeight = c_pCollisionData->fDimensions[2] / 2.0f;
; 101  : 				float fHalfLength = c_pCollisionData->fDimensions[1];
; 102  : 				TAABBData& AABBData = paci->GetAttribute();

  004cb	8b cf		 mov	 ecx, edi
  004cd	f3 0f 10 4e 34	 movss	 xmm1, DWORD PTR [esi+52]
  004d2	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  004da	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  004dd	f3 0f 11 8d bc
	fe ff ff	 movss	 DWORD PTR tv3683[ebp], xmm1
  004e5	f3 0f 10 4e 3c	 movss	 xmm1, DWORD PTR [esi+60]
  004ea	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@3f000000
  004f2	0f 11 45 8c	 movups	 XMMWORD PTR _matTransform$21[ebp], xmm0
  004f6	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  004fa	f3 0f 11 8d c0
	fe ff ff	 movss	 DWORD PTR tv3856[ebp], xmm1
  00502	0f 11 45 9c	 movups	 XMMWORD PTR _matTransform$21[ebp+16], xmm0
  00506	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [eax+32]
  0050a	0f 11 45 ac	 movups	 XMMWORD PTR _matTransform$21[ebp+32], xmm0
  0050e	0f 10 40 30	 movups	 xmm0, XMMWORD PTR [eax+48]
  00512	0f 11 45 bc	 movups	 XMMWORD PTR _matTransform$21[ebp+48], xmm0
  00516	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$17[ebp+48]
  0051e	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR tv3883[ebp], xmm0
  00526	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _matTranslationLocal$17[ebp+52]
  0052b	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR tv3684[ebp], xmm0
  00533	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _matTranslationLocal$17[ebp+56]
  00538	f3 0f 11 85 b8
	fe ff ff	 movss	 DWORD PTR tv3685[ebp], xmm0
  00540	f3 0f 10 46 38	 movss	 xmm0, DWORD PTR [esi+56]
  00545	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR tv3854[ebp], xmm0
  0054d	e8 00 00 00 00	 call	 ?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ ; CAABBCollisionInstance::GetAttribute
  00552	f3 0f 10 85 c8
	fe ff ff	 movss	 xmm0, DWORD PTR tv3883[ebp]

; 103  : 				AABBData.v3Min.x = v3Pos.x - fHalfWidth;
; 104  : 				AABBData.v3Min.y = v3Pos.y - fHalfHeight;
; 105  : 				AABBData.v3Min.z = v3Pos.z - fHalfLength;
; 106  : 				AABBData.v3Max.x = v3Pos.x + fHalfWidth;

  0055a	8d 70 0c	 lea	 esi, DWORD PTR [eax+12]
  0055d	f3 0f 10 9d bc
	fe ff ff	 movss	 xmm3, DWORD PTR tv3683[ebp]
  00565	f3 0f 10 ad c4
	fe ff ff	 movss	 xmm5, DWORD PTR tv3684[ebp]
  0056d	f3 0f 5c c3	 subss	 xmm0, xmm3
  00571	f3 0f 10 b5 b8
	fe ff ff	 movss	 xmm6, DWORD PTR tv3685[ebp]
  00579	f3 0f 58 9d c8
	fe ff ff	 addss	 xmm3, DWORD PTR tv3883[ebp]
  00581	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00585	0f 28 c5	 movaps	 xmm0, xmm5
  00588	f3 0f 5c 85 c0
	fe ff ff	 subss	 xmm0, DWORD PTR tv3856[ebp]
  00590	f3 0f 58 ad c0
	fe ff ff	 addss	 xmm5, DWORD PTR tv3856[ebp]
  00598	f3 0f 11 1e	 movss	 DWORD PTR [esi], xmm3
  0059c	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  005a1	0f 28 c6	 movaps	 xmm0, xmm6
  005a4	f3 0f 5c 85 b4
	fe ff ff	 subss	 xmm0, DWORD PTR tv3854[ebp]

; 107  : 				AABBData.v3Max.y = v3Pos.y + fHalfHeight;

  005ac	f3 0f 58 b5 b4
	fe ff ff	 addss	 xmm6, DWORD PTR tv3854[ebp]
  005b4	f3 0f 11 68 10	 movss	 DWORD PTR [eax+16], xmm5
  005b9	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 108  : 				AABBData.v3Max.z = v3Pos.z + fHalfLength;

  005be	f3 0f 11 70 14	 movss	 DWORD PTR [eax+20], xmm6
$LN191@BuildColli:

; 224  : }

  005c3	8d 4d 8c	 lea	 ecx, DWORD PTR _matTransform$21[ebp]
  005c6	51		 push	 ecx
  005c7	50		 push	 eax
  005c8	50		 push	 eax
  005c9	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
  005ce	8d 45 8c	 lea	 eax, DWORD PTR _matTransform$21[ebp]
  005d1	50		 push	 eax
  005d2	56		 push	 esi
  005d3	56		 push	 esi
  005d4	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
  005d9	8b c7		 mov	 eax, edi
  005db	5f		 pop	 edi
  005dc	5e		 pop	 esi
  005dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005e0	33 cd		 xor	 ecx, ebp
  005e2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005e7	8b e5		 mov	 esp, ebp
  005e9	5d		 pop	 ebp
  005ea	c3		 ret	 0
$LN9@BuildColli:

; 109  : 
; 110  : 				D3DXVec3TransformCoord(&AABBData.v3Min, &AABBData.v3Min, &matTransform);
; 111  : 				D3DXVec3TransformCoord(&AABBData.v3Max, &AABBData.v3Max, &matTransform);
; 112  : 
; 113  : 				return paci;
; 114  : 			}
; 115  : 			break;
; 116  : 		case COLLISION_TYPE_AABB:
; 117  : 			{
; 118  : 				CAABBCollisionInstance * paci = gs_aci.Alloc();

  005eb	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A ; gs_aci
  005f0	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCAABBCollisionInstance@@@@QAEPAVCAABBCollisionInstance@@XZ ; CDynamicPool<CAABBCollisionInstance>::Alloc

; 119  : 
; 120  : 				D3DXMATRIX matTranslationLocal;
; 121  : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  005f5	f3 0f 10 46 30	 movss	 xmm0, DWORD PTR [esi+48]
  005fa	83 ec 0c	 sub	 esp, 12			; 0000000cH
  005fd	8b f8		 mov	 edi, eax
  005ff	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$16[ebp]
  00605	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  0060b	f3 0f 10 46 2c	 movss	 xmm0, DWORD PTR [esi+44]
  00610	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00616	f3 0f 10 46 28	 movss	 xmm0, DWORD PTR [esi+40]
  0061b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00620	50		 push	 eax
  00621	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 122  : 				D3DXMATRIX matTransform = *pMat;

  00626	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _pMat$GSCopy$1$[ebp]

; 123  : 
; 124  : 				D3DXVECTOR3 v3Pos;
; 125  : 				v3Pos.x = matTranslationLocal._41;
; 126  : 				v3Pos.y = matTranslationLocal._42;
; 127  : 				v3Pos.z = matTranslationLocal._43;
; 128  : 
; 129  : 				TAABBData & AABBData = paci->GetAttribute();

  0062c	8b cf		 mov	 ecx, edi
  0062e	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00631	0f 11 45 8c	 movups	 XMMWORD PTR _matTransform$20[ebp], xmm0
  00635	0f 10 40 10	 movups	 xmm0, XMMWORD PTR [eax+16]
  00639	0f 11 45 9c	 movups	 XMMWORD PTR _matTransform$20[ebp+16], xmm0
  0063d	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [eax+32]
  00641	0f 11 45 ac	 movups	 XMMWORD PTR _matTransform$20[ebp+32], xmm0
  00645	0f 10 40 30	 movups	 xmm0, XMMWORD PTR [eax+48]
  00649	0f 11 45 bc	 movups	 XMMWORD PTR _matTransform$20[ebp+48], xmm0
  0064d	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _matTranslationLocal$16[ebp+48]
  00655	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR tv3702[ebp], xmm0
  0065d	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _matTranslationLocal$16[ebp+52]
  00662	f3 0f 11 85 b8
	fe ff ff	 movss	 DWORD PTR tv3703[ebp], xmm0
  0066a	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _matTranslationLocal$16[ebp+56]
  0066f	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR tv3704[ebp], xmm0
  00677	e8 00 00 00 00	 call	 ?GetAttribute@CAABBCollisionInstance@@QAEAAUSAABBData@@XZ ; CAABBCollisionInstance::GetAttribute

; 130  : 				AABBData.v3Min.x = v3Pos.x - c_pCollisionData->fDimensions[0];

  0067c	f3 0f 10 8d b4
	fe ff ff	 movss	 xmm1, DWORD PTR tv3702[ebp]

; 131  : 				AABBData.v3Min.y = v3Pos.y - c_pCollisionData->fDimensions[1];

  00684	f3 0f 10 95 b8
	fe ff ff	 movss	 xmm2, DWORD PTR tv3703[ebp]
  0068c	0f 28 c1	 movaps	 xmm0, xmm1
  0068f	f3 0f 5c 46 34	 subss	 xmm0, DWORD PTR [esi+52]

; 132  : 				AABBData.v3Min.z = v3Pos.z - c_pCollisionData->fDimensions[2];

  00694	f3 0f 10 9d bc
	fe ff ff	 movss	 xmm3, DWORD PTR tv3704[ebp]

; 133  : 				AABBData.v3Max.x = v3Pos.x + c_pCollisionData->fDimensions[0];

  0069c	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR _c_pCollisionData$GSCopy$1$[ebp]
  006a2	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  006a6	0f 28 c2	 movaps	 xmm0, xmm2
  006a9	f3 0f 5c 46 38	 subss	 xmm0, DWORD PTR [esi+56]
  006ae	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  006b3	0f 28 c3	 movaps	 xmm0, xmm3
  006b6	f3 0f 5c 46 3c	 subss	 xmm0, DWORD PTR [esi+60]
  006bb	8d 70 0c	 lea	 esi, DWORD PTR [eax+12]
  006be	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  006c3	f3 0f 58 49 34	 addss	 xmm1, DWORD PTR [ecx+52]
  006c8	f3 0f 11 0e	 movss	 DWORD PTR [esi], xmm1

; 134  : 				AABBData.v3Max.y = v3Pos.y + c_pCollisionData->fDimensions[1];

  006cc	f3 0f 58 51 38	 addss	 xmm2, DWORD PTR [ecx+56]
  006d1	f3 0f 11 50 10	 movss	 DWORD PTR [eax+16], xmm2

; 135  : 				AABBData.v3Max.z = v3Pos.z + c_pCollisionData->fDimensions[2];

  006d6	f3 0f 58 59 3c	 addss	 xmm3, DWORD PTR [ecx+60]
  006db	f3 0f 11 58 14	 movss	 DWORD PTR [eax+20], xmm3

; 136  : 
; 137  : 				D3DXVec3TransformCoord(&AABBData.v3Min, &AABBData.v3Min, &matTransform);
; 138  : 				D3DXVec3TransformCoord(&AABBData.v3Max, &AABBData.v3Max, &matTransform);
; 139  : 
; 140  : 				return paci;

  006e0	e9 de fe ff ff	 jmp	 $LN191@BuildColli
$LN10@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  006e5	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+20
  006eb	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 64   : 			if (m_kVct_pkFree.empty())

  006f1	75 6f		 jne	 SHORT $LN72@BuildColli

; 66   : 				T* pkNewData=new T;

  006f3	6a 5c		 push	 92			; 0000005cH
  006f5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  006fa	83 c4 04	 add	 esp, 4
  006fd	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00703	85 c0		 test	 eax, eax
  00705	74 08		 je	 SHORT $LN74@BuildColli
  00707	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7COBBCollisionInstance@@6B@
  0070d	eb 08		 jmp	 SHORT $LN75@BuildColli
$LN74@BuildColli:
  0070f	33 c0		 xor	 eax, eax
  00711	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
$LN75@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00717	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 66   : 				T* pkNewData=new T;

  0071d	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _pkNewData$8[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00723	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+12
  00729	74 11		 je	 SHORT $LN88@BuildColli

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  0072b	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  0072d	83 05 08 00 00
	00 04		 add	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  00734	ff 05 20 00 00
	00		 inc	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+32

; 69   : 				return pkNewData;

  0073a	eb 37		 jmp	 SHORT $LN71@BuildColli
$LN88@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0073c	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _pkNewData$8[ebp]
  00742	50		 push	 eax
  00743	51		 push	 ecx
  00744	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+4
  00749	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCOBBCollisionInstance@@@?$vector@PAVCOBBCollisionInstance@@V?$allocator@PAVCOBBCollisionInstance@@@std@@@std@@AAEPAPAVCOBBCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<COBBCollisionInstance *,std::allocator<COBBCollisionInstance *> >::_Emplace_reallocate<COBBCollisionInstance * const &>
  0074e	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _pkNewData$8[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  00754	ff 05 20 00 00
	00		 inc	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+32
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0075a	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 69   : 				return pkNewData;

  00760	eb 11		 jmp	 SHORT $LN71@BuildColli
$LN72@BuildColli:

; 70   : 			}
; 71   : 
; 72   : 			T* pkFreeData=m_kVct_pkFree.back();

  00762	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00765	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1744 :         --_Mylast;

  0076b	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  0076e	a3 14 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+20, eax
$LN71@BuildColli:
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 147  : 				D3DXMATRIX matTranslationLocal; D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  00773	f3 0f 10 46 30	 movss	 xmm0, DWORD PTR [esi+48]
  00778	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _matTranslationLocal$10[ebp]
  0077e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00781	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00787	f3 0f 10 46 2c	 movss	 xmm0, DWORD PTR [esi+44]
  0078c	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00792	f3 0f 10 46 28	 movss	 xmm0, DWORD PTR [esi+40]
  00797	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0079c	50		 push	 eax
  0079d	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16

; 148  : 				D3DXMATRIX matRotation; D3DXMatrixRotationQuaternion(&matRotation, &c_pCollisionData->quatRotation);

  007a2	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  007a5	50		 push	 eax
  007a6	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _matRotation$12[ebp]
  007ac	50		 push	 eax
  007ad	e8 00 00 00 00	 call	 _D3DXMatrixRotationQuaternion@8

; 149  : 
; 150  : 				D3DXMATRIX matTranslationWorld; D3DXMatrixIdentity(&matTranslationWorld);
; 151  : 				matTranslationWorld._41 = pMat->_41; matTranslationWorld._42 = pMat->_42; matTranslationWorld._43 = pMat->_43; matTranslationWorld._44 = pMat->_44;
; 152  : 
; 153  : 				D3DXVECTOR3 v3Min, v3Max;
; 154  : 				v3Min.x = c_pCollisionData->v3Position.x - c_pCollisionData->fDimensions[0];

  007b2	f3 0f 10 6e 34	 movss	 xmm5, DWORD PTR [esi+52]

; 155  : 				v3Min.y = c_pCollisionData->v3Position.y - c_pCollisionData->fDimensions[1];
; 156  : 				v3Min.z = c_pCollisionData->v3Position.z - c_pCollisionData->fDimensions[2];
; 157  : 				v3Max.x = c_pCollisionData->v3Position.x + c_pCollisionData->fDimensions[0];
; 158  : 				v3Max.y = c_pCollisionData->v3Position.y + c_pCollisionData->fDimensions[1];
; 159  : 				v3Max.z = c_pCollisionData->v3Position.z + c_pCollisionData->fDimensions[2];
; 160  : 
; 161  : 				D3DXVec3TransformCoord(&v3Min, &v3Min, pMat);

  007b7	8d 45 f0	 lea	 eax, DWORD PTR _v3Min$28[ebp]
  007ba	f3 0f 10 46 28	 movss	 xmm0, DWORD PTR [esi+40]
  007bf	f3 0f 10 5e 38	 movss	 xmm3, DWORD PTR [esi+56]
  007c4	f3 0f 5c c5	 subss	 xmm0, xmm5
  007c8	f3 0f 10 4e 3c	 movss	 xmm1, DWORD PTR [esi+60]
  007cd	f3 0f 58 6e 28	 addss	 xmm5, DWORD PTR [esi+40]
  007d2	57		 push	 edi
  007d3	50		 push	 eax
  007d4	f3 0f 11 45 f0	 movss	 DWORD PTR _v3Min$28[ebp], xmm0
  007d9	f3 0f 10 46 2c	 movss	 xmm0, DWORD PTR [esi+44]
  007de	f3 0f 5c c3	 subss	 xmm0, xmm3
  007e2	f3 0f 11 6d e4	 movss	 DWORD PTR _v3Max$25[ebp], xmm5
  007e7	f3 0f 58 5e 2c	 addss	 xmm3, DWORD PTR [esi+44]
  007ec	50		 push	 eax
  007ed	f3 0f 11 45 f4	 movss	 DWORD PTR _v3Min$28[ebp+4], xmm0
  007f2	f3 0f 10 46 30	 movss	 xmm0, DWORD PTR [esi+48]
  007f7	f3 0f 5c c1	 subss	 xmm0, xmm1
  007fb	f3 0f 11 5d e8	 movss	 DWORD PTR _v3Max$25[ebp+4], xmm3
  00800	f3 0f 58 4e 30	 addss	 xmm1, DWORD PTR [esi+48]
  00805	f3 0f 11 45 f8	 movss	 DWORD PTR _v3Min$28[ebp+8], xmm0
  0080a	f3 0f 11 4d ec	 movss	 DWORD PTR _v3Max$25[ebp+8], xmm1
  0080f	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 162  : 				D3DXVec3TransformCoord(&v3Max, &v3Max, pMat);

  00814	57		 push	 edi
  00815	8d 45 e4	 lea	 eax, DWORD PTR _v3Max$25[ebp]
  00818	50		 push	 eax
  00819	50		 push	 eax
  0081a	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0081f	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _v3Max$25[ebp]
  00824	f3 0f 58 4d f0	 addss	 xmm1, DWORD PTR _v3Min$28[ebp]

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00829	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 165  : 				TOBBData & OBBData = poci->GetAttribute();

  00831	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00837	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0083b	f3 0f 11 8d b4
	fe ff ff	 movss	 DWORD PTR tv3740[ebp], xmm1

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00843	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _v3Max$25[ebp+4]
  00848	f3 0f 58 4d f4	 addss	 xmm1, DWORD PTR _v3Min$28[ebp+4]

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  0084d	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00851	f3 0f 11 8d b8
	fe ff ff	 movss	 DWORD PTR tv3741[ebp], xmm1

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00859	f3 0f 10 4d ec	 movss	 xmm1, DWORD PTR _v3Max$25[ebp+8]
  0085e	f3 0f 58 4d f8	 addss	 xmm1, DWORD PTR _v3Min$28[ebp+8]

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00863	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00867	f3 0f 11 8d c8
	fe ff ff	 movss	 DWORD PTR tv3742[ebp], xmm1
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 165  : 				TOBBData & OBBData = poci->GetAttribute();

  0086f	e8 00 00 00 00	 call	 ?GetAttribute@COBBCollisionInstance@@QAEAAUSOBBData@@XZ ; COBBCollisionInstance::GetAttribute

; 166  : 				OBBData.v3Min.x = v3Position.x - c_pCollisionData->fDimensions[0];

  00874	f3 0f 10 9d b4
	fe ff ff	 movss	 xmm3, DWORD PTR tv3740[ebp]

; 167  : 				OBBData.v3Min.y = v3Position.y - c_pCollisionData->fDimensions[1];

  0087c	f3 0f 10 95 b8
	fe ff ff	 movss	 xmm2, DWORD PTR tv3741[ebp]
  00884	0f 28 c3	 movaps	 xmm0, xmm3
  00887	f3 0f 5c 46 34	 subss	 xmm0, DWORD PTR [esi+52]

; 168  : 				OBBData.v3Min.z = v3Position.z - c_pCollisionData->fDimensions[2];

  0088c	f3 0f 10 8d c8
	fe ff ff	 movss	 xmm1, DWORD PTR tv3742[ebp]
  00894	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  00898	0f 28 c2	 movaps	 xmm0, xmm2
  0089b	f3 0f 5c 46 38	 subss	 xmm0, DWORD PTR [esi+56]
  008a0	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  008a5	0f 28 c1	 movaps	 xmm0, xmm1
  008a8	f3 0f 5c 46 3c	 subss	 xmm0, DWORD PTR [esi+60]
  008ad	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 169  : 				OBBData.v3Max.x = v3Position.x + c_pCollisionData->fDimensions[0];

  008b2	f3 0f 58 5e 34	 addss	 xmm3, DWORD PTR [esi+52]
  008b7	f3 0f 11 58 0c	 movss	 DWORD PTR [eax+12], xmm3

; 170  : 				OBBData.v3Max.y = v3Position.y + c_pCollisionData->fDimensions[1];

  008bc	f3 0f 58 56 38	 addss	 xmm2, DWORD PTR [esi+56]
  008c1	f3 0f 11 50 10	 movss	 DWORD PTR [eax+16], xmm2

; 171  : 				OBBData.v3Max.z = v3Position.z + c_pCollisionData->fDimensions[2];

  008c6	f3 0f 58 4e 3c	 addss	 xmm1, DWORD PTR [esi+60]
  008cb	f3 0f 11 48 14	 movss	 DWORD PTR [eax+20], xmm1
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  008d0	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0
  008d7	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0
  008de	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0
  008e5	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [eax+68], 0
  008ec	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0
  008f3	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
  008fa	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0
  00901	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  00908	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  0090f	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
  00916	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0
  0091d	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00924	c7 40 54 00 00
	80 3f		 mov	 DWORD PTR [eax+84], 1065353216 ; 3f800000H
  0092b	c7 40 40 00 00
	80 3f		 mov	 DWORD PTR [eax+64], 1065353216 ; 3f800000H
  00932	c7 40 2c 00 00
	80 3f		 mov	 DWORD PTR [eax+44], 1065353216 ; 3f800000H
  00939	c7 40 18 00 00
	80 3f		 mov	 DWORD PTR [eax+24], 1065353216 ; 3f800000H
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 177  : 				D3DXMatrixIdentity(&OBBData.matRot); OBBData.matRot = *pMat;

  00940	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00943	0f 11 40 18	 movups	 XMMWORD PTR [eax+24], xmm0
  00947	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [edi+16]
  0094b	0f 11 40 28	 movups	 XMMWORD PTR [eax+40], xmm0
  0094f	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [edi+32]
  00953	0f 11 40 38	 movups	 XMMWORD PTR [eax+56], xmm0
  00957	0f 10 47 30	 movups	 xmm0, XMMWORD PTR [edi+48]
  0095b	5f		 pop	 edi

; 224  : }

  0095c	5e		 pop	 esi
  0095d	0f 11 40 48	 movups	 XMMWORD PTR [eax+72], xmm0
  00961	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [eax+72], 0
  00968	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], 0
  0096f	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0
  00976	c7 40 54 00 00
	80 3f		 mov	 DWORD PTR [eax+84], 1065353216 ; 3f800000H
  0097d	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00983	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00986	33 cd		 xor	 ecx, ebp
  00988	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0098d	8b e5		 mov	 esp, ebp
  0098f	5d		 pop	 ebp
  00990	c3		 ret	 0
$LN11@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00991	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+20
  00997	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+16, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 64   : 			if (m_kVct_pkFree.empty())

  0099d	75 6f		 jne	 SHORT $LN115@BuildColli

; 66   : 				T* pkNewData=new T;

  0099f	6a 14		 push	 20			; 00000014H
  009a1	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  009a6	83 c4 04	 add	 esp, 4
  009a9	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  009af	85 c0		 test	 eax, eax
  009b1	74 08		 je	 SHORT $LN117@BuildColli
  009b3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSphereCollisionInstance@@6B@
  009b9	eb 08		 jmp	 SHORT $LN118@BuildColli
$LN117@BuildColli:
  009bb	33 c0		 xor	 eax, eax
  009bd	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
$LN118@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  009c3	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+8
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 66   : 				T* pkNewData=new T;

  009c9	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _pkNewData$6[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  009cf	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+12
  009d5	74 11		 je	 SHORT $LN131@BuildColli

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  009d7	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  009d9	83 05 08 00 00
	00 04		 add	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+8, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  009e0	ff 05 20 00 00
	00		 inc	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+32

; 69   : 				return pkNewData;

  009e6	eb 37		 jmp	 SHORT $LN114@BuildColli
$LN131@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  009e8	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _pkNewData$6[ebp]
  009ee	50		 push	 eax
  009ef	51		 push	 ecx
  009f0	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+4
  009f5	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCSphereCollisionInstance@@@?$vector@PAVCSphereCollisionInstance@@V?$allocator@PAVCSphereCollisionInstance@@@std@@@std@@AAEPAPAVCSphereCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CSphereCollisionInstance *,std::allocator<CSphereCollisionInstance *> >::_Emplace_reallocate<CSphereCollisionInstance * const &>
  009fa	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _pkNewData$6[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  00a00	ff 05 20 00 00
	00		 inc	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+32
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00a06	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 69   : 				return pkNewData;

  00a0c	eb 11		 jmp	 SHORT $LN114@BuildColli
$LN115@BuildColli:

; 70   : 			}
; 71   : 
; 72   : 			T* pkFreeData=m_kVct_pkFree.back();

  00a0e	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00a11	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1744 :         --_Mylast;

  00a17	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00a1a	a3 14 00 00 00	 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+20, eax
$LN114@BuildColli:
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 191  : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  00a1f	f3 0f 10 46 30	 movss	 xmm0, DWORD PTR [esi+48]
  00a24	8d 45 8c	 lea	 eax, DWORD PTR _matTranslationLocal$19[ebp]
  00a27	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00a2a	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00a30	f3 0f 10 46 2c	 movss	 xmm0, DWORD PTR [esi+44]
  00a35	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00a3b	f3 0f 10 46 28	 movss	 xmm0, DWORD PTR [esi+40]
  00a40	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a45	50		 push	 eax
  00a46	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00a4b	57		 push	 edi
  00a4c	8d 45 8c	 lea	 eax, DWORD PTR _matTranslationLocal$19[ebp]
  00a4f	50		 push	 eax
  00a50	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00a56	50		 push	 eax
  00a57	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 192  : 				matTranslationLocal = matTranslationLocal * *pMat;

  00a5c	0f 10 85 4c ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T15[ebp]

; 193  : 
; 194  : 				TSphereData & SphereData = psci->GetAttribute();

  00a63	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  00a69	0f 11 45 8c	 movups	 XMMWORD PTR _matTranslationLocal$19[ebp], xmm0
  00a6d	0f 10 85 5c ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T15[ebp+16]
  00a74	0f 11 45 9c	 movups	 XMMWORD PTR _matTranslationLocal$19[ebp+16], xmm0
  00a78	0f 10 85 6c ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T15[ebp+32]
  00a7f	0f 11 45 ac	 movups	 XMMWORD PTR _matTranslationLocal$19[ebp+32], xmm0
  00a83	0f 10 85 7c ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T15[ebp+48]
  00a8a	0f 11 45 bc	 movups	 XMMWORD PTR _matTranslationLocal$19[ebp+48], xmm0
  00a8e	e8 00 00 00 00	 call	 ?GetAttribute@CSphereCollisionInstance@@QAEAAUSSphereData@@XZ ; CSphereCollisionInstance::GetAttribute

; 195  : 				SphereData.v3Position.x = matTranslationLocal._41;

  00a93	0f 10 85 7c ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T15[ebp+48]
  00a9a	5f		 pop	 edi
  00a9b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 196  : 				SphereData.v3Position.y = matTranslationLocal._42;

  00a9f	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _matTranslationLocal$19[ebp+52]
  00aa4	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 197  : 				SphereData.v3Position.z = matTranslationLocal._43;

  00aa9	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _matTranslationLocal$19[ebp+56]
  00aae	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 198  : 				SphereData.fRadius = c_pCollisionData->fDimensions[0];

  00ab3	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00ab6	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 199  : 
; 200  : 				return psci;

  00ab9	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]

; 224  : }

  00abf	5e		 pop	 esi
  00ac0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ac3	33 cd		 xor	 ecx, ebp
  00ac5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00aca	8b e5		 mov	 esp, ebp
  00acc	5d		 pop	 ebp
  00acd	c3		 ret	 0
$LN12@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1895 :         return _My_data._Myfirst == _My_data._Mylast;

  00ace	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+20
  00ad4	39 0d 10 00 00
	00		 cmp	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+16, ecx
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 64   : 			if (m_kVct_pkFree.empty())

  00ada	75 6f		 jne	 SHORT $LN144@BuildColli

; 66   : 				T* pkNewData=new T;

  00adc	6a 18		 push	 24			; 00000018H
  00ade	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00ae3	83 c4 04	 add	 esp, 4
  00ae6	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  00aec	85 c0		 test	 eax, eax
  00aee	74 08		 je	 SHORT $LN146@BuildColli
  00af0	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCylinderCollisionInstance@@6B@
  00af6	eb 08		 jmp	 SHORT $LN147@BuildColli
$LN146@BuildColli:
  00af8	33 c0		 xor	 eax, eax
  00afa	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
$LN147@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00b00	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+8
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 66   : 				T* pkNewData=new T;

  00b06	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _pkNewData$7[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00b0c	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+12
  00b12	74 11		 je	 SHORT $LN160@BuildColli

; 845  :             _STD _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00b14	89 01		 mov	 DWORD PTR [ecx], eax

; 846  :         } else {
; 847  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00b16	83 05 08 00 00
	00 04		 add	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+8, 4
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  00b1d	ff 05 20 00 00
	00		 inc	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+32

; 69   : 				return pkNewData;

  00b23	eb 37		 jmp	 SHORT $LN143@BuildColli
$LN160@BuildColli:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00b25	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _pkNewData$7[ebp]
  00b2b	50		 push	 eax
  00b2c	51		 push	 ecx
  00b2d	b9 04 00 00 00	 mov	 ecx, OFFSET ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+4
  00b32	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCCylinderCollisionInstance@@@?$vector@PAVCCylinderCollisionInstance@@V?$allocator@PAVCCylinderCollisionInstance@@@std@@@std@@AAEPAPAVCCylinderCollisionInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CCylinderCollisionInstance *,std::allocator<CCylinderCollisionInstance *> >::_Emplace_reallocate<CCylinderCollisionInstance * const &>
  00b37	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _pkNewData$7[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 68   : 				++m_uUsedCapacity;

  00b3d	ff 05 20 00 00
	00		 inc	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+32
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00b43	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 69   : 				return pkNewData;

  00b49	eb 11		 jmp	 SHORT $LN143@BuildColli
$LN144@BuildColli:

; 70   : 			}
; 71   : 
; 72   : 			T* pkFreeData=m_kVct_pkFree.back();

  00b4b	8b 41 fc	 mov	 eax, DWORD PTR [ecx-4]
  00b4e	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1744 :         --_Mylast;

  00b54	8d 41 fc	 lea	 eax, DWORD PTR [ecx-4]
  00b57	a3 14 00 00 00	 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+20, eax
$LN143@BuildColli:
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 208  : 				D3DXMatrixTranslation(&matTranslationLocal, c_pCollisionData->v3Position.x, c_pCollisionData->v3Position.y, c_pCollisionData->v3Position.z);

  00b5c	f3 0f 10 46 30	 movss	 xmm0, DWORD PTR [esi+48]
  00b61	8d 45 8c	 lea	 eax, DWORD PTR _matTranslationLocal$22[ebp]
  00b64	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00b67	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  00b6d	f3 0f 10 46 2c	 movss	 xmm0, DWORD PTR [esi+44]
  00b72	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00b78	f3 0f 10 46 28	 movss	 xmm0, DWORD PTR [esi+40]
  00b7d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00b82	50		 push	 eax
  00b83	e8 00 00 00 00	 call	 _D3DXMatrixTranslation@16
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00b88	57		 push	 edi
  00b89	8d 45 8c	 lea	 eax, DWORD PTR _matTranslationLocal$22[ebp]
  00b8c	50		 push	 eax
  00b8d	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  00b93	50		 push	 eax
  00b94	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 209  : 				matTranslationLocal = matTranslationLocal * *pMat;

  00b99	0f 10 85 4c ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T14[ebp]

; 210  : 
; 211  : 				TCylinderData & CylinderData = pcci->GetAttribute();

  00ba0	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  00ba6	0f 11 45 8c	 movups	 XMMWORD PTR _matTranslationLocal$22[ebp], xmm0
  00baa	0f 10 85 5c ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T14[ebp+16]
  00bb1	0f 11 45 9c	 movups	 XMMWORD PTR _matTranslationLocal$22[ebp+16], xmm0
  00bb5	0f 10 85 6c ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T14[ebp+32]
  00bbc	0f 11 45 ac	 movups	 XMMWORD PTR _matTranslationLocal$22[ebp+32], xmm0
  00bc0	0f 10 85 7c ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T14[ebp+48]
  00bc7	0f 11 45 bc	 movups	 XMMWORD PTR _matTranslationLocal$22[ebp+48], xmm0
  00bcb	e8 00 00 00 00	 call	 ?GetAttribute@CCylinderCollisionInstance@@QAEAAUSCylinderData@@XZ ; CCylinderCollisionInstance::GetAttribute

; 212  : 				CylinderData.fRadius = c_pCollisionData->fDimensions[0];

  00bd0	8b 4e 34	 mov	 ecx, DWORD PTR [esi+52]
  00bd3	5f		 pop	 edi
  00bd4	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 213  : 				CylinderData.fHeight = c_pCollisionData->fDimensions[1];

  00bd7	8b 4e 38	 mov	 ecx, DWORD PTR [esi+56]
  00bda	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 214  : 				CylinderData.v3Position.x = matTranslationLocal._41;

  00bdd	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _matTranslationLocal$22[ebp+48]
  00be2	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 215  : 				CylinderData.v3Position.y = matTranslationLocal._42;

  00be6	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _matTranslationLocal$22[ebp+52]
  00beb	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 216  : 				CylinderData.v3Position.z = matTranslationLocal._43 /*+ CylinderData.fHeight/2.0f*/;

  00bf0	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _matTranslationLocal$22[ebp+56]
  00bf5	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 217  : 
; 218  : 				return pcci;

  00bfa	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]

; 224  : }

  00c00	5e		 pop	 esi
  00c01	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c04	33 cd		 xor	 ecx, ebp
  00c06	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c0b	8b e5		 mov	 esp, ebp
  00c0d	5d		 pop	 ebp
  00c0e	c3		 ret	 0
$LN2@BuildColli:
  00c0f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c12	33 c0		 xor	 eax, eax
  00c14	5f		 pop	 edi
  00c15	33 cd		 xor	 ecx, ebp
  00c17	5e		 pop	 esi
  00c18	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c1d	8b e5		 mov	 esp, ebp
  00c1f	5d		 pop	 ebp
  00c20	c3		 ret	 0
  00c21	0f 1f 00	 npad	 3
$LN176@BuildColli:
  00c24	00 00 00 00	 DD	 $LN7@BuildColli
  00c28	00 00 00 00	 DD	 $LN8@BuildColli
  00c2c	00 00 00 00	 DD	 $LN11@BuildColli
  00c30	00 00 00 00	 DD	 $LN12@BuildColli
  00c34	00 00 00 00	 DD	 $LN9@BuildColli
  00c38	00 00 00 00	 DD	 $LN10@BuildColli
?BuildCollisionInstance@CBaseCollisionInstance@@SAPAV1@PBVCStaticCollisionData@@PBUD3DXMATRIX@@@Z ENDP ; CBaseCollisionInstance::BuildCollisionInstance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?Destroy@CBaseCollisionInstance@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CBaseCollisionInstance@@QAEXXZ PROC		; CBaseCollisionInstance::Destroy, COMDAT
; _this$ = ecx

; 228  : 	OnDestroy();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 10	 jmp	 DWORD PTR [eax+16]
?Destroy@CBaseCollisionInstance@@QAEXXZ ENDP		; CBaseCollisionInstance::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp
;	COMDAT ?DestroyCollisionInstanceSystem@@YAXXZ
_TEXT	SEGMENT
?DestroyCollisionInstanceSystem@@YAXXZ PROC		; DestroyCollisionInstanceSystem, COMDAT

; 25   : {

  00000	56		 push	 esi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  00001	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+4
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 25   : {

  00007	57		 push	 edi
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  00008	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+8
  0000e	3b f7		 cmp	 esi, edi
  00010	74 29		 je	 SHORT $LN10@DestroyCol
$LL6@DestroyCol:

; 111  : 			delete pkData;

  00012	6a 14		 push	 20			; 00000014H
  00014	ff 36		 push	 DWORD PTR [esi]
  00016	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete

; 50   : 			for (auto v : m_kVct_pkData)

  0001b	83 c6 04	 add	 esi, 4

; 111  : 			delete pkData;

  0001e	83 c4 08	 add	 esp, 8

; 50   : 			for (auto v : m_kVct_pkData)

  00021	3b f7		 cmp	 esi, edi
  00023	75 ed		 jne	 SHORT $LL6@DestroyCol
  00025	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+8
  0002b	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	3b f7		 cmp	 esi, edi
  00033	74 06		 je	 SHORT $LN10@DestroyCol

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00035	89 35 08 00 00
	00		 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+8, esi
$LN10@DestroyCol:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0003b	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+16
  00040	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+20
  00046	74 05		 je	 SHORT $LN14@DestroyCol

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00048	a3 14 00 00 00	 mov	 DWORD PTR ?gs_sci@@3V?$CDynamicPool@VCSphereCollisionInstance@@@@A+20, eax
$LN14@DestroyCol:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  0004d	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+8
  00053	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+4
  00059	3b f7		 cmp	 esi, edi
  0005b	74 2c		 je	 SHORT $LN25@DestroyCol
  0005d	0f 1f 00	 npad	 3
$LL21@DestroyCol:

; 111  : 			delete pkData;

  00060	6a 18		 push	 24			; 00000018H
  00062	ff 36		 push	 DWORD PTR [esi]
  00064	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete

; 50   : 			for (auto v : m_kVct_pkData)

  00069	83 c6 04	 add	 esi, 4

; 111  : 			delete pkData;

  0006c	83 c4 08	 add	 esp, 8

; 50   : 			for (auto v : m_kVct_pkData)

  0006f	3b f7		 cmp	 esi, edi
  00071	75 ed		 jne	 SHORT $LL21@DestroyCol
  00073	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+8
  00079	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0007f	3b f7		 cmp	 esi, edi
  00081	74 06		 je	 SHORT $LN25@DestroyCol

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00083	89 35 08 00 00
	00		 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+8, esi
$LN25@DestroyCol:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00089	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+16
  0008e	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+20
  00094	74 05		 je	 SHORT $LN29@DestroyCol

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00096	a3 14 00 00 00	 mov	 DWORD PTR ?gs_cci@@3V?$CDynamicPool@VCCylinderCollisionInstance@@@@A+20, eax
$LN29@DestroyCol:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  0009b	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+8
  000a1	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+4
  000a7	3b f7		 cmp	 esi, edi
  000a9	74 2e		 je	 SHORT $LN40@DestroyCol
  000ab	0f 1f 44 00 00	 npad	 5
$LL36@DestroyCol:

; 111  : 			delete pkData;

  000b0	6a 7c		 push	 124			; 0000007cH
  000b2	ff 36		 push	 DWORD PTR [esi]
  000b4	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete

; 50   : 			for (auto v : m_kVct_pkData)

  000b9	83 c6 04	 add	 esi, 4

; 111  : 			delete pkData;

  000bc	83 c4 08	 add	 esp, 8

; 50   : 			for (auto v : m_kVct_pkData)

  000bf	3b f7		 cmp	 esi, edi
  000c1	75 ed		 jne	 SHORT $LL36@DestroyCol
  000c3	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+8
  000c9	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000cf	3b f7		 cmp	 esi, edi
  000d1	74 06		 je	 SHORT $LN40@DestroyCol

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  000d3	89 35 08 00 00
	00		 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+8, esi
$LN40@DestroyCol:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  000d9	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+16
  000de	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+20
  000e4	74 05		 je	 SHORT $LN44@DestroyCol

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  000e6	a3 14 00 00 00	 mov	 DWORD PTR ?gs_pci@@3V?$CDynamicPool@VCPlaneCollisionInstance@@@@A+20, eax
$LN44@DestroyCol:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  000eb	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+8
  000f1	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+4
  000f7	3b f7		 cmp	 esi, edi
  000f9	74 2e		 je	 SHORT $LN55@DestroyCol
  000fb	0f 1f 44 00 00	 npad	 5
$LL51@DestroyCol:

; 111  : 			delete pkData;

  00100	6a 1c		 push	 28			; 0000001cH
  00102	ff 36		 push	 DWORD PTR [esi]
  00104	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete

; 50   : 			for (auto v : m_kVct_pkData)

  00109	83 c6 04	 add	 esi, 4

; 111  : 			delete pkData;

  0010c	83 c4 08	 add	 esp, 8

; 50   : 			for (auto v : m_kVct_pkData)

  0010f	3b f7		 cmp	 esi, edi
  00111	75 ed		 jne	 SHORT $LL51@DestroyCol
  00113	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+8
  00119	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0011f	3b f7		 cmp	 esi, edi
  00121	74 06		 je	 SHORT $LN55@DestroyCol

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00123	89 35 08 00 00
	00		 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+8, esi
$LN55@DestroyCol:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00129	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+16
  0012e	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+20
  00134	74 05		 je	 SHORT $LN59@DestroyCol

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00136	a3 14 00 00 00	 mov	 DWORD PTR ?gs_aci@@3V?$CDynamicPool@VCAABBCollisionInstance@@@@A+20, eax
$LN59@DestroyCol:
; File C:\Marty 5.5\Src-Client\Client\EterLib\Pool.h

; 50   : 			for (auto v : m_kVct_pkData)

  0013b	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8
  00141	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+4
  00147	3b f7		 cmp	 esi, edi
  00149	74 2e		 je	 SHORT $LN70@DestroyCol
  0014b	0f 1f 44 00 00	 npad	 5
$LL66@DestroyCol:

; 111  : 			delete pkData;

  00150	6a 5c		 push	 92			; 0000005cH
  00152	ff 36		 push	 DWORD PTR [esi]
  00154	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete

; 50   : 			for (auto v : m_kVct_pkData)

  00159	83 c6 04	 add	 esi, 4

; 111  : 			delete pkData;

  0015c	83 c4 08	 add	 esp, 8

; 50   : 			for (auto v : m_kVct_pkData)

  0015f	3b f7		 cmp	 esi, edi
  00161	75 ed		 jne	 SHORT $LL66@DestroyCol
  00163	8b 3d 08 00 00
	00		 mov	 edi, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8
  00169	8b 35 04 00 00
	00		 mov	 esi, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0016f	3b f7		 cmp	 esi, edi
  00171	74 06		 je	 SHORT $LN70@DestroyCol

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00173	89 35 08 00 00
	00		 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+8, esi
$LN70@DestroyCol:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00179	a1 10 00 00 00	 mov	 eax, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+16
  0017e	5f		 pop	 edi
  0017f	5e		 pop	 esi
  00180	3b 05 14 00 00
	00		 cmp	 eax, DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+20
  00186	74 05		 je	 SHORT $LN74@DestroyCol

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00188	a3 14 00 00 00	 mov	 DWORD PTR ?gs_oci@@3V?$CDynamicPool@VCOBBCollisionInstance@@@@A+20, eax
$LN74@DestroyCol:
; File C:\Marty 5.5\Src-Client\Client\EterLib\CollisionData.cpp

; 31   : }

  0018d	c3		 ret	 0
?DestroyCollisionInstanceSystem@@YAXXZ ENDP		; DestroyCollisionInstanceSystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\extern\include\d3dx8math.h
;	COMDAT ??0D3DXVECTOR3@@QAE@XZ
_TEXT	SEGMENT
??0D3DXVECTOR3@@QAE@XZ PROC				; D3DXVECTOR3::D3DXVECTOR3, COMDAT
; _this$ = ecx

; 89   :     D3DXVECTOR3() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXVECTOR3@@QAE@XZ ENDP				; D3DXVECTOR3::D3DXVECTOR3
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
