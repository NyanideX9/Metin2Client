; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\EterBase\Distribute\FileLoader.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CMemoryTextFileLoader@@QAE@XZ		; CMemoryTextFileLoader::CMemoryTextFileLoader
PUBLIC	??1CMemoryTextFileLoader@@UAE@XZ		; CMemoryTextFileLoader::~CMemoryTextFileLoader
PUBLIC	?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z		; CMemoryTextFileLoader::Bind
PUBLIC	?GetLineCount@CMemoryTextFileLoader@@QAEKXZ	; CMemoryTextFileLoader::GetLineCount
PUBLIC	?CheckLineIndex@CMemoryTextFileLoader@@QAE_NK@Z	; CMemoryTextFileLoader::CheckLineIndex
PUBLIC	?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ; CMemoryTextFileLoader::SplitLine
PUBLIC	?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ; CMemoryTextFileLoader::SplitLine2
PUBLIC	?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; CMemoryTextFileLoader::SplitLineByTab
PUBLIC	?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
PUBLIC	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
PUBLIC	??_GCMemoryTextFileLoader@@UAEPAXI@Z		; CMemoryTextFileLoader::`scalar deleting destructor'
PUBLIC	??0CMemoryFileLoader@@QAE@HPBX@Z		; CMemoryFileLoader::CMemoryFileLoader
PUBLIC	??1CMemoryFileLoader@@UAE@XZ			; CMemoryFileLoader::~CMemoryFileLoader
PUBLIC	?Read@CMemoryFileLoader@@QAE_NHPAX@Z		; CMemoryFileLoader::Read
PUBLIC	?GetPosition@CMemoryFileLoader@@QAEHXZ		; CMemoryFileLoader::GetPosition
PUBLIC	?GetSize@CMemoryFileLoader@@QAEHXZ		; CMemoryFileLoader::GetSize
PUBLIC	?IsReadableSize@CMemoryFileLoader@@IAE_NH@Z	; CMemoryFileLoader::IsReadableSize
PUBLIC	?GetCurrentPositionPointer@CMemoryFileLoader@@IAEPBDXZ ; CMemoryFileLoader::GetCurrentPositionPointer
PUBLIC	??_GCMemoryFileLoader@@UAEPAXI@Z		; CMemoryFileLoader::`scalar deleting destructor'
PUBLIC	??0CDiskFileLoader@@QAE@XZ			; CDiskFileLoader::CDiskFileLoader
PUBLIC	??1CDiskFileLoader@@UAE@XZ			; CDiskFileLoader::~CDiskFileLoader
PUBLIC	?Close@CDiskFileLoader@@QAEXXZ			; CDiskFileLoader::Close
PUBLIC	?Open@CDiskFileLoader@@QAE_NPBD@Z		; CDiskFileLoader::Open
PUBLIC	?Read@CDiskFileLoader@@QAE_NHPAX@Z		; CDiskFileLoader::Read
PUBLIC	?GetSize@CDiskFileLoader@@QAEHXZ		; CDiskFileLoader::GetSize
PUBLIC	?Initialize@CDiskFileLoader@@IAEXXZ		; CDiskFileLoader::Initialize
PUBLIC	??_GCDiskFileLoader@@UAEPAXI@Z			; CDiskFileLoader::`scalar deleting destructor'
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
PUBLIC	?_Mark@?$_String_bitmap@D$00@std@@QAE_NPBDQBD@Z	; std::_String_bitmap<char,1>::_Mark
PUBLIC	??$_Find_first_of_vectorized@$$CBD$$CBD@std@@YAPBDQBD000@Z ; std::_Find_first_of_vectorized<char const ,char const >
PUBLIC	??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_7CMemoryTextFileLoader@@6B@			; CMemoryTextFileLoader::`vftable'
PUBLIC	??_7CMemoryFileLoader@@6B@			; CMemoryFileLoader::`vftable'
PUBLIC	??_7CDiskFileLoader@@6B@			; CDiskFileLoader::`vftable'
PUBLIC	??_C@_01GPOEFGEJ@?7@				; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC@				; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CMemoryTextFileLoader@@6B@			; CMemoryTextFileLoader::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMemoryTextFileLoader@@@8		; CMemoryTextFileLoader `RTTI Type Descriptor'
PUBLIC	??_R3CMemoryTextFileLoader@@8			; CMemoryTextFileLoader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMemoryTextFileLoader@@8			; CMemoryTextFileLoader::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMemoryTextFileLoader@@8		; CMemoryTextFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CMemoryFileLoader@@6B@			; CMemoryFileLoader::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMemoryFileLoader@@@8			; CMemoryFileLoader `RTTI Type Descriptor'
PUBLIC	??_R3CMemoryFileLoader@@8			; CMemoryFileLoader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMemoryFileLoader@@8			; CMemoryFileLoader::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMemoryFileLoader@@8		; CMemoryFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CDiskFileLoader@@6B@			; CDiskFileLoader::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDiskFileLoader@@@8			; CDiskFileLoader `RTTI Type Descriptor'
PUBLIC	??_R3CDiskFileLoader@@8				; CDiskFileLoader::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDiskFileLoader@@8				; CDiskFileLoader::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDiskFileLoader@@8		; CDiskFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fread:PROC
EXTRN	_fseek:PROC
EXTRN	_ftell:PROC
EXTRN	___std_find_first_of_trivial_1@16:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_ECMemoryTextFileLoader@@UAEPAXI@Z:PROC	; CMemoryTextFileLoader::`vector deleting destructor'
EXTRN	??_ECMemoryFileLoader@@UAEPAXI@Z:PROC		; CMemoryFileLoader::`vector deleting destructor'
EXTRN	??_ECDiskFileLoader@@UAEPAXI@Z:PROC		; CDiskFileLoader::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ??_R1A@?0A@EA@CDiskFileLoader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDiskFileLoader@@8 DD FLAT:??_R0?AVCDiskFileLoader@@@8 ; CDiskFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDiskFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R2CDiskFileLoader@@8
rdata$r	SEGMENT
??_R2CDiskFileLoader@@8 DD FLAT:??_R1A@?0A@EA@CDiskFileLoader@@8 ; CDiskFileLoader::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDiskFileLoader@@8
rdata$r	SEGMENT
??_R3CDiskFileLoader@@8 DD 00H				; CDiskFileLoader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDiskFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDiskFileLoader@@@8
data$rs	SEGMENT
??_R0?AVCDiskFileLoader@@@8 DD FLAT:??_7type_info@@6B@	; CDiskFileLoader `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDiskFileLoader@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDiskFileLoader@@6B@
rdata$r	SEGMENT
??_R4CDiskFileLoader@@6B@ DD 00H			; CDiskFileLoader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDiskFileLoader@@@8
	DD	FLAT:??_R3CDiskFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CMemoryFileLoader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMemoryFileLoader@@8 DD FLAT:??_R0?AVCMemoryFileLoader@@@8 ; CMemoryFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMemoryFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R2CMemoryFileLoader@@8
rdata$r	SEGMENT
??_R2CMemoryFileLoader@@8 DD FLAT:??_R1A@?0A@EA@CMemoryFileLoader@@8 ; CMemoryFileLoader::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMemoryFileLoader@@8
rdata$r	SEGMENT
??_R3CMemoryFileLoader@@8 DD 00H			; CMemoryFileLoader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMemoryFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMemoryFileLoader@@@8
data$rs	SEGMENT
??_R0?AVCMemoryFileLoader@@@8 DD FLAT:??_7type_info@@6B@ ; CMemoryFileLoader `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMemoryFileLoader@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CMemoryFileLoader@@6B@
rdata$r	SEGMENT
??_R4CMemoryFileLoader@@6B@ DD 00H			; CMemoryFileLoader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMemoryFileLoader@@@8
	DD	FLAT:??_R3CMemoryFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CMemoryTextFileLoader@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMemoryTextFileLoader@@8 DD FLAT:??_R0?AVCMemoryTextFileLoader@@@8 ; CMemoryTextFileLoader::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMemoryTextFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R2CMemoryTextFileLoader@@8
rdata$r	SEGMENT
??_R2CMemoryTextFileLoader@@8 DD FLAT:??_R1A@?0A@EA@CMemoryTextFileLoader@@8 ; CMemoryTextFileLoader::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CMemoryTextFileLoader@@8
rdata$r	SEGMENT
??_R3CMemoryTextFileLoader@@8 DD 00H			; CMemoryTextFileLoader::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CMemoryTextFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMemoryTextFileLoader@@@8
data$rs	SEGMENT
??_R0?AVCMemoryTextFileLoader@@@8 DD FLAT:??_7type_info@@6B@ ; CMemoryTextFileLoader `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMemoryTextFileLoader@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CMemoryTextFileLoader@@6B@
rdata$r	SEGMENT
??_R4CMemoryTextFileLoader@@6B@ DD 00H			; CMemoryTextFileLoader::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMemoryTextFileLoader@@@8
	DD	FLAT:??_R3CMemoryTextFileLoader@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GPOEFGEJ@?7@
CONST	SEGMENT
??_C@_01GPOEFGEJ@?7@ DB 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CDiskFileLoader@@6B@
CONST	SEGMENT
??_7CDiskFileLoader@@6B@ DD FLAT:??_R4CDiskFileLoader@@6B@ ; CDiskFileLoader::`vftable'
	DD	FLAT:??_ECDiskFileLoader@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CMemoryFileLoader@@6B@
CONST	SEGMENT
??_7CMemoryFileLoader@@6B@ DD FLAT:??_R4CMemoryFileLoader@@6B@ ; CMemoryFileLoader::`vftable'
	DD	FLAT:??_ECMemoryFileLoader@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CMemoryTextFileLoader@@6B@
CONST	SEGMENT
??_7CMemoryTextFileLoader@@6B@ DD FLAT:??_R4CMemoryTextFileLoader@@6B@ ; CMemoryTextFileLoader::`vftable'
	DD	FLAT:??_ECMemoryTextFileLoader@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z$0
__ehfuncinfo$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0
__ehfuncinfo$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$1
__ehfuncinfo$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$1
__ehfuncinfo$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z$0
__ehfuncinfo$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard, COMDAT
; _this$ = ecx

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 606  :             if (_New_begin != nullptr) {

  00003	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00007	74 40		 je	 SHORT $LN10@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	ff 76 10	 push	 DWORD PTR [esi+16]
  0000e	ff 76 0c	 push	 DWORD PTR [esi+12]
  00011	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00016	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001c	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  0001f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00022	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00025	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002b	72 12		 jb	 SHORT $LN21@Reallocati

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0002d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00030	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00033	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00035	83 c0 fc	 add	 eax, -4			; fffffffcH
  00038	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0003b	77 0e		 ja	 SHORT $LN18@Reallocati

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0003d	8b c2		 mov	 eax, edx
$LN21@Reallocati:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0003f	51		 push	 ecx
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00046	83 c4 08	 add	 esp, 8
$LN10@Reallocati:
  00049	5e		 pop	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 610  :         }

  0004a	c3		 ret	 0
$LN18@Reallocati:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@Reallocati:
  00050	cc		 int	 3
??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
;	COMDAT ??$_Find_first_of_vectorized@$$CBD$$CBD@std@@YAPBDQBD000@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
??$_Find_first_of_vectorized@$$CBD$$CBD@std@@YAPBDQBD000@Z PROC ; std::_Find_first_of_vectorized<char const ,char const >, COMDAT

; 257  :     _Ty1* const _First1, _Ty1* const _Last1, _Ty2* const _First2, _Ty2* const _Last2) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 258  :     _STL_INTERNAL_STATIC_ASSERT(sizeof(_Ty1) == sizeof(_Ty2));
; 259  :     if constexpr (sizeof(_Ty1) == 1) {
; 260  :         return const_cast<_Ty1*>(

  00003	ff 75 14	 push	 DWORD PTR __Last2$[ebp]
  00006	ff 75 10	 push	 DWORD PTR __First2$[ebp]
  00009	ff 75 0c	 push	 DWORD PTR __Last1$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __First1$[ebp]
  0000f	e8 00 00 00 00	 call	 ___std_find_first_of_trivial_1@16

; 261  :             static_cast<const _Ty1*>(::__std_find_first_of_trivial_1(_First1, _Last1, _First2, _Last2)));
; 262  :     } else if constexpr (sizeof(_Ty1) == 2) {
; 263  :         return const_cast<_Ty1*>(
; 264  :             static_cast<const _Ty1*>(::__std_find_first_of_trivial_2(_First1, _Last1, _First2, _Last2)));
; 265  :     } else if constexpr (sizeof(_Ty1) == 4) {
; 266  :         return const_cast<_Ty1*>(
; 267  :             static_cast<const _Ty1*>(::__std_find_first_of_trivial_4(_First1, _Last1, _First2, _Last2)));
; 268  :     } else if constexpr (sizeof(_Ty1) == 8) {
; 269  :         return const_cast<_Ty1*>(
; 270  :             static_cast<const _Ty1*>(::__std_find_first_of_trivial_8(_First1, _Last1, _First2, _Last2)));
; 271  :     } else {
; 272  :         _STL_INTERNAL_STATIC_ASSERT(false); // unexpected size
; 273  :     }
; 274  : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Find_first_of_vectorized@$$CBD$$CBD@std@@YAPBDQBD000@Z ENDP ; std::_Find_first_of_vectorized<char const ,char const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
;	COMDAT ?_Mark@?$_String_bitmap@D$00@std@@QAE_NPBDQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Mark@?$_String_bitmap@D$00@std@@QAE_NPBDQBD@Z PROC	; std::_String_bitmap<char,1>::_Mark, COMDAT
; _this$ = ecx

; 758  :     constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 759  :         // mark this bitmap such that the characters in [_First, _Last) are intended to match
; 760  :         // returns whether all inputs can be placed in the bitmap
; 761  :         for (; _First != _Last; ++_First) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Last$[ebp]
  0000a	3b c6		 cmp	 eax, esi
  0000c	74 0e		 je	 SHORT $LN11@Mark
  0000e	66 90		 npad	 2
$LL4@Mark:

; 762  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00010	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00013	40		 inc	 eax
  00014	c6 04 0a 01	 mov	 BYTE PTR [edx+ecx], 1
  00018	3b c6		 cmp	 eax, esi
  0001a	75 f4		 jne	 SHORT $LL4@Mark
$LN11@Mark:

; 763  :         }
; 764  : 
; 765  :         return true;
; 766  :     }

  0001c	b0 01		 mov	 al, 1
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
?_Mark@?$_String_bitmap@D$00@std@@QAE_NPBDQBD@Z ENDP	; std::_String_bitmap<char,1>::_Mark
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z
_TEXT	SEGMENT
__Guard$ = -44						; size = 20
__Oldsize$1$ = -24					; size = 4
$T2 = -20						; size = 4
__Whereoff$1$ = -16					; size = 4
tv351 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b d9		 mov	 ebx, ecx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0002a	8b 33		 mov	 esi, DWORD PTR [ebx]
  0002c	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00031	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00034	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  00037	2b d6		 sub	 edx, esi
  00039	f7 ea		 imul	 edx
  0003b	2b ce		 sub	 ecx, esi
  0003d	c1 fa 02	 sar	 edx, 2
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00045	03 c2		 add	 eax, edx
  00047	89 45 f0	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  0004a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0004f	f7 e9		 imul	 ecx
  00051	c1 fa 02	 sar	 edx, 2
  00054	8b c2		 mov	 eax, edx
  00056	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00059	03 c2		 add	 eax, edx
  0005b	89 45 e8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0005e	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00063	0f 84 16 01 00
	00		 je	 $LN37@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00069	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0006c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006f	2b ce		 sub	 ecx, esi
  00071	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00076	f7 e9		 imul	 ecx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00078	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0007d	c1 fa 02	 sar	 edx, 2
  00080	8b ca		 mov	 ecx, edx
  00082	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00085	03 ca		 add	 ecx, edx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00087	8b d1		 mov	 edx, ecx
  00089	d1 ea		 shr	 edx, 1
  0008b	2b c2		 sub	 eax, edx
  0008d	3b c8		 cmp	 ecx, eax
  0008f	76 12		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00091	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  00096	be aa aa aa 0a	 mov	 esi, 178956970		; 0aaaaaaaH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a1	eb 39		 jmp	 SHORT $LN35@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000a3	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  000a6	8b f7		 mov	 esi, edi
  000a8	3b c7		 cmp	 eax, edi
  000aa	0f 43 f0	 cmovae	 esi, eax
  000ad	81 fe aa aa aa
	0a		 cmp	 esi, 178956970		; 0aaaaaaaH
  000b3	0f 87 cb 00 00
	00		 ja	 $LN38@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  000b9	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  000bc	c1 e0 03	 shl	 eax, 3

; 227  :     if (_Bytes == 0) {

  000bf	85 c0		 test	 eax, eax
  000c1	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  000c3	33 ff		 xor	 edi, edi
  000c5	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000c7	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000cc	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000ce	50		 push	 eax
  000cf	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000d4	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN35@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000dc	8b f8		 mov	 edi, eax
  000de	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]

; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  000e4	89 5d d4	 mov	 DWORD PTR __Guard$[ebp], ebx
  000e7	89 7d d8	 mov	 DWORD PTR __Guard$[ebp+4], edi
  000ea	89 75 dc	 mov	 DWORD PTR __Guard$[ebp+8], esi
  000ed	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000f0	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
  000f3	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
  000f6	89 4d f0	 mov	 DWORD PTR tv351[ebp], ecx
  000f9	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  000fc	89 45 e0	 mov	 DWORD PTR __Guard$[ebp+12], eax
  000ff	89 45 e4	 mov	 DWORD PTR __Guard$[ebp+16], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00102	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  00105	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0010c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 886  :         _Constructed_first = _Newvec + _Whereoff;

  00111	8b 45 f0	 mov	 eax, DWORD PTR tv351[ebp]

; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00114	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00117	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00119	89 45 e0	 mov	 DWORD PTR __Guard$[ebp+12], eax
  0011c	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  0011f	3b c2		 cmp	 eax, edx
  00121	75 04		 jne	 SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

  00123	8b c7		 mov	 eax, edi

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

  00125	eb 18		 jmp	 SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

  00127	53		 push	 ebx
  00128	57		 push	 edi
  00129	50		 push	 eax
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 896  :             _Constructed_first = _Newvec;
; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  00130	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00133	83 c4 10	 add	 esp, 16			; 00000010H
  00136	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  00139	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0013c	89 7d e0	 mov	 DWORD PTR __Guard$[ebp+12], edi
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  0013f	53		 push	 ebx
  00140	50		 push	 eax
  00141	52		 push	 edx
  00142	51		 push	 ecx
  00143	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00148	8b 45 e8	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  0014b	83 c4 10	 add	 esp, 16			; 00000010H
  0014e	40		 inc	 eax
  0014f	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR __Guard$[ebp+4], 0
  00156	8b cb		 mov	 ecx, ebx
  00158	56		 push	 esi
  00159	50		 push	 eax
  0015a	57		 push	 edi
  0015b	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array

; 902  :         return _Newvec + _Whereoff;

  00160	8d 4d d4	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00163	e8 00 00 00 00	 call	 ??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
  00168	8b 45 f0	 mov	 eax, DWORD PTR tv351[ebp]

; 903  :     }

  0016b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0016e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00175	59		 pop	 ecx
  00176	5f		 pop	 edi
  00177	5e		 pop	 esi
  00178	5b		 pop	 ebx
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c2 08 00	 ret	 8
$LN37@Emplace_re:

; 873  :             _Xlength();

  0017f	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN38@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  00184	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN34@Emplace_re:
  00189	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z
_TEXT	SEGMENT
__Guard$ = -32						; size = 20
_this$1$ = -12						; size = 4
__Oldsize$1$ = -8					; size = 4
__Whereoff$1$ = -4					; size = 4
$T1 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00006	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00009	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000e	53		 push	 ebx
  0000f	8b d9		 mov	 ebx, ecx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b 33		 mov	 esi, DWORD PTR [ebx]
  00015	2b d6		 sub	 edx, esi

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00017	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0001a	f7 ea		 imul	 edx
  0001c	2b ce		 sub	 ecx, esi
  0001e	c1 fa 02	 sar	 edx, 2
  00021	8b c2		 mov	 eax, edx
  00023	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00026	03 c2		 add	 eax, edx
  00028	89 45 fc	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  0002b	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00030	f7 e9		 imul	 ecx
  00032	c1 fa 02	 sar	 edx, 2
  00035	8b c2		 mov	 eax, edx
  00037	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0003a	03 c2		 add	 eax, edx
  0003c	89 45 f8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0003f	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00044	0f 84 2b 01 00
	00		 je	 $LN70@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0004a	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0004d	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00050	2b ce		 sub	 ecx, esi
  00052	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00057	f7 e9		 imul	 ecx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00059	b8 aa aa aa 0a	 mov	 eax, 178956970		; 0aaaaaaaH

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0005e	c1 fa 02	 sar	 edx, 2
  00061	8b ca		 mov	 ecx, edx
  00063	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00066	03 ca		 add	 ecx, edx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00068	8b d1		 mov	 edx, ecx
  0006a	d1 ea		 shr	 edx, 1
  0006c	2b c2		 sub	 eax, edx
  0006e	3b c8		 cmp	 ecx, eax
  00070	76 12		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00072	b8 f0 ff ff ff	 mov	 eax, -16		; fffffff0H
  00077	be aa aa aa 0a	 mov	 esi, 178956970		; 0aaaaaaaH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00082	eb 39		 jmp	 SHORT $LN68@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00084	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  00087	8b f7		 mov	 esi, edi
  00089	3b c7		 cmp	 eax, edi
  0008b	0f 43 f0	 cmovae	 esi, eax
  0008e	81 fe aa aa aa
	0a		 cmp	 esi, 178956970		; 0aaaaaaaH
  00094	0f 87 e0 00 00
	00		 ja	 $LN71@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  0009a	8d 04 76	 lea	 eax, DWORD PTR [esi+esi*2]
  0009d	c1 e0 03	 shl	 eax, 3

; 227  :     if (_Bytes == 0) {

  000a0	85 c0		 test	 eax, eax
  000a2	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  000a4	33 ff		 xor	 edi, edi
  000a6	eb 1a		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000a8	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000ad	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000b5	eb 06		 jmp	 SHORT $LN68@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN68@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000bd	8b f8		 mov	 edi, eax
  000bf	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  000c2	8b 45 fc	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  000c5	0f 57 c0	 xorps	 xmm0, xmm0

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  000c8	89 5d e0	 mov	 DWORD PTR __Guard$[ebp], ebx
  000cb	89 75 e8	 mov	 DWORD PTR __Guard$[ebp+8], esi
  000ce	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  000d1	8d 0c c7	 lea	 ecx, DWORD PTR [edi+eax*8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  000d4	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000d7	8d 41 18	 lea	 eax, DWORD PTR [ecx+24]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 498  :     size_type _Mysize = 0; // current length of string (size)

  000da	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  000e1	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000e8	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  000eb	89 45 f0	 mov	 DWORD PTR __Guard$[ebp+16], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000ee	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000f1	89 4d f4	 mov	 DWORD PTR _this$1$[ebp], ecx

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;
; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);
; 886  :         _Constructed_first = _Newvec + _Whereoff;

  000f4	89 4d ec	 mov	 DWORD PTR __Guard$[ebp+12], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000f7	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  000fa	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0
  000fd	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00102	66 0f d6 41 10	 movq	 QWORD PTR [ecx+16], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00107	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1264 :                 _Right_data._Mysize = 0;

  0010a	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  00111	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00118	c6 00 00	 mov	 BYTE PTR [eax], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0011b	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0011e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00120	3b ca		 cmp	 ecx, edx
  00122	75 04		 jne	 SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

  00124	8b cf		 mov	 ecx, edi

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

  00126	eb 18		 jmp	 SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

  00128	53		 push	 ebx
  00129	57		 push	 edi
  0012a	51		 push	 ecx
  0012b	50		 push	 eax
  0012c	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 896  :             _Constructed_first = _Newvec;
; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  00131	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00134	83 c4 10	 add	 esp, 16			; 00000010H
  00137	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  0013a	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0013d	89 7d ec	 mov	 DWORD PTR __Guard$[ebp+12], edi
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  00140	53		 push	 ebx
  00141	51		 push	 ecx
  00142	52		 push	 edx
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00149	8b 45 f8	 mov	 eax, DWORD PTR __Oldsize$1$[ebp]
  0014c	83 c4 10	 add	 esp, 16			; 00000010H
  0014f	40		 inc	 eax
  00150	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Guard$[ebp+4], 0
  00157	8b cb		 mov	 ecx, ebx
  00159	56		 push	 esi
  0015a	50		 push	 eax
  0015b	57		 push	 edi
  0015c	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array

; 902  :         return _Newvec + _Whereoff;

  00161	8d 4d e0	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00164	e8 00 00 00 00	 call	 ??1_Reallocation_guard@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocation_guard::~_Reallocation_guard
  00169	8b 45 f4	 mov	 eax, DWORD PTR _this$1$[ebp]

; 903  :     }

  0016c	5f		 pop	 edi
  0016d	5e		 pop	 esi
  0016e	5b		 pop	 ebx
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c2 08 00	 ret	 8
$LN70@Emplace_re:

; 873  :             _Xlength();

  00175	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN71@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  0017a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:
  0017f	cc		 int	 3
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1956 :             return _Dest + (_ULast - _UFirst);
; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00009	56		 push	 esi

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0000a	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1956 :             return _Dest + (_ULast - _UFirst);
; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  0000d	3b c2		 cmp	 eax, edx
  0000f	74 4f		 je	 SHORT $LN3@Uninitiali

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00011	8b ce		 mov	 ecx, esi
  00013	2b c8		 sub	 ecx, eax
  00015	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL4@Uninitiali:
  00020	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00023	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00026	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0002d	c7 44 01 14 00
	00 00 00	 mov	 DWORD PTR [ecx+eax+20], 0

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00035	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00038	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  0003b	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  00040	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  00045	83 c6 18	 add	 esi, 24			; 00000018H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1264 :                 _Right_data._Mysize = 0;

  00048	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  0004f	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00056	c6 00 00	 mov	 BYTE PTR [eax], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1808 :         ++_Last;

  00059	83 c0 18	 add	 eax, 24			; 00000018H

; 1941 :     // move [_First, _Last) to raw _Dest, using _Al
; 1942 :     // note: only called internally from elsewhere in the STL
; 1943 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1944 :     _STD _Adl_verify_range(_First, _Last);
; 1945 : #endif // ^^^ defined(_ENABLE_STL_INTERNAL_CHECK) ^^^
; 1946 :     using _Ptrval     = typename _Alloc::value_type*;
; 1947 :     auto _UFirst      = _STD _Get_unwrapped(_First);
; 1948 :     const auto _ULast = _STD _Get_unwrapped(_Last);
; 1949 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1950 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1951 : #if _HAS_CXX20
; 1952 :         if (!_STD is_constant_evaluated())
; 1953 : #endif // _HAS_CXX20
; 1954 :         {
; 1955 :             _STD _Copy_memmove(_UFirst, _ULast, _STD _Unfancy(_Dest));
; 1956 :             return _Dest + (_ULast - _UFirst);
; 1957 :         }
; 1958 :     }
; 1959 : 
; 1960 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  0005c	3b c2		 cmp	 eax, edx
  0005e	75 c0		 jne	 SHORT $LL4@Uninitiali
$LN3@Uninitiali:

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  00060	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  00063	56		 push	 esi
  00064	56		 push	 esi
  00065	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1963 :     }
; 1964 : 
; 1965 :     return _Backout._Release();

  0006d	8b c6		 mov	 eax, esi
  0006f	5e		 pop	 esi

; 1966 : }

  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1098 :         for (; _First != _Last; ++_First) {

  00004	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	3b f7		 cmp	 esi, edi
  0000d	74 48		 je	 SHORT $LN55@Destroy_ra
  0000f	90		 npad	 1
$LL4@Destroy_ra:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00010	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00013	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00016	76 27		 jbe	 SHORT $LN33@Destroy_ra
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00018	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0001a	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0001b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00021	72 12		 jb	 SHORT $LN44@Destroy_ra

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00023	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00026	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00029	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00031	77 28		 ja	 SHORT $LN41@Destroy_ra

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00033	8b c2		 mov	 eax, edx
$LN44@Destroy_ra:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00035	51		 push	 ecx
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003c	83 c4 08	 add	 esp, 8
$LN33@Destroy_ra:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  0003f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00046	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004d	c6 06 00	 mov	 BYTE PTR [esi], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00050	83 c6 18	 add	 esi, 24			; 00000018H
  00053	3b f7		 cmp	 esi, edi
  00055	75 b9		 jne	 SHORT $LL4@Destroy_ra
$LN55@Destroy_ra:
  00057	5f		 pop	 edi

; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1100 :         }
; 1101 :     }
; 1102 : }

  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
$LN41@Destroy_ra:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0005b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN62@Destroy_ra:
  00060	cc		 int	 3
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCDiskFileLoader@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCDiskFileLoader@@UAEPAXI@Z PROC			; CDiskFileLoader::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CDiskFileLoader@@UAE@XZ ; CDiskFileLoader::~CDiskFileLoader
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 0c		 push	 12			; 0000000cH
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCDiskFileLoader@@UAEPAXI@Z ENDP			; CDiskFileLoader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Initialize@CDiskFileLoader@@IAEXXZ
_TEXT	SEGMENT
?Initialize@CDiskFileLoader@@IAEXXZ PROC		; CDiskFileLoader::Initialize, COMDAT
; _this$ = ecx

; 274  : 	m_fp = NULL;

  00000	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 275  : 	m_size = 0;

  00007	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 276  : }

  0000e	c3		 ret	 0
?Initialize@CDiskFileLoader@@IAEXXZ ENDP		; CDiskFileLoader::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetSize@CDiskFileLoader@@QAEHXZ
_TEXT	SEGMENT
?GetSize@CDiskFileLoader@@QAEHXZ PROC			; CDiskFileLoader::GetSize, COMDAT
; _this$ = ecx

; 231  : 	return m_size;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 232  : }

  00003	c3		 ret	 0
?GetSize@CDiskFileLoader@@QAEHXZ ENDP			; CDiskFileLoader::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Read@CDiskFileLoader@@QAE_NHPAX@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_pvDst$ = 12						; size = 4
?Read@CDiskFileLoader@@QAE_NHPAX@Z PROC			; CDiskFileLoader::Read, COMDAT
; _this$ = ecx

; 235  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 236  : 	assert(m_fp != NULL);
; 237  : 
; 238  : 	int ret = fread(pvDst, size, 1, m_fp);

  00003	ff 71 04	 push	 DWORD PTR [ecx+4]
  00006	6a 01		 push	 1
  00008	ff 75 08	 push	 DWORD PTR _size$[ebp]
  0000b	ff 75 0c	 push	 DWORD PTR _pvDst$[ebp]
  0000e	e8 00 00 00 00	 call	 _fread
  00013	83 c4 10	 add	 esp, 16			; 00000010H

; 239  : 
; 240  : 	if (ret <= 0)

  00016	85 c0		 test	 eax, eax
  00018	0f 9f c0	 setg	 al

; 241  : 		return false;
; 242  : 
; 243  : 	return true;
; 244  : }

  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?Read@CDiskFileLoader@@QAE_NHPAX@Z ENDP			; CDiskFileLoader::Read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Open@CDiskFileLoader@@QAE_NPBD@Z
_TEXT	SEGMENT
_c_szFileName$ = 8					; size = 4
?Open@CDiskFileLoader@@QAE_NPBD@Z PROC			; CDiskFileLoader::Open, COMDAT
; _this$ = ecx

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 248  : 	Close();

  00006	e8 00 00 00 00	 call	 ?Close@CDiskFileLoader@@QAEXXZ ; CDiskFileLoader::Close

; 249  : 
; 250  : 	if (!c_szFileName[0])

  0000b	8b 45 08	 mov	 eax, DWORD PTR _c_szFileName$[ebp]
  0000e	80 38 00	 cmp	 BYTE PTR [eax], 0
  00011	74 40		 je	 SHORT $LN5@Open

; 251  : 		return false;
; 252  : 
; 253  : 	m_fp = fopen(c_szFileName, "rb");

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 _fopen
  0001e	83 c4 08	 add	 esp, 8
  00021	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 254  : 
; 255  : 	if (!m_fp)

  00024	85 c0		 test	 eax, eax
  00026	74 2b		 je	 SHORT $LN5@Open

; 257  : 
; 258  : 	fseek(m_fp, 0, SEEK_END);

  00028	6a 02		 push	 2
  0002a	6a 00		 push	 0
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 _fseek

; 259  : 	m_size = ftell(m_fp);

  00032	ff 76 04	 push	 DWORD PTR [esi+4]
  00035	e8 00 00 00 00	 call	 _ftell

; 260  : 	fseek(m_fp, 0, SEEK_SET);

  0003a	6a 00		 push	 0
  0003c	6a 00		 push	 0
  0003e	ff 76 04	 push	 DWORD PTR [esi+4]
  00041	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00044	e8 00 00 00 00	 call	 _fseek
  00049	83 c4 1c	 add	 esp, 28			; 0000001cH

; 261  : 	return true;

  0004c	b0 01		 mov	 al, 1
  0004e	5e		 pop	 esi

; 262  : }

  0004f	5d		 pop	 ebp
  00050	c2 04 00	 ret	 4
$LN5@Open:

; 256  : 		return false;

  00053	32 c0		 xor	 al, al
  00055	5e		 pop	 esi

; 262  : }

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?Open@CDiskFileLoader@@QAE_NPBD@Z ENDP			; CDiskFileLoader::Open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Close@CDiskFileLoader@@QAEXXZ
_TEXT	SEGMENT
?Close@CDiskFileLoader@@QAEXXZ PROC			; CDiskFileLoader::Close, COMDAT
; _this$ = ecx

; 265  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 266  : 	if (m_fp)

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	85 c0		 test	 eax, eax
  00008	74 09		 je	 SHORT $LN2@Close

; 267  : 		fclose(m_fp);

  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _fclose
  00010	83 c4 04	 add	 esp, 4
$LN2@Close:

; 268  : 
; 269  : 	Initialize();

  00013	8b ce		 mov	 ecx, esi
  00015	5e		 pop	 esi
  00016	e9 00 00 00 00	 jmp	 ?Initialize@CDiskFileLoader@@IAEXXZ ; CDiskFileLoader::Initialize
?Close@CDiskFileLoader@@QAEXXZ ENDP			; CDiskFileLoader::Close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ??1CDiskFileLoader@@UAE@XZ
_TEXT	SEGMENT
??1CDiskFileLoader@@UAE@XZ PROC				; CDiskFileLoader::~CDiskFileLoader, COMDAT
; _this$ = ecx

; 284  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CDiskFileLoader@@6B@

; 285  : 	Close();

  00006	e9 00 00 00 00	 jmp	 ?Close@CDiskFileLoader@@QAEXXZ ; CDiskFileLoader::Close
??1CDiskFileLoader@@UAE@XZ ENDP				; CDiskFileLoader::~CDiskFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ??0CDiskFileLoader@@QAE@XZ
_TEXT	SEGMENT
??0CDiskFileLoader@@QAE@XZ PROC				; CDiskFileLoader::CDiskFileLoader, COMDAT
; _this$ = ecx

; 279  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CDiskFileLoader@@6B@

; 280  : 	Initialize();

  00009	e8 00 00 00 00	 call	 ?Initialize@CDiskFileLoader@@IAEXXZ ; CDiskFileLoader::Initialize

; 281  : }

  0000e	8b c6		 mov	 eax, esi
  00010	5e		 pop	 esi
  00011	c3		 ret	 0
??0CDiskFileLoader@@QAE@XZ ENDP				; CDiskFileLoader::CDiskFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCMemoryFileLoader@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMemoryFileLoader@@UAEPAXI@Z PROC			; CMemoryFileLoader::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMemoryFileLoader@@UAE@XZ ; CMemoryFileLoader::~CMemoryFileLoader
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 10		 push	 16			; 00000010H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCMemoryFileLoader@@UAEPAXI@Z ENDP			; CMemoryFileLoader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetCurrentPositionPointer@CMemoryFileLoader@@IAEPBDXZ
_TEXT	SEGMENT
?GetCurrentPositionPointer@CMemoryFileLoader@@IAEPBDXZ PROC ; CMemoryFileLoader::GetCurrentPositionPointer, COMDAT
; _this$ = ecx

; 211  : 	assert(m_pcBase != NULL);
; 212  : 	return (m_pcBase + m_pos);

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	03 41 04	 add	 eax, DWORD PTR [ecx+4]

; 213  : }

  00006	c3		 ret	 0
?GetCurrentPositionPointer@CMemoryFileLoader@@IAEPBDXZ ENDP ; CMemoryFileLoader::GetCurrentPositionPointer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?IsReadableSize@CMemoryFileLoader@@IAE_NH@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
?IsReadableSize@CMemoryFileLoader@@IAE_NH@Z PROC	; CMemoryFileLoader::IsReadableSize, COMDAT
; _this$ = ecx

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 193  : 	if (m_pos + size > m_size)

  00003	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00006	03 45 08	 add	 eax, DWORD PTR _size$[ebp]
  00009	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0000c	0f 9e c0	 setle	 al

; 194  : 		return false;
; 195  : 
; 196  : 	return true;
; 197  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?IsReadableSize@CMemoryFileLoader@@IAE_NH@Z ENDP	; CMemoryFileLoader::IsReadableSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetSize@CMemoryFileLoader@@QAEHXZ
_TEXT	SEGMENT
?GetSize@CMemoryFileLoader@@QAEHXZ PROC			; CMemoryFileLoader::GetSize, COMDAT
; _this$ = ecx

; 183  : 	return m_size;

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 184  : }

  00003	c3		 ret	 0
?GetSize@CMemoryFileLoader@@QAEHXZ ENDP			; CMemoryFileLoader::GetSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetPosition@CMemoryFileLoader@@QAEHXZ
_TEXT	SEGMENT
?GetPosition@CMemoryFileLoader@@QAEHXZ PROC		; CMemoryFileLoader::GetPosition, COMDAT
; _this$ = ecx

; 188  : 	return m_pos;

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 189  : }

  00003	c3		 ret	 0
?GetPosition@CMemoryFileLoader@@QAEHXZ ENDP		; CMemoryFileLoader::GetPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Read@CMemoryFileLoader@@QAE_NHPAX@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_pvDst$ = 12						; size = 4
?Read@CMemoryFileLoader@@QAE_NHPAX@Z PROC		; CMemoryFileLoader::Read, COMDAT
; _this$ = ecx

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 201  : 	if (!IsReadableSize(size))

  00005	8b 7d 08	 mov	 edi, DWORD PTR _size$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi
  0000b	e8 00 00 00 00	 call	 ?IsReadableSize@CMemoryFileLoader@@IAE_NH@Z ; CMemoryFileLoader::IsReadableSize
  00010	84 c0		 test	 al, al
  00012	75 06		 jne	 SHORT $LN2@Read

; 207  : }

  00014	5f		 pop	 edi
  00015	5e		 pop	 esi
  00016	5d		 pop	 ebp
  00017	c2 08 00	 ret	 8
$LN2@Read:

; 202  : 		return false;
; 203  : 
; 204  : 	memcpy(pvDst, GetCurrentPositionPointer(), size);

  0001a	57		 push	 edi
  0001b	8b ce		 mov	 ecx, esi
  0001d	e8 00 00 00 00	 call	 ?GetCurrentPositionPointer@CMemoryFileLoader@@IAEPBDXZ ; CMemoryFileLoader::GetCurrentPositionPointer
  00022	50		 push	 eax
  00023	ff 75 0c	 push	 DWORD PTR _pvDst$[ebp]
  00026	e8 00 00 00 00	 call	 _memcpy
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 205  : 	m_pos += size;
; 206  : 	return true;

  0002e	b0 01		 mov	 al, 1
  00030	01 7e 0c	 add	 DWORD PTR [esi+12], edi
  00033	5f		 pop	 edi

; 207  : }

  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?Read@CMemoryFileLoader@@QAE_NHPAX@Z ENDP		; CMemoryFileLoader::Read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ??1CMemoryFileLoader@@UAE@XZ
_TEXT	SEGMENT
??1CMemoryFileLoader@@UAE@XZ PROC			; CMemoryFileLoader::~CMemoryFileLoader, COMDAT
; _this$ = ecx

; 225  : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMemoryFileLoader@@6B@

; 226  : }

  00006	c3		 ret	 0
??1CMemoryFileLoader@@UAE@XZ ENDP			; CMemoryFileLoader::~CMemoryFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ??0CMemoryFileLoader@@QAE@HPBX@Z
_TEXT	SEGMENT
_size$ = 8						; size = 4
_c_pvMemoryFile$ = 12					; size = 4
??0CMemoryFileLoader@@QAE@HPBX@Z PROC			; CMemoryFileLoader::CMemoryFileLoader, COMDAT
; _this$ = ecx

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 217  : 	assert(c_pvMemoryFile != NULL);
; 218  : 
; 219  : 	m_pos = 0;
; 220  : 	m_size = size;

  00003	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 221  : 	m_pcBase = (const char *) c_pvMemoryFile;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _c_pvMemoryFile$[ebp]
  0000c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 222  : }

  0000f	8b c1		 mov	 eax, ecx
  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMemoryFileLoader@@6B@
  00017	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
??0CMemoryFileLoader@@QAE@HPBX@Z ENDP			; CMemoryFileLoader::CMemoryFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCMemoryTextFileLoader@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMemoryTextFileLoader@@UAEPAXI@Z PROC		; CMemoryTextFileLoader::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 10		 push	 16			; 00000010H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_GCMemoryTextFileLoader@@UAEPAXI@Z ENDP		; CMemoryTextFileLoader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array, COMDAT
; _this$ = ecx

; 2044 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi
  00004	8b f9		 mov	 edi, ecx

; 2045 :         // orphan all iterators, discard old array, acquire new array
; 2046 :         auto& _Al         = _Getal();
; 2047 :         auto& _My_data    = _Mypair._Myval2;
; 2048 :         pointer& _Myfirst = _My_data._Myfirst;
; 2049 :         pointer& _Mylast  = _My_data._Mylast;
; 2050 :         pointer& _Myend   = _My_data._Myend;
; 2051 : 
; 2052 :         _My_data._Orphan_all();
; 2053 : 
; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00006	8b 07		 mov	 eax, DWORD PTR [edi]
  00008	85 c0		 test	 eax, eax
  0000a	74 51		 je	 SHORT $LN10@Change_arr

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000c	56		 push	 esi
  0000d	57		 push	 edi
  0000e	ff 77 04	 push	 DWORD PTR [edi+4]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00017	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  0001a	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001f	8b 37		 mov	 esi, DWORD PTR [edi]
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH
  00024	2b ce		 sub	 ecx, esi
  00026	f7 e9		 imul	 ecx
  00028	c1 fa 02	 sar	 edx, 2
  0002b	8b c2		 mov	 eax, edx
  0002d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00030	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00032	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00035	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00038	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003e	72 12		 jb	 SHORT $LN21@Change_arr

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00040	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00043	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00046	2b f2		 sub	 esi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00048	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0004b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004e	77 2f		 ja	 SHORT $LN18@Change_arr

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00050	8b f2		 mov	 esi, edx
$LN21@Change_arr:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00052	51		 push	 ecx
  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00059	83 c4 08	 add	 esp, 8
  0005c	5e		 pop	 esi
$LN10@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2060 :         _Myfirst = _Newvec;

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]

; 2061 :         _Mylast  = _Newvec + _Newsize;

  00060	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00063	89 0f		 mov	 DWORD PTR [edi], ecx
  00065	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00068	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0006b	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  0006e	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00071	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00074	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00077	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0007a	5f		 pop	 edi

; 2064 :     }

  0007b	5d		 pop	 ebp
  0007c	c2 0c 00	 ret	 12			; 0000000cH
$LN18@Change_arr:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0007f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@Change_arr:
  00084	cc		 int	 3
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcapacity$ = 8					; size = 4
__Size$1$ = 8						; size = 4
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve, COMDAT
; _this$ = ecx

; 1708 :     _CONSTEXPR20 void reserve(_CRT_GUARDOVERFLOW size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1709 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1710 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00004	8b 5d 08	 mov	 ebx, DWORD PTR __Newcapacity$[ebp]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00007	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH

; 1708 :     _CONSTEXPR20 void reserve(_CRT_GUARDOVERFLOW size_type _Newcapacity) {

  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	57		 push	 edi

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00010	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  00013	8b 3e		 mov	 edi, DWORD PTR [esi]
  00015	2b d7		 sub	 edx, edi
  00017	f7 ea		 imul	 edx
  00019	c1 fa 02	 sar	 edx, 2
  0001c	8b c2		 mov	 eax, edx
  0001e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00021	03 c2		 add	 eax, edx

; 1709 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1710 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00023	3b d8		 cmp	 ebx, eax
  00025	76 63		 jbe	 SHORT $LN36@reserve

; 1711 :             if (_Newcapacity > max_size()) {

  00027	81 fb aa aa aa
	0a		 cmp	 ebx, 178956970		; 0aaaaaaaH
  0002d	77 62		 ja	 SHORT $LN59@reserve

; 1634 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  0002f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00032	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00037	2b cf		 sub	 ecx, edi
  00039	f7 e9		 imul	 ecx
  0003b	c1 fa 02	 sar	 edx, 2
  0003e	8b c2		 mov	 eax, edx
  00040	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00043	03 c2		 add	 eax, edx
  00045	89 45 08	 mov	 DWORD PTR __Size$1$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 122  :     return _Count * _Ty_size;

  00048	8d 04 5b	 lea	 eax, DWORD PTR [ebx+ebx*2]
  0004b	c1 e0 03	 shl	 eax, 3

; 227  :     if (_Bytes == 0) {

  0004e	85 c0		 test	 eax, eax
  00050	75 04		 jne	 SHORT $LN20@reserve

; 228  :         return nullptr;

  00052	33 ff		 xor	 edi, edi
  00054	eb 19		 jmp	 SHORT $LN19@reserve
$LN20@reserve:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00056	50		 push	 eax
  00057	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0005c	72 07		 jb	 SHORT $LN21@reserve

; 252  :             // boost the alignment of big allocations to help autovectorization
; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0005e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00063	eb 05		 jmp	 SHORT $LN57@reserve
$LN21@reserve:

; 136  :         return ::operator new(_Bytes);

  00065	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN57@reserve:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1647 :             _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

  0006a	8b f8		 mov	 edi, eax
  0006c	83 c4 04	 add	 esp, 4
$LN19@reserve:
  0006f	56		 push	 esi
  00070	57		 push	 edi
  00071	ff 76 04	 push	 DWORD PTR [esi+4]
  00074	ff 36		 push	 DWORD PTR [esi]
  00076	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0007b	83 c4 10	 add	 esp, 16			; 00000010H

; 1648 :         } else {
; 1649 :             _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 1650 :         }
; 1651 : 
; 1652 :         _Guard._New_begin = nullptr;
; 1653 :         _Change_array(_Newvec, _Size, _Newcapacity);

  0007e	8b ce		 mov	 ecx, esi
  00080	53		 push	 ebx
  00081	ff 75 08	 push	 DWORD PTR __Size$1$[ebp]
  00084	57		 push	 edi
  00085	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
$LN36@reserve:
  0008a	5f		 pop	 edi

; 1713 :             }
; 1714 : 
; 1715 :             _Reallocate<_Reallocation_policy::_At_least>(_Newcapacity);
; 1716 :         }
; 1717 :     }

  0008b	5e		 pop	 esi
  0008c	5b		 pop	 ebx
  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
$LN59@reserve:

; 1712 :                 _Xlength();

  00091	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN56@reserve:
  00096	cc		 int	 3
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 65		 je	 SHORT $LN5@vector
  00009	57		 push	 edi

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000a	56		 push	 esi
  0000b	ff 76 04	 push	 DWORD PTR [esi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0001c	8b 3e		 mov	 edi, DWORD PTR [esi]
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	2b cf		 sub	 ecx, edi
  00023	f7 e9		 imul	 ecx
  00025	c1 fa 02	 sar	 edx, 2
  00028	8b c2		 mov	 eax, edx
  0002a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002d	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00032	c1 e1 03	 shl	 ecx, 3

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00035	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003b	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003d	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  00040	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00043	2b fa		 sub	 edi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00048	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004b	77 23		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0004d	8b fa		 mov	 edi, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0004f	51		 push	 ecx
  00050	57		 push	 edi
  00051	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00056	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00059	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 2081 :             _Mylast  = nullptr;

  0005f	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  00066	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  0006d	5f		 pop	 edi
$LN5@vector:
  0006e	5e		 pop	 esi

; 820  :     }

  0006f	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00075	cc		 int	 3
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z
_TEXT	SEGMENT
_dwLine$ = 8						; size = 4
?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z PROC ; CMemoryTextFileLoader::GetLineString, COMDAT
; _this$ = ecx

; 139  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00003	8b 45 08	 mov	 eax, DWORD PTR _dwLine$[ebp]
  00006	8d 14 40	 lea	 edx, DWORD PTR [eax+eax*2]
  00009	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000c	8d 04 d0	 lea	 eax, DWORD PTR [eax+edx*8]
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 142  : }

  0000f	5d		 pop	 ebp
  00010	c2 04 00	 ret	 4
?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ENDP ; CMemoryTextFileLoader::GetLineString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_c_iLineLength$1$ = -316				; size = 4
_c_rstLine$1$ = -312					; size = 4
_pstTokenVector$GSCopy$1$ = -308			; size = 4
__Result$1$ = -304					; size = 4
_basePos$1$ = -300					; size = 4
__Matches$2 = -296					; size = 256
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwLine$ = 8						; size = 4
_pstTokenVector$ = 12					; size = 4
?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; CMemoryTextFileLoader::SplitLineByTab, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx
  0002f	8b 45 0c	 mov	 eax, DWORD PTR _pstTokenVector$[ebp]

; 15   : 	pstTokenVector->reserve(10);

  00032	8b c8		 mov	 ecx, eax
  00034	8b 7d 08	 mov	 edi, DWORD PTR _dwLine$[ebp]
  00037	6a 0a		 push	 10			; 0000000aH
  00039	89 85 cc fe ff
	ff		 mov	 DWORD PTR _pstTokenVector$GSCopy$1$[ebp], eax
  0003f	e8 00 00 00 00	 call	 ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00044	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
  0004a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0004f	3b c2		 cmp	 eax, edx
  00051	74 16		 je	 SHORT $LN9@SplitLineB

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  00053	51		 push	 ecx
  00054	52		 push	 edx
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0005b	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	8b 01		 mov	 eax, DWORD PTR [ecx]
  00066	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN9@SplitLineB:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 18   : 	const std::string & c_rstLine = GetLineString(dwLine);

  00069	57		 push	 edi
  0006a	8b ce		 mov	 ecx, esi
  0006c	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  00071	8b f0		 mov	 esi, eax
  00073	89 b5 c8 fe ff
	ff		 mov	 DWORD PTR _c_rstLine$1$[ebp], esi

; 19   : 	const int c_iLineLength = c_rstLine.length();

  00079	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0007c	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _c_iLineLength$1$[ebp], eax

; 20   : 
; 21   : 	if (0 == c_iLineLength)

  00082	85 c0		 test	 eax, eax
  00084	75 1f		 jne	 SHORT $LN5@SplitLineB

; 22   : 		return false;

  00086	32 c0		 xor	 al, al
$LN1@SplitLineB:

; 36   : }

  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	5f		 pop	 edi
  00094	5e		 pop	 esi
  00095	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00098	33 cd		 xor	 ecx, ebp
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 08 00	 ret	 8
$LN5@SplitLineB:

; 23   : 
; 24   : 	int basePos = 0;

  000a5	33 c0		 xor	 eax, eax
  000a7	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _basePos$1$[ebp], eax
  000ad	0f 1f 00	 npad	 3
$LL4@SplitLineB:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000b0	83 7e 14 0f	 cmp	 DWORD PTR [esi+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  000b4	8b d6		 mov	 edx, esi

; 2661 :         return static_cast<size_type>(_Traits_find_first_of<_Traits>(

  000b6	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]

; 425  :         const value_type* _Result = _Bx._Buf;

  000b9	89 b5 d0 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], esi

; 426  :         if (_Large_mode_engaged()) {

  000bf	76 08		 jbe	 SHORT $LN198@SplitLineB

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  000c1	8b 16		 mov	 edx, DWORD PTR [esi]
  000c3	89 95 d0 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edx
$LN198@SplitLineB:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 812  :     if (_Needle_size == 0 || _Start_at >= _Hay_size) { // no match possible

  000c9	3b c1		 cmp	 eax, ecx
  000cb	73 4f		 jae	 SHORT $LN34@SplitLineB

; 813  :         return static_cast<size_t>(-1);
; 814  :     }
; 815  : 
; 816  :     const auto _Hay_start = _Haystack + _Start_at;
; 817  :     const auto _Hay_end   = _Haystack + _Hay_size;

  000cd	8d 3c 11	 lea	 edi, DWORD PTR [ecx+edx]

; 818  : 
; 819  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 820  :         if (!_STD _Is_constant_evaluated()) {
; 821  :             using _Elem = typename _Traits::char_type;
; 822  : 
; 823  : #if _USE_STD_VECTOR_ALGORITHMS
; 824  :             const bool _Try_vectorize = _Hay_size - _Start_at > _Threshold_find_first_of;

  000d0	2b c8		 sub	 ecx, eax
  000d2	8d 34 02	 lea	 esi, DWORD PTR [edx+eax]

; 825  : 
; 826  :             // Additional condition for when the vectorization outperforms the table lookup
; 827  :             constexpr size_t _Find_first_of_bitmap_threshold = sizeof(_Elem) == 1 ? 48 : sizeof(_Elem) == 8 ? 8 : 16;
; 828  : 
; 829  :             const bool _Use_bitmap = !_Try_vectorize || _Needle_size > _Find_first_of_bitmap_threshold;

  000d5	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000d8	0f 87 ce 00 00
	00		 ja	 $LN199@SplitLineB
  000de	68 00 01 00 00	 push	 256			; 00000100H
  000e3	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR __Matches$2[ebp]
  000e9	6a 00		 push	 0
  000eb	50		 push	 eax
  000ec	e8 00 00 00 00	 call	 _memset
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 762  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  000f4	c6 85 e1 fe ff
	ff 01		 mov	 BYTE PTR __Matches$2[ebp+9], 1

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  000fb	3b f7		 cmp	 esi, edi
  000fd	73 17		 jae	 SHORT $LN28@SplitLineB
  000ff	90		 npad	 1
$LL29@SplitLineB:

; 770  :         return _Matches[static_cast<unsigned char>(_Ch)];

  00100	0f b6 06	 movzx	 eax, BYTE PTR [esi]

; 839  :                         if (_Matches._Match(*_Match_try)) {

  00103	80 bc 05 d8 fe
	ff ff 00	 cmp	 BYTE PTR __Matches$2[ebp+eax], 0
  0010b	0f 85 8a 00 00
	00		 jne	 $LN180@SplitLineB

; 830  : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
; 831  :             const bool _Use_bitmap = true;
; 832  : #endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
; 833  : 
; 834  :             if (_Use_bitmap) {
; 835  :                 _String_bitmap<_Elem> _Matches;
; 836  : 
; 837  :                 if (_Matches._Mark(_Needle, _Needle + _Needle_size)) {
; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  00111	46		 inc	 esi
  00112	3b f7		 cmp	 esi, edi
  00114	72 ea		 jb	 SHORT $LL29@SplitLineB
$LN28@SplitLineB:

; 841  :                         }
; 842  :                     }
; 843  :                     return static_cast<size_t>(-1); // no match

  00116	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _basePos$1$[ebp]
$LN34@SplitLineB:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0011c	83 ce ff	 or	 esi, -1
$LN26@SplitLineB:

; 450  :         if (_Mysize < _Off) {

  0011f	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR _c_rstLine$1$[ebp]
  00125	0f 57 c0	 xorps	 xmm0, xmm0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00128	0f 11 45 d8	 movups	 XMMWORD PTR $T3[ebp], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  0012c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00133	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 0

; 450  :         if (_Mysize < _Off) {

  0013a	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0013d	3b c8		 cmp	 ecx, eax
  0013f	0f 82 00 01 00
	00		 jb	 $LN182@SplitLineB

; 468  :         return (_STD min)(_Size, _Mysize - _Off);

  00145	2b c8		 sub	 ecx, eax
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 30   : 		pstTokenVector->push_back(c_rstLine.substr(basePos, beginPos-basePos));

  00147	8b d6		 mov	 edx, esi
  00149	2b d0		 sub	 edx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 468  :         return (_STD min)(_Size, _Mysize - _Off);

  0014b	3b ca		 cmp	 ecx, edx
  0014d	0f 42 d1	 cmovb	 edx, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00150	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00154	8b cf		 mov	 ecx, edi

; 426  :         if (_Large_mode_engaged()) {

  00156	76 02		 jbe	 SHORT $LN197@SplitLineB

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00158	8b 0f		 mov	 ecx, DWORD PTR [edi]
$LN197@SplitLineB:

; 713  :         _Construct<_Construct_strategy::_From_ptr>(

  0015a	03 c1		 add	 eax, ecx
  0015c	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0015f	52		 push	 edx
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00166	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 30   : 		pstTokenVector->push_back(c_rstLine.substr(basePos, beginPos-basePos));

  0016c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00173	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00176	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  00179	74 60		 je	 SHORT $LN103@SplitLineB
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0017b	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR $T3[ebp]

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;
; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  0017f	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00184	c6 45 d8 00	 mov	 BYTE PTR $T3[ebp], 0
  00188	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  0018b	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR $T3[ebp+16]
  00190	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 854  :         ++_Mylast;

  00195	83 42 04 18	 add	 DWORD PTR [edx+4], 24	; 00000018H

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00199	eb 4f		 jmp	 SHORT $LN102@SplitLineB
$LN180@SplitLineB:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 840  :                             return static_cast<size_t>(_Match_try - _Haystack); // found a match

  0019b	2b b5 d0 fe ff
	ff		 sub	 esi, DWORD PTR __Result$1$[ebp]
  001a1	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _basePos$1$[ebp]
  001a7	e9 73 ff ff ff	 jmp	 $LN26@SplitLineB
$LN199@SplitLineB:

; 844  :                 }
; 845  : 
; 846  :                 // couldn't put one of the characters into the bitmap, fall back to vectorized or serial algorithms
; 847  :             }
; 848  : 
; 849  : #if _USE_STD_VECTOR_ALGORITHMS
; 850  :             if (_Try_vectorize) {
; 851  :                 const _Traits_ptr_t<_Traits> _Found =

  001ac	68 01 00 00 00	 push	 OFFSET ??_C@_01GPOEFGEJ@?7@+1
  001b1	68 00 00 00 00	 push	 OFFSET ??_C@_01GPOEFGEJ@?7@
  001b6	57		 push	 edi
  001b7	56		 push	 esi
  001b8	e8 00 00 00 00	 call	 ??$_Find_first_of_vectorized@$$CBD$$CBD@std@@YAPBDQBD000@Z ; std::_Find_first_of_vectorized<char const ,char const >
  001bd	8b f0		 mov	 esi, eax
  001bf	83 c4 10	 add	 esp, 16			; 00000010H

; 852  :                     _STD _Find_first_of_vectorized(_Hay_start, _Hay_end, _Needle, _Needle + _Needle_size);
; 853  : 
; 854  :                 if (_Found != _Hay_end) {

  001c2	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _basePos$1$[ebp]
  001c8	3b f7		 cmp	 esi, edi
  001ca	0f 84 4c ff ff
	ff		 je	 $LN34@SplitLineB

; 855  :                     return static_cast<size_t>(_Found - _Haystack); // found a match

  001d0	2b b5 d0 fe ff
	ff		 sub	 esi, DWORD PTR __Result$1$[ebp]
  001d6	e9 44 ff ff ff	 jmp	 $LN26@SplitLineB
$LN103@SplitLineB:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  001db	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  001de	51		 push	 ecx
  001df	50		 push	 eax
  001e0	8b ca		 mov	 ecx, edx
  001e2	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  001e7	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp+20]
$LN102@SplitLineB:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 30   : 		pstTokenVector->push_back(c_rstLine.substr(basePos, beginPos-basePos));

  001ea	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  001f1	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  001f4	76 28		 jbe	 SHORT $LN159@SplitLineB
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001f6	8b 55 d8	 mov	 edx, DWORD PTR $T3[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  001f9	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001fa	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001fc	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00202	72 10		 jb	 SHORT $LN170@SplitLineB

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00204	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00207	83 c1 23	 add	 ecx, 35			; 00000023H
  0020a	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0020c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0020f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00212	77 36		 ja	 SHORT $LN167@SplitLineB
$LN170@SplitLineB:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00214	51		 push	 ecx
  00215	52		 push	 edx
  00216	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0021b	83 c4 08	 add	 esp, 8
$LN159@SplitLineB:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 32   : 		basePos = beginPos+1;

  0021e	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00221	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _basePos$1$[ebp], eax

; 33   : 	} while (basePos < c_iLineLength && basePos > 0);

  00227	3b 85 c4 fe ff
	ff		 cmp	 eax, DWORD PTR _c_iLineLength$1$[ebp]
  0022d	7d 0f		 jge	 SHORT $LN6@SplitLineB
  0022f	85 c0		 test	 eax, eax
  00231	7e 0b		 jle	 SHORT $LN6@SplitLineB
  00233	8b b5 c8 fe ff
	ff		 mov	 esi, DWORD PTR _c_rstLine$1$[ebp]
  00239	e9 72 fe ff ff	 jmp	 $LL4@SplitLineB
$LN6@SplitLineB:

; 34   : 
; 35   : 	return true;

  0023e	b0 01		 mov	 al, 1
  00240	e9 43 fe ff ff	 jmp	 $LN1@SplitLineB
$LN182@SplitLineB:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 451  :             _Xran();

  00245	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN167@SplitLineB:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0024a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN201@SplitLineB:
  0024f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a c4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-316]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SplitLineByTab@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; CMemoryTextFileLoader::SplitLineByTab
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
_TEXT	SEGMENT
_pstTokenVector$GSCopy$1$ = -860			; size = 4
$T2 = -856						; size = 4
$T3 = -856						; size = 4
_c_rstLine$1$ = -852					; size = 4
__Result$1$ = -848					; size = 4
__Result$1$ = -848					; size = 4
_beginPos$1$ = -844					; size = 4
__Result$1$ = -844					; size = 4
__Result$1$ = -844					; size = 4
_c_szDelimeter$GSCopy$1$ = -840				; size = 4
__Hay_end$1$ = -836					; size = 4
__Hay_end$1$ = -836					; size = 4
__Match_try$1$ = -836					; size = 4
__Matches$4 = -832					; size = 256
__Matches$5 = -576					; size = 256
__Matches$6 = -320					; size = 256
__Matches$7 = -320					; size = 256
_stToken$ = -64						; size = 24
$T8 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwLine$ = 8						; size = 4
_pstTokenVector$ = 12					; size = 4
_c_szDelimeter$ = 16					; size = 4
?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z PROC ; CMemoryTextFileLoader::SplitLine2, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 50 03 00
	00		 sub	 esp, 848		; 00000350H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _pstTokenVector$[ebp]
  00032	8b 45 10	 mov	 eax, DWORD PTR _c_szDelimeter$[ebp]
  00035	8b 7d 08	 mov	 edi, DWORD PTR _dwLine$[ebp]

; 40   : 	pstTokenVector->reserve(10);

  00038	6a 0a		 push	 10			; 0000000aH
  0003a	89 8d a4 fc ff
	ff		 mov	 DWORD PTR _pstTokenVector$GSCopy$1$[ebp], ecx
  00040	89 85 b8 fc ff
	ff		 mov	 DWORD PTR _c_szDelimeter$GSCopy$1$[ebp], eax
  00046	e8 00 00 00 00	 call	 ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0004b	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00056	3b c1		 cmp	 eax, ecx
  00058	74 16		 je	 SHORT $LN313@SplitLine2

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  0005a	52		 push	 edx
  0005b	51		 push	 ecx
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00062	8b 8d a4 fc ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN313@SplitLine2:
  00070	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00073	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _stToken$[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0007a	0f 11 45 c0	 movups	 XMMWORD PTR _stToken$[ebp], xmm0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0007e	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _stToken$[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00085	c6 45 c0 00	 mov	 BYTE PTR _stToken$[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 44   : 	const std::string & c_rstLine = GetLineString(dwLine);

  00089	57		 push	 edi
  0008a	8b ce		 mov	 ecx, esi
  0008c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00093	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  00098	8b d0		 mov	 edx, eax

; 45   : 
; 46   : 	DWORD basePos = 0;

  0009a	33 f6		 xor	 esi, esi
  0009c	89 95 ac fc ff
	ff		 mov	 DWORD PTR _c_rstLine$1$[ebp], edx
$LL4@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  000a2	8b bd b8 fc ff
	ff		 mov	 edi, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  000a8	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  000ab	0f 1f 44 00 00	 npad	 5
$LL483@SplitLine2:
  000b0	8a 07		 mov	 al, BYTE PTR [edi]
  000b2	47		 inc	 edi
  000b3	84 c0		 test	 al, al
  000b5	75 f9		 jne	 SHORT $LL483@SplitLine2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2737 :         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(

  000b7	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  000ba	2b f9		 sub	 edi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000bc	83 7a 14 0f	 cmp	 DWORD PTR [edx+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  000c0	8b ca		 mov	 ecx, edx
  000c2	89 95 b4 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edx

; 426  :         if (_Large_mode_engaged()) {

  000c8	76 08		 jbe	 SHORT $LN474@SplitLine2

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  000ca	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000cc	89 8d b4 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN474@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 944  :     if (_Start_at >= _Hay_size) { // no room for match

  000d2	3b f0		 cmp	 esi, eax
  000d4	73 6c		 jae	 SHORT $LN424@SplitLine2
  000d6	68 00 01 00 00	 push	 256			; 00000100H
  000db	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR __Matches$6[ebp]

; 945  :         return static_cast<size_t>(-1);
; 946  :     }
; 947  : 
; 948  :     const auto _Hay_start = _Haystack + _Start_at;

  000e1	03 f1		 add	 esi, ecx
  000e3	6a 00		 push	 0
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _memset

; 949  :     const auto _Hay_end   = _Haystack + _Hay_size;
; 950  : 
; 951  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 952  :         using _Elem = typename _Traits::char_type;
; 953  :         _String_bitmap<_Elem> _Matches;
; 954  :         if (_Matches._Mark(_Needle, _Needle + _Needle_size)) {

  000eb	8b 85 b8 fc ff
	ff		 mov	 eax, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	8b c8		 mov	 ecx, eax
  000f6	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]

; 761  :         for (; _First != _Last; ++_First) {

  000f9	3b c2		 cmp	 eax, edx
  000fb	74 13		 je	 SHORT $LN46@SplitLine2
  000fd	0f 1f 00	 npad	 3
$LL47@SplitLine2:

; 762  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00100	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00103	41		 inc	 ecx
  00104	c6 84 05 c0 fe
	ff ff 01	 mov	 BYTE PTR __Matches$6[ebp+eax], 1
  0010c	3b ca		 cmp	 ecx, edx
  0010e	75 f0		 jne	 SHORT $LL47@SplitLine2
$LN46@SplitLine2:

; 955  :             for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  00110	8b bd ac fc ff
	ff		 mov	 edi, DWORD PTR _c_rstLine$1$[ebp]
  00116	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR __Result$1$[ebp]
  0011c	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  0011f	03 ca		 add	 ecx, edx
  00121	3b f1		 cmp	 esi, ecx
  00123	73 1d		 jae	 SHORT $LN424@SplitLine2
  00125	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL31@SplitLine2:

; 770  :         return _Matches[static_cast<unsigned char>(_Ch)];

  00130	0f b6 06	 movzx	 eax, BYTE PTR [esi]

; 956  :                 if (!_Matches._Match(*_Match_try)) {

  00133	80 bc 05 c0 fe
	ff ff 00	 cmp	 BYTE PTR __Matches$6[ebp+eax], 0
  0013b	74 25		 je	 SHORT $LN416@SplitLine2

; 955  :             for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  0013d	46		 inc	 esi
  0013e	3b f1		 cmp	 esi, ecx
  00140	72 ee		 jb	 SHORT $LL31@SplitLine2
$LN424@SplitLine2:
  00142	83 c8 ff	 or	 eax, -1
$LN1@SplitLine2:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 80   : }

  00145	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00148	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014f	59		 pop	 ecx
  00150	5f		 pop	 edi
  00151	5e		 pop	 esi
  00152	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00155	33 cd		 xor	 ecx, ebp
  00157	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015c	8b e5		 mov	 esp, ebp
  0015e	5d		 pop	 ebp
  0015f	c2 0c 00	 ret	 12			; 0000000cH
$LN416@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 957  :                     return static_cast<size_t>(_Match_try - _Haystack); // found a match

  00162	2b f2		 sub	 esi, edx
  00164	89 b5 b4 fc ff
	ff		 mov	 DWORD PTR _beginPos$1$[ebp], esi
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 52   : 		if (beginPos < 0)

  0016a	78 d6		 js	 SHORT $LN424@SplitLine2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0016c	8b 57 14	 mov	 edx, DWORD PTR [edi+20]

; 425  :         const value_type* _Result = _Bx._Buf;

  0016f	8b c7		 mov	 eax, edi

; 434  :         return _Myres > _Small_string_capacity;

  00171	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00174	76 02		 jbe	 SHORT $LN475@SplitLine2

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00176	8b 07		 mov	 eax, DWORD PTR [edi]
$LN475@SplitLine2:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 57   : 		if (c_rstLine[beginPos] == '"')

  00178	80 3c 06 22	 cmp	 BYTE PTR [esi+eax], 34	; 00000022H
  0017c	0f 85 aa 00 00
	00		 jne	 $LN6@SplitLine2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2661 :         return static_cast<size_type>(_Traits_find_first_of<_Traits>(

  00182	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 59   : 			++beginPos;

  00185	46		 inc	 esi
  00186	89 b5 b4 fc ff
	ff		 mov	 DWORD PTR _beginPos$1$[ebp], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  0018c	8b c7		 mov	 eax, edi
  0018e	89 bd b0 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edi

; 434  :         return _Myres > _Small_string_capacity;

  00194	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00197	76 08		 jbe	 SHORT $LN477@SplitLine2

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00199	8b 07		 mov	 eax, DWORD PTR [edi]
  0019b	89 85 b0 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN477@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 812  :     if (_Needle_size == 0 || _Start_at >= _Hay_size) { // no match possible

  001a1	3b f1		 cmp	 esi, ecx
  001a3	73 4d		 jae	 SHORT $LN482@SplitLine2

; 813  :         return static_cast<size_t>(-1);
; 814  :     }
; 815  : 
; 816  :     const auto _Hay_start = _Haystack + _Start_at;

  001a5	8d 3c 30	 lea	 edi, DWORD PTR [eax+esi]

; 817  :     const auto _Hay_end   = _Haystack + _Hay_size;

  001a8	03 c1		 add	 eax, ecx

; 818  : 
; 819  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 820  :         if (!_STD _Is_constant_evaluated()) {
; 821  :             using _Elem = typename _Traits::char_type;
; 822  : 
; 823  : #if _USE_STD_VECTOR_ALGORITHMS
; 824  :             const bool _Try_vectorize = _Hay_size - _Start_at > _Threshold_find_first_of;

  001aa	2b ce		 sub	 ecx, esi
  001ac	89 85 bc fc ff
	ff		 mov	 DWORD PTR __Hay_end$1$[ebp], eax

; 825  : 
; 826  :             // Additional condition for when the vectorization outperforms the table lookup
; 827  :             constexpr size_t _Find_first_of_bitmap_threshold = sizeof(_Elem) == 1 ? 48 : sizeof(_Elem) == 8 ? 8 : 16;
; 828  : 
; 829  :             const bool _Use_bitmap = !_Try_vectorize || _Needle_size > _Find_first_of_bitmap_threshold;

  001b2	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001b5	77 45		 ja	 SHORT $LN479@SplitLine2
  001b7	68 00 01 00 00	 push	 256			; 00000100H
  001bc	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR __Matches$5[ebp]
  001c2	6a 00		 push	 0
  001c4	50		 push	 eax
  001c5	e8 00 00 00 00	 call	 _memset

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  001ca	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR __Hay_end$1$[ebp]
  001d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 762  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  001d3	c6 85 e2 fd ff
	ff 01		 mov	 BYTE PTR __Matches$5[ebp+34], 1

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  001da	3b f9		 cmp	 edi, ecx
  001dc	73 14		 jae	 SHORT $LN482@SplitLine2
  001de	66 90		 npad	 2
$LL237@SplitLine2:

; 770  :         return _Matches[static_cast<unsigned char>(_Ch)];

  001e0	0f b6 07	 movzx	 eax, BYTE PTR [edi]

; 839  :                         if (_Matches._Match(*_Match_try)) {

  001e3	80 bc 05 c0 fd
	ff ff 00	 cmp	 BYTE PTR __Matches$5[ebp+eax], 0
  001eb	75 2d		 jne	 SHORT $LN418@SplitLine2

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  001ed	47		 inc	 edi
  001ee	3b f9		 cmp	 edi, ecx
  001f0	72 ee		 jb	 SHORT $LL237@SplitLine2
$LN482@SplitLine2:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 63   : 				return -2;

  001f2	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  001f7	e9 49 ff ff ff	 jmp	 $LN1@SplitLine2
$LN479@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 851  :                 const _Traits_ptr_t<_Traits> _Found =

  001fc	68 01 00 00 00	 push	 OFFSET ??_C@_01BJJEKLCA@?$CC@+1
  00201	68 00 00 00 00	 push	 OFFSET ??_C@_01BJJEKLCA@?$CC@
  00206	50		 push	 eax
  00207	57		 push	 edi
  00208	e8 00 00 00 00	 call	 ??$_Find_first_of_vectorized@$$CBD$$CBD@std@@YAPBDQBD000@Z ; std::_Find_first_of_vectorized<char const ,char const >
  0020d	8b f8		 mov	 edi, eax
  0020f	83 c4 10	 add	 esp, 16			; 00000010H

; 852  :                     _STD _Find_first_of_vectorized(_Hay_start, _Hay_end, _Needle, _Needle + _Needle_size);
; 853  : 
; 854  :                 if (_Found != _Hay_end) {

  00212	3b bd bc fc ff
	ff		 cmp	 edi, DWORD PTR __Hay_end$1$[ebp]
  00218	74 d8		 je	 SHORT $LN482@SplitLine2
$LN418@SplitLine2:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 62   : 			if (endPos < 0)

  0021a	2b bd b0 fc ff
	ff		 sub	 edi, DWORD PTR __Result$1$[ebp]
  00220	85 ff		 test	 edi, edi
  00222	78 ce		 js	 SHORT $LN482@SplitLine2

; 64   : 
; 65   : 			basePos = endPos + 1;

  00224	8d 77 01	 lea	 esi, DWORD PTR [edi+1]

; 66   : 		}

  00227	e9 19 01 00 00	 jmp	 $LN490@SplitLine2
$LN6@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  0022c	8b bd b8 fc ff
	ff		 mov	 edi, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00232	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
$LL484@SplitLine2:
  00235	8a 07		 mov	 al, BYTE PTR [edi]
  00237	47		 inc	 edi
  00238	84 c0		 test	 al, al
  0023a	75 f9		 jne	 SHORT $LL484@SplitLine2
  0023c	2b f9		 sub	 edi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2661 :         return static_cast<size_type>(_Traits_find_first_of<_Traits>(

  0023e	8b 8d ac fc ff
	ff		 mov	 ecx, DWORD PTR _c_rstLine$1$[ebp]

; 425  :         const value_type* _Result = _Bx._Buf;

  00244	89 8d b0 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx

; 2661 :         return static_cast<size_type>(_Traits_find_first_of<_Traits>(

  0024a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 434  :         return _Myres > _Small_string_capacity;

  0024d	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00250	76 08		 jbe	 SHORT $LN277@SplitLine2

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00252	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00254	89 8d b0 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN277@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 812  :     if (_Needle_size == 0 || _Start_at >= _Hay_size) { // no match possible

  0025a	85 ff		 test	 edi, edi
  0025c	0f 84 de 00 00
	00		 je	 $LN291@SplitLine2
  00262	3b f0		 cmp	 esi, eax
  00264	0f 83 d6 00 00
	00		 jae	 $LN291@SplitLine2

; 813  :         return static_cast<size_t>(-1);
; 814  :     }
; 815  : 
; 816  :     const auto _Hay_start = _Haystack + _Start_at;

  0026a	03 f1		 add	 esi, ecx

; 817  :     const auto _Hay_end   = _Haystack + _Hay_size;

  0026c	03 c8		 add	 ecx, eax

; 818  : 
; 819  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 820  :         if (!_STD _Is_constant_evaluated()) {
; 821  :             using _Elem = typename _Traits::char_type;
; 822  : 
; 823  : #if _USE_STD_VECTOR_ALGORITHMS
; 824  :             const bool _Try_vectorize = _Hay_size - _Start_at > _Threshold_find_first_of;

  0026e	2b 85 b4 fc ff
	ff		 sub	 eax, DWORD PTR _beginPos$1$[ebp]
  00274	89 8d bc fc ff
	ff		 mov	 DWORD PTR __Hay_end$1$[ebp], ecx
  0027a	89 85 a8 fc ff
	ff		 mov	 DWORD PTR $T3[ebp], eax

; 825  : 
; 826  :             // Additional condition for when the vectorization outperforms the table lookup
; 827  :             constexpr size_t _Find_first_of_bitmap_threshold = sizeof(_Elem) == 1 ? 48 : sizeof(_Elem) == 8 ? 8 : 16;
; 828  : 
; 829  :             const bool _Use_bitmap = !_Try_vectorize || _Needle_size > _Find_first_of_bitmap_threshold;

  00280	83 f8 10	 cmp	 eax, 16			; 00000010H
  00283	76 05		 jbe	 SHORT $LN301@SplitLine2
  00285	83 ff 30	 cmp	 edi, 48			; 00000030H
  00288	76 60		 jbe	 SHORT $LN476@SplitLine2
$LN301@SplitLine2:
  0028a	68 00 01 00 00	 push	 256			; 00000100H
  0028f	8d 85 c0 fc ff
	ff		 lea	 eax, DWORD PTR __Matches$4[ebp]
  00295	6a 00		 push	 0
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 _memset

; 837  :                 if (_Matches._Mark(_Needle, _Needle + _Needle_size)) {

  0029d	8b 8d b8 fc ff
	ff		 mov	 ecx, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  002a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a6	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  002a9	50		 push	 eax
  002aa	51		 push	 ecx
  002ab	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR __Matches$4[ebp]
  002b1	e8 00 00 00 00	 call	 ?_Mark@?$_String_bitmap@D$00@std@@QAE_NPBDQBD@Z ; std::_String_bitmap<char,1>::_Mark
  002b6	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR __Hay_end$1$[ebp]
  002bc	84 c0		 test	 al, al
  002be	74 24		 je	 SHORT $LN486@SplitLine2

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  002c0	3b f1		 cmp	 esi, ecx
  002c2	73 7c		 jae	 SHORT $LN291@SplitLine2
  002c4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL286@SplitLine2:

; 770  :         return _Matches[static_cast<unsigned char>(_Ch)];

  002d0	0f b6 06	 movzx	 eax, BYTE PTR [esi]

; 839  :                         if (_Matches._Match(*_Match_try)) {

  002d3	80 bc 05 c0 fc
	ff ff 00	 cmp	 BYTE PTR __Matches$4[ebp+eax], 0
  002db	75 31		 jne	 SHORT $LN420@SplitLine2

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  002dd	46		 inc	 esi
  002de	3b f1		 cmp	 esi, ecx
  002e0	72 ee		 jb	 SHORT $LL286@SplitLine2
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 75   : 		if (int(c_rstLine.find_first_not_of(c_szDelimeter, basePos)) < 0)

  002e2	eb 5c		 jmp	 SHORT $LN291@SplitLine2
$LN486@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 837  :                 if (_Matches._Mark(_Needle, _Needle + _Needle_size)) {

  002e4	8b 85 a8 fc ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
$LN476@SplitLine2:

; 840  :                             return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 841  :                         }
; 842  :                     }
; 843  :                     return static_cast<size_t>(-1); // no match
; 844  :                 }
; 845  : 
; 846  :                 // couldn't put one of the characters into the bitmap, fall back to vectorized or serial algorithms
; 847  :             }
; 848  : 
; 849  : #if _USE_STD_VECTOR_ALGORITHMS
; 850  :             if (_Try_vectorize) {

  002ea	83 f8 10	 cmp	 eax, 16			; 00000010H
  002ed	76 27		 jbe	 SHORT $LN298@SplitLine2

; 851  :                 const _Traits_ptr_t<_Traits> _Found =

  002ef	8b 95 b8 fc ff
	ff		 mov	 edx, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  002f5	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  002f8	50		 push	 eax
  002f9	52		 push	 edx
  002fa	51		 push	 ecx
  002fb	56		 push	 esi
  002fc	e8 00 00 00 00	 call	 ??$_Find_first_of_vectorized@$$CBD$$CBD@std@@YAPBDQBD000@Z ; std::_Find_first_of_vectorized<char const ,char const >
  00301	8b f0		 mov	 esi, eax
  00303	83 c4 10	 add	 esp, 16			; 00000010H

; 852  :                     _STD _Find_first_of_vectorized(_Hay_start, _Hay_end, _Needle, _Needle + _Needle_size);
; 853  : 
; 854  :                 if (_Found != _Hay_end) {

  00306	3b b5 bc fc ff
	ff		 cmp	 esi, DWORD PTR __Hay_end$1$[ebp]
  0030c	74 32		 je	 SHORT $LN291@SplitLine2
$LN420@SplitLine2:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 69   : 			endPos = c_rstLine.find_first_of(c_szDelimeter, beginPos);

  0030e	2b b5 b0 fc ff
	ff		 sub	 esi, DWORD PTR __Result$1$[ebp]
  00314	eb 2d		 jmp	 SHORT $LN489@SplitLine2
$LN298@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 864  :     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  00316	3b f1		 cmp	 esi, ecx
  00318	73 26		 jae	 SHORT $LN291@SplitLine2
  0031a	66 0f 1f 44 00
	00		 npad	 6
$LL289@SplitLine2:

; 451  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00320	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00323	57		 push	 edi
  00324	50		 push	 eax
  00325	ff b5 b8 fc ff
	ff		 push	 DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  0032b	e8 00 00 00 00	 call	 _memchr
  00330	83 c4 0c	 add	 esp, 12			; 0000000cH

; 865  :         if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {

  00333	85 c0		 test	 eax, eax
  00335	75 d7		 jne	 SHORT $LN420@SplitLine2

; 864  :     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  00337	46		 inc	 esi
  00338	3b b5 bc fc ff
	ff		 cmp	 esi, DWORD PTR __Hay_end$1$[ebp]
  0033e	72 e0		 jb	 SHORT $LL289@SplitLine2
$LN291@SplitLine2:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 69   : 			endPos = c_rstLine.find_first_of(c_szDelimeter, beginPos);

  00340	83 ce ff	 or	 esi, -1
$LN489@SplitLine2:
  00343	8b fe		 mov	 edi, esi
$LN490@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 450  :         if (_Mysize < _Off) {

  00345	8b 95 ac fc ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
  0034b	0f 57 c0	 xorps	 xmm0, xmm0
  0034e	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _beginPos$1$[ebp]

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00354	89 b5 bc fc ff
	ff		 mov	 DWORD PTR __Match_try$1$[ebp], esi
  0035a	0f 11 45 d8	 movups	 XMMWORD PTR $T8[ebp], xmm0

; 450  :         if (_Mysize < _Off) {

  0035e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00361	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T8[ebp+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00368	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T8[ebp+20], 0

; 450  :         if (_Mysize < _Off) {

  0036f	3b c8		 cmp	 ecx, eax
  00371	0f 82 5c 01 00
	00		 jb	 $LN426@SplitLine2

; 468  :         return (_STD min)(_Size, _Mysize - _Off);

  00377	2b c8		 sub	 ecx, eax
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 73   : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  00379	2b f8		 sub	 edi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 468  :         return (_STD min)(_Size, _Mysize - _Off);

  0037b	3b cf		 cmp	 ecx, edi
  0037d	0f 42 f9	 cmovb	 edi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00380	83 7a 14 0f	 cmp	 DWORD PTR [edx+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00384	8b ca		 mov	 ecx, edx

; 426  :         if (_Large_mode_engaged()) {

  00386	76 02		 jbe	 SHORT $LN478@SplitLine2

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00388	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN478@SplitLine2:

; 713  :         _Construct<_Construct_strategy::_From_ptr>(

  0038a	03 c1		 add	 eax, ecx
  0038c	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  0038f	57		 push	 edi
  00390	50		 push	 eax
  00391	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00396	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 73   : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  0039c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  003a0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003a3	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  003a6	74 20		 je	 SHORT $LN107@SplitLine2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  003a8	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR $T8[ebp]

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;
; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  003ac	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  003b1	c6 45 d8 00	 mov	 BYTE PTR $T8[ebp], 0
  003b5	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  003b8	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR $T8[ebp+16]
  003bd	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 854  :         ++_Mylast;

  003c2	83 42 04 18	 add	 DWORD PTR [edx+4], 24	; 00000018H

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  003c6	eb 0f		 jmp	 SHORT $LN106@SplitLine2
$LN107@SplitLine2:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  003c8	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  003cb	51		 push	 ecx
  003cc	50		 push	 eax
  003cd	8b ca		 mov	 ecx, edx
  003cf	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  003d4	8b 4d ec	 mov	 ecx, DWORD PTR $T8[ebp+20]
$LN106@SplitLine2:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 73   : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  003d7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  003db	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  003de	76 2c		 jbe	 SHORT $LN163@SplitLine2
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003e0	8b 55 d8	 mov	 edx, DWORD PTR $T8[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  003e3	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003e4	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  003e6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  003ec	72 14		 jb	 SHORT $LN174@SplitLine2

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003ee	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  003f1	83 c1 23	 add	 ecx, 35			; 00000023H
  003f4	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003f6	83 c0 fc	 add	 eax, -4			; fffffffcH
  003f9	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003fc	0f 87 d6 00 00
	00		 ja	 $LN171@SplitLine2
$LN174@SplitLine2:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00402	51		 push	 ecx
  00403	52		 push	 edx
  00404	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00409	83 c4 08	 add	 esp, 8
$LN163@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  0040c	8b 8d b8 fc ff
	ff		 mov	 ecx, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00412	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL485@SplitLine2:
  00415	8a 01		 mov	 al, BYTE PTR [ecx]
  00417	41		 inc	 ecx
  00418	84 c0		 test	 al, al
  0041a	75 f9		 jne	 SHORT $LL485@SplitLine2
  0041c	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2737 :         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(

  0041e	8b 95 ac fc ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  00424	89 8d a8 fc ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  0042a	8b ca		 mov	 ecx, edx
  0042c	89 95 b4 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edx

; 434  :         return _Myres > _Small_string_capacity;

  00432	83 7a 14 0f	 cmp	 DWORD PTR [edx+20], 15	; 0000000fH

; 2737 :         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(

  00436	8b 42 10	 mov	 eax, DWORD PTR [edx+16]

; 426  :         if (_Large_mode_engaged()) {

  00439	76 08		 jbe	 SHORT $LN473@SplitLine2

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0043b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0043d	89 8d b4 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN473@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 944  :     if (_Start_at >= _Hay_size) { // no room for match

  00443	3b f0		 cmp	 esi, eax
  00445	73 6b		 jae	 SHORT $LN3@SplitLine2
  00447	68 00 01 00 00	 push	 256			; 00000100H
  0044c	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR __Matches$7[ebp]
  00452	6a 00		 push	 0
  00454	50		 push	 eax

; 945  :         return static_cast<size_t>(-1);
; 946  :     }
; 947  : 
; 948  :     const auto _Hay_start = _Haystack + _Start_at;

  00455	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  00458	e8 00 00 00 00	 call	 _memset

; 949  :     const auto _Hay_end   = _Haystack + _Hay_size;
; 950  : 
; 951  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 952  :         using _Elem = typename _Traits::char_type;
; 953  :         _String_bitmap<_Elem> _Matches;
; 954  :         if (_Matches._Mark(_Needle, _Needle + _Needle_size)) {

  0045d	8b 95 b8 fc ff
	ff		 mov	 edx, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00463	83 c4 0c	 add	 esp, 12			; 0000000cH
  00466	8b ca		 mov	 ecx, edx
  00468	03 95 a8 fc ff
	ff		 add	 edx, DWORD PTR $T2[ebp]

; 761  :         for (; _First != _Last; ++_First) {

  0046e	3b ca		 cmp	 ecx, edx
  00470	74 10		 je	 SHORT $LN211@SplitLine2
$LL212@SplitLine2:

; 762  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00472	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00475	41		 inc	 ecx
  00476	c6 84 05 c0 fe
	ff ff 01	 mov	 BYTE PTR __Matches$7[ebp+eax], 1
  0047e	3b ca		 cmp	 ecx, edx
  00480	75 f0		 jne	 SHORT $LL212@SplitLine2
$LN211@SplitLine2:

; 955  :             for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  00482	8b b5 ac fc ff
	ff		 mov	 esi, DWORD PTR _c_rstLine$1$[ebp]
  00488	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR __Result$1$[ebp]
  0048e	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00491	8b b5 bc fc ff
	ff		 mov	 esi, DWORD PTR __Match_try$1$[ebp]
  00497	03 ca		 add	 ecx, edx
  00499	3b f9		 cmp	 edi, ecx
  0049b	73 15		 jae	 SHORT $LN3@SplitLine2
  0049d	0f 1f 00	 npad	 3
$LL196@SplitLine2:

; 770  :         return _Matches[static_cast<unsigned char>(_Ch)];

  004a0	0f b6 07	 movzx	 eax, BYTE PTR [edi]

; 956  :                 if (!_Matches._Match(*_Match_try)) {

  004a3	80 bc 05 c0 fe
	ff ff 00	 cmp	 BYTE PTR __Matches$7[ebp+eax], 0
  004ab	74 0c		 je	 SHORT $LN422@SplitLine2

; 955  :             for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  004ad	47		 inc	 edi
  004ae	3b f9		 cmp	 edi, ecx
  004b0	72 ee		 jb	 SHORT $LL196@SplitLine2
$LN3@SplitLine2:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 79   : 	return 0;

  004b2	33 c0		 xor	 eax, eax
  004b4	e9 8c fc ff ff	 jmp	 $LN1@SplitLine2
$LN422@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 957  :                     return static_cast<size_t>(_Match_try - _Haystack); // found a match

  004b9	2b fa		 sub	 edi, edx
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 75   : 		if (int(c_rstLine.find_first_not_of(c_szDelimeter, basePos)) < 0)

  004bb	78 f5		 js	 SHORT $LN3@SplitLine2

; 76   : 			break;
; 77   : 	} while (basePos < c_rstLine.length());

  004bd	8b 95 ac fc ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
  004c3	3b 72 10	 cmp	 esi, DWORD PTR [edx+16]
  004c6	0f 82 d6 fb ff
	ff		 jb	 $LL4@SplitLine2

; 79   : 	return 0;

  004cc	33 c0		 xor	 eax, eax
  004ce	e9 72 fc ff ff	 jmp	 $LN1@SplitLine2
$LN426@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 451  :             _Xran();

  004d3	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN171@SplitLine2:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004d8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN488@SplitLine2:
  004dd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _stToken$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 8a a4 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-860]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SplitLine2@CMemoryTextFileLoader@@QAEHKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ENDP ; CMemoryTextFileLoader::SplitLine2
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
_TEXT	SEGMENT
_pstTokenVector$GSCopy$1$ = -860			; size = 4
$T2 = -856						; size = 4
$T3 = -856						; size = 4
_c_rstLine$1$ = -852					; size = 4
__Result$1$ = -848					; size = 4
__Result$1$ = -848					; size = 4
_beginPos$1$ = -844					; size = 4
__Result$1$ = -844					; size = 4
__Result$1$ = -844					; size = 4
_c_szDelimeter$GSCopy$1$ = -840				; size = 4
__Hay_end$1$ = -836					; size = 4
__Hay_end$1$ = -836					; size = 4
__Match_try$1$ = -836					; size = 4
__Matches$4 = -832					; size = 256
__Matches$5 = -576					; size = 256
__Matches$6 = -320					; size = 256
__Matches$7 = -320					; size = 256
_stToken$ = -64						; size = 24
$T8 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwLine$ = 8						; size = 4
_pstTokenVector$ = 12					; size = 4
_c_szDelimeter$ = 16					; size = 4
?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z PROC ; CMemoryTextFileLoader::SplitLine, COMDAT
; _this$ = ecx

; 83   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 50 03 00
	00		 sub	 esp, 848		; 00000350H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _pstTokenVector$[ebp]
  00032	8b 45 10	 mov	 eax, DWORD PTR _c_szDelimeter$[ebp]
  00035	8b 7d 08	 mov	 edi, DWORD PTR _dwLine$[ebp]

; 84   : 	pstTokenVector->reserve(10);

  00038	6a 0a		 push	 10			; 0000000aH
  0003a	89 8d a4 fc ff
	ff		 mov	 DWORD PTR _pstTokenVector$GSCopy$1$[ebp], ecx
  00040	89 85 b8 fc ff
	ff		 mov	 DWORD PTR _c_szDelimeter$GSCopy$1$[ebp], eax
  00046	e8 00 00 00 00	 call	 ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0004b	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
  00051	8b 02		 mov	 eax, DWORD PTR [edx]
  00053	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00056	3b c1		 cmp	 eax, ecx
  00058	74 16		 je	 SHORT $LN313@SplitLine

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  0005a	52		 push	 edx
  0005b	51		 push	 ecx
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00062	8b 8d a4 fc ff
	ff		 mov	 ecx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0006d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN313@SplitLine:
  00070	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  00073	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _stToken$[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0007a	0f 11 45 c0	 movups	 XMMWORD PTR _stToken$[ebp], xmm0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0007e	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _stToken$[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00085	c6 45 c0 00	 mov	 BYTE PTR _stToken$[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 88   : 	const std::string & c_rstLine = GetLineString(dwLine);

  00089	57		 push	 edi
  0008a	8b ce		 mov	 ecx, esi
  0008c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00093	e8 00 00 00 00	 call	 ?GetLineString@CMemoryTextFileLoader@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@K@Z ; CMemoryTextFileLoader::GetLineString
  00098	8b d0		 mov	 edx, eax

; 89   : 
; 90   : 	DWORD basePos = 0;

  0009a	33 f6		 xor	 esi, esi
  0009c	89 95 ac fc ff
	ff		 mov	 DWORD PTR _c_rstLine$1$[ebp], edx
$LL4@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  000a2	8b bd b8 fc ff
	ff		 mov	 edi, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  000a8	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  000ab	0f 1f 44 00 00	 npad	 5
$LL483@SplitLine:
  000b0	8a 07		 mov	 al, BYTE PTR [edi]
  000b2	47		 inc	 edi
  000b3	84 c0		 test	 al, al
  000b5	75 f9		 jne	 SHORT $LL483@SplitLine
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2737 :         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(

  000b7	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  000ba	2b f9		 sub	 edi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000bc	83 7a 14 0f	 cmp	 DWORD PTR [edx+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  000c0	8b ca		 mov	 ecx, edx
  000c2	89 95 b4 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edx

; 426  :         if (_Large_mode_engaged()) {

  000c8	76 08		 jbe	 SHORT $LN474@SplitLine

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  000ca	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000cc	89 8d b4 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN474@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 944  :     if (_Start_at >= _Hay_size) { // no room for match

  000d2	3b f0		 cmp	 esi, eax
  000d4	73 6c		 jae	 SHORT $LN424@SplitLine
  000d6	68 00 01 00 00	 push	 256			; 00000100H
  000db	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR __Matches$6[ebp]

; 945  :         return static_cast<size_t>(-1);
; 946  :     }
; 947  : 
; 948  :     const auto _Hay_start = _Haystack + _Start_at;

  000e1	03 f1		 add	 esi, ecx
  000e3	6a 00		 push	 0
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _memset

; 949  :     const auto _Hay_end   = _Haystack + _Hay_size;
; 950  : 
; 951  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 952  :         using _Elem = typename _Traits::char_type;
; 953  :         _String_bitmap<_Elem> _Matches;
; 954  :         if (_Matches._Mark(_Needle, _Needle + _Needle_size)) {

  000eb	8b 85 b8 fc ff
	ff		 mov	 eax, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	8b c8		 mov	 ecx, eax
  000f6	8d 14 38	 lea	 edx, DWORD PTR [eax+edi]

; 761  :         for (; _First != _Last; ++_First) {

  000f9	3b c2		 cmp	 eax, edx
  000fb	74 13		 je	 SHORT $LN46@SplitLine
  000fd	0f 1f 00	 npad	 3
$LL47@SplitLine:

; 762  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00100	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00103	41		 inc	 ecx
  00104	c6 84 05 c0 fe
	ff ff 01	 mov	 BYTE PTR __Matches$6[ebp+eax], 1
  0010c	3b ca		 cmp	 ecx, edx
  0010e	75 f0		 jne	 SHORT $LL47@SplitLine
$LN46@SplitLine:

; 955  :             for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  00110	8b bd ac fc ff
	ff		 mov	 edi, DWORD PTR _c_rstLine$1$[ebp]
  00116	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR __Result$1$[ebp]
  0011c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0011f	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]
  00122	3b f1		 cmp	 esi, ecx
  00124	73 1c		 jae	 SHORT $LN424@SplitLine
  00126	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL31@SplitLine:

; 770  :         return _Matches[static_cast<unsigned char>(_Ch)];

  00130	0f b6 06	 movzx	 eax, BYTE PTR [esi]

; 956  :                 if (!_Matches._Match(*_Match_try)) {

  00133	80 bc 05 c0 fe
	ff ff 00	 cmp	 BYTE PTR __Matches$6[ebp+eax], 0
  0013b	74 24		 je	 SHORT $LN416@SplitLine

; 955  :             for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  0013d	46		 inc	 esi
  0013e	3b f1		 cmp	 esi, ecx
  00140	72 ee		 jb	 SHORT $LL31@SplitLine
$LN424@SplitLine:
  00142	32 c0		 xor	 al, al
$LN1@SplitLine:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 123  : }

  00144	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00147	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014e	59		 pop	 ecx
  0014f	5f		 pop	 edi
  00150	5e		 pop	 esi
  00151	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00154	33 cd		 xor	 ecx, ebp
  00156	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 0c 00	 ret	 12			; 0000000cH
$LN416@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 957  :                     return static_cast<size_t>(_Match_try - _Haystack); // found a match

  00161	2b f2		 sub	 esi, edx
  00163	89 b5 b4 fc ff
	ff		 mov	 DWORD PTR _beginPos$1$[ebp], esi
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 95   : 		if (beginPos < 0)

  00169	78 d7		 js	 SHORT $LN424@SplitLine
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0016b	8b 57 14	 mov	 edx, DWORD PTR [edi+20]

; 425  :         const value_type* _Result = _Bx._Buf;

  0016e	8b c7		 mov	 eax, edi

; 434  :         return _Myres > _Small_string_capacity;

  00170	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00173	76 02		 jbe	 SHORT $LN475@SplitLine

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00175	8b 07		 mov	 eax, DWORD PTR [edi]
$LN475@SplitLine:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 100  : 		if (c_rstLine[beginPos] == '"')

  00177	80 3c 06 22	 cmp	 BYTE PTR [esi+eax], 34	; 00000022H
  0017b	0f 85 af 00 00
	00		 jne	 $LN6@SplitLine
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2661 :         return static_cast<size_type>(_Traits_find_first_of<_Traits>(

  00181	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 102  : 			++beginPos;

  00184	46		 inc	 esi
  00185	89 b5 b4 fc ff
	ff		 mov	 DWORD PTR _beginPos$1$[ebp], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  0018b	8b c7		 mov	 eax, edi
  0018d	89 bd b0 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edi

; 434  :         return _Myres > _Small_string_capacity;

  00193	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00196	76 08		 jbe	 SHORT $LN477@SplitLine

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00198	8b 07		 mov	 eax, DWORD PTR [edi]
  0019a	89 85 b0 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
$LN477@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 812  :     if (_Needle_size == 0 || _Start_at >= _Hay_size) { // no match possible

  001a0	3b f1		 cmp	 esi, ecx
  001a2	73 9e		 jae	 SHORT $LN424@SplitLine

; 813  :         return static_cast<size_t>(-1);
; 814  :     }
; 815  : 
; 816  :     const auto _Hay_start = _Haystack + _Start_at;

  001a4	8d 3c 30	 lea	 edi, DWORD PTR [eax+esi]

; 817  :     const auto _Hay_end   = _Haystack + _Hay_size;

  001a7	03 c1		 add	 eax, ecx

; 818  : 
; 819  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 820  :         if (!_STD _Is_constant_evaluated()) {
; 821  :             using _Elem = typename _Traits::char_type;
; 822  : 
; 823  : #if _USE_STD_VECTOR_ALGORITHMS
; 824  :             const bool _Try_vectorize = _Hay_size - _Start_at > _Threshold_find_first_of;

  001a9	2b ce		 sub	 ecx, esi
  001ab	89 85 bc fc ff
	ff		 mov	 DWORD PTR __Hay_end$1$[ebp], eax

; 825  : 
; 826  :             // Additional condition for when the vectorization outperforms the table lookup
; 827  :             constexpr size_t _Find_first_of_bitmap_threshold = sizeof(_Elem) == 1 ? 48 : sizeof(_Elem) == 8 ? 8 : 16;
; 828  : 
; 829  :             const bool _Use_bitmap = !_Try_vectorize || _Needle_size > _Find_first_of_bitmap_threshold;

  001b1	83 f9 10	 cmp	 ecx, 16			; 00000010H
  001b4	77 42		 ja	 SHORT $LN479@SplitLine
  001b6	68 00 01 00 00	 push	 256			; 00000100H
  001bb	8d 85 c0 fd ff
	ff		 lea	 eax, DWORD PTR __Matches$5[ebp]
  001c1	6a 00		 push	 0
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 _memset

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  001c9	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR __Hay_end$1$[ebp]
  001cf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 762  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  001d2	c6 85 e2 fd ff
	ff 01		 mov	 BYTE PTR __Matches$5[ebp+34], 1

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  001d9	3b f9		 cmp	 edi, ecx
  001db	0f 83 61 ff ff
	ff		 jae	 $LN424@SplitLine
$LL237@SplitLine:

; 770  :         return _Matches[static_cast<unsigned char>(_Ch)];

  001e1	0f b6 07	 movzx	 eax, BYTE PTR [edi]

; 839  :                         if (_Matches._Match(*_Match_try)) {

  001e4	80 bc 05 c0 fd
	ff ff 00	 cmp	 BYTE PTR __Matches$5[ebp+eax], 0
  001ec	75 2c		 jne	 SHORT $LN418@SplitLine

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  001ee	47		 inc	 edi
  001ef	3b f9		 cmp	 edi, ecx
  001f1	72 ee		 jb	 SHORT $LL237@SplitLine
  001f3	e9 4a ff ff ff	 jmp	 $LN424@SplitLine
$LN479@SplitLine:

; 851  :                 const _Traits_ptr_t<_Traits> _Found =

  001f8	68 01 00 00 00	 push	 OFFSET ??_C@_01BJJEKLCA@?$CC@+1
  001fd	68 00 00 00 00	 push	 OFFSET ??_C@_01BJJEKLCA@?$CC@
  00202	50		 push	 eax
  00203	57		 push	 edi
  00204	e8 00 00 00 00	 call	 ??$_Find_first_of_vectorized@$$CBD$$CBD@std@@YAPBDQBD000@Z ; std::_Find_first_of_vectorized<char const ,char const >
  00209	8b f8		 mov	 edi, eax
  0020b	83 c4 10	 add	 esp, 16			; 00000010H

; 852  :                     _STD _Find_first_of_vectorized(_Hay_start, _Hay_end, _Needle, _Needle + _Needle_size);
; 853  : 
; 854  :                 if (_Found != _Hay_end) {

  0020e	3b bd bc fc ff
	ff		 cmp	 edi, DWORD PTR __Hay_end$1$[ebp]
  00214	0f 84 28 ff ff
	ff		 je	 $LN424@SplitLine
$LN418@SplitLine:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 105  : 			if (endPos < 0)

  0021a	2b bd b0 fc ff
	ff		 sub	 edi, DWORD PTR __Result$1$[ebp]
  00220	85 ff		 test	 edi, edi
  00222	0f 88 1a ff ff
	ff		 js	 $LN424@SplitLine

; 106  : 				return false;
; 107  : 
; 108  : 			basePos = endPos + 1;

  00228	8d 77 01	 lea	 esi, DWORD PTR [edi+1]

; 109  : 		}

  0022b	e9 15 01 00 00	 jmp	 $LN490@SplitLine
$LN6@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  00230	8b bd b8 fc ff
	ff		 mov	 edi, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00236	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  00239	0f 1f 80 00 00
	00 00		 npad	 7
$LL484@SplitLine:
  00240	8a 07		 mov	 al, BYTE PTR [edi]
  00242	47		 inc	 edi
  00243	84 c0		 test	 al, al
  00245	75 f9		 jne	 SHORT $LL484@SplitLine
  00247	2b f9		 sub	 edi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2661 :         return static_cast<size_type>(_Traits_find_first_of<_Traits>(

  00249	8b 8d ac fc ff
	ff		 mov	 ecx, DWORD PTR _c_rstLine$1$[ebp]

; 425  :         const value_type* _Result = _Bx._Buf;

  0024f	89 8d b0 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx

; 2661 :         return static_cast<size_type>(_Traits_find_first_of<_Traits>(

  00255	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]

; 434  :         return _Myres > _Small_string_capacity;

  00258	83 fa 0f	 cmp	 edx, 15			; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0025b	76 08		 jbe	 SHORT $LN277@SplitLine

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0025d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0025f	89 8d b0 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN277@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 812  :     if (_Needle_size == 0 || _Start_at >= _Hay_size) { // no match possible

  00265	85 ff		 test	 edi, edi
  00267	0f 84 d3 00 00
	00		 je	 $LN291@SplitLine
  0026d	3b f0		 cmp	 esi, eax
  0026f	0f 83 cb 00 00
	00		 jae	 $LN291@SplitLine

; 813  :         return static_cast<size_t>(-1);
; 814  :     }
; 815  : 
; 816  :     const auto _Hay_start = _Haystack + _Start_at;

  00275	03 f1		 add	 esi, ecx

; 817  :     const auto _Hay_end   = _Haystack + _Hay_size;

  00277	03 c8		 add	 ecx, eax

; 818  : 
; 819  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 820  :         if (!_STD _Is_constant_evaluated()) {
; 821  :             using _Elem = typename _Traits::char_type;
; 822  : 
; 823  : #if _USE_STD_VECTOR_ALGORITHMS
; 824  :             const bool _Try_vectorize = _Hay_size - _Start_at > _Threshold_find_first_of;

  00279	2b 85 b4 fc ff
	ff		 sub	 eax, DWORD PTR _beginPos$1$[ebp]
  0027f	89 8d bc fc ff
	ff		 mov	 DWORD PTR __Hay_end$1$[ebp], ecx
  00285	89 85 a8 fc ff
	ff		 mov	 DWORD PTR $T3[ebp], eax

; 825  : 
; 826  :             // Additional condition for when the vectorization outperforms the table lookup
; 827  :             constexpr size_t _Find_first_of_bitmap_threshold = sizeof(_Elem) == 1 ? 48 : sizeof(_Elem) == 8 ? 8 : 16;
; 828  : 
; 829  :             const bool _Use_bitmap = !_Try_vectorize || _Needle_size > _Find_first_of_bitmap_threshold;

  0028b	83 f8 10	 cmp	 eax, 16			; 00000010H
  0028e	76 05		 jbe	 SHORT $LN301@SplitLine
  00290	83 ff 30	 cmp	 edi, 48			; 00000030H
  00293	76 55		 jbe	 SHORT $LN476@SplitLine
$LN301@SplitLine:
  00295	68 00 01 00 00	 push	 256			; 00000100H
  0029a	8d 85 c0 fc ff
	ff		 lea	 eax, DWORD PTR __Matches$4[ebp]
  002a0	6a 00		 push	 0
  002a2	50		 push	 eax
  002a3	e8 00 00 00 00	 call	 _memset

; 837  :                 if (_Matches._Mark(_Needle, _Needle + _Needle_size)) {

  002a8	8b 8d b8 fc ff
	ff		 mov	 ecx, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  002b4	50		 push	 eax
  002b5	51		 push	 ecx
  002b6	8d 8d c0 fc ff
	ff		 lea	 ecx, DWORD PTR __Matches$4[ebp]
  002bc	e8 00 00 00 00	 call	 ?_Mark@?$_String_bitmap@D$00@std@@QAE_NPBDQBD@Z ; std::_String_bitmap<char,1>::_Mark
  002c1	8b 8d bc fc ff
	ff		 mov	 ecx, DWORD PTR __Hay_end$1$[ebp]
  002c7	84 c0		 test	 al, al
  002c9	74 19		 je	 SHORT $LN486@SplitLine

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  002cb	3b f1		 cmp	 esi, ecx
  002cd	73 71		 jae	 SHORT $LN291@SplitLine
  002cf	90		 npad	 1
$LL286@SplitLine:

; 770  :         return _Matches[static_cast<unsigned char>(_Ch)];

  002d0	0f b6 06	 movzx	 eax, BYTE PTR [esi]

; 839  :                         if (_Matches._Match(*_Match_try)) {

  002d3	80 bc 05 c0 fc
	ff ff 00	 cmp	 BYTE PTR __Matches$4[ebp+eax], 0
  002db	75 31		 jne	 SHORT $LN420@SplitLine

; 838  :                     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  002dd	46		 inc	 esi
  002de	3b f1		 cmp	 esi, ecx
  002e0	72 ee		 jb	 SHORT $LL286@SplitLine
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 118  : 		if (int(c_rstLine.find_first_not_of(c_szDelimeter, basePos)) < 0)

  002e2	eb 5c		 jmp	 SHORT $LN291@SplitLine
$LN486@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 837  :                 if (_Matches._Mark(_Needle, _Needle + _Needle_size)) {

  002e4	8b 85 a8 fc ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
$LN476@SplitLine:

; 840  :                             return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 841  :                         }
; 842  :                     }
; 843  :                     return static_cast<size_t>(-1); // no match
; 844  :                 }
; 845  : 
; 846  :                 // couldn't put one of the characters into the bitmap, fall back to vectorized or serial algorithms
; 847  :             }
; 848  : 
; 849  : #if _USE_STD_VECTOR_ALGORITHMS
; 850  :             if (_Try_vectorize) {

  002ea	83 f8 10	 cmp	 eax, 16			; 00000010H
  002ed	76 27		 jbe	 SHORT $LN298@SplitLine

; 851  :                 const _Traits_ptr_t<_Traits> _Found =

  002ef	8b 95 b8 fc ff
	ff		 mov	 edx, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  002f5	8d 04 3a	 lea	 eax, DWORD PTR [edx+edi]
  002f8	50		 push	 eax
  002f9	52		 push	 edx
  002fa	51		 push	 ecx
  002fb	56		 push	 esi
  002fc	e8 00 00 00 00	 call	 ??$_Find_first_of_vectorized@$$CBD$$CBD@std@@YAPBDQBD000@Z ; std::_Find_first_of_vectorized<char const ,char const >
  00301	8b f0		 mov	 esi, eax
  00303	83 c4 10	 add	 esp, 16			; 00000010H

; 852  :                     _STD _Find_first_of_vectorized(_Hay_start, _Hay_end, _Needle, _Needle + _Needle_size);
; 853  : 
; 854  :                 if (_Found != _Hay_end) {

  00306	3b b5 bc fc ff
	ff		 cmp	 esi, DWORD PTR __Hay_end$1$[ebp]
  0030c	74 32		 je	 SHORT $LN291@SplitLine
$LN420@SplitLine:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 112  : 			endPos = c_rstLine.find_first_of(c_szDelimeter, beginPos);

  0030e	2b b5 b0 fc ff
	ff		 sub	 esi, DWORD PTR __Result$1$[ebp]
  00314	eb 2d		 jmp	 SHORT $LN489@SplitLine
$LN298@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 864  :     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  00316	3b f1		 cmp	 esi, ecx
  00318	73 26		 jae	 SHORT $LN291@SplitLine
  0031a	66 0f 1f 44 00
	00		 npad	 6
$LL289@SplitLine:

; 451  :             return __builtin_char_memchr(_First, _Ch, _Count);

  00320	0f be 06	 movsx	 eax, BYTE PTR [esi]
  00323	57		 push	 edi
  00324	50		 push	 eax
  00325	ff b5 b8 fc ff
	ff		 push	 DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  0032b	e8 00 00 00 00	 call	 _memchr
  00330	83 c4 0c	 add	 esp, 12			; 0000000cH

; 865  :         if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {

  00333	85 c0		 test	 eax, eax
  00335	75 d7		 jne	 SHORT $LN420@SplitLine

; 864  :     for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  00337	46		 inc	 esi
  00338	3b b5 bc fc ff
	ff		 cmp	 esi, DWORD PTR __Hay_end$1$[ebp]
  0033e	72 e0		 jb	 SHORT $LL289@SplitLine
$LN291@SplitLine:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 112  : 			endPos = c_rstLine.find_first_of(c_szDelimeter, beginPos);

  00340	83 ce ff	 or	 esi, -1
$LN489@SplitLine:
  00343	8b fe		 mov	 edi, esi
$LN490@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 450  :         if (_Mysize < _Off) {

  00345	8b 95 ac fc ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
  0034b	0f 57 c0	 xorps	 xmm0, xmm0
  0034e	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _beginPos$1$[ebp]

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00354	89 b5 bc fc ff
	ff		 mov	 DWORD PTR __Match_try$1$[ebp], esi
  0035a	0f 11 45 d8	 movups	 XMMWORD PTR $T8[ebp], xmm0

; 450  :         if (_Mysize < _Off) {

  0035e	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00361	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T8[ebp+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00368	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T8[ebp+20], 0

; 450  :         if (_Mysize < _Off) {

  0036f	3b c8		 cmp	 ecx, eax
  00371	0f 82 6c 01 00
	00		 jb	 $LN426@SplitLine

; 468  :         return (_STD min)(_Size, _Mysize - _Off);

  00377	2b c8		 sub	 ecx, eax
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 116  : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  00379	2b f8		 sub	 edi, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 468  :         return (_STD min)(_Size, _Mysize - _Off);

  0037b	3b cf		 cmp	 ecx, edi
  0037d	0f 42 f9	 cmovb	 edi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00380	83 7a 14 0f	 cmp	 DWORD PTR [edx+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00384	8b ca		 mov	 ecx, edx

; 426  :         if (_Large_mode_engaged()) {

  00386	76 02		 jbe	 SHORT $LN478@SplitLine

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00388	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN478@SplitLine:

; 713  :         _Construct<_Construct_strategy::_From_ptr>(

  0038a	03 c1		 add	 eax, ecx
  0038c	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  0038f	57		 push	 edi
  00390	50		 push	 eax
  00391	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00396	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _pstTokenVector$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 116  : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  0039c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  003a0	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  003a3	3b 42 08	 cmp	 eax, DWORD PTR [edx+8]
  003a6	74 20		 je	 SHORT $LN107@SplitLine
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  003a8	0f 10 45 d8	 movups	 xmm0, XMMWORD PTR $T8[ebp]

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;
; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  003ac	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  003b1	c6 45 d8 00	 mov	 BYTE PTR $T8[ebp], 0
  003b5	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  003b8	f3 0f 7e 45 e8	 movq	 xmm0, QWORD PTR $T8[ebp+16]
  003bd	66 0f d6 40 10	 movq	 QWORD PTR [eax+16], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 854  :         ++_Mylast;

  003c2	83 42 04 18	 add	 DWORD PTR [edx+4], 24	; 00000018H

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  003c6	eb 0f		 jmp	 SHORT $LN106@SplitLine
$LN107@SplitLine:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  003c8	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  003cb	51		 push	 ecx
  003cc	50		 push	 eax
  003cd	8b ca		 mov	 ecx, edx
  003cf	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  003d4	8b 4d ec	 mov	 ecx, DWORD PTR $T8[ebp+20]
$LN106@SplitLine:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 116  : 		pstTokenVector->push_back(c_rstLine.substr(beginPos, endPos - beginPos));

  003d7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  003db	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  003de	76 2c		 jbe	 SHORT $LN163@SplitLine
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003e0	8b 55 d8	 mov	 edx, DWORD PTR $T8[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  003e3	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003e4	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  003e6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  003ec	72 14		 jb	 SHORT $LN174@SplitLine

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003ee	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  003f1	83 c1 23	 add	 ecx, 35			; 00000023H
  003f4	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003f6	83 c0 fc	 add	 eax, -4			; fffffffcH
  003f9	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  003fc	0f 87 e6 00 00
	00		 ja	 $LN171@SplitLine
$LN174@SplitLine:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00402	51		 push	 ecx
  00403	52		 push	 edx
  00404	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00409	83 c4 08	 add	 esp, 8
$LN163@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  0040c	8b 8d b8 fc ff
	ff		 mov	 ecx, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00412	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL485@SplitLine:
  00415	8a 01		 mov	 al, BYTE PTR [ecx]
  00417	41		 inc	 ecx
  00418	84 c0		 test	 al, al
  0041a	75 f9		 jne	 SHORT $LL485@SplitLine
  0041c	2b ca		 sub	 ecx, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2737 :         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(

  0041e	8b 95 ac fc ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 430  :             return __builtin_strlen(_First);

  00424	89 8d a8 fc ff
	ff		 mov	 DWORD PTR $T2[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  0042a	8b ca		 mov	 ecx, edx
  0042c	89 95 b4 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edx

; 434  :         return _Myres > _Small_string_capacity;

  00432	83 7a 14 0f	 cmp	 DWORD PTR [edx+20], 15	; 0000000fH

; 2737 :         return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(

  00436	8b 42 10	 mov	 eax, DWORD PTR [edx+16]

; 426  :         if (_Large_mode_engaged()) {

  00439	76 08		 jbe	 SHORT $LN473@SplitLine

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0043b	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0043d	89 8d b4 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN473@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 944  :     if (_Start_at >= _Hay_size) { // no room for match

  00443	3b f0		 cmp	 esi, eax
  00445	0f 83 77 00 00
	00		 jae	 $LN3@SplitLine
  0044b	68 00 01 00 00	 push	 256			; 00000100H
  00450	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR __Matches$7[ebp]
  00456	6a 00		 push	 0
  00458	50		 push	 eax

; 945  :         return static_cast<size_t>(-1);
; 946  :     }
; 947  : 
; 948  :     const auto _Hay_start = _Haystack + _Start_at;

  00459	8d 3c 31	 lea	 edi, DWORD PTR [ecx+esi]
  0045c	e8 00 00 00 00	 call	 _memset

; 949  :     const auto _Hay_end   = _Haystack + _Hay_size;
; 950  : 
; 951  :     if constexpr (_Is_implementation_handled_char_traits<_Traits>) {
; 952  :         using _Elem = typename _Traits::char_type;
; 953  :         _String_bitmap<_Elem> _Matches;
; 954  :         if (_Matches._Mark(_Needle, _Needle + _Needle_size)) {

  00461	8b 95 b8 fc ff
	ff		 mov	 edx, DWORD PTR _c_szDelimeter$GSCopy$1$[ebp]
  00467	83 c4 0c	 add	 esp, 12			; 0000000cH
  0046a	8b ca		 mov	 ecx, edx
  0046c	03 95 a8 fc ff
	ff		 add	 edx, DWORD PTR $T2[ebp]

; 761  :         for (; _First != _Last; ++_First) {

  00472	3b ca		 cmp	 ecx, edx
  00474	74 1a		 je	 SHORT $LN211@SplitLine
  00476	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL212@SplitLine:

; 762  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00480	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00483	41		 inc	 ecx
  00484	c6 84 05 c0 fe
	ff ff 01	 mov	 BYTE PTR __Matches$7[ebp+eax], 1
  0048c	3b ca		 cmp	 ecx, edx
  0048e	75 f0		 jne	 SHORT $LL212@SplitLine
$LN211@SplitLine:

; 955  :             for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  00490	8b b5 ac fc ff
	ff		 mov	 esi, DWORD PTR _c_rstLine$1$[ebp]
  00496	8b 95 b4 fc ff
	ff		 mov	 edx, DWORD PTR __Result$1$[ebp]
  0049c	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  0049f	8b b5 bc fc ff
	ff		 mov	 esi, DWORD PTR __Match_try$1$[ebp]
  004a5	03 ca		 add	 ecx, edx
  004a7	3b f9		 cmp	 edi, ecx
  004a9	73 17		 jae	 SHORT $LN3@SplitLine
  004ab	0f 1f 44 00 00	 npad	 5
$LL196@SplitLine:

; 770  :         return _Matches[static_cast<unsigned char>(_Ch)];

  004b0	0f b6 07	 movzx	 eax, BYTE PTR [edi]

; 956  :                 if (!_Matches._Match(*_Match_try)) {

  004b3	80 bc 05 c0 fe
	ff ff 00	 cmp	 BYTE PTR __Matches$7[ebp+eax], 0
  004bb	74 0c		 je	 SHORT $LN422@SplitLine

; 955  :             for (auto _Match_try = _Hay_start; _Match_try < _Hay_end; ++_Match_try) {

  004bd	47		 inc	 edi
  004be	3b f9		 cmp	 edi, ecx
  004c0	72 ee		 jb	 SHORT $LL196@SplitLine
$LN3@SplitLine:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 122  : 	return true;

  004c2	b0 01		 mov	 al, 1
  004c4	e9 7b fc ff ff	 jmp	 $LN1@SplitLine
$LN422@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 957  :                     return static_cast<size_t>(_Match_try - _Haystack); // found a match

  004c9	2b fa		 sub	 edi, edx
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 118  : 		if (int(c_rstLine.find_first_not_of(c_szDelimeter, basePos)) < 0)

  004cb	78 f5		 js	 SHORT $LN3@SplitLine

; 119  : 			break;
; 120  : 	} while (basePos < c_rstLine.length());

  004cd	8b 95 ac fc ff
	ff		 mov	 edx, DWORD PTR _c_rstLine$1$[ebp]
  004d3	3b 72 10	 cmp	 esi, DWORD PTR [edx+16]
  004d6	0f 82 c6 fb ff
	ff		 jb	 $LL4@SplitLine

; 122  : 	return true;

  004dc	b0 01		 mov	 al, 1
  004de	e9 61 fc ff ff	 jmp	 $LN1@SplitLine
$LN426@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 451  :             _Xran();

  004e3	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN171@SplitLine:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004e8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN488@SplitLine:
  004ed	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _stToken$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 8a a4 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-860]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ENDP ; CMemoryTextFileLoader::SplitLine
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?CheckLineIndex@CMemoryTextFileLoader@@QAE_NK@Z
_TEXT	SEGMENT
_dwLine$ = 8						; size = 4
?CheckLineIndex@CMemoryTextFileLoader@@QAE_NK@Z PROC	; CMemoryTextFileLoader::CheckLineIndex, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00006	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  0000b	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000e	f7 ea		 imul	 edx
  00010	c1 fa 02	 sar	 edx, 2
  00013	8b c2		 mov	 eax, edx
  00015	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00018	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 132  : 	if (dwLine >= m_stLineVector.size())

  0001a	39 45 08	 cmp	 DWORD PTR _dwLine$[ebp], eax
  0001d	0f 92 c0	 setb	 al

; 133  : 		return false;
; 134  : 
; 135  : 	return true;
; 136  : }

  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
?CheckLineIndex@CMemoryTextFileLoader@@QAE_NK@Z ENDP	; CMemoryTextFileLoader::CheckLineIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ
_TEXT	SEGMENT
?GetLineCount@CMemoryTextFileLoader@@QAEKXZ PROC	; CMemoryTextFileLoader::GetLineCount, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00003	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00008	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  0000b	f7 ea		 imul	 edx
  0000d	c1 fa 02	 sar	 edx, 2
  00010	8b c2		 mov	 eax, edx
  00012	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00015	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 128  : }

  00017	c3		 ret	 0
?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ENDP	; CMemoryTextFileLoader::GetLineCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z
_TEXT	SEGMENT
__My_data$1$ = -72					; size = 4
_c_pvBuf$GSCopy$1$ = -68				; size = 4
tv1581 = -64						; size = 4
__Old_size$1$ = -64					; size = 4
tv1567 = -60						; size = 4
tv1570 = -60						; size = 4
__Old_size$1$ = -60					; size = 4
_pos$1$ = -56						; size = 4
__Old_capacity$1$ = -52					; size = 4
__Old_capacity$1$ = -52					; size = 4
$T2 = -48						; size = 4
$T3 = -48						; size = 4
_c$1$ = -41						; size = 1
_stLine$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_bufSize$ = 8						; size = 4
_c_pvBuf$ = 12						; size = 4
?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z PROC		; CMemoryTextFileLoader::Bind, COMDAT
; _this$ = ecx

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _c_pvBuf$[ebp]

; 146  : 	m_stLineVector.reserve(128);

  0002d	8d 79 04	 lea	 edi, DWORD PTR [ecx+4]
  00030	68 80 00 00 00	 push	 128			; 00000080H
  00035	8b cf		 mov	 ecx, edi
  00037	89 45 bc	 mov	 DWORD PTR _c_pvBuf$GSCopy$1$[ebp], eax
  0003a	89 7d b8	 mov	 DWORD PTR __My_data$1$[ebp], edi
  0003d	e8 00 00 00 00	 call	 ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00042	8b 07		 mov	 eax, DWORD PTR [edi]
  00044	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00047	3b c1		 cmp	 eax, ecx
  00049	74 10		 je	 SHORT $LN14@Bind

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  0004b	57		 push	 edi
  0004c	51		 push	 ecx
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00053	8b 07		 mov	 eax, DWORD PTR [edi]
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN14@Bind:
  0005b	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  0005e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stLine$[ebp+16], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00065	be 0f 00 00 00	 mov	 esi, 15			; 0000000fH

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0006a	0f 11 45 d8	 movups	 XMMWORD PTR _stLine$[ebp], xmm0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0006e	89 75 ec	 mov	 DWORD PTR _stLine$[ebp+20], esi

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00071	c6 45 d8 00	 mov	 BYTE PTR _stLine$[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 151  : 	int pos = 0;

  00075	33 c0		 xor	 eax, eax
  00077	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 153  : 	while (pos < bufSize)

  0007e	39 45 08	 cmp	 DWORD PTR _bufSize$[ebp], eax
  00081	0f 8e 34 03 00
	00		 jle	 $LN340@Bind
  00087	8b 7d d8	 mov	 edi, DWORD PTR _stLine$[ebp]
  0008a	66 0f 1f 44 00
	00		 npad	 6
$LL2@Bind:

; 154  : 	{
; 155  : 		const char c = c_pcBuf[pos++];

  00090	8b 4d bc	 mov	 ecx, DWORD PTR _c_pvBuf$GSCopy$1$[ebp]
  00093	8a 14 01	 mov	 dl, BYTE PTR [ecx+eax]
  00096	40		 inc	 eax
  00097	88 55 d7	 mov	 BYTE PTR _c$1$[ebp], dl
  0009a	89 45 c8	 mov	 DWORD PTR _pos$1$[ebp], eax

; 156  : 
; 157  : 		if ('\n' == c || '\r' == c)

  0009d	80 fa 0a	 cmp	 dl, 10			; 0000000aH
  000a0	0f 84 b1 02 00
	00		 je	 $LN338@Bind
  000a6	80 fa 0d	 cmp	 dl, 13			; 0000000dH
  000a9	0f 84 a8 02 00
	00		 je	 $LN338@Bind

; 162  : 
; 163  : 			m_stLineVector.push_back(stLine);
; 164  : 			stLine = "";
; 165  : 		}
; 166  : 		else if (c < 0)

  000af	84 d2		 test	 dl, dl
  000b1	0f 89 73 01 00
	00		 jns	 $LN10@Bind
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1488 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  000b7	8b 55 e8	 mov	 edx, DWORD PTR _stLine$[ebp+16]
  000ba	8b c6		 mov	 eax, esi
  000bc	2b c2		 sub	 eax, edx
  000be	89 55 c0	 mov	 DWORD PTR __Old_size$1$[ebp], edx

; 1489 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  000c1	83 f8 02	 cmp	 eax, 2
  000c4	72 32		 jb	 SHORT $LN129@Bind

; 1490 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1491 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  000c6	8d 42 02	 lea	 eax, DWORD PTR [edx+2]

; 434  :         return _Myres > _Small_string_capacity;

  000c9	83 fe 0f	 cmp	 esi, 15			; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000cc	8b 75 bc	 mov	 esi, DWORD PTR _c_pvBuf$GSCopy$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 416  :         value_type* _Result = _Bx._Buf;

  000cf	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]

; 1491 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  000d2	89 45 e8	 mov	 DWORD PTR _stLine$[ebp+16], eax

; 417  :         if (_Large_mode_engaged()) {

  000d5	0f 47 cf	 cmova	 ecx, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000d8	8b 45 c8	 mov	 eax, DWORD PTR _pos$1$[ebp]
  000db	66 8b 44 06 ff	 mov	 ax, WORD PTR [esi+eax-1]
  000e0	66 89 04 11	 mov	 WORD PTR [ecx+edx], ax
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 169  : 			++pos;

  000e4	8b 45 c8	 mov	 eax, DWORD PTR _pos$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1494 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  000e7	c6 44 11 02 00	 mov	 BYTE PTR [ecx+edx+2], 0
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 169  : 			++pos;

  000ec	40		 inc	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1495 :             return *this;

  000ed	8b 75 ec	 mov	 esi, DWORD PTR _stLine$[ebp+20]
  000f0	8b 7d d8	 mov	 edi, DWORD PTR _stLine$[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 170  : 		}

  000f3	e9 b7 02 00 00	 jmp	 $LN70@Bind
$LN129@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2992 :         const size_type _Old_size = _My_data._Mysize;

  000f8	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000fd	2b c2		 sub	 eax, edx

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

  000ff	83 f8 02	 cmp	 eax, 2
  00102	0f 82 21 03 00
	00		 jb	 $LN334@Bind

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;
; 2998 :         const size_type _Old_capacity = _My_data._Myres;

  00108	8b c6		 mov	 eax, esi

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  0010a	8d 72 02	 lea	 esi, DWORD PTR [edx+2]
  0010d	83 ce 0f	 or	 esi, 15			; 0000000fH

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

  00110	89 45 cc	 mov	 DWORD PTR __Old_capacity$1$[ebp], eax

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00113	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00119	76 12		 jbe	 SHORT $LN150@Bind

; 2944 :             return _Max;

  0011b	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00120	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0012b	eb 4c		 jmp	 SHORT $LN347@Bind
$LN150@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0012d	8b c8		 mov	 ecx, eax
  0012f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00134	d1 e9		 shr	 ecx, 1
  00136	2b c1		 sub	 eax, ecx
  00138	39 45 cc	 cmp	 DWORD PTR __Old_capacity$1$[ebp], eax
  0013b	76 12		 jbe	 SHORT $LN151@Bind

; 2948 :             return _Max;

  0013d	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00142	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0014d	eb 2a		 jmp	 SHORT $LN347@Bind
$LN151@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0014f	8b 45 cc	 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]
  00152	03 c1		 add	 eax, ecx
  00154	3b f0		 cmp	 esi, eax
  00156	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  00159	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  0015c	85 c0		 test	 eax, eax
  0015e	75 04		 jne	 SHORT $LN164@Bind

; 228  :         return nullptr;

  00160	33 c9		 xor	 ecx, ecx
  00162	eb 1d		 jmp	 SHORT $LN346@Bind
$LN164@Bind:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00164	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00169	72 08		 jb	 SHORT $LN165@Bind

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00171	eb 06		 jmp	 SHORT $LN347@Bind
$LN165@Bind:

; 136  :         return ::operator new(_Bytes);

  00173	50		 push	 eax
  00174	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN347@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3005 :         _My_data._Mysize      = _New_size;

  00179	8b 55 c0	 mov	 edx, DWORD PTR __Old_size$1$[ebp]
  0017c	8b c8		 mov	 ecx, eax
  0017e	83 c4 04	 add	 esp, 4
$LN346@Bind:
  00181	8d 42 02	 lea	 eax, DWORD PTR [edx+2]
  00184	89 4d d0	 mov	 DWORD PTR $T2[ebp], ecx
  00187	89 45 e8	 mov	 DWORD PTR _stLine$[ebp+16], eax

; 3006 :         _My_data._Myres       = _New_capacity;
; 3007 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0018a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0018d	8b 4d bc	 mov	 ecx, DWORD PTR _c_pvBuf$GSCopy$1$[ebp]
  00190	89 45 c4	 mov	 DWORD PTR tv1570[ebp], eax
  00193	49		 dec	 ecx
  00194	8b 45 c8	 mov	 eax, DWORD PTR _pos$1$[ebp]
  00197	03 c1		 add	 eax, ecx
  00199	89 75 ec	 mov	 DWORD PTR _stLine$[ebp+20], esi

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

  0019c	83 7d cc 0f	 cmp	 DWORD PTR __Old_capacity$1$[ebp], 15 ; 0000000fH
  001a0	8b 4d d0	 mov	 ecx, DWORD PTR $T2[ebp]
  001a3	89 45 c0	 mov	 DWORD PTR tv1581[ebp], eax
  001a6	52		 push	 edx
  001a7	76 55		 jbe	 SHORT $LN143@Bind
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001a9	57		 push	 edi
  001aa	51		 push	 ecx
  001ab	e8 00 00 00 00	 call	 _memcpy
  001b0	8b 45 c0	 mov	 eax, DWORD PTR tv1581[ebp]
  001b3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b6	8b 4d c4	 mov	 ecx, DWORD PTR tv1570[ebp]
  001b9	66 8b 00	 mov	 ax, WORD PTR [eax]
  001bc	66 89 01	 mov	 WORD PTR [ecx], ax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001bf	8b c7		 mov	 eax, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  001c1	c6 41 02 00	 mov	 BYTE PTR [ecx+2], 0

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  001c5	8b 4d cc	 mov	 ecx, DWORD PTR __Old_capacity$1$[ebp]
  001c8	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001c9	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001cf	72 14		 jb	 SHORT $LN196@Bind

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001d1	8b 78 fc	 mov	 edi, DWORD PTR [eax-4]
  001d4	83 c1 23	 add	 ecx, 35			; 00000023H
  001d7	2b c7		 sub	 eax, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001d9	83 c0 fc	 add	 eax, -4			; fffffffcH
  001dc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001df	0f 87 49 02 00
	00		 ja	 $LN323@Bind
$LN196@Bind:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001e5	51		 push	 ecx
  001e6	57		 push	 edi
  001e7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 169  : 			++pos;

  001ec	8b 45 c8	 mov	 eax, DWORD PTR _pos$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  001ef	83 c4 08	 add	 esp, 8
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 169  : 			++pos;

  001f2	8b 7d d0	 mov	 edi, DWORD PTR $T2[ebp]
  001f5	40		 inc	 eax
  001f6	89 7d d8	 mov	 DWORD PTR _stLine$[ebp], edi

; 170  : 		}

  001f9	e9 b1 01 00 00	 jmp	 $LN70@Bind
$LN143@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001fe	8d 45 d8	 lea	 eax, DWORD PTR _stLine$[ebp]
  00201	50		 push	 eax
  00202	51		 push	 ecx
  00203	e8 00 00 00 00	 call	 _memcpy
  00208	8b 45 c0	 mov	 eax, DWORD PTR tv1581[ebp]
  0020b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020e	8b 4d c4	 mov	 ecx, DWORD PTR tv1570[ebp]
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 169  : 			++pos;

  00211	8b 7d d0	 mov	 edi, DWORD PTR $T2[ebp]
  00214	89 7d d8	 mov	 DWORD PTR _stLine$[ebp], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00217	66 8b 00	 mov	 ax, WORD PTR [eax]
  0021a	66 89 01	 mov	 WORD PTR [ecx], ax
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 169  : 			++pos;

  0021d	8b 45 c8	 mov	 eax, DWORD PTR _pos$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1504 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00220	c6 41 02 00	 mov	 BYTE PTR [ecx+2], 0
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 169  : 			++pos;

  00224	40		 inc	 eax

; 170  : 		}

  00225	e9 85 01 00 00	 jmp	 $LN70@Bind
$LN10@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2266 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0022a	8b 4d e8	 mov	 ecx, DWORD PTR _stLine$[ebp+16]
  0022d	89 4d c4	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  00230	3b ce		 cmp	 ecx, esi

; 2267 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00232	73 1c		 jae	 SHORT $LN213@Bind

; 2268 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2269 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  00234	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]

; 434  :         return _Myres > _Small_string_capacity;

  00237	83 fe 0f	 cmp	 esi, 15			; 0000000fH

; 2269 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0023a	89 45 e8	 mov	 DWORD PTR _stLine$[ebp+16], eax

; 416  :         value_type* _Result = _Bx._Buf;

  0023d	8d 45 d8	 lea	 eax, DWORD PTR _stLine$[ebp]

; 417  :         if (_Large_mode_engaged()) {

  00240	0f 47 c7	 cmova	 eax, edi

; 2271 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00243	88 14 08	 mov	 BYTE PTR [eax+ecx], dl

; 2272 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00246	c6 44 08 01 00	 mov	 BYTE PTR [eax+ecx+1], 0

; 2273 :             return;

  0024b	e9 56 01 00 00	 jmp	 $LN349@Bind
$LN213@Bind:

; 2992 :         const size_type _Old_size = _My_data._Mysize;

  00250	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00255	2b c1		 sub	 eax, ecx

; 2993 :         if (max_size() - _Old_size < _Size_increase) {

  00257	83 f8 01	 cmp	 eax, 1
  0025a	0f 82 c9 01 00
	00		 jb	 $LN334@Bind

; 2995 :         }
; 2996 : 
; 2997 :         const size_type _New_size     = _Old_size + _Size_increase;
; 2998 :         const size_type _Old_capacity = _My_data._Myres;

  00260	8b c6		 mov	 eax, esi

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00262	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  00265	83 ce 0f	 or	 esi, 15			; 0000000fH

; 2998 :         const size_type _Old_capacity = _My_data._Myres;

  00268	89 45 cc	 mov	 DWORD PTR __Old_capacity$1$[ebp], eax

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  0026b	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00271	76 12		 jbe	 SHORT $LN231@Bind

; 2944 :             return _Max;

  00273	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00278	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00283	eb 48		 jmp	 SHORT $LN351@Bind
$LN231@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00285	8b d0		 mov	 edx, eax
  00287	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0028c	d1 ea		 shr	 edx, 1
  0028e	2b c2		 sub	 eax, edx
  00290	39 45 cc	 cmp	 DWORD PTR __Old_capacity$1$[ebp], eax
  00293	76 12		 jbe	 SHORT $LN232@Bind

; 2948 :             return _Max;

  00295	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0029a	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  002a5	eb 26		 jmp	 SHORT $LN351@Bind
$LN232@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  002a7	8b 45 cc	 mov	 eax, DWORD PTR __Old_capacity$1$[ebp]
  002aa	03 c2		 add	 eax, edx
  002ac	3b f0		 cmp	 esi, eax
  002ae	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  002b1	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  002b4	85 c0		 test	 eax, eax
  002b6	74 1b		 je	 SHORT $LN350@Bind
$LN245@Bind:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  002b8	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  002bd	72 08		 jb	 SHORT $LN246@Bind

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  002bf	50		 push	 eax
  002c0	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  002c5	eb 06		 jmp	 SHORT $LN351@Bind
$LN246@Bind:

; 136  :         return ::operator new(_Bytes);

  002c7	50		 push	 eax
  002c8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN351@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3005 :         _My_data._Mysize      = _New_size;

  002cd	8b 4d c4	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  002d0	83 c4 04	 add	 esp, 4
$LN350@Bind:

; 3008 :         if (_Old_capacity > _Small_string_capacity) {

  002d3	83 7d cc 0f	 cmp	 DWORD PTR __Old_capacity$1$[ebp], 15 ; 0000000fH
  002d7	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
  002da	89 55 e8	 mov	 DWORD PTR _stLine$[ebp+16], edx
  002dd	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]
  002e0	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  002e3	89 75 ec	 mov	 DWORD PTR _stLine$[ebp+20], esi
  002e6	89 55 c4	 mov	 DWORD PTR tv1567[ebp], edx
  002e9	51		 push	 ecx
  002ea	76 4a		 jbe	 SHORT $LN224@Bind
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  002ec	57		 push	 edi
  002ed	50		 push	 eax
  002ee	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2281 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  002f3	8b 4d c4	 mov	 ecx, DWORD PTR tv1567[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  002f6	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2281 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  002f9	8a 45 d7	 mov	 al, BYTE PTR _c$1$[ebp]
  002fc	88 01		 mov	 BYTE PTR [ecx], al
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002fe	8b c7		 mov	 eax, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2282 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00300	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00304	8b 4d cc	 mov	 ecx, DWORD PTR __Old_capacity$1$[ebp]
  00307	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00308	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0030e	72 14		 jb	 SHORT $LN274@Bind

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00310	8b 78 fc	 mov	 edi, DWORD PTR [eax-4]
  00313	83 c1 23	 add	 ecx, 35			; 00000023H
  00316	2b c7		 sub	 eax, edi

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00318	83 c0 fc	 add	 eax, -4			; fffffffcH
  0031b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0031e	0f 87 0a 01 00
	00		 ja	 $LN323@Bind
$LN274@Bind:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00324	51		 push	 ecx
  00325	57		 push	 edi
  00326	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3012 :             _My_data._Bx._Ptr = _New_ptr;

  0032b	8b 7d d0	 mov	 edi, DWORD PTR $T3[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  0032e	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3012 :             _My_data._Bx._Ptr = _New_ptr;

  00331	89 7d d8	 mov	 DWORD PTR _stLine$[ebp], edi

; 3013 :         } else {

  00334	eb 76		 jmp	 SHORT $LN352@Bind
$LN224@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00336	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]
  00339	51		 push	 ecx
  0033a	50		 push	 eax
  0033b	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2281 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  00340	8b 4d c4	 mov	 ecx, DWORD PTR tv1567[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00343	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2281 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  00346	8a 45 d7	 mov	 al, BYTE PTR _c$1$[ebp]

; 3015 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00349	8b 7d d0	 mov	 edi, DWORD PTR $T3[ebp]
  0034c	89 7d d8	 mov	 DWORD PTR _stLine$[ebp], edi

; 2281 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  0034f	88 01		 mov	 BYTE PTR [ecx], al

; 2282 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00351	c6 41 01 00	 mov	 BYTE PTR [ecx+1], 0

; 3015 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00355	eb 55		 jmp	 SHORT $LN352@Bind
$LN338@Bind:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 159  : 			if (pos < bufSize)

  00357	3b 45 08	 cmp	 eax, DWORD PTR _bufSize$[ebp]
  0035a	7d 11		 jge	 SHORT $LN8@Bind

; 160  : 				if ('\n' == c_pcBuf[pos] || '\r' == c_pcBuf[pos])

  0035c	8a 0c 01	 mov	 cl, BYTE PTR [ecx+eax]
  0035f	80 f9 0a	 cmp	 cl, 10			; 0000000aH
  00362	74 05		 je	 SHORT $LN9@Bind
  00364	80 f9 0d	 cmp	 cl, 13			; 0000000dH
  00367	75 04		 jne	 SHORT $LN8@Bind
$LN9@Bind:

; 161  : 					++pos;

  00369	40		 inc	 eax
  0036a	89 45 c8	 mov	 DWORD PTR _pos$1$[ebp], eax
$LN8@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  0036d	8b 75 b8	 mov	 esi, DWORD PTR __My_data$1$[ebp]
  00370	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]
  00373	51		 push	 ecx
  00374	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00377	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0037a	74 0d		 je	 SHORT $LN41@Bind
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0037c	8b c8		 mov	 ecx, eax
  0037e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 854  :         ++_Mylast;

  00383	83 46 04 18	 add	 DWORD PTR [esi+4], 24	; 00000018H

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00387	eb 08		 jmp	 SHORT $LN40@Bind
$LN41@Bind:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00389	50		 push	 eax
  0038a	8b ce		 mov	 ecx, esi
  0038c	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
$LN40@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00391	83 7d ec 0f	 cmp	 DWORD PTR _stLine$[ebp+20], 15 ; 0000000fH

; 416  :         value_type* _Result = _Bx._Buf;

  00395	8d 45 d8	 lea	 eax, DWORD PTR _stLine$[ebp]

; 1597 :             _Mypair._Myval2._Mysize = _Count;

  00398	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _stLine$[ebp+16], 0

; 417  :         if (_Large_mode_engaged()) {

  0039f	0f 47 45 d8	 cmova	 eax, DWORD PTR _stLine$[ebp]

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  003a3	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN349@Bind:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 153  : 	while (pos < bufSize)

  003a6	8b 7d d8	 mov	 edi, DWORD PTR _stLine$[ebp]
  003a9	8b 75 ec	 mov	 esi, DWORD PTR _stLine$[ebp+20]
$LN352@Bind:
  003ac	8b 45 c8	 mov	 eax, DWORD PTR _pos$1$[ebp]
$LN70@Bind:
  003af	3b 45 08	 cmp	 eax, DWORD PTR _bufSize$[ebp]
  003b2	0f 8c d8 fc ff
	ff		 jl	 $LL2@Bind
  003b8	8b 7d b8	 mov	 edi, DWORD PTR __My_data$1$[ebp]
$LN340@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  003bb	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  003be	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]
  003c1	51		 push	 ecx
  003c2	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  003c5	74 0d		 je	 SHORT $LN289@Bind
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 732  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  003c7	8b c8		 mov	 ecx, eax
  003c9	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 854  :         ++_Mylast;

  003ce	83 47 04 18	 add	 DWORD PTR [edi+4], 24	; 00000018H

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  003d2	eb 08		 jmp	 SHORT $LN288@Bind
$LN289@Bind:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  003d4	50		 push	 eax
  003d5	8b cf		 mov	 ecx, edi
  003d7	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
$LN288@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  003dc	8b 4d ec	 mov	 ecx, DWORD PTR _stLine$[ebp+20]
  003df	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  003e2	76 28		 jbe	 SHORT $LN315@Bind
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003e4	8b 55 d8	 mov	 edx, DWORD PTR _stLine$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  003e7	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003e8	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  003ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  003f0	72 10		 jb	 SHORT $LN326@Bind

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  003f5	83 c1 23	 add	 ecx, 35			; 00000023H
  003f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  003fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  003fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00400	77 2c		 ja	 SHORT $LN323@Bind
$LN326@Bind:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00402	51		 push	 ecx
  00403	52		 push	 edx
  00404	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00409	83 c4 08	 add	 esp, 8
$LN315@Bind:
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 178  : }

  0040c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0040f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00416	59		 pop	 ecx
  00417	5f		 pop	 edi
  00418	5e		 pop	 esi
  00419	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041c	33 cd		 xor	 ecx, ebp
  0041e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00423	8b e5		 mov	 esp, ebp
  00425	5d		 pop	 ebp
  00426	c2 08 00	 ret	 8
$LN334@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2994 :             _Xlen_string(); // result too long

  00429	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN323@Bind:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0042e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN345@Bind:
  00433	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _stLine$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ENDP		; CMemoryTextFileLoader::Bind
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ??1CMemoryTextFileLoader@@UAE@XZ
_TEXT	SEGMENT
??1CMemoryTextFileLoader@@UAE@XZ PROC			; CMemoryTextFileLoader::~CMemoryTextFileLoader, COMDAT
; _this$ = ecx

; 10   : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMemoryTextFileLoader@@6B@

; 11   : }

  00006	83 c1 04	 add	 ecx, 4
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
??1CMemoryTextFileLoader@@UAE@XZ ENDP			; CMemoryTextFileLoader::~CMemoryTextFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp
;	COMDAT ??0CMemoryTextFileLoader@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMemoryTextFileLoader@@QAE@XZ PROC			; CMemoryTextFileLoader::CMemoryTextFileLoader, COMDAT
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CMemoryTextFileLoader@@6B@

; 7    : }

  0000a	8b c1		 mov	 eax, ecx
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0000f	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  00016	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  0001d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0
; File C:\Marty 5.5\Src-Client\Client\EterBase\FileLoader.cpp

; 7    : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??0CMemoryTextFileLoader@@QAE@XZ ENDP			; CMemoryTextFileLoader::CMemoryTextFileLoader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
$T1 = 12						; size = 4
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT
; _this$ = ecx

; 847  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 848  :         auto& _My_data = _Mypair._Myval2;
; 849  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 850  : 
; 851  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 852  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 853  :         } else {
; 854  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 855  :         }
; 856  : 
; 857  :         if (_Count > max_size()) {

  00005	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00010	0f 87 95 00 00
	00		 ja	 $LN40@Construct

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();
; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

  00016	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  00019	77 21		 ja	 SHORT $LN3@Construct
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0001b	56		 push	 esi
  0001c	ff 75 08	 push	 DWORD PTR __Arg$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 866  :             _My_data._Mysize = _Count;

  0001f	89 73 10	 mov	 DWORD PTR [ebx+16], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00022	53		 push	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 867  :             _My_data._Myres  = _Small_string_capacity;

  00023	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0002a	e8 00 00 00 00	 call	 _memcpy
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00032	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0
  00036	5e		 pop	 esi

; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();
; 905  :     }

  00037	5b		 pop	 ebx
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN3@Construct:
  0003c	57		 push	 edi

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  0003d	8b fe		 mov	 edi, esi
  0003f	83 cf 0f	 or	 edi, 15			; 0000000fH
  00042	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00048	76 12		 jbe	 SHORT $LN9@Construct

; 2944 :             return _Max;

  0004a	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0004f	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0005a	eb 26		 jmp	 SHORT $LN38@Construct
$LN9@Construct:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005c	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00061	3b f8		 cmp	 edi, eax
  00063	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  00066	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  00069	85 c0		 test	 eax, eax
  0006b	74 18		 je	 SHORT $LN37@Construct
$LN23@Construct:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0006d	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00072	72 08		 jb	 SHORT $LN24@Construct

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0007a	eb 06		 jmp	 SHORT $LN38@Construct
$LN24@Construct:

; 136  :         return ::operator new(_Bytes);

  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN38@Construct:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00082	83 c4 04	 add	 esp, 4
$LN37@Construct:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00085	56		 push	 esi
  00086	ff 75 08	 push	 DWORD PTR __Arg$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00089	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0008c	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0008d	89 03		 mov	 DWORD PTR [ebx], eax

; 890  : 
; 891  :         _My_data._Mysize = _Count;

  0008f	89 73 10	 mov	 DWORD PTR [ebx+16], esi

; 892  :         _My_data._Myres  = _New_capacity;

  00092	89 7b 14	 mov	 DWORD PTR [ebx+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00095	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  0009a	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000a0	5f		 pop	 edi
  000a1	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0
  000a5	5e		 pop	 esi

; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 901  :         }
; 902  : 
; 903  :         _ASAN_STRING_CREATE(*this);
; 904  :         _Proxy._Release();
; 905  :     }

  000a6	5b		 pop	 ebx
  000a7	5d		 pop	 ebp
  000a8	c2 08 00	 ret	 8
$LN40@Construct:

; 858  :             _Xlen_string(); // result too long

  000ab	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN36@Construct:
  000b0	cc		 int	 3
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 27		 jbe	 SHORT $LN19@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN30@basic_stri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN27@basic_stri

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN30@basic_stri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN19@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 1366 :     }

  00044	c3		 ret	 0
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 693  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 694  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	53		 push	 ebx
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000d	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00010	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00017	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 434  :         return _Myres > _Small_string_capacity;

  0001e	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 694  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00022	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]

; 426  :         if (_Large_mode_engaged()) {

  00025	76 05		 jbe	 SHORT $LN17@basic_stri

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	89 45 08	 mov	 DWORD PTR __Right$[ebp], eax
$LN17@basic_stri:

; 857  :         if (_Count > max_size()) {

  0002c	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00032	0f 87 8d 00 00
	00		 ja	 $LN63@basic_stri

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();
; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

  00038	83 fb 0f	 cmp	 ebx, 15			; 0000000fH
  0003b	77 18		 ja	 SHORT $LN25@basic_stri

; 866  :             _My_data._Mysize = _Count;

  0003d	89 5f 10	 mov	 DWORD PTR [edi+16], ebx

; 867  :             _My_data._Myres  = _Small_string_capacity;

  00040	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00047	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 695  :     }

  0004a	8b c7		 mov	 eax, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0004c	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 695  :     }

  0004f	5f		 pop	 edi
  00050	5b		 pop	 ebx
  00051	5d		 pop	 ebp
  00052	c2 04 00	 ret	 4
$LN25@basic_stri:
  00055	56		 push	 esi

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00056	8b f3		 mov	 esi, ebx
  00058	83 ce 0f	 or	 esi, 15			; 0000000fH
  0005b	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00061	76 12		 jbe	 SHORT $LN31@basic_stri

; 2944 :             return _Max;

  00063	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00068	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00073	eb 2a		 jmp	 SHORT $LN61@basic_stri
$LN31@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00075	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0007a	3b f0		 cmp	 esi, eax
  0007c	0f 42 f0	 cmovb	 esi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0007f	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  00082	85 c0		 test	 eax, eax
  00084	75 04		 jne	 SHORT $LN45@basic_stri

; 228  :         return nullptr;

  00086	33 c9		 xor	 ecx, ecx
  00088	eb 1a		 jmp	 SHORT $LN44@basic_stri
$LN45@basic_stri:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  0008a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0008f	72 08		 jb	 SHORT $LN46@basic_stri

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00097	eb 06		 jmp	 SHORT $LN61@basic_stri
$LN46@basic_stri:

; 136  :         return ::operator new(_Bytes);

  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN61@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0009f	8b c8		 mov	 ecx, eax
  000a1	83 c4 04	 add	 esp, 4
$LN44@basic_stri:

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  000a4	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  000a7	89 0f		 mov	 DWORD PTR [edi], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a9	50		 push	 eax
  000aa	ff 75 08	 push	 DWORD PTR __Right$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 891  :         _My_data._Mysize = _Count;

  000ad	89 5f 10	 mov	 DWORD PTR [edi+16], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b0	51		 push	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 892  :         _My_data._Myres  = _New_capacity;

  000b1	89 77 14	 mov	 DWORD PTR [edi+20], esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b4	e8 00 00 00 00	 call	 _memcpy
  000b9	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 695  :     }

  000bc	8b c7		 mov	 eax, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000be	5e		 pop	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 695  :     }

  000bf	5f		 pop	 edi
  000c0	5b		 pop	 ebx
  000c1	5d		 pop	 ebp
  000c2	c2 04 00	 ret	 4
$LN63@basic_stri:

; 858  :             _Xlen_string(); // result too long

  000c5	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN60@basic_stri:
  000ca	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 463  :         _Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 512  :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
