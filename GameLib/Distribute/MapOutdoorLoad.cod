; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\GameLib\Distribute\MapOutdoorLoad.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
PUBLIC	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?Load@CMapOutdoor@@UAE_NMMM@Z			; CMapOutdoor::Load
PUBLIC	?LoadSetting@CMapOutdoor@@QAE_NPBD@Z		; CMapOutdoor::LoadSetting
PUBLIC	?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z		; CMapOutdoor::LoadTerrain
PUBLIC	?LoadArea@CMapOutdoor@@MAE_NGGGG@Z		; CMapOutdoor::LoadArea
PUBLIC	?isTerrainLoaded@CMapOutdoor@@IAE_NGG@Z		; CMapOutdoor::isTerrainLoaded
PUBLIC	?isAreaLoaded@CMapOutdoor@@IAE_NGG@Z		; CMapOutdoor::isAreaLoaded
PUBLIC	?AssignTerrainPtr@CMapOutdoor@@IAEXXZ		; CMapOutdoor::AssignTerrainPtr
PUBLIC	?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength
PUBLIC	?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength
PUBLIC	?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ	; CMapOutdoor::LoadMonsterAreaInfo
PUBLIC	?GetEnvironmentDataName@CMapOutdoor@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CMapOutdoor::GetEnvironmentDataName
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
PUBLIC	??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEPAPAVCArea@@QAPAV2@ABQAV2@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_reallocate<CArea * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_reallocate<CTerrain * const &>
PUBLIC	??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ; std::_Copy_memmove<CArea * *,CArea * *>
PUBLIC	??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ; std::_Copy_memmove<CTerrain * *,CTerrain * *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	??_C@_06NLAJNNNM@?2cache@			; `string'
PUBLIC	??_C@_0N@NBPBKCDE@?2Setting?4txt@		; `string'
PUBLIC	??_C@_0CL@PFEFOJBM@CMapOutdoor?3?3Load?5?3?5LoadSetting@ ; `string'
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_C@_0BK@PHKPBKKC@d?3?1ymir?5work?1environment?1@ ; `string'
PUBLIC	??_C@_06MANNNLLA@?4msenv@			; `string'
PUBLIC	??_C@_08HAAOAKJA@?$CFs?2?$CF06u?2@		; `string'
PUBLIC	??_C@_0DD@GDFLJGIN@?5CMapOutdoor?3?3LoadArea?$CI?$CFd?0?5?$CFd?$CJ?5@ ; `string'
PUBLIC	??_C@_0BJ@PNPPDMHN@?$CFs?2?$CF06u?2AreaProperty?4txt@ ; `string'
PUBLIC	??_C@_0DC@PJKFCPIK@CMapOutdoor?3?3LoadTerrain?5AreaPr@ ; `string'
PUBLIC	??_C@_0L@PCFMFEAG@scripttype@			; `string'
PUBLIC	??_C@_0DK@IGMBLPHB@CMapOutdoor?3?3LoadTerrain?5AreaPr@ ; `string'
PUBLIC	??_C@_0DK@IEIHABCI@CMapOutdoor?3?3LoadTerrain?5AreaPr@ ; `string'
PUBLIC	??_C@_0N@JAFNMPED@AreaProperty@			; `string'
PUBLIC	??_C@_0DK@IFEFGLBP@CMapOutdoor?3?3LoadTerrain?5AreaPr@ ; `string'
PUBLIC	??_C@_0BD@OEBGBMHL@?$CFs?2?$CF06u?2height?4raw@	; `string'
PUBLIC	??_C@_0BB@KIEAEMGF@?$CFs?2?$CF06u?2tile?4raw@	; `string'
PUBLIC	??_C@_0BB@MGHNOCIE@?$CFs?2?$CF06u?2attr?4atr@	; `string'
PUBLIC	??_C@_0BC@COFDKBDG@?$CFs?2?$CF06u?2water?4wtr@	; `string'
PUBLIC	??_C@_0BG@JDDLCJKB@?$CFs?2?$CF06u?2shadowmap?4dds@ ; `string'
PUBLIC	??_C@_0BG@IEOOCGAN@?$CFs?2?$CF06u?2shadowmap?4raw@ ; `string'
PUBLIC	??_C@_0BE@OEFJKKPK@?$CFs?2?$CF06u?2minimap?4dds@ ; `string'
PUBLIC	??_C@_0DF@FPDAHDEG@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@ ; `string'
PUBLIC	??_C@_0DG@DLOMPGBF@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@ ; `string'
PUBLIC	??_C@_0DE@PJJDEPO@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@ ; `string'
PUBLIC	??_C@_0DI@CJHIDJBM@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@ ; `string'
PUBLIC	??_C@_0DG@BIPHGMEM@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@ ; `string'
PUBLIC	??_C@_0BN@GEPFPGEO@CMapOutdoor?3?3LoadTerrain?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0EA@IGDFIJCO@MapOutdoor?3?3LoadSetting?$CIc_szFil@ ; `string'
PUBLIC	??_C@_0EG@NNBBNFDL@MapOutdoor?3?3LoadSetting?$CIc_szFil@ ; `string'
PUBLIC	??_C@_0L@NLJHFBAM@viewradius@			; `string'
PUBLIC	??_C@_0EG@PNENCHJD@MapOutdoor?3?3LoadSetting?$CIc_szFil@ ; `string'
PUBLIC	??_C@_09HCPKDAEG@cellscale@			; `string'
PUBLIC	??_C@_0EF@BILODNMF@MapOutdoor?3?3LoadSetting?$CIc_szFil@ ; `string'
PUBLIC	??_C@_0M@MNHNKMP@heightscale@			; `string'
PUBLIC	??_C@_0EH@FNDNEACP@MapOutdoor?3?3LoadSetting?$CIc_szFil@ ; `string'
PUBLIC	??_C@_07EOGAIPJO@mapsize@			; `string'
PUBLIC	??_C@_0ED@JGKHJMHO@MapOutdoor?3?3LoadSetting?$CIc_szFil@ ; `string'
PUBLIC	??_C@_0L@FLIBEPMB@textureset@			; `string'
PUBLIC	??_C@_0EG@CGMMOJDP@MapOutdoor?3?3LoadSetting?$CIc_szFil@ ; `string'
PUBLIC	??_C@_0P@DDEPCBBP@terrainvisible@		; `string'
PUBLIC	??_C@_0L@PHDPILBM@MapSetting@			; `string'
PUBLIC	??_C@_0DP@BHJEEKBL@MapOutdoor?3?3LoadSetting?$CIc_szFil@ ; `string'
PUBLIC	??_C@_0EM@PIICKGLP@MapOutdoor?3?3LoadSetting?$CIc_szFil@ ; `string'
PUBLIC	??_C@_0N@IEEHNMJN@baseposition@			; `string'
PUBLIC	??_C@_0M@PKDGGBDB@textureset?2@			; `string'
PUBLIC	??_C@_0EG@MFMOCBKJ@MapOutdoor?3?3LoadSetting?$CIc_szFil@ ; `string'
PUBLIC	??_C@_0M@PINLHHEI@environment@			; `string'
PUBLIC	??_C@_0EN@PIOHNJHJ@CMapOutdoor?3?3LoadSetting?$CIc_szFi@ ; `string'
PUBLIC	??_C@_0N@CBKBELEM@?$CFs?2regen?4txt@		; `string'
PUBLIC	??_C@_02OJDBNLEE@?5?7@				; `string'
PUBLIC	??_C@_01GOHFPIOK@m@				; `string'
PUBLIC	??_C@_01JEJKBAGA@g@				; `string'
PUBLIC	??_C@_0FJ@GIKGLIIH@CMapOutdoorAccessor?3?3LoadMonste@ ; `string'
PUBLIC	??_C@_0FC@JEHNDEBI@CMapOutdoorAccessor?3?3LoadMonste@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	__real@3b800000
PUBLIC	__real@3e000000
PUBLIC	__real@3f800000
PUBLIC	__real@40933333
PUBLIC	__real@41800000
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_atof:PROC
EXTRN	_atol:PROC
EXTRN	__atoi64:PROC
EXTRN	_D3DXMatrixScaling@16:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?Tracef@@YAXPBDZZ:PROC				; Tracef
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	?stl_lowers@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; stl_lowers
EXTRN	?ELTimer_GetMSec@@YAKXZ:PROC			; ELTimer_GetMSec
EXTRN	??0CMemoryTextFileLoader@@QAE@XZ:PROC		; CMemoryTextFileLoader::CMemoryTextFileLoader
EXTRN	??1CMemoryTextFileLoader@@UAE@XZ:PROC		; CMemoryTextFileLoader::~CMemoryTextFileLoader
EXTRN	?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z:PROC	; CMemoryTextFileLoader::Bind
EXTRN	?GetLineCount@CMemoryTextFileLoader@@QAEKXZ:PROC ; CMemoryTextFileLoader::GetLineCount
EXTRN	?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z:PROC ; CMemoryTextFileLoader::SplitLine
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	?LoadMultipleTextData@@YA_NPBDAAV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@@Z:PROC ; LoadMultipleTextData
EXTRN	?Load@CTextureSet@@QAE_NPBDM@Z:PROC		; CTextureSet::Load
EXTRN	?SetRenderingDevice@CSpeedTreeForestDirectX8@@QAE_NPAUIDirect3DDevice8@@@Z:PROC ; CSpeedTreeForestDirectX8::SetRenderingDevice
EXTRN	?SetMapOutDoor@CArea@@QAEXPAVCMapOutdoor@@@Z:PROC ; CArea::SetMapOutDoor
EXTRN	?Load@CArea@@QAE_NPBD@Z:PROC			; CArea::Load
EXTRN	?EnablePortal@CArea@@QAEXH@Z:PROC		; CArea::EnablePortal
EXTRN	?SetCoordinate@CArea@@QAEXABG0@Z:PROC		; CArea::SetCoordinate
EXTRN	?GetCoordinate@CArea@@QAEXPAG0@Z:PROC		; CArea::GetCoordinate
EXTRN	?New@CArea@@SAPAV1@XZ:PROC			; CArea::New
EXTRN	?SetTextureSet@CTerrainImpl@@SAXPAVCTextureSet@@@Z:PROC ; CTerrainImpl::SetTextureSet
EXTRN	?LoadWaterMap@CTerrainImpl@@QAE_NPBD@Z:PROC	; CTerrainImpl::LoadWaterMap
EXTRN	?SetMapOutDoor@CTerrain@@QAEXPAVCMapOutdoor@@@Z:PROC ; CTerrain::SetMapOutDoor
EXTRN	?RAW_LoadTileMap@CTerrain@@QAE_NPBD_N@Z:PROC	; CTerrain::RAW_LoadTileMap
EXTRN	?LoadHeightMap@CTerrain@@QAE_NPBD@Z:PROC	; CTerrain::LoadHeightMap
EXTRN	?CalculateTerrainPatch@CTerrain@@QAEXXZ:PROC	; CTerrain::CalculateTerrainPatch
EXTRN	?CopySettingFromGlobalSetting@CTerrain@@QAEXXZ:PROC ; CTerrain::CopySettingFromGlobalSetting
EXTRN	?LoadAttrMap@CTerrain@@QAE_NPBD@Z:PROC		; CTerrain::LoadAttrMap
EXTRN	?LoadShadowTexture@CTerrain@@QAEXPBD@Z:PROC	; CTerrain::LoadShadowTexture
EXTRN	?LoadShadowMap@CTerrain@@QAE_NPBD@Z:PROC	; CTerrain::LoadShadowMap
EXTRN	?LoadMiniMapTexture@CTerrain@@QAEXPBD@Z:PROC	; CTerrain::LoadMiniMapTexture
EXTRN	?SetCoordinate@CTerrain@@QAEXGG@Z:PROC		; CTerrain::SetCoordinate
EXTRN	?New@CTerrain@@SAPAV1@XZ:PROC			; CTerrain::New
EXTRN	?SetMonsterCount@CMonsterAreaInfo@@QAEXK@Z:PROC	; CMonsterAreaInfo::SetMonsterCount
EXTRN	?SetMonsterDirection@CMonsterAreaInfo@@QAEXW4EMonsterDir@1@@Z:PROC ; CMonsterAreaInfo::SetMonsterDirection
EXTRN	?CreateCharacterShadowTexture@CMapOutdoor@@QAEXXZ:PROC ; CMapOutdoor::CreateCharacterShadowTexture
EXTRN	?SetTerrainCount@CMapOutdoor@@QAE_NFF@Z:PROC	; CMapOutdoor::SetTerrainCount
EXTRN	?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ:PROC ; CMapOutdoor::CreateTerrainPatchProxyList
EXTRN	?BuildQuadTree@CMapOutdoor@@IAEXXZ:PROC		; CMapOutdoor::BuildQuadTree
EXTRN	?LoadWaterTexture@CMapOutdoor@@IAEXXZ:PROC	; CMapOutdoor::LoadWaterTexture
EXTRN	?AddMonsterAreaInfo@CMapOutdoor@@QAEPAVCMonsterAreaInfo@@JJJJ@Z:PROC ; CMapOutdoor::AddMonsterAreaInfo
EXTRN	?RemoveAllMonsterAreaInfo@CMapOutdoor@@QAEXXZ:PROC ; CMapOutdoor::RemoveAllMonsterAreaInfo
EXTRN	?SetBaseXY@CMapOutdoor@@QAEXKK@Z:PROC		; CMapOutdoor::SetBaseXY
EXTRN	?__HeightCache_Init@CMapOutdoor@@AAEXXZ:PROC	; CMapOutdoor::__HeightCache_Init
EXTRN	?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z:PROC ; CEterPackManager::Get
EXTRN	?isExist@CEterPackManager@@QAE_NPBD@Z:PROC	; CEterPackManager::isExist
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_iWidth@CGraphicBase@@1HA:DWORD		; CGraphicBase::ms_iWidth
EXTRN	?ms_iHeight@CGraphicBase@@1HA:DWORD		; CGraphicBase::ms_iHeight
EXTRN	?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A:DWORD ; CGraphicBase::ms_lpd3dDevice
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A DD 01H DUP (?) ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?$TSS0@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4HA
_BSS	SEGMENT
?$TSS0@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4HA DD 01H DUP (?) ; `CMapOutdoor::Load'::`3'::$TSS0
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@40933333
CONST	SEGMENT
__real@40933333 DD 040933333r			; 4.6
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@3b800000
CONST	SEGMENT
__real@3b800000 DD 03b800000r			; 0.00390625
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@JEHNDEBI@CMapOutdoorAccessor?3?3LoadMonste@
CONST	SEGMENT
??_C@_0FC@JEHNDEBI@CMapOutdoorAccessor?3?3LoadMonste@ DB 'CMapOutdoorAcce'
	DB	'ssor::LoadMonsterAreaInfo Get MonsterInfo Data ERROR! continu'
	DB	'e....', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FJ@GIKGLIIH@CMapOutdoorAccessor?3?3LoadMonste@
CONST	SEGMENT
??_C@_0FJ@GIKGLIIH@CMapOutdoorAccessor?3?3LoadMonste@ DB 'CMapOutdoorAcce'
	DB	'ssor::LoadMonsterAreaInfo Get MonsterInfo File Format ERROR! '
	DB	'continue....', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g@
CONST	SEGMENT
??_C@_01JEJKBAGA@g@ DB 'g', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GOHFPIOK@m@
CONST	SEGMENT
??_C@_01GOHFPIOK@m@ DB 'm', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02OJDBNLEE@?5?7@
CONST	SEGMENT
??_C@_02OJDBNLEE@?5?7@ DB ' ', 09H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CBKBELEM@?$CFs?2regen?4txt@
CONST	SEGMENT
??_C@_0N@CBKBELEM@?$CFs?2regen?4txt@ DB '%s\regen.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@PIOHNJHJ@CMapOutdoor?3?3LoadSetting?$CIc_szFi@
CONST	SEGMENT
??_C@_0EN@PIOHNJHJ@CMapOutdoor?3?3LoadSetting?$CIc_szFi@ DB 'CMapOutdoor:'
	DB	':LoadSetting(c_szFileName=%s) - Failed to load environment da'
	DB	'ta', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PINLHHEI@environment@
CONST	SEGMENT
??_C@_0M@PINLHHEI@environment@ DB 'environment', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@MFMOCBKJ@MapOutdoor?3?3LoadSetting?$CIc_szFil@
CONST	SEGMENT
??_C@_0EG@MFMOCBKJ@MapOutdoor?3?3LoadSetting?$CIc_szFil@ DB 'MapOutdoor::'
	DB	'LoadSetting(c_szFileName=%s) - LOAD TEXTURE SET(%s) ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PKDGGBDB@textureset?2@
CONST	SEGMENT
??_C@_0M@PKDGGBDB@textureset?2@ DB 'textureset\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IEEHNMJN@baseposition@
CONST	SEGMENT
??_C@_0N@IEEHNMJN@baseposition@ DB 'baseposition', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EM@PIICKGLP@MapOutdoor?3?3LoadSetting?$CIc_szFil@
CONST	SEGMENT
??_C@_0EM@PIICKGLP@MapOutdoor?3?3LoadSetting?$CIc_szFil@ DB 'MapOutdoor::'
	DB	'LoadSetting(c_szFileName=%s) - VIEWRADIUS IS NOT GREATER THAN'
	DB	' 0', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@BHJEEKBL@MapOutdoor?3?3LoadSetting?$CIc_szFil@
CONST	SEGMENT
??_C@_0DP@BHJEEKBL@MapOutdoor?3?3LoadSetting?$CIc_szFil@ DB 'MapOutdoor::'
	DB	'LoadSetting(c_szFileName=%s) - Resourse Type ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PHDPILBM@MapSetting@
CONST	SEGMENT
??_C@_0L@PHDPILBM@MapSetting@ DB 'MapSetting', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DDEPCBBP@terrainvisible@
CONST	SEGMENT
??_C@_0P@DDEPCBBP@terrainvisible@ DB 'terrainvisible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@CGMMOJDP@MapOutdoor?3?3LoadSetting?$CIc_szFil@
CONST	SEGMENT
??_C@_0EG@CGMMOJDP@MapOutdoor?3?3LoadSetting?$CIc_szFil@ DB 'MapOutdoor::'
	DB	'LoadSetting(c_szFileName=%s) - FIND ''textureset'' - FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FLIBEPMB@textureset@
CONST	SEGMENT
??_C@_0L@FLIBEPMB@textureset@ DB 'textureset', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@JGKHJMHO@MapOutdoor?3?3LoadSetting?$CIc_szFil@
CONST	SEGMENT
??_C@_0ED@JGKHJMHO@MapOutdoor?3?3LoadSetting?$CIc_szFil@ DB 'MapOutdoor::'
	DB	'LoadSetting(c_szFileName=%s) - FIND ''mapsize'' - FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07EOGAIPJO@mapsize@
CONST	SEGMENT
??_C@_07EOGAIPJO@mapsize@ DB 'mapsize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EH@FNDNEACP@MapOutdoor?3?3LoadSetting?$CIc_szFil@
CONST	SEGMENT
??_C@_0EH@FNDNEACP@MapOutdoor?3?3LoadSetting?$CIc_szFil@ DB 'MapOutdoor::'
	DB	'LoadSetting(c_szFileName=%s) - FIND ''heightscale'' - FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MNHNKMP@heightscale@
CONST	SEGMENT
??_C@_0M@MNHNKMP@heightscale@ DB 'heightscale', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@BILODNMF@MapOutdoor?3?3LoadSetting?$CIc_szFil@
CONST	SEGMENT
??_C@_0EF@BILODNMF@MapOutdoor?3?3LoadSetting?$CIc_szFil@ DB 'MapOutdoor::'
	DB	'LoadSetting(c_szFileName=%s) - FIND ''cellscale'' - FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09HCPKDAEG@cellscale@
CONST	SEGMENT
??_C@_09HCPKDAEG@cellscale@ DB 'cellscale', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@PNENCHJD@MapOutdoor?3?3LoadSetting?$CIc_szFil@
CONST	SEGMENT
??_C@_0EG@PNENCHJD@MapOutdoor?3?3LoadSetting?$CIc_szFil@ DB 'MapOutdoor::'
	DB	'LoadSetting(c_szFileName=%s) - FIND ''viewradius'' - FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NLJHFBAM@viewradius@
CONST	SEGMENT
??_C@_0L@NLJHFBAM@viewradius@ DB 'viewradius', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@NNBBNFDL@MapOutdoor?3?3LoadSetting?$CIc_szFil@
CONST	SEGMENT
??_C@_0EG@NNBBNFDL@MapOutdoor?3?3LoadSetting?$CIc_szFil@ DB 'MapOutdoor::'
	DB	'LoadSetting(c_szFileName=%s) - FIND ''scripttype'' - FAILED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@IGDFIJCO@MapOutdoor?3?3LoadSetting?$CIc_szFil@
CONST	SEGMENT
??_C@_0EA@IGDFIJCO@MapOutdoor?3?3LoadSetting?$CIc_szFil@ DB 'MapOutdoor::'
	DB	'LoadSetting(c_szFileName=%s) - LoadMultipleTextData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@GEPFPGEO@CMapOutdoor?3?3LoadTerrain?5?$CFd?6@
CONST	SEGMENT
??_C@_0BN@GEPFPGEO@CMapOutdoor?3?3LoadTerrain?5?$CFd?6@ DB 'CMapOutdoor::'
	DB	'LoadTerrain %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@BIPHGMEM@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@
CONST	SEGMENT
??_C@_0DG@BIPHGMEM@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@ DB ' CM'
	DB	'apOutdoor::LoadTerrain(%d, %d) LoadShadowMap ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@CJHIDJBM@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@
CONST	SEGMENT
??_C@_0DI@CJHIDJBM@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@ DB ' CM'
	DB	'apOutdoor::LoadTerrain(%d, %d) RAW_LoadTileMap ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PJJDEPO@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@
CONST	SEGMENT
??_C@_0DE@PJJDEPO@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@ DB ' CMa'
	DB	'pOutdoor::LoadTerrain(%d, %d) LoadAttrMap ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@DLOMPGBF@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@
CONST	SEGMENT
??_C@_0DG@DLOMPGBF@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@ DB ' CM'
	DB	'apOutdoor::LoadTerrain(%d, %d) LoadHeightMap ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@FPDAHDEG@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@
CONST	SEGMENT
??_C@_0DF@FPDAHDEG@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@ DB ' CM'
	DB	'apOutdoor::LoadTerrain(%d, %d) LoadWaterMap ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OEFJKKPK@?$CFs?2?$CF06u?2minimap?4dds@
CONST	SEGMENT
??_C@_0BE@OEFJKKPK@?$CFs?2?$CF06u?2minimap?4dds@ DB '%s\%06u\minimap.dds', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IEOOCGAN@?$CFs?2?$CF06u?2shadowmap?4raw@
CONST	SEGMENT
??_C@_0BG@IEOOCGAN@?$CFs?2?$CF06u?2shadowmap?4raw@ DB '%s\%06u\shadowmap.'
	DB	'raw', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JDDLCJKB@?$CFs?2?$CF06u?2shadowmap?4dds@
CONST	SEGMENT
??_C@_0BG@JDDLCJKB@?$CFs?2?$CF06u?2shadowmap?4dds@ DB '%s\%06u\shadowmap.'
	DB	'dds', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@COFDKBDG@?$CFs?2?$CF06u?2water?4wtr@
CONST	SEGMENT
??_C@_0BC@COFDKBDG@?$CFs?2?$CF06u?2water?4wtr@ DB '%s\%06u\water.wtr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MGHNOCIE@?$CFs?2?$CF06u?2attr?4atr@
CONST	SEGMENT
??_C@_0BB@MGHNOCIE@?$CFs?2?$CF06u?2attr?4atr@ DB '%s\%06u\attr.atr', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KIEAEMGF@?$CFs?2?$CF06u?2tile?4raw@
CONST	SEGMENT
??_C@_0BB@KIEAEMGF@?$CFs?2?$CF06u?2tile?4raw@ DB '%s\%06u\tile.raw', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OEBGBMHL@?$CFs?2?$CF06u?2height?4raw@
CONST	SEGMENT
??_C@_0BD@OEBGBMHL@?$CFs?2?$CF06u?2height?4raw@ DB '%s\%06u\height.raw', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@IFEFGLBP@CMapOutdoor?3?3LoadTerrain?5AreaPr@
CONST	SEGMENT
??_C@_0DK@IFEFGLBP@CMapOutdoor?3?3LoadTerrain?5AreaPr@ DB 'CMapOutdoor::L'
	DB	'oadTerrain AreaProperty FileFormat Error 3', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JAFNMPED@AreaProperty@
CONST	SEGMENT
??_C@_0N@JAFNMPED@AreaProperty@ DB 'AreaProperty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@IEIHABCI@CMapOutdoor?3?3LoadTerrain?5AreaPr@
CONST	SEGMENT
??_C@_0DK@IEIHABCI@CMapOutdoor?3?3LoadTerrain?5AreaPr@ DB 'CMapOutdoor::L'
	DB	'oadTerrain AreaProperty FileFormat Error 2', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@IGMBLPHB@CMapOutdoor?3?3LoadTerrain?5AreaPr@
CONST	SEGMENT
??_C@_0DK@IGMBLPHB@CMapOutdoor?3?3LoadTerrain?5AreaPr@ DB 'CMapOutdoor::L'
	DB	'oadTerrain AreaProperty FileFormat Error 1', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PCFMFEAG@scripttype@
CONST	SEGMENT
??_C@_0L@PCFMFEAG@scripttype@ DB 'scripttype', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PJKFCPIK@CMapOutdoor?3?3LoadTerrain?5AreaPr@
CONST	SEGMENT
??_C@_0DC@PJKFCPIK@CMapOutdoor?3?3LoadTerrain?5AreaPr@ DB 'CMapOutdoor::L'
	DB	'oadTerrain AreaProperty Read Error', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PNPPDMHN@?$CFs?2?$CF06u?2AreaProperty?4txt@
CONST	SEGMENT
??_C@_0BJ@PNPPDMHN@?$CFs?2?$CF06u?2AreaProperty?4txt@ DB '%s\%06u\AreaPro'
	DB	'perty.txt', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GDFLJGIN@?5CMapOutdoor?3?3LoadArea?$CI?$CFd?0?5?$CFd?$CJ?5@
CONST	SEGMENT
??_C@_0DD@GDFLJGIN@?5CMapOutdoor?3?3LoadArea?$CI?$CFd?0?5?$CFd?$CJ?5@ DB ' '
	DB	'CMapOutdoor::LoadArea(%d, %d) LoadShadowMap ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HAAOAKJA@?$CFs?2?$CF06u?2@
CONST	SEGMENT
??_C@_08HAAOAKJA@?$CFs?2?$CF06u?2@ DB '%s\%06u\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06MANNNLLA@?4msenv@
CONST	SEGMENT
??_C@_06MANNNLLA@?4msenv@ DB '.msenv', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PHKPBKKC@d?3?1ymir?5work?1environment?1@
CONST	SEGMENT
??_C@_0BK@PHKPBKKC@d?3?1ymir?5work?1environment?1@ DB 'd:/ymir work/envir'
	DB	'onment/', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PFEFOJBM@CMapOutdoor?3?3Load?5?3?5LoadSetting@
CONST	SEGMENT
??_C@_0CL@PFEFOJBM@CMapOutdoor?3?3Load?5?3?5LoadSetting@ DB 'CMapOutdoor:'
	DB	':Load : LoadSetting(%s) Failed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NBPBKCDE@?2Setting?4txt@
CONST	SEGMENT
??_C@_0N@NBPBKCDE@?2Setting?4txt@ DB '\Setting.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06NLAJNNNM@?2cache@
CONST	SEGMENT
??_C@_06NLAJNNNM@?2cache@ DB '\cache', 00H		; `string'
CONST	ENDS
;	COMDAT ?s_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
_DATA	SEGMENT
?s_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; `CMapOutdoor::Load'::`3'::s_strOldPathName
	DB	19 DUP(00H)
	DD	0fH
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z$1
__ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2
__ehfuncinfo$??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2
__ehfuncinfo$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$12
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z$18
__ehfuncinfo$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$13
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$14
	DD	07H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$15
	DD	07H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$17
	DD	07H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$18
	DD	07H
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$19
	DD	0bH
	DD	FLAT:__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$22
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Load@CMapOutdoor@@UAE_NMMM@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?Load@CMapOutdoor@@UAE_NMMM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Load@CMapOutdoor@@UAE_NMMM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$4
	DD	05H
	DD	FLAT:__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$5
	DD	06H
	DD	FLAT:__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetName@CTerrain@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetName@CTerrain@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$?SetName@CTerrain@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetName@CTerrain@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CTerrain * *,CTerrain * *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CTerrain * *,CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CArea * *,CArea * *>, COMDAT

; 4526 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4527 :     auto _FirstPtr              = _To_address(_First);
; 4528 :     auto _LastPtr               = _To_address(_Last);
; 4529 :     auto _DestPtr               = _To_address(_Dest);
; 4530 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));
; 4531 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));
; 4532 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));
; 4533 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4534 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4535 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4536 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4537 :     } else {
; 4538 :         return _Dest + (_LastPtr - _FirstPtr);
; 4539 :     }
; 4540 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CArea * *,CArea * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5056 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2235 :         const value_type* _Result = _Bx._Buf;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	8b d0		 mov	 edx, eax

; 2244 :         return _BUF_SIZE <= _Myres;

  00008	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2236 :         if (_Large_string_engaged()) {

  0000c	72 02		 jb	 SHORT $LN6@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0000e	8b 10		 mov	 edx, DWORD PTR [eax]
$LN6@operator:

; 2235 :         const value_type* _Result = _Bx._Buf;

  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00013	56		 push	 esi
  00014	8b f1		 mov	 esi, ecx

; 2244 :         return _BUF_SIZE <= _Myres;

  00016	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H

; 2236 :         if (_Large_string_engaged()) {

  0001a	72 02		 jb	 SHORT $LN11@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0001c	8b 31		 mov	 esi, DWORD PTR [ecx]
$LN11@operator:

; 4626 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0001e	ff 70 10	 push	 DWORD PTR [eax+16]
  00021	52		 push	 edx
  00022	ff 71 10	 push	 DWORD PTR [ecx+16]
  00025	56		 push	 esi
  00026	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 5057 :     return _Left.compare(_Right) < 0;

  0002e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00031	5e		 pop	 esi

; 5058 : }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >, COMDAT

; 724  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  00007	8d 4e 18	 lea	 ecx, DWORD PTR [esi+24]
  0000a	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  0000f	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00012	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  00015	72 27		 jb	 SHORT $LN21@destroy
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00017	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00019	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0001a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00020	72 12		 jb	 SHORT $LN31@destroy

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00022	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00025	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00028	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00030	77 20		 ja	 SHORT $LN28@destroy

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00032	8b c2		 mov	 eax, edx
$LN31@destroy:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00034	51		 push	 ecx
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	83 c4 08	 add	 esp, 8
$LN21@destroy:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

  0003e	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00045	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004c	c6 06 00	 mov	 BYTE PTR [esi], 0
  0004f	5e		 pop	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 730  :     }

  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
$LN28@destroy:

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00052	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN42@destroy:
  00057	cc		 int	 3
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv607 = -8						; size = 4
tv590 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_reallocate<CTerrain * const &>, COMDAT
; _this$ = ecx

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 0f 01 00
	00		 je	 $LN96@Emplace_re

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 15		 jbe	 SHORT $LN12@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004a	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1967 :             return _Max; // geometric growth would overflow

  0004b	89 45 f8	 mov	 DWORD PTR tv607[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00053	83 c4 04	 add	 esp, 4
  00056	8b f8		 mov	 edi, eax
  00058	eb 47		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0005a	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

  0005d	8b cf		 mov	 ecx, edi
  0005f	3b c7		 cmp	 eax, edi
  00061	0f 43 c8	 cmovae	 ecx, eax
  00064	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  0006a	0f 87 cc 00 00
	00		 ja	 $LN97@Emplace_re

; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

  00070	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00077	89 45 f8	 mov	 DWORD PTR tv607[ebp], eax

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007f	72 0d		 jb	 SHORT $LN24@Emplace_re

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00087	83 c4 04	 add	 esp, 4
  0008a	8b f8		 mov	 edi, eax
  0008c	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

  0008e	85 c0		 test	 eax, eax
  00090	74 0d		 je	 SHORT $LN25@Emplace_re

; 87   :         return ::operator new(_Bytes);

  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00098	83 c4 04	 add	 esp, 4

; 245  :         return _Traits::_Allocate(_Bytes);

  0009b	8b f8		 mov	 edi, eax
  0009d	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

  0009f	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a1	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000a4	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 837  :         _Constructed_first = _Newvec + _Whereoff;
; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a7	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000aa	89 4d fc	 mov	 DWORD PTR tv590[ebp], ecx
  000ad	8b 00		 mov	 eax, DWORD PTR [eax]
  000af	89 01		 mov	 DWORD PTR [ecx], eax
  000b1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b6	3b d8		 cmp	 ebx, eax
  000b8	75 07		 jne	 SHORT $LN4@Emplace_re

; 845  :         } else { // provide basic guarantee

  000ba	8b 5d fc	 mov	 ebx, DWORD PTR tv590[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bd	8b d7		 mov	 edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 845  :         } else { // provide basic guarantee

  000bf	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000c1	57		 push	 edi
  000c2	53		 push	 ebx
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ; std::_Copy_memmove<CTerrain * *,CTerrain * *>
  000c9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000cc	8b cb		 mov	 ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8b 5d fc	 mov	 ebx, DWORD PTR tv590[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000d4	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:
  000d7	52		 push	 edx
  000d8	50		 push	 eax
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ; std::_Copy_memmove<CTerrain * *,CTerrain * *>

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

  000df	8b 06		 mov	 eax, DWORD PTR [esi]

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

  000e4	85 c0		 test	 eax, eax
  000e6	74 2c		 je	 SHORT $LN70@Emplace_re

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000eb	2b c8		 sub	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ed	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000f0	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f6	72 12		 jb	 SHORT $LN80@Emplace_re

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f8	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000fb	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fe	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00100	83 c0 fc	 add	 eax, -4			; fffffffcH
  00103	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00106	77 2a		 ja	 SHORT $LN77@Emplace_re

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00108	8b c2		 mov	 eax, edx
$LN80@Emplace_re:

; 265  :         ::operator delete(_Ptr, _Bytes);

  0010a	51		 push	 ecx
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00111	83 c4 08	 add	 esp, 8
$LN70@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

  00114	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00117	89 3e		 mov	 DWORD PTR [esi], edi
  00119	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 857  :         return _Newvec + _Whereoff;

  0011c	8b c3		 mov	 eax, ebx

; 2030 :         _Mylast  = _Newvec + _Newsize;

  0011e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2031 :         _Myend   = _Newvec + _Newcapacity;

  00121	8b 4d f8	 mov	 ecx, DWORD PTR tv607[ebp]
  00124	03 cf		 add	 ecx, edi

; 858  :     }

  00126	5f		 pop	 edi

; 2031 :         _Myend   = _Newvec + _Newcapacity;

  00127	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 858  :     }

  0012a	5e		 pop	 esi
  0012b	5b		 pop	 ebx
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 08 00	 ret	 8
$LN77@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00132	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN96@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 825  :             _Xlength();

  00137	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength
$LN97@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 71   :             _Throw_bad_array_new_length(); // multiply overflow

  0013c	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN94@Emplace_re:
  00141	cc		 int	 3
??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_reallocate<CTerrain * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEPAPAVCArea@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Newsize$1$ = -12					; size = 4
tv607 = -8						; size = 4
tv590 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEPAPAVCArea@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_reallocate<CArea * const &>, COMDAT
; _this$ = ecx

; 812  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 813  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 814  :         _Alty& _Al        = _Getal();
; 815  :         auto& _My_data    = _Mypair._Myval2;
; 816  :         pointer& _Myfirst = _My_data._Myfirst;
; 817  :         pointer& _Mylast  = _My_data._Mylast;
; 818  : 
; 819  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 820  : 
; 821  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00010	2b d9		 sub	 ebx, ecx

; 822  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c1		 sub	 eax, ecx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 823  : 
; 824  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 0f 01 00
	00		 je	 $LN96@Emplace_re

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 56 08	 mov	 edx, DWORD PTR [esi+8]

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b d1		 sub	 edx, ecx

; 826  :         }
; 827  : 
; 828  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 7d f4	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1879 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 fa 02	 sar	 edx, 2

; 1966 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b ca		 mov	 ecx, edx
  0003d	d1 e9		 shr	 ecx, 1
  0003f	2b c1		 sub	 eax, ecx
  00041	3b d0		 cmp	 edx, eax
  00043	76 15		 jbe	 SHORT $LN12@Emplace_re

; 1967 :             return _Max; // geometric growth would overflow

  00045	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004a	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1967 :             return _Max; // geometric growth would overflow

  0004b	89 45 f8	 mov	 DWORD PTR tv607[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0004e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00053	83 c4 04	 add	 esp, 4
  00056	8b f8		 mov	 edi, eax
  00058	eb 47		 jmp	 SHORT $LN23@Emplace_re
$LN12@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1970 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0005a	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 70   :         if (_Count > _Max_possible) {

  0005d	8b cf		 mov	 ecx, edi
  0005f	3b c7		 cmp	 eax, edi
  00061	0f 43 c8	 cmovae	 ecx, eax
  00064	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  0006a	0f 87 cc 00 00
	00		 ja	 $LN97@Emplace_re

; 72   :         }
; 73   :     }
; 74   : 
; 75   :     return _Count * _Ty_size;

  00070	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00077	89 45 f8	 mov	 DWORD PTR tv607[ebp], eax

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007a	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0007f	72 0d		 jb	 SHORT $LN24@Emplace_re

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00087	83 c4 04	 add	 esp, 4
  0008a	8b f8		 mov	 edi, eax
  0008c	eb 13		 jmp	 SHORT $LN23@Emplace_re
$LN24@Emplace_re:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

  0008e	85 c0		 test	 eax, eax
  00090	74 0d		 je	 SHORT $LN25@Emplace_re

; 87   :         return ::operator new(_Bytes);

  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00098	83 c4 04	 add	 esp, 4

; 245  :         return _Traits::_Allocate(_Bytes);

  0009b	8b f8		 mov	 edi, eax
  0009d	eb 02		 jmp	 SHORT $LN23@Emplace_re
$LN25@Emplace_re:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

  0009f	33 ff		 xor	 edi, edi
$LN23@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 836  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000a1	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000a4	8d 0c 9f	 lea	 ecx, DWORD PTR [edi+ebx*4]

; 837  :         _Constructed_first = _Newvec + _Whereoff;
; 838  : 
; 839  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000a7	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  000aa	89 4d fc	 mov	 DWORD PTR tv590[ebp], ecx
  000ad	8b 00		 mov	 eax, DWORD PTR [eax]
  000af	89 01		 mov	 DWORD PTR [ecx], eax
  000b1	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000b4	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000b6	3b d8		 cmp	 ebx, eax
  000b8	75 07		 jne	 SHORT $LN4@Emplace_re

; 845  :         } else { // provide basic guarantee

  000ba	8b 5d fc	 mov	 ebx, DWORD PTR tv590[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bd	8b d7		 mov	 edx, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 845  :         } else { // provide basic guarantee

  000bf	eb 16		 jmp	 SHORT $LN52@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000c1	57		 push	 edi
  000c2	53		 push	 ebx
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ; std::_Copy_memmove<CArea * *,CArea * *>
  000c9	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  000cc	8b cb		 mov	 ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000ce	8b 5d fc	 mov	 ebx, DWORD PTR tv590[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1939 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000d4	8d 53 04	 lea	 edx, DWORD PTR [ebx+4]
$LN52@Emplace_re:
  000d7	52		 push	 edx
  000d8	50		 push	 eax
  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ; std::_Copy_memmove<CArea * *,CArea * *>

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

  000df	8b 06		 mov	 eax, DWORD PTR [esi]

; 848  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  000e1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2023 :         if (_Myfirst) { // destroy and deallocate old array

  000e4	85 c0		 test	 eax, eax
  000e6	74 2c		 je	 SHORT $LN70@Emplace_re

; 2024 :             _Destroy_range(_Myfirst, _Mylast, _Al);
; 2025 :             _ASAN_VECTOR_REMOVE;
; 2026 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000e8	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000eb	2b c8		 sub	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ed	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000f0	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000f6	72 12		 jb	 SHORT $LN80@Emplace_re

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000f8	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000fb	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000fe	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00100	83 c0 fc	 add	 eax, -4			; fffffffcH
  00103	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00106	77 2a		 ja	 SHORT $LN77@Emplace_re

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00108	8b c2		 mov	 eax, edx
$LN80@Emplace_re:

; 265  :         ::operator delete(_Ptr, _Bytes);

  0010a	51		 push	 ecx
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00111	83 c4 08	 add	 esp, 8
$LN70@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2030 :         _Mylast  = _Newvec + _Newsize;

  00114	8b 45 f4	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  00117	89 3e		 mov	 DWORD PTR [esi], edi
  00119	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 849  :         }
; 850  :         _CATCH_ALL
; 851  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);
; 852  :         _Al.deallocate(_Newvec, _Newcapacity);
; 853  :         _RERAISE;
; 854  :         _CATCH_END
; 855  : 
; 856  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 857  :         return _Newvec + _Whereoff;

  0011c	8b c3		 mov	 eax, ebx

; 2030 :         _Mylast  = _Newvec + _Newsize;

  0011e	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2031 :         _Myend   = _Newvec + _Newcapacity;

  00121	8b 4d f8	 mov	 ecx, DWORD PTR tv607[ebp]
  00124	03 cf		 add	 ecx, edi

; 858  :     }

  00126	5f		 pop	 edi

; 2031 :         _Myend   = _Newvec + _Newcapacity;

  00127	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 858  :     }

  0012a	5e		 pop	 esi
  0012b	5b		 pop	 ebx
  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 08 00	 ret	 8
$LN77@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00132	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN96@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 825  :             _Xlength();

  00137	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength
$LN97@Emplace_re:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 71   :             _Throw_bad_array_new_length(); // multiply overflow

  0013c	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN94@Emplace_re:
  00141	cc		 int	 3
??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEPAPAVCArea@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_reallocate<CArea * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx

; 744  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00005	8b 75 0c	 mov	 esi, DWORD PTR __Rootnode$[ebp]
  00008	8b c1		 mov	 eax, ecx
  0000a	89 45 fc	 mov	 DWORD PTR _this$1$[ebp], eax
  0000d	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00011	75 34		 jne	 SHORT $LN3@Erase_tree
  00013	53		 push	 ebx
  00014	8b 5d 08	 mov	 ebx, DWORD PTR __Al$[ebp]
  00017	57		 push	 edi
$LL2@Erase_tree:

; 746  :             _Erase_tree(_Al, _Rootnode->_Right);

  00018	ff 76 08	 push	 DWORD PTR [esi+8]
  0001b	8b c8		 mov	 ecx, eax
  0001d	53		 push	 ebx
  0001e	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 754  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00023	8b fe		 mov	 edi, esi

; 755  :     _Val         = static_cast<_Other&&>(_New_val);

  00025	8b 36		 mov	 esi, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 382  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00027	8d 47 10	 lea	 eax, DWORD PTR [edi+16]
  0002a	50		 push	 eax
  0002b	53		 push	 ebx
  0002c	e8 00 00 00 00	 call	 ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

  00031	6a 34		 push	 52			; 00000034H
  00033	57		 push	 edi
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

  0003c	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 745  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  0003f	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00043	74 d3		 je	 SHORT $LL2@Erase_tree
  00045	5f		 pop	 edi
  00046	5b		 pop	 ebx
$LN3@Erase_tree:
  00047	5e		 pop	 esi

; 747  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));
; 748  :         }
; 749  :     }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx

; 1156 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN8@Alloc_cons

; 265  :         ::operator delete(_Ptr, _Bytes);

  00007	6a 34		 push	 52			; 00000034H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000f	83 c4 08	 add	 esp, 8
$LN8@Alloc_cons:

; 1157 :             _Al.deallocate(_Ptr, 1);
; 1158 :         }
; 1159 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1611 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1612 :         const auto _Scary = _Get_scary();
; 1613 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00003	8b 01		 mov	 eax, DWORD PTR [ecx]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  0000d	89 37		 mov	 DWORD PTR [edi], esi

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

  0000f	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00013	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0001a	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0001d	75 32		 jne	 SHORT $LN12@Find_lower
  0001f	53		 push	 ebx
  00020	8b 5d 0c	 mov	 ebx, DWORD PTR __Keyval$[ebp]
$LL2@Find_lower:

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00023	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00026	89 37		 mov	 DWORD PTR [edi], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

  00028	53		 push	 ebx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0002f	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1617 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00032	84 c0		 test	 al, al
  00034	74 07		 je	 SHORT $LN4@Find_lower

; 1618 :                 _Result._Location._Child = _Tree_child::_Right;
; 1619 :                 _Trynode                 = _Trynode->_Right;

  00036	8b 76 08	 mov	 esi, DWORD PTR [esi+8]
  00039	33 c0		 xor	 eax, eax

; 1620 :             } else {

  0003b	eb 0a		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1621 :                 _Result._Location._Child = _Tree_child::_Left;
; 1622 :                 _Result._Bound           = _Trynode;

  0003d	89 77 08	 mov	 DWORD PTR [edi+8], esi

; 1623 :                 _Trynode                 = _Trynode->_Left;

  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	8b 36		 mov	 esi, DWORD PTR [esi]
$LN5@Find_lower:

; 1614 :         _Nodeptr _Trynode = _Result._Location._Parent;
; 1615 :         while (!_Trynode->_Isnil) {

  00047	89 47 04	 mov	 DWORD PTR [edi+4], eax
  0004a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0004e	74 d3		 je	 SHORT $LL2@Find_lower
  00050	5b		 pop	 ebx
$LN12@Find_lower:

; 1624 :             }
; 1625 :         }
; 1626 : 
; 1627 :         return _Result;
; 1628 :     }

  00051	8b c7		 mov	 eax, edi
  00053	5f		 pop	 edi
  00054	5e		 pop	 esi
  00055	5d		 pop	 ebp
  00056	c2 08 00	 ret	 8
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 5050 : _NODISCARD bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00004	8b 75 0c	 mov	 esi, DWORD PTR __Right$[ebp]

; 5050 : _NODISCARD bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

  00007	57		 push	 edi

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00008	8b fe		 mov	 edi, esi
  0000a	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
  0000d	0f 1f 00	 npad	 3
$LL20@operator:
  00010	8a 07		 mov	 al, BYTE PTR [edi]
  00012	47		 inc	 edi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL20@operator

; 2235 :         const value_type* _Result = _Bx._Buf;

  00017	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0001a	2b f9		 sub	 edi, ecx

; 2235 :         const value_type* _Result = _Bx._Buf;

  0001c	8b ca		 mov	 ecx, edx

; 2244 :         return _BUF_SIZE <= _Myres;

  0001e	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H

; 2236 :         if (_Large_string_engaged()) {

  00022	72 02		 jb	 SHORT $LN10@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00024	8b 0a		 mov	 ecx, DWORD PTR [edx]
$LN10@operator:

; 4590 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00026	8b 52 10	 mov	 edx, DWORD PTR [edx+16]

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00029	3b d7		 cmp	 edx, edi
  0002b	75 5b		 jne	 SHORT $LN16@operator

; 383  :         return _CSTD memcmp(_First1, _First2, _Count);

  0002d	83 ea 04	 sub	 edx, 4
  00030	72 11		 jb	 SHORT $LN23@operator
$LL24@operator:
  00032	8b 01		 mov	 eax, DWORD PTR [ecx]
  00034	3b 06		 cmp	 eax, DWORD PTR [esi]
  00036	75 10		 jne	 SHORT $LN22@operator
  00038	83 c1 04	 add	 ecx, 4
  0003b	83 c6 04	 add	 esi, 4
  0003e	83 ea 04	 sub	 edx, 4
  00041	73 ef		 jae	 SHORT $LL24@operator
$LN23@operator:
  00043	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00046	74 34		 je	 SHORT $LN21@operator
$LN22@operator:
  00048	8a 01		 mov	 al, BYTE PTR [ecx]
  0004a	3a 06		 cmp	 al, BYTE PTR [esi]
  0004c	75 27		 jne	 SHORT $LN25@operator
  0004e	83 fa fd	 cmp	 edx, -3			; fffffffdH
  00051	74 29		 je	 SHORT $LN21@operator
  00053	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00056	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00059	75 1a		 jne	 SHORT $LN25@operator
  0005b	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0005e	74 1c		 je	 SHORT $LN21@operator
  00060	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00063	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00066	75 0d		 jne	 SHORT $LN25@operator
  00068	83 fa ff	 cmp	 edx, -1
  0006b	74 0f		 je	 SHORT $LN21@operator
  0006d	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  00070	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00073	74 07		 je	 SHORT $LN21@operator
$LN25@operator:
  00075	1b c0		 sbb	 eax, eax
  00077	83 c8 01	 or	 eax, 1
  0007a	eb 02		 jmp	 SHORT $LN26@operator
$LN21@operator:
  0007c	33 c0		 xor	 eax, eax
$LN26@operator:

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  0007e	85 c0		 test	 eax, eax
  00080	75 06		 jne	 SHORT $LN16@operator
  00082	5f		 pop	 edi
  00083	32 c0		 xor	 al, al

; 5051 :     return !(_Left == _Right);
; 5052 : }

  00085	5e		 pop	 esi
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
$LN16@operator:
  00088	5f		 pop	 edi

; 548  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00089	b0 01		 mov	 al, 1

; 5051 :     return !(_Left == _Right);
; 5052 : }

  0008b	5e		 pop	 esi
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT
; _this$ = ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	ff 70 04	 push	 DWORD PTR [eax+4]
  00008	56		 push	 esi
  00009	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

  0000e	6a 34		 push	 52			; 00000034H
  00010	ff 36		 push	 DWORD PTR [esi]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	83 c4 08	 add	 esp, 8
  0001a	5e		 pop	 esi
  0001b	c3		 ret	 0
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map
;	COMDAT ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Loc$2 = -36						; size = 12
$T3 = -24						; size = 8
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Keyval$ = 8						; size = 4
??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[], COMDAT
; _this$ = ecx

; 175  :     mapped_type& operator[](key_type&& _Keyval) { // find element matching _Keyval or insert value-initialized value

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	89 4d f0	 mov	 DWORD PTR _this$1$[ebp], ecx

; 198  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

  0002a	8b 7d 08	 mov	 edi, DWORD PTR __Keyval$[ebp]
  0002d	8d 45 dc	 lea	 eax, DWORD PTR __Loc$2[ebp]
  00030	57		 push	 edi
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00037	8b 75 e4	 mov	 esi, DWORD PTR __Loc$2[ebp+8]
  0003a	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0003e	75 15		 jne	 SHORT $LN4@operator
  00040	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

  00043	50		 push	 eax
  00044	57		 push	 edi
  00045	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0004a	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004d	84 c0		 test	 al, al
  0004f	0f 84 98 00 00
	00		 je	 $LN3@operator
$LN4@operator:

; 1631 :         if (max_size() == _Get_scary()->_Mysize) {

  00055	8b 45 f0	 mov	 eax, DWORD PTR _this$1$[ebp]
  00058	81 78 04 c4 4e
	ec 04		 cmp	 DWORD PTR [eax+4], 82595524 ; 04ec4ec4H
  0005f	0f 84 9e 00 00
	00		 je	 $LN133@operator
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 206  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  00065	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1144 :     _CONSTEXPR20 explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00067	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 87   :         return ::operator new(_Bytes);

  0006a	6a 34		 push	 52			; 00000034H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 785  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1151 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00073	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 0

; 87   :         return ::operator new(_Bytes);

  0007a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 212  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0007f	8b 4d f0	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00082	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

  00085	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00088	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

  0008c	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  00093	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0009a	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 212  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0009d	50		 push	 eax
  0009e	ff 75 e0	 push	 DWORD PTR __Loc$2[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000a1	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  000a5	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 212  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000aa	ff 75 dc	 push	 DWORD PTR __Loc$2[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  000ad	66 0f d6 40 20	 movq	 QWORD PTR [eax+32], xmm0

; 4821 :         _My_data._Mysize = 0;

  000b2	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

  000b9	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000c0	c6 07 00	 mov	 BYTE PTR [edi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000c3	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
  000ca	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  000d1	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 808  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  000d8	89 30		 mov	 DWORD PTR [eax], esi

; 809  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  000da	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 810  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000dd	89 70 08	 mov	 DWORD PTR [eax+8], esi

; 811  :         this->_Ptr->_Color = _Red;

  000e0	66 c7 40 0c 00
	00		 mov	 WORD PTR [eax+12], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\map

; 212  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  000e6	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
  000eb	8b f0		 mov	 esi, eax
$LN3@operator:

; 176  :         return _Try_emplace(_STD move(_Keyval)).first->_Myval.second;

  000ed	8d 46 28	 lea	 eax, DWORD PTR [esi+40]

; 177  :     }

  000f0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fa	59		 pop	 ecx
  000fb	5f		 pop	 edi
  000fc	5e		 pop	 esi
  000fd	8b e5		 mov	 esp, ebp
  000ff	5d		 pop	 ebp
  00100	c2 04 00	 ret	 4
$LN133@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1632 :             _Throw_tree_length_error();

  00103	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN131@operator:
  00108	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$2:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Head$1$ = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node, COMDAT
; _this$ = ecx

; 646  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 647  :         ++_Mysize;
; 648  :         const auto _Head  = _Myhead;
; 649  :         _Newnode->_Parent = _Loc._Parent;

  00004	8b 55 08	 mov	 edx, DWORD PTR __Loc$[ebp]
  00007	53		 push	 ebx
  00008	8b d9		 mov	 ebx, ecx
  0000a	57		 push	 edi
  0000b	8b 7d 10	 mov	 edi, DWORD PTR __Newnode$[ebp]
  0000e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00010	ff 43 04	 inc	 DWORD PTR [ebx+4]
  00013	89 45 fc	 mov	 DWORD PTR __Head$1$[ebp], eax
  00016	89 57 04	 mov	 DWORD PTR [edi+4], edx

; 650  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00019	3b d0		 cmp	 edx, eax
  0001b	75 16		 jne	 SHORT $LN5@Insert_nod

; 651  :             _Head->_Left     = _Newnode;

  0001d	89 38		 mov	 DWORD PTR [eax], edi

; 652  :             _Head->_Parent   = _Newnode;

  0001f	89 78 04	 mov	 DWORD PTR [eax+4], edi

; 653  :             _Head->_Right    = _Newnode;

  00022	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 712  :         return _Newnode;
; 713  :     }

  00025	8b c7		 mov	 eax, edi
  00027	c6 47 0c 01	 mov	 BYTE PTR [edi+12], 1
  0002b	5f		 pop	 edi
  0002c	5b		 pop	 ebx
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 0c 00	 ret	 12			; 0000000cH
$LN5@Insert_nod:

; 654  :             _Newnode->_Color = _Black; // the root is black
; 655  :             return _Newnode;
; 656  :         }
; 657  : 
; 658  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 659  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00033	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  00037	75 0d		 jne	 SHORT $LN6@Insert_nod

; 660  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 661  :             _Loc._Parent->_Right = _Newnode;

  00039	89 7a 08	 mov	 DWORD PTR [edx+8], edi

; 662  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  0003c	3b 50 08	 cmp	 edx, DWORD PTR [eax+8]
  0003f	75 0d		 jne	 SHORT $LN9@Insert_nod

; 663  :                 _Head->_Right = _Newnode;

  00041	89 78 08	 mov	 DWORD PTR [eax+8], edi

; 664  :             }
; 665  :         } else { // add to left of _Loc._Parent

  00044	eb 08		 jmp	 SHORT $LN9@Insert_nod
$LN6@Insert_nod:

; 666  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 667  :             _Loc._Parent->_Left = _Newnode;

  00046	89 3a		 mov	 DWORD PTR [edx], edi

; 668  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00048	3b 10		 cmp	 edx, DWORD PTR [eax]
  0004a	75 02		 jne	 SHORT $LN9@Insert_nod

; 669  :                 _Head->_Left = _Newnode;

  0004c	89 38		 mov	 DWORD PTR [eax], edi
$LN9@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  0004e	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  00051	8b c7		 mov	 eax, edi
  00053	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00057	0f 85 7d 01 00
	00		 jne	 $LN3@Insert_nod
  0005d	56		 push	 esi
  0005e	66 90		 npad	 2
$LL2@Insert_nod:

; 674  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  00060	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00063	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00068	3b d1		 cmp	 edx, ecx
  0006a	0f 85 aa 00 00
	00		 jne	 $LN10@Insert_nod

; 675  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  00070	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 676  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00073	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  00077	0f 84 a3 00 00
	00		 je	 $LN76@Insert_nod

; 677  :                     _Pnode->_Parent->_Color          = _Black;
; 678  :                     _Parent_sibling->_Color          = _Black;
; 679  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 680  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 681  :                 } else { // parent's sibling has red and black children
; 682  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0007d	8b 72 08	 mov	 esi, DWORD PTR [edx+8]
  00080	3b c6		 cmp	 eax, esi
  00082	75 37		 jne	 SHORT $LN51@Insert_nod

; 462  :         _Wherenode->_Right = _Pnode->_Left;

  00084	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 683  :                         _Pnode = _Pnode->_Parent;

  00086	8b c2		 mov	 eax, edx

; 462  :         _Wherenode->_Right = _Pnode->_Left;

  00088	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

  0008b	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0008d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00091	75 03		 jne	 SHORT $LN20@Insert_nod

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

  00093	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN20@Insert_nod:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

  00096	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00099	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

  0009c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0009e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000a1	75 05		 jne	 SHORT $LN21@Insert_nod

; 471  :             _Myhead->_Parent = _Pnode;

  000a3	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  000a6	eb 0e		 jmp	 SHORT $LN24@Insert_nod
$LN21@Insert_nod:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  000a8	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000ab	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000ad	75 04		 jne	 SHORT $LN23@Insert_nod

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

  000af	89 31		 mov	 DWORD PTR [ecx], esi

; 474  :         } else {

  000b1	eb 03		 jmp	 SHORT $LN24@Insert_nod
$LN23@Insert_nod:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

  000b3	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN24@Insert_nod:

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

  000b6	89 06		 mov	 DWORD PTR [esi], eax

; 479  :         _Wherenode->_Parent = _Pnode;

  000b8	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN51@Insert_nod:

; 684  :                         _Lrotate(_Pnode);
; 685  :                     }
; 686  : 
; 687  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  000bb	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000be	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 688  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000c2	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000c5	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000c8	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 689  :                     _Rrotate(_Pnode->_Parent->_Parent);

  000cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000cf	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 483  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  000d2	8b 32		 mov	 esi, DWORD PTR [edx]

; 484  :         _Wherenode->_Left = _Pnode->_Right;

  000d4	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000d7	89 0a		 mov	 DWORD PTR [edx], ecx

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

  000d9	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  000dc	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  000e0	75 03		 jne	 SHORT $LN27@Insert_nod

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

  000e2	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN27@Insert_nod:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

  000e5	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  000e8	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

  000eb	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000ed	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  000f0	75 0b		 jne	 SHORT $LN28@Insert_nod

; 493  :             _Myhead->_Parent = _Pnode;

  000f2	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  000f5	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

  000f8	e9 cc 00 00 00	 jmp	 $LN75@Insert_nod
$LN28@Insert_nod:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  000fd	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00100	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00103	75 0b		 jne	 SHORT $LN30@Insert_nod

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

  00105	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  00108	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

  0010b	e9 b9 00 00 00	 jmp	 $LN75@Insert_nod
$LN30@Insert_nod:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

  00110	89 31		 mov	 DWORD PTR [ecx], esi

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  00112	89 56 08	 mov	 DWORD PTR [esi+8], edx

; 690  :                 }
; 691  :             } else { // fixup red-red in right subtree

  00115	e9 af 00 00 00	 jmp	 $LN75@Insert_nod
$LN10@Insert_nod:

; 692  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;
; 693  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  0011a	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  0011e	75 1d		 jne	 SHORT $LN15@Insert_nod
$LN76@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00120	c6 42 0c 01	 mov	 BYTE PTR [edx+12], 1
  00124	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1
  00128	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0012b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0012e	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0
  00132	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00135	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00138	e9 8f 00 00 00	 jmp	 $LN46@Insert_nod
$LN15@Insert_nod:

; 694  :                     _Pnode->_Parent->_Color          = _Black;
; 695  :                     _Parent_sibling->_Color          = _Black;
; 696  :                     _Pnode->_Parent->_Parent->_Color = _Red;
; 697  :                     _Pnode                           = _Pnode->_Parent->_Parent;
; 698  :                 } else { // parent's sibling has red and black children
; 699  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  0013d	8b 32		 mov	 esi, DWORD PTR [edx]
  0013f	3b c6		 cmp	 eax, esi
  00141	75 3a		 jne	 SHORT $LN39@Insert_nod

; 484  :         _Wherenode->_Left = _Pnode->_Right;

  00143	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 700  :                         _Pnode = _Pnode->_Parent;

  00146	8b c2		 mov	 eax, edx

; 484  :         _Wherenode->_Left = _Pnode->_Right;

  00148	89 08		 mov	 DWORD PTR [eax], ecx

; 485  : 
; 486  :         if (!_Pnode->_Right->_Isnil) {

  0014a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0014d	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  00151	75 03		 jne	 SHORT $LN34@Insert_nod

; 487  :             _Pnode->_Right->_Parent = _Wherenode;

  00153	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN34@Insert_nod:

; 488  :         }
; 489  : 
; 490  :         _Pnode->_Parent = _Wherenode->_Parent;

  00156	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00159	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 491  : 
; 492  :         if (_Wherenode == _Myhead->_Parent) {

  0015c	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0015e	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00161	75 05		 jne	 SHORT $LN35@Insert_nod

; 493  :             _Myhead->_Parent = _Pnode;

  00163	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  00166	eb 0f		 jmp	 SHORT $LN38@Insert_nod
$LN35@Insert_nod:

; 494  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  00168	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0016b	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0016e	75 05		 jne	 SHORT $LN37@Insert_nod

; 495  :             _Wherenode->_Parent->_Right = _Pnode;

  00170	89 71 08	 mov	 DWORD PTR [ecx+8], esi

; 496  :         } else {

  00173	eb 02		 jmp	 SHORT $LN38@Insert_nod
$LN37@Insert_nod:

; 497  :             _Wherenode->_Parent->_Left = _Pnode;

  00175	89 31		 mov	 DWORD PTR [ecx], esi
$LN38@Insert_nod:

; 498  :         }
; 499  : 
; 500  :         _Pnode->_Right      = _Wherenode;

  00177	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 501  :         _Wherenode->_Parent = _Pnode;

  0017a	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN39@Insert_nod:

; 701  :                         _Rrotate(_Pnode);
; 702  :                     }
; 703  : 
; 704  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0017d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00180	c6 41 0c 01	 mov	 BYTE PTR [ecx+12], 1

; 705  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00184	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00187	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0018a	c6 41 0c 00	 mov	 BYTE PTR [ecx+12], 0

; 706  :                     _Lrotate(_Pnode->_Parent->_Parent);

  0018e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00191	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 461  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00194	8b 72 08	 mov	 esi, DWORD PTR [edx+8]

; 462  :         _Wherenode->_Right = _Pnode->_Left;

  00197	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00199	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 463  : 
; 464  :         if (!_Pnode->_Left->_Isnil) {

  0019c	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0019e	80 79 0d 00	 cmp	 BYTE PTR [ecx+13], 0
  001a2	75 03		 jne	 SHORT $LN41@Insert_nod

; 465  :             _Pnode->_Left->_Parent = _Wherenode;

  001a4	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$LN41@Insert_nod:

; 466  :         }
; 467  : 
; 468  :         _Pnode->_Parent = _Wherenode->_Parent;

  001a7	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001aa	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 469  : 
; 470  :         if (_Wherenode == _Myhead->_Parent) {

  001ad	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  001af	3b 51 04	 cmp	 edx, DWORD PTR [ecx+4]
  001b2	75 05		 jne	 SHORT $LN42@Insert_nod

; 471  :             _Myhead->_Parent = _Pnode;

  001b4	89 71 04	 mov	 DWORD PTR [ecx+4], esi
  001b7	eb 0e		 jmp	 SHORT $LN45@Insert_nod
$LN42@Insert_nod:

; 472  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  001b9	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  001bc	3b 11		 cmp	 edx, DWORD PTR [ecx]
  001be	75 04		 jne	 SHORT $LN44@Insert_nod

; 473  :             _Wherenode->_Parent->_Left = _Pnode;

  001c0	89 31		 mov	 DWORD PTR [ecx], esi

; 474  :         } else {

  001c2	eb 03		 jmp	 SHORT $LN45@Insert_nod
$LN44@Insert_nod:

; 475  :             _Wherenode->_Parent->_Right = _Pnode;

  001c4	89 71 08	 mov	 DWORD PTR [ecx+8], esi
$LN45@Insert_nod:

; 476  :         }
; 477  : 
; 478  :         _Pnode->_Left       = _Wherenode;

  001c7	89 16		 mov	 DWORD PTR [esi], edx
$LN75@Insert_nod:

; 670  :             }
; 671  :         }
; 672  : 
; 673  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  001c9	89 72 04	 mov	 DWORD PTR [edx+4], esi
$LN46@Insert_nod:
  001cc	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001cf	80 79 0c 00	 cmp	 BYTE PTR [ecx+12], 0
  001d3	0f 84 87 fe ff
	ff		 je	 $LL2@Insert_nod
  001d9	5e		 pop	 esi
$LN3@Insert_nod:

; 707  :                 }
; 708  :             }
; 709  :         }
; 710  : 
; 711  :         _Head->_Parent->_Color = _Black; // root is always black

  001da	8b 45 fc	 mov	 eax, DWORD PTR __Head$1$[ebp]
  001dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e0	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 712  :         return _Newnode;
; 713  :     }

  001e4	8b c7		 mov	 eax, edi
  001e6	5f		 pop	 edi
  001e7	5b		 pop	 ebx
  001e8	8b e5		 mov	 esp, ebp
  001ea	5d		 pop	 ebp
  001eb	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Loc$1 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find, COMDAT
; _this$ = ecx

; 1377 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00008	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000b	8d 45 f4	 lea	 eax, DWORD PTR __Loc$1[ebp]

; 1377 :     _NODISCARD iterator find(const key_type& _Keyval) {

  0000e	8b f9		 mov	 edi, ecx

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00016	8b 75 fc	 mov	 esi, DWORD PTR __Loc$1[ebp+8]
  00019	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  0001d	75 20		 jne	 SHORT $LN4@find
  0001f	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

  00022	50		 push	 eax
  00023	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00026	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0002b	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0002e	84 c0		 test	 al, al
  00030	75 0d		 jne	 SHORT $LN4@find

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00035	5f		 pop	 edi
  00036	89 30		 mov	 DWORD PTR [eax], esi

; 1378 :         return iterator(_Find(_Keyval), _Get_scary());
; 1379 :     }

  00038	5e		 pop	 esi
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
$LN4@find:

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0003f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1373 :         return _Get_scary()->_Myhead;

  00042	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00044	5f		 pop	 edi

; 1378 :         return iterator(_Find(_Keyval), _Get_scary());
; 1379 :     }

  00045	5e		 pop	 esi

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00046	89 08		 mov	 DWORD PTR [eax], ecx

; 1378 :         return iterator(_Find(_Keyval), _Get_scary());
; 1379 :     }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??__Fs_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@YAXXZ
text$yd	SEGMENT
??__Fs_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@YAXXZ PROC ; `CMapOutdoor::Load'::`3'::`dynamic atexit destructor for 's_strOldPathName'', COMDAT

; 2244 :         return _BUF_SIZE <= _Myres;

  00000	8b 0d 14 00 00
	00		 mov	 ecx, DWORD PTR ?s_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  00009	72 2f		 jb	 SHORT $LN15@dynamic
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?s_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00011	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00012	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00014	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001a	72 14		 jb	 SHORT $LN25@dynamic

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001f	83 c1 23	 add	 ecx, 35			; 00000023H
  00022	2b c2		 sub	 eax, edx

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00024	83 c0 fc	 add	 eax, -4			; fffffffcH
  00027	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002a	0f 87 00 00 00
	00		 ja	 __invalid_parameter_noinfo_noreturn
$LN25@dynamic:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00030	51		 push	 ecx
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00037	83 c4 08	 add	 esp, 8
$LN15@dynamic:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

  0003a	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?s_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00044	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?s_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?s_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00055	c3		 ret	 0
??__Fs_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@YAXXZ ENDP ; `CMapOutdoor::Load'::`3'::`dynamic atexit destructor for 's_strOldPathName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
;	COMDAT ?GetEnvironmentDataName@CMapOutdoor@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
?GetEnvironmentDataName@CMapOutdoor@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CMapOutdoor::GetEnvironmentDataName, COMDAT
; _this$ = ecx

; 72   : 	return m_envDataName;

  00000	8d 81 94 13 00
	00		 lea	 eax, DWORD PTR [ecx+5012]

; 73   : }

  00006	c3		 ret	 0
?GetEnvironmentDataName@CMapOutdoor@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CMapOutdoor::GetEnvironmentDataName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
;	COMDAT ?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ
_TEXT	SEGMENT
_textFileLoader$ = -904					; size = 16
_eMonsterDir$1$ = -888					; size = 4
_dwMonsterCount$1$ = -884				; size = 4
_this$GSCopy$1$ = -880					; size = 4
_lOriginX$1$ = -876					; size = 4
_lOriginY$1$ = -872					; size = 4
_pModelData$ = -868					; size = 4
_i$1$ = -864						; size = 4
_stTokenVector$ = -860					; size = 12
_eMonsterAreaInfoType$1$ = -848				; size = 4
tv2528 = -848						; size = 4
_dwMonsterVID$1$ = -844					; size = 4
tv2529 = -844						; size = 4
$T2 = -837						; size = 1
_File$ = -836						; size = 324
_$S3$3 = -512						; size = 24
_$S4$4 = -488						; size = 24
_$S5$5 = -464						; size = 24
_$S6$6 = -440						; size = 24
_$S7$7 = -416						; size = 24
_$S8$8 = -392						; size = 24
_$S9$9 = -368						; size = 24
_$S10$10 = -344						; size = 24
_$S11$11 = -320						; size = 24
_$S12$12 = -296						; size = 24
_c_szFileName$ = -272					; size = 256
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ PROC		; CMapOutdoor::LoadMonsterAreaInfo, COMDAT
; _this$ = ecx

; 443  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 7c 03 00
	00		 sub	 esp, 892		; 0000037cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx
  0002f	89 b5 90 fc ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], esi

; 444  : 	RemoveAllMonsterAreaInfo();

  00035	e8 00 00 00 00	 call	 ?RemoveAllMonsterAreaInfo@CMapOutdoor@@QAEXXZ ; CMapOutdoor::RemoveAllMonsterAreaInfo
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

  0003a	33 c0		 xor	 eax, eax
  0003c	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  0003f	1b c0		 sbb	 eax, eax
  00041	83 e0 18	 and	 eax, 24			; 00000018H
  00044	83 c0 08	 add	 eax, 8
  00047	03 c6		 add	 eax, esi

; 2236 :         if (_Large_string_engaged()) {

  00049	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0004d	72 02		 jb	 SHORT $LN54@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN54@LoadMonste:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 447  : 	sprintf(c_szFileName, "%s\\regen.txt", GetMapDataDirectory().c_str());

  00051	50		 push	 eax
  00052	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _c_szFileName$[ebp]
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CBKBELEM@?$CFs?2regen?4txt@
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _sprintf
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 448  : 
; 449  : 	LPCVOID pModelData;
; 450  : 	CMappedFile File;

  00066	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR _File$[ebp]
  0006c	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile

; 451  : 
; 452  : 	if (!CEterPackManager::Instance().Get(File, c_szFileName, &pModelData))

  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00077	8d 85 9c fc ff
	ff		 lea	 eax, DWORD PTR _pModelData$[ebp]
  0007d	50		 push	 eax
  0007e	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _c_szFileName$[ebp]
  00084	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008b	50		 push	 eax
  0008c	8d 85 bc fc ff
	ff		 lea	 eax, DWORD PTR _File$[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  00098	84 c0		 test	 al, al
  0009a	75 0b		 jne	 SHORT $LN5@LoadMonste
  0009c	88 85 bb fc ff
	ff		 mov	 BYTE PTR $T2[ebp], al
  000a2	e9 d7 09 00 00	 jmp	 $LN31@LoadMonste
$LN5@LoadMonste:

; 453  : 	{
; 454  : 		//TraceError(" CMapOutdoorAccessor::LoadMonsterAreaInfo Load File %s ERROR", c_szFileName);
; 455  : 		return false;
; 456  : 	}
; 457  : 
; 458  : 	CMemoryTextFileLoader textFileLoader;

  000a7	8d 8d 78 fc ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$[ebp]
  000ad	e8 00 00 00 00	 call	 ??0CMemoryTextFileLoader@@QAE@XZ ; CMemoryTextFileLoader::CMemoryTextFileLoader
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 398  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000b2	c7 85 a4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$[ebp], 0
  000bc	c7 85 a8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$[ebp+4], 0
  000c6	c7 85 ac fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVector$[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 461  : 	textFileLoader.Bind(File.Size(), pModelData);

  000d0	ff b5 9c fc ff
	ff		 push	 DWORD PTR _pModelData$[ebp]
  000d6	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR _File$[ebp]
  000dc	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000e0	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000e5	50		 push	 eax
  000e6	8d 8d 78 fc ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$[ebp]
  000ec	e8 00 00 00 00	 call	 ?Bind@CMemoryTextFileLoader@@QAEXHPBX@Z ; CMemoryTextFileLoader::Bind

; 462  : 
; 463  : 	for (DWORD i = 0; i < textFileLoader.GetLineCount(); ++i)

  000f1	33 f6		 xor	 esi, esi
  000f3	8d 8d 78 fc ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$[ebp]
  000f9	89 b5 a0 fc ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  000ff	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  00104	85 c0		 test	 eax, eax
  00106	0f 84 55 09 00
	00		 je	 $LN659@LoadMonste
  0010c	0f 1f 40 00	 npad	 4
$LL4@LoadMonste:

; 464  : 	{
; 465  : 		if (!textFileLoader.SplitLine(i, &stTokenVector))

  00110	68 00 00 00 00	 push	 OFFSET ??_C@_02OJDBNLEE@?5?7@
  00115	8d 85 a4 fc ff
	ff		 lea	 eax, DWORD PTR _stTokenVector$[ebp]
  0011b	50		 push	 eax
  0011c	56		 push	 esi
  0011d	8d 8d 78 fc ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$[ebp]
  00123	e8 00 00 00 00	 call	 ?SplitLine@CMemoryTextFileLoader@@QAE_NKPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PBD@Z ; CMemoryTextFileLoader::SplitLine
  00128	84 c0		 test	 al, al
  0012a	0f 84 12 09 00
	00		 je	 $LN2@LoadMonste

; 468  : 		stl_lowers(stTokenVector[0]);

  00130	ff b5 a4 fc ff
	ff		 push	 DWORD PTR _stTokenVector$[ebp]
  00136	e8 00 00 00 00	 call	 ?stl_lowers@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; stl_lowers
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

  0013b	8b bd a4 fc ff
	ff		 mov	 edi, DWORD PTR _stTokenVector$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 468  : 		stl_lowers(stTokenVector[0]);

  00141	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

  00144	8b cf		 mov	 ecx, edi
  00146	8b f1		 mov	 esi, ecx

; 2244 :         return _BUF_SIZE <= _Myres;

  00148	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  0014b	89 85 b4 fc ff
	ff		 mov	 DWORD PTR tv2529[ebp], eax

; 2236 :         if (_Large_string_engaged()) {

  00151	83 f8 10	 cmp	 eax, 16			; 00000010H
  00154	72 02		 jb	 SHORT $LN657@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00156	8b 0f		 mov	 ecx, DWORD PTR [edi]
$LN657@LoadMonste:

; 4648 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00158	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0015b	6a 01		 push	 1
  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_01GOHFPIOK@m@
  00162	50		 push	 eax
  00163	51		 push	 ecx
  00164	89 85 b0 fc ff
	ff		 mov	 DWORD PTR tv2528[ebp], eax
  0016a	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  0016f	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 471  : 		if (0 == stTokenVector[0].compare("m") || 0 == stTokenVector[0].compare("g"))

  00172	85 c0		 test	 eax, eax
  00174	74 2d		 je	 SHORT $LN8@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00176	83 bd b4 fc ff
	ff 10		 cmp	 DWORD PTR tv2529[ebp], 16 ; 00000010H
  0017d	72 04		 jb	 SHORT $LN656@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0017f	8b 07		 mov	 eax, DWORD PTR [edi]
  00181	eb 02		 jmp	 SHORT $LN653@LoadMonste
$LN656@LoadMonste:
  00183	8b c6		 mov	 eax, esi
$LN653@LoadMonste:

; 4648 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00185	6a 01		 push	 1
  00187	68 00 00 00 00	 push	 OFFSET ??_C@_01JEJKBAGA@g@
  0018c	ff b5 b0 fc ff
	ff		 push	 DWORD PTR tv2528[ebp]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  00198	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 471  : 		if (0 == stTokenVector[0].compare("m") || 0 == stTokenVector[0].compare("g"))

  0019b	85 c0		 test	 eax, eax
  0019d	0f 85 9f 08 00
	00		 jne	 $LN2@LoadMonste
$LN8@LoadMonste:

; 472  : 		{

  001a3	8b 8d a8 fc ff
	ff		 mov	 ecx, DWORD PTR _stTokenVector$[ebp+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001a9	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 472  : 		{

  001ae	2b ce		 sub	 ecx, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001b0	f7 e9		 imul	 ecx
  001b2	c1 fa 02	 sar	 edx, 2
  001b5	8b c2		 mov	 eax, edx
  001b7	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001ba	03 c2		 add	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 473  : 			if (stTokenVector.size() < 11)

  001bc	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  001bf	73 0a		 jae	 SHORT $LN9@LoadMonste

; 474  : 			{
; 475  : 				TraceError("CMapOutdoorAccessor::LoadMonsterAreaInfo Get MonsterInfo File Format ERROR! continue....");

  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0FJ@GIKGLIIH@CMapOutdoorAccessor?3?3LoadMonste@

; 476  : 				continue;

  001c6	e9 6f 08 00 00	 jmp	 $LN672@LoadMonste
$LN9@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  001cb	83 bd b4 fc ff
	ff 10		 cmp	 DWORD PTR tv2529[ebp], 16 ; 00000010H
  001d2	8b c6		 mov	 eax, esi
  001d4	72 02		 jb	 SHORT $LN658@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  001d6	8b 07		 mov	 eax, DWORD PTR [edi]
$LN658@LoadMonste:

; 4648 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  001d8	6a 01		 push	 1
  001da	68 00 00 00 00	 push	 OFFSET ??_C@_01GOHFPIOK@m@
  001df	ff b5 b0 fc ff
	ff		 push	 DWORD PTR tv2528[ebp]
  001e5	50		 push	 eax
  001e6	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  001eb	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 480  : 			if (0 == stTokenVector[0].compare("m"))

  001ee	85 c0		 test	 eax, eax
  001f0	75 0c		 jne	 SHORT $LN10@LoadMonste

; 481  : 			{
; 482  : 				eMonsterAreaInfoType = CMonsterAreaInfo::MONSTERAREAINFOTYPE_MONSTER;

  001f2	c7 85 b0 fc ff
	ff 01 00 00 00	 mov	 DWORD PTR _eMonsterAreaInfoType$1$[ebp], 1

; 483  : 			}

  001fc	eb 35		 jmp	 SHORT $LN13@LoadMonste
$LN10@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  001fe	83 bd b4 fc ff
	ff 10		 cmp	 DWORD PTR tv2529[ebp], 16 ; 00000010H
  00205	8b c6		 mov	 eax, esi
  00207	72 02		 jb	 SHORT $LN646@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00209	8b 07		 mov	 eax, DWORD PTR [edi]
$LN646@LoadMonste:

; 4648 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  0020b	6a 01		 push	 1
  0020d	68 00 00 00 00	 push	 OFFSET ??_C@_01JEJKBAGA@g@
  00212	ff b5 b0 fc ff
	ff		 push	 DWORD PTR tv2528[ebp]
  00218	50		 push	 eax
  00219	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  0021e	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 484  : 			else if (0 == stTokenVector[0].compare("g"))

  00221	85 c0		 test	 eax, eax
  00223	0f 85 0c 08 00
	00		 jne	 $LN12@LoadMonste

; 485  : 			{
; 486  : 				eMonsterAreaInfoType = CMonsterAreaInfo::MONSTERAREAINFOTYPE_GROUP;

  00229	c7 85 b0 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR _eMonsterAreaInfoType$1$[ebp], 2
$LN13@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  00233	83 c6 18	 add	 esi, 24			; 00000018H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00236	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  0023a	72 02		 jb	 SHORT $LN121@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0023c	8b 36		 mov	 esi, DWORD PTR [esi]
$LN121@LoadMonste:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0023e	8b ce		 mov	 ecx, esi

; 2293 :     size_type _Mysize = 0; // current length of string

  00240	c7 85 10 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S3$3[ebp+16], 0
  0024a	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  0024d	c7 85 14 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S3$3[ebp+20], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00257	0f 11 85 00 fe
	ff ff		 movups	 XMMWORD PTR _$S3$3[ebp], xmm0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0025e	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL660@LoadMonste:
  00261	8a 01		 mov	 al, BYTE PTR [ecx]
  00263	41		 inc	 ecx
  00264	84 c0		 test	 al, al
  00266	75 f9		 jne	 SHORT $LL660@LoadMonste
  00268	2b ca		 sub	 ecx, edx

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0026a	51		 push	 ecx
  0026b	56		 push	 esi
  0026c	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _$S3$3[ebp]
  00272	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  00277	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _stTokenVector$[ebp]
  0027d	83 c2 30	 add	 edx, 48			; 00000030H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 494  : 			const std::string & c_rstrOriginX	= stTokenVector[1].c_str();

  00280	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00284	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00288	72 02		 jb	 SHORT $LN142@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0028a	8b 12		 mov	 edx, DWORD PTR [edx]
$LN142@LoadMonste:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0028c	8b ca		 mov	 ecx, edx

; 2293 :     size_type _Mysize = 0; // current length of string

  0028e	c7 85 28 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S4$4[ebp+16], 0
  00298	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  0029b	c7 85 2c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S4$4[ebp+20], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  002a5	0f 11 85 18 fe
	ff ff		 movups	 XMMWORD PTR _$S4$4[ebp], xmm0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  002ac	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  002af	90		 npad	 1
$LL661@LoadMonste:
  002b0	8a 01		 mov	 al, BYTE PTR [ecx]
  002b2	41		 inc	 ecx
  002b3	84 c0		 test	 al, al
  002b5	75 f9		 jne	 SHORT $LL661@LoadMonste
  002b7	2b ce		 sub	 ecx, esi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  002b9	51		 push	 ecx
  002ba	52		 push	 edx
  002bb	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _$S4$4[ebp]
  002c1	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  002c6	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _stTokenVector$[ebp]
  002cc	83 c2 48	 add	 edx, 72			; 00000048H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 495  : 			const std::string & c_rstrOriginY	= stTokenVector[2].c_str();

  002cf	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  002d3	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  002d7	72 02		 jb	 SHORT $LN163@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  002d9	8b 12		 mov	 edx, DWORD PTR [edx]
$LN163@LoadMonste:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  002db	8b ca		 mov	 ecx, edx

; 2293 :     size_type _Mysize = 0; // current length of string

  002dd	c7 85 40 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S5$5[ebp+16], 0
  002e7	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  002ea	c7 85 44 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S5$5[ebp+20], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  002f4	0f 11 85 30 fe
	ff ff		 movups	 XMMWORD PTR _$S5$5[ebp], xmm0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  002fb	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  002fe	66 90		 npad	 2
$LL662@LoadMonste:
  00300	8a 01		 mov	 al, BYTE PTR [ecx]
  00302	41		 inc	 ecx
  00303	84 c0		 test	 al, al
  00305	75 f9		 jne	 SHORT $LL662@LoadMonste
  00307	2b ce		 sub	 ecx, esi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00309	51		 push	 ecx
  0030a	52		 push	 edx
  0030b	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR _$S5$5[ebp]
  00311	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  00316	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _stTokenVector$[ebp]
  0031c	83 c2 60	 add	 edx, 96			; 00000060H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 496  : 			const std::string & c_rstrSizeX		= stTokenVector[3].c_str();

  0031f	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00323	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00327	72 02		 jb	 SHORT $LN184@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00329	8b 12		 mov	 edx, DWORD PTR [edx]
$LN184@LoadMonste:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0032b	8b ca		 mov	 ecx, edx

; 2293 :     size_type _Mysize = 0; // current length of string

  0032d	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S6$6[ebp+16], 0
  00337	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  0033a	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S6$6[ebp+20], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00344	0f 11 85 48 fe
	ff ff		 movups	 XMMWORD PTR _$S6$6[ebp], xmm0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0034b	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0034e	66 90		 npad	 2
$LL663@LoadMonste:
  00350	8a 01		 mov	 al, BYTE PTR [ecx]
  00352	41		 inc	 ecx
  00353	84 c0		 test	 al, al
  00355	75 f9		 jne	 SHORT $LL663@LoadMonste
  00357	2b ce		 sub	 ecx, esi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00359	51		 push	 ecx
  0035a	52		 push	 edx
  0035b	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR _$S6$6[ebp]
  00361	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  00366	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _stTokenVector$[ebp]
  0036c	83 c2 78	 add	 edx, 120		; 00000078H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 497  : 			const std::string & c_rstrSizeY		= stTokenVector[4].c_str();

  0036f	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00373	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  00377	72 02		 jb	 SHORT $LN205@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00379	8b 12		 mov	 edx, DWORD PTR [edx]
$LN205@LoadMonste:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0037b	8b ca		 mov	 ecx, edx

; 2293 :     size_type _Mysize = 0; // current length of string

  0037d	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S7$7[ebp+16], 0
  00387	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  0038a	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S7$7[ebp+20], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00394	0f 11 85 60 fe
	ff ff		 movups	 XMMWORD PTR _$S7$7[ebp], xmm0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0039b	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
  0039e	66 90		 npad	 2
$LL664@LoadMonste:
  003a0	8a 01		 mov	 al, BYTE PTR [ecx]
  003a2	41		 inc	 ecx
  003a3	84 c0		 test	 al, al
  003a5	75 f9		 jne	 SHORT $LL664@LoadMonste
  003a7	2b ce		 sub	 ecx, esi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003a9	51		 push	 ecx
  003aa	52		 push	 edx
  003ab	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _$S7$7[ebp]
  003b1	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  003b6	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _stTokenVector$[ebp]
  003bc	81 c2 90 00 00
	00		 add	 edx, 144		; 00000090H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 498  : 			const std::string & c_rstrZ			= stTokenVector[5].c_str();

  003c2	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  003c6	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  003ca	72 02		 jb	 SHORT $LN226@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  003cc	8b 12		 mov	 edx, DWORD PTR [edx]
$LN226@LoadMonste:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  003ce	8b ca		 mov	 ecx, edx

; 2293 :     size_type _Mysize = 0; // current length of string

  003d0	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S8$8[ebp+16], 0
  003da	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  003dd	c7 85 8c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S8$8[ebp+20], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  003e7	0f 11 85 78 fe
	ff ff		 movups	 XMMWORD PTR _$S8$8[ebp], xmm0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  003ee	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL665@LoadMonste:
  003f1	8a 01		 mov	 al, BYTE PTR [ecx]
  003f3	41		 inc	 ecx
  003f4	84 c0		 test	 al, al
  003f6	75 f9		 jne	 SHORT $LL665@LoadMonste
  003f8	2b ce		 sub	 ecx, esi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003fa	51		 push	 ecx
  003fb	52		 push	 edx
  003fc	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR _$S8$8[ebp]
  00402	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  00407	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _stTokenVector$[ebp]
  0040d	81 c2 a8 00 00
	00		 add	 edx, 168		; 000000a8H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 499  : 			const std::string & c_rstrDir		= stTokenVector[6].c_str();

  00413	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00417	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  0041b	72 02		 jb	 SHORT $LN247@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0041d	8b 12		 mov	 edx, DWORD PTR [edx]
$LN247@LoadMonste:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0041f	8b ca		 mov	 ecx, edx

; 2293 :     size_type _Mysize = 0; // current length of string

  00421	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S9$9[ebp+16], 0
  0042b	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  0042e	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S9$9[ebp+20], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00438	0f 11 85 90 fe
	ff ff		 movups	 XMMWORD PTR _$S9$9[ebp], xmm0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0043f	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL666@LoadMonste:
  00442	8a 01		 mov	 al, BYTE PTR [ecx]
  00444	41		 inc	 ecx
  00445	84 c0		 test	 al, al
  00447	75 f9		 jne	 SHORT $LL666@LoadMonste
  00449	2b ce		 sub	 ecx, esi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0044b	51		 push	 ecx
  0044c	52		 push	 edx
  0044d	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _$S9$9[ebp]
  00453	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  00458	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _stTokenVector$[ebp]
  0045e	81 c2 c0 00 00
	00		 add	 edx, 192		; 000000c0H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 500  : 			const std::string & c_rstrTime		= stTokenVector[7].c_str();

  00464	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00468	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  0046c	72 02		 jb	 SHORT $LN268@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0046e	8b 12		 mov	 edx, DWORD PTR [edx]
$LN268@LoadMonste:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00470	8b ca		 mov	 ecx, edx

; 2293 :     size_type _Mysize = 0; // current length of string

  00472	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S10$10[ebp+16], 0
  0047c	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  0047f	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S10$10[ebp+20], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00489	0f 11 85 a8 fe
	ff ff		 movups	 XMMWORD PTR _$S10$10[ebp], xmm0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00490	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL667@LoadMonste:
  00493	8a 01		 mov	 al, BYTE PTR [ecx]
  00495	41		 inc	 ecx
  00496	84 c0		 test	 al, al
  00498	75 f9		 jne	 SHORT $LL667@LoadMonste
  0049a	2b ce		 sub	 ecx, esi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0049c	51		 push	 ecx
  0049d	52		 push	 edx
  0049e	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _$S10$10[ebp]
  004a4	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  004a9	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _stTokenVector$[ebp]
  004af	81 c2 d8 00 00
	00		 add	 edx, 216		; 000000d8H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 501  : 			const std::string & c_rstrPercent	= stTokenVector[8].c_str();

  004b5	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  004b9	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  004bd	72 02		 jb	 SHORT $LN289@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  004bf	8b 12		 mov	 edx, DWORD PTR [edx]
$LN289@LoadMonste:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  004c1	8b c2		 mov	 eax, edx

; 2293 :     size_type _Mysize = 0; // current length of string

  004c3	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S11$11[ebp+16], 0
  004cd	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  004d0	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S11$11[ebp+20], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  004da	0f 11 85 c0 fe
	ff ff		 movups	 XMMWORD PTR _$S11$11[ebp], xmm0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  004e1	8d 70 01	 lea	 esi, DWORD PTR [eax+1]
$LL668@LoadMonste:
  004e4	8a 08		 mov	 cl, BYTE PTR [eax]
  004e6	40		 inc	 eax
  004e7	84 c9		 test	 cl, cl
  004e9	75 f9		 jne	 SHORT $LL668@LoadMonste
  004eb	2b c6		 sub	 eax, esi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  004ed	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _$S11$11[ebp]
  004f3	50		 push	 eax
  004f4	52		 push	 edx
  004f5	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  004fa	8b 95 a4 fc ff
	ff		 mov	 edx, DWORD PTR _stTokenVector$[ebp]
  00500	81 c2 f0 00 00
	00		 add	 edx, 240		; 000000f0H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 502  : 			const std::string & c_rstrCount		= stTokenVector[9].c_str();

  00506	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0050a	83 7a 14 10	 cmp	 DWORD PTR [edx+20], 16	; 00000010H
  0050e	72 02		 jb	 SHORT $LN310@LoadMonste

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00510	8b 12		 mov	 edx, DWORD PTR [edx]
$LN310@LoadMonste:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00512	8b ca		 mov	 ecx, edx

; 2293 :     size_type _Mysize = 0; // current length of string

  00514	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S12$12[ebp+16], 0
  0051e	0f 57 c0	 xorps	 xmm0, xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  00521	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S12$12[ebp+20], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0052b	0f 11 85 d8 fe
	ff ff		 movups	 XMMWORD PTR _$S12$12[ebp], xmm0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00532	8d 71 01	 lea	 esi, DWORD PTR [ecx+1]
$LL669@LoadMonste:
  00535	8a 01		 mov	 al, BYTE PTR [ecx]
  00537	41		 inc	 ecx
  00538	84 c0		 test	 al, al
  0053a	75 f9		 jne	 SHORT $LL669@LoadMonste
  0053c	2b ce		 sub	 ecx, esi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0053e	51		 push	 ecx
  0053f	52		 push	 edx
  00540	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _$S12$12[ebp]
  00546	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 2236 :         if (_Large_string_engaged()) {

  0054b	83 bd 14 fe ff
	ff 10		 cmp	 DWORD PTR _$S3$3[ebp+20], 16 ; 00000010H
  00552	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _$S3$3[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 503  : 			const std::string & c_rstrVID		= stTokenVector[10].c_str();

  00558	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0055c	0f 43 85 00 fe
	ff ff		 cmovae	 eax, DWORD PTR _$S3$3[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 510  : 			lOriginX		= atol(c_rstrOriginX.c_str());

  00563	50		 push	 eax
  00564	e8 00 00 00 00	 call	 _atol
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00569	83 bd 2c fe ff
	ff 10		 cmp	 DWORD PTR _$S4$4[ebp+20], 16 ; 00000010H
  00570	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _$S4$4[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 510  : 			lOriginX		= atol(c_rstrOriginX.c_str());

  00576	89 85 94 fc ff
	ff		 mov	 DWORD PTR _lOriginX$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0057c	0f 43 8d 18 fe
	ff ff		 cmovae	 ecx, DWORD PTR _$S4$4[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 511  : 			lOriginY		= atol(c_rstrOriginY.c_str());

  00583	51		 push	 ecx
  00584	e8 00 00 00 00	 call	 _atol
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00589	83 bd 44 fe ff
	ff 10		 cmp	 DWORD PTR _$S5$5[ebp+20], 16 ; 00000010H
  00590	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR _$S5$5[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 511  : 			lOriginY		= atol(c_rstrOriginY.c_str());

  00596	89 85 98 fc ff
	ff		 mov	 DWORD PTR _lOriginY$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0059c	0f 43 8d 30 fe
	ff ff		 cmovae	 ecx, DWORD PTR _$S5$5[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 512  : 			lSizeX			= atol(c_rstrSizeX.c_str());

  005a3	51		 push	 ecx
  005a4	e8 00 00 00 00	 call	 _atol
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  005a9	83 bd 5c fe ff
	ff 10		 cmp	 DWORD PTR _$S6$6[ebp+20], 16 ; 00000010H
  005b0	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR _$S6$6[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 512  : 			lSizeX			= atol(c_rstrSizeX.c_str());

  005b6	8b f8		 mov	 edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  005b8	0f 43 8d 48 fe
	ff ff		 cmovae	 ecx, DWORD PTR _$S6$6[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 513  : 			lSizeY			= atol(c_rstrSizeY.c_str());

  005bf	51		 push	 ecx
  005c0	e8 00 00 00 00	 call	 _atol
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  005c5	83 bd 74 fe ff
	ff 10		 cmp	 DWORD PTR _$S7$7[ebp+20], 16 ; 00000010H
  005cc	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _$S7$7[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 513  : 			lSizeY			= atol(c_rstrSizeY.c_str());

  005d2	8b f0		 mov	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  005d4	0f 43 8d 60 fe
	ff ff		 cmovae	 ecx, DWORD PTR _$S7$7[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 514  : 			lZ				= atol(c_rstrZ.c_str());

  005db	51		 push	 ecx
  005dc	e8 00 00 00 00	 call	 _atol
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  005e1	83 bd 8c fe ff
	ff 10		 cmp	 DWORD PTR _$S8$8[ebp+20], 16 ; 00000010H
  005e8	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR _$S8$8[ebp]
  005ee	0f 43 85 78 fe
	ff ff		 cmovae	 eax, DWORD PTR _$S8$8[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 515  : 			eMonsterDir		= (CMonsterAreaInfo::EMonsterDir) atoi(c_rstrDir.c_str());

  005f5	50		 push	 eax
  005f6	e8 00 00 00 00	 call	 __atoi64
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  005fb	83 bd a4 fe ff
	ff 10		 cmp	 DWORD PTR _$S9$9[ebp+20], 16 ; 00000010H
  00602	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _$S9$9[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 515  : 			eMonsterDir		= (CMonsterAreaInfo::EMonsterDir) atoi(c_rstrDir.c_str());

  00608	89 85 88 fc ff
	ff		 mov	 DWORD PTR _eMonsterDir$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0060e	0f 43 8d 90 fe
	ff ff		 cmovae	 ecx, DWORD PTR _$S9$9[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 516  : 			lTime			= atol(c_rstrTime.c_str());

  00615	51		 push	 ecx
  00616	e8 00 00 00 00	 call	 _atol
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0061b	83 bd bc fe ff
	ff 10		 cmp	 DWORD PTR _$S10$10[ebp+20], 16 ; 00000010H
  00622	8d 85 a8 fe ff
	ff		 lea	 eax, DWORD PTR _$S10$10[ebp]
  00628	0f 43 85 a8 fe
	ff ff		 cmovae	 eax, DWORD PTR _$S10$10[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 517  : 			lPercent		= atol(c_rstrPercent.c_str());

  0062f	50		 push	 eax
  00630	e8 00 00 00 00	 call	 _atol
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00635	83 bd d4 fe ff
	ff 10		 cmp	 DWORD PTR _$S11$11[ebp+20], 16 ; 00000010H
  0063c	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR _$S11$11[ebp]
  00642	0f 43 85 c0 fe
	ff ff		 cmovae	 eax, DWORD PTR _$S11$11[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 518  : 			dwMonsterCount	= (DWORD) atoi(c_rstrCount.c_str());

  00649	50		 push	 eax
  0064a	e8 00 00 00 00	 call	 __atoi64
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0064f	83 bd ec fe ff
	ff 10		 cmp	 DWORD PTR _$S12$12[ebp+20], 16 ; 00000010H
  00656	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _$S12$12[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 518  : 			dwMonsterCount	= (DWORD) atoi(c_rstrCount.c_str());

  0065c	89 85 8c fc ff
	ff		 mov	 DWORD PTR _dwMonsterCount$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00662	0f 43 8d d8 fe
	ff ff		 cmovae	 ecx, DWORD PTR _$S12$12[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 519  : 			dwMonsterVID	= (DWORD) atoi(c_rstrVID.c_str());

  00669	51		 push	 ecx
  0066a	e8 00 00 00 00	 call	 __atoi64

; 520  : 
; 521  : //			lOriginX -= m_dwBaseX / 100;
; 522  : //			lOriginY -= m_dwBaseY / 100;
; 523  : 
; 524  : 			CMonsterAreaInfo * pMonsterAreaInfo = AddMonsterAreaInfo(lOriginX, lOriginY, lSizeX, lSizeY);

  0066f	8b 8d 90 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  00675	83 c4 28	 add	 esp, 40			; 00000028H
  00678	89 85 b4 fc ff
	ff		 mov	 DWORD PTR _dwMonsterVID$1$[ebp], eax
  0067e	56		 push	 esi
  0067f	57		 push	 edi
  00680	ff b5 98 fc ff
	ff		 push	 DWORD PTR _lOriginY$1$[ebp]
  00686	ff b5 94 fc ff
	ff		 push	 DWORD PTR _lOriginX$1$[ebp]
  0068c	e8 00 00 00 00	 call	 ?AddMonsterAreaInfo@CMapOutdoor@@QAEPAVCMonsterAreaInfo@@JJJJ@Z ; CMapOutdoor::AddMonsterAreaInfo
  00691	8b f0		 mov	 esi, eax

; 525  : 			pMonsterAreaInfo->SetMonsterAreaInfoType(eMonsterAreaInfoType);

  00693	8b 85 b0 fc ff
	ff		 mov	 eax, DWORD PTR _eMonsterAreaInfoType$1$[ebp]
  00699	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 526  : 			if (CMonsterAreaInfo::MONSTERAREAINFOTYPE_MONSTER == eMonsterAreaInfoType)

  0069c	83 f8 01	 cmp	 eax, 1
  0069f	75 0b		 jne	 SHORT $LN14@LoadMonste

; 527  : 				pMonsterAreaInfo->SetMonsterVID(dwMonsterVID);

  006a1	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _dwMonsterVID$1$[ebp]
  006a7	89 46 40	 mov	 DWORD PTR [esi+64], eax
  006aa	eb 0e		 jmp	 SHORT $LN16@LoadMonste
$LN14@LoadMonste:

; 528  : 			else if (CMonsterAreaInfo::MONSTERAREAINFOTYPE_GROUP == eMonsterAreaInfoType)

  006ac	83 f8 02	 cmp	 eax, 2
  006af	75 09		 jne	 SHORT $LN16@LoadMonste

; 529  : 				pMonsterAreaInfo->SetMonsterGroupID(dwMonsterVID);

  006b1	8b 85 b4 fc ff
	ff		 mov	 eax, DWORD PTR _dwMonsterVID$1$[ebp]
  006b7	89 46 08	 mov	 DWORD PTR [esi+8], eax
$LN16@LoadMonste:

; 530  : 			pMonsterAreaInfo->SetMonsterCount(dwMonsterCount);

  006ba	ff b5 8c fc ff
	ff		 push	 DWORD PTR _dwMonsterCount$1$[ebp]
  006c0	8b ce		 mov	 ecx, esi
  006c2	e8 00 00 00 00	 call	 ?SetMonsterCount@CMonsterAreaInfo@@QAEXK@Z ; CMonsterAreaInfo::SetMonsterCount

; 531  : 			pMonsterAreaInfo->SetMonsterDirection(eMonsterDir);

  006c7	ff b5 88 fc ff
	ff		 push	 DWORD PTR _eMonsterDir$1$[ebp]
  006cd	8b ce		 mov	 ecx, esi
  006cf	e8 00 00 00 00	 call	 ?SetMonsterDirection@CMonsterAreaInfo@@QAEXW4EMonsterDir@1@@Z ; CMonsterAreaInfo::SetMonsterDirection
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  006d4	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR _$S12$12[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 532  : 		}

  006da	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  006de	83 f9 10	 cmp	 ecx, 16			; 00000010H
  006e1	72 2f		 jb	 SHORT $LN401@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006e3	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _$S12$12[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  006e9	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006ea	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  006ec	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  006f2	72 14		 jb	 SHORT $LN411@LoadMonste

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  006f4	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  006f7	83 c1 23	 add	 ecx, 35			; 00000023H
  006fa	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  006fc	83 c0 fc	 add	 eax, -4			; fffffffcH
  006ff	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00702	0f 87 a2 03 00
	00		 ja	 $LN631@LoadMonste
$LN411@LoadMonste:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00708	51		 push	 ecx
  00709	52		 push	 edx
  0070a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0070f	83 c4 08	 add	 esp, 8
$LN401@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00712	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _$S11$11[ebp+20]

; 4841 :         _My_data._Mysize = 0;

  00718	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S12$12[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00722	c7 85 ec fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S12$12[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0072c	c6 85 d8 fe ff
	ff 00		 mov	 BYTE PTR _$S12$12[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 532  : 		}

  00733	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00737	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0073a	72 2f		 jb	 SHORT $LN428@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0073c	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR _$S11$11[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00742	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00743	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00745	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0074b	72 14		 jb	 SHORT $LN438@LoadMonste

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0074d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00750	83 c1 23	 add	 ecx, 35			; 00000023H
  00753	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00755	83 c0 fc	 add	 eax, -4			; fffffffcH
  00758	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0075b	0f 87 49 03 00
	00		 ja	 $LN631@LoadMonste
$LN438@LoadMonste:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00761	51		 push	 ecx
  00762	52		 push	 edx
  00763	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00768	83 c4 08	 add	 esp, 8
$LN428@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  0076b	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR _$S10$10[ebp+20]

; 4841 :         _My_data._Mysize = 0;

  00771	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S11$11[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  0077b	c7 85 d4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S11$11[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00785	c6 85 c0 fe ff
	ff 00		 mov	 BYTE PTR _$S11$11[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 532  : 		}

  0078c	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00790	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00793	72 2f		 jb	 SHORT $LN100@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00795	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR _$S10$10[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0079b	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0079c	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0079e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  007a4	72 14		 jb	 SHORT $LN110@LoadMonste

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  007a6	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  007a9	83 c1 23	 add	 ecx, 35			; 00000023H
  007ac	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  007ae	83 c0 fc	 add	 eax, -4			; fffffffcH
  007b1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  007b4	0f 87 f0 02 00
	00		 ja	 $LN631@LoadMonste
$LN110@LoadMonste:

; 265  :         ::operator delete(_Ptr, _Bytes);

  007ba	51		 push	 ecx
  007bb	52		 push	 edx
  007bc	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  007c1	83 c4 08	 add	 esp, 8
$LN100@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  007c4	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _$S9$9[ebp+20]

; 4841 :         _My_data._Mysize = 0;

  007ca	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S10$10[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  007d4	c7 85 bc fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S10$10[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  007de	c6 85 a8 fe ff
	ff 00		 mov	 BYTE PTR _$S10$10[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 532  : 		}

  007e5	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  007e9	83 f9 10	 cmp	 ecx, 16			; 00000010H
  007ec	72 2f		 jb	 SHORT $LN462@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007ee	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR _$S9$9[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  007f4	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007f5	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  007f7	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  007fd	72 14		 jb	 SHORT $LN472@LoadMonste

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  007ff	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00802	83 c1 23	 add	 ecx, 35			; 00000023H
  00805	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00807	83 c0 fc	 add	 eax, -4			; fffffffcH
  0080a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0080d	0f 87 97 02 00
	00		 ja	 $LN631@LoadMonste
$LN472@LoadMonste:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00813	51		 push	 ecx
  00814	52		 push	 edx
  00815	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0081a	83 c4 08	 add	 esp, 8
$LN462@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  0081d	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR _$S8$8[ebp+20]

; 4841 :         _My_data._Mysize = 0;

  00823	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S9$9[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  0082d	c7 85 a4 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S9$9[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00837	c6 85 90 fe ff
	ff 00		 mov	 BYTE PTR _$S9$9[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 532  : 		}

  0083e	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00842	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00845	72 2f		 jb	 SHORT $LN489@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00847	8b 95 78 fe ff
	ff		 mov	 edx, DWORD PTR _$S8$8[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0084d	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0084e	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00850	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00856	72 14		 jb	 SHORT $LN499@LoadMonste

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00858	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0085b	83 c1 23	 add	 ecx, 35			; 00000023H
  0085e	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00860	83 c0 fc	 add	 eax, -4			; fffffffcH
  00863	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00866	0f 87 3e 02 00
	00		 ja	 $LN631@LoadMonste
$LN499@LoadMonste:

; 265  :         ::operator delete(_Ptr, _Bytes);

  0086c	51		 push	 ecx
  0086d	52		 push	 edx
  0086e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00873	83 c4 08	 add	 esp, 8
$LN489@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00876	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR _$S7$7[ebp+20]

; 4841 :         _My_data._Mysize = 0;

  0087c	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S8$8[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00886	c7 85 8c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S8$8[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00890	c6 85 78 fe ff
	ff 00		 mov	 BYTE PTR _$S8$8[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 532  : 		}

  00897	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  0089b	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0089e	72 2f		 jb	 SHORT $LN516@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008a0	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR _$S7$7[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  008a6	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008a7	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  008a9	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  008af	72 14		 jb	 SHORT $LN526@LoadMonste

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  008b1	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  008b4	83 c1 23	 add	 ecx, 35			; 00000023H
  008b7	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  008b9	83 c0 fc	 add	 eax, -4			; fffffffcH
  008bc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008bf	0f 87 e5 01 00
	00		 ja	 $LN631@LoadMonste
$LN526@LoadMonste:

; 265  :         ::operator delete(_Ptr, _Bytes);

  008c5	51		 push	 ecx
  008c6	52		 push	 edx
  008c7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  008cc	83 c4 08	 add	 esp, 8
$LN516@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  008cf	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR _$S6$6[ebp+20]

; 4841 :         _My_data._Mysize = 0;

  008d5	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S7$7[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  008df	c7 85 74 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S7$7[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  008e9	c6 85 60 fe ff
	ff 00		 mov	 BYTE PTR _$S7$7[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 532  : 		}

  008f0	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  008f4	83 f9 10	 cmp	 ecx, 16			; 00000010H
  008f7	72 2f		 jb	 SHORT $LN543@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008f9	8b 95 48 fe ff
	ff		 mov	 edx, DWORD PTR _$S6$6[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  008ff	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00900	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00902	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00908	72 14		 jb	 SHORT $LN553@LoadMonste

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0090a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0090d	83 c1 23	 add	 ecx, 35			; 00000023H
  00910	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00912	83 c0 fc	 add	 eax, -4			; fffffffcH
  00915	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00918	0f 87 8c 01 00
	00		 ja	 $LN631@LoadMonste
$LN553@LoadMonste:

; 265  :         ::operator delete(_Ptr, _Bytes);

  0091e	51		 push	 ecx
  0091f	52		 push	 edx
  00920	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00925	83 c4 08	 add	 esp, 8
$LN543@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00928	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR _$S5$5[ebp+20]

; 4841 :         _My_data._Mysize = 0;

  0092e	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S6$6[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00938	c7 85 5c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S6$6[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00942	c6 85 48 fe ff
	ff 00		 mov	 BYTE PTR _$S6$6[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 532  : 		}

  00949	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  0094d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00950	72 2f		 jb	 SHORT $LN570@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00952	8b 95 30 fe ff
	ff		 mov	 edx, DWORD PTR _$S5$5[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00958	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00959	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0095b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00961	72 14		 jb	 SHORT $LN580@LoadMonste

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00963	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00966	83 c1 23	 add	 ecx, 35			; 00000023H
  00969	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0096b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0096e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00971	0f 87 33 01 00
	00		 ja	 $LN631@LoadMonste
$LN580@LoadMonste:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00977	51		 push	 ecx
  00978	52		 push	 edx
  00979	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0097e	83 c4 08	 add	 esp, 8
$LN570@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00981	8b 8d 2c fe ff
	ff		 mov	 ecx, DWORD PTR _$S4$4[ebp+20]

; 4841 :         _My_data._Mysize = 0;

  00987	c7 85 40 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S5$5[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00991	c7 85 44 fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S5$5[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0099b	c6 85 30 fe ff
	ff 00		 mov	 BYTE PTR _$S5$5[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 532  : 		}

  009a2	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  009a6	83 f9 10	 cmp	 ecx, 16			; 00000010H
  009a9	72 2f		 jb	 SHORT $LN597@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009ab	8b 95 18 fe ff
	ff		 mov	 edx, DWORD PTR _$S4$4[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  009b1	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009b2	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  009b4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  009ba	72 14		 jb	 SHORT $LN607@LoadMonste

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009bc	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  009bf	83 c1 23	 add	 ecx, 35			; 00000023H
  009c2	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009c4	83 c0 fc	 add	 eax, -4			; fffffffcH
  009c7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009ca	0f 87 da 00 00
	00		 ja	 $LN631@LoadMonste
$LN607@LoadMonste:

; 265  :         ::operator delete(_Ptr, _Bytes);

  009d0	51		 push	 ecx
  009d1	52		 push	 edx
  009d2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009d7	83 c4 08	 add	 esp, 8
$LN597@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  009da	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR _$S3$3[ebp+20]

; 4841 :         _My_data._Mysize = 0;

  009e0	c7 85 28 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _$S4$4[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  009ea	c7 85 2c fe ff
	ff 0f 00 00 00	 mov	 DWORD PTR _$S4$4[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  009f4	c6 85 18 fe ff
	ff 00		 mov	 BYTE PTR _$S4$4[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 532  : 		}

  009fb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  009ff	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  00a02	72 3e		 jb	 SHORT $LN2@LoadMonste
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a04	8b 95 00 fe ff
	ff		 mov	 edx, DWORD PTR _$S3$3[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00a0a	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a0b	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00a0d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00a13	72 14		 jb	 SHORT $LN634@LoadMonste

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a15	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00a18	83 c1 23	 add	 ecx, 35			; 00000023H
  00a1b	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a1d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00a20	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a23	0f 87 81 00 00
	00		 ja	 $LN631@LoadMonste
$LN634@LoadMonste:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00a29	51		 push	 ecx
  00a2a	52		 push	 edx
  00a2b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a30	83 c4 08	 add	 esp, 8
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 533  : 	}

  00a33	eb 0d		 jmp	 SHORT $LN2@LoadMonste
$LN12@LoadMonste:

; 487  : 			}
; 488  : 			else
; 489  : 			{
; 490  : 				TraceError("CMapOutdoorAccessor::LoadMonsterAreaInfo Get MonsterInfo Data ERROR! continue....");

  00a35	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@JEHNDEBI@CMapOutdoorAccessor?3?3LoadMonste@
$LN672@LoadMonste:

; 462  : 
; 463  : 	for (DWORD i = 0; i < textFileLoader.GetLineCount(); ++i)

  00a3a	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00a3f	83 c4 04	 add	 esp, 4
$LN2@LoadMonste:
  00a42	ff 85 a0 fc ff
	ff		 inc	 DWORD PTR _i$1$[ebp]
  00a48	8d 8d 78 fc ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$[ebp]
  00a4e	e8 00 00 00 00	 call	 ?GetLineCount@CMemoryTextFileLoader@@QAEKXZ ; CMemoryTextFileLoader::GetLineCount
  00a53	8b b5 a0 fc ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
  00a59	3b f0		 cmp	 esi, eax
  00a5b	0f 82 af f6 ff
	ff		 jb	 $LL4@LoadMonste
$LN659@LoadMonste:

; 534  : 
; 535  : 	return true;

  00a61	8d 8d a4 fc ff
	ff		 lea	 ecx, DWORD PTR _stTokenVector$[ebp]
  00a67	c6 85 bb fc ff
	ff 01		 mov	 BYTE PTR $T2[ebp], 1
  00a6e	e8 00 00 00 00	 call	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00a73	8d 8d 78 fc ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$[ebp]
  00a79	e8 00 00 00 00	 call	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
$LN31@LoadMonste:
  00a7e	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR _File$[ebp]
  00a84	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00a89	8a 85 bb fc ff
	ff		 mov	 al, BYTE PTR $T2[ebp]

; 536  : }

  00a8f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00a92	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00a99	59		 pop	 ecx
  00a9a	5f		 pop	 edi
  00a9b	5e		 pop	 esi
  00a9c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a9f	33 cd		 xor	 ecx, ebp
  00aa1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00aa6	8b e5		 mov	 esp, ebp
  00aa8	5d		 pop	 ebp
  00aa9	c3		 ret	 0
$LN631@LoadMonste:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00aaa	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN671@LoadMonste:
  00aaf	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$0:
  00000	8d 8d bc fc ff
	ff		 lea	 ecx, DWORD PTR _File$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$1:
  0000b	8d 8d 78 fc ff
	ff		 lea	 ecx, DWORD PTR _textFileLoader$[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1CMemoryTextFileLoader@@UAE@XZ ; CMemoryTextFileLoader::~CMemoryTextFileLoader
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$2:
  00016	8d 8d a4 fc ff
	ff		 lea	 ecx, DWORD PTR _stTokenVector$[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$3:
  00021	8d 8d 00 fe ff
	ff		 lea	 ecx, DWORD PTR _$S3$3[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$4:
  0002c	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR _$S4$4[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$5:
  00037	8d 8d 30 fe ff
	ff		 lea	 ecx, DWORD PTR _$S5$5[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$6:
  00042	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR _$S6$6[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$7:
  0004d	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _$S7$7[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$8:
  00058	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR _$S8$8[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$9:
  00063	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR _$S9$9[ebp]
  00069	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$10:
  0006e	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR _$S10$10[ebp]
  00074	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$11:
  00079	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _$S11$11[ebp]
  0007f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ$12:
  00084	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR _$S12$12[ebp]
  0008a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0008f	cc		 int	 3
  00090	cc		 int	 3
  00091	cc		 int	 3
  00092	cc		 int	 3
  00093	cc		 int	 3
__ehhandler$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ:
  00094	90		 npad	 1
  00095	90		 npad	 1
  00096	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0009a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0009d	8b 8a 78 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-904]
  000a3	33 c8		 xor	 ecx, eax
  000a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000aa	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  000ad	33 c8		 xor	 ecx, eax
  000af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b4	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ
  000b9	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadMonsterAreaInfo@CMapOutdoor@@QAE_NXZ ENDP		; CMapOutdoor::LoadMonsterAreaInfo
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength, COMDAT

; 2138 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength, COMDAT

; 2138 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
;	COMDAT ?AssignTerrainPtr@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
tv1346 = -24						; size = 4
tv1349 = -20						; size = 4
tv1350 = -16						; size = 4
$T1 = -12						; size = 4
tv1345 = -12						; size = 4
tv1360 = -8						; size = 4
_usCoordY$2 = -8					; size = 2
_usCoordX$3 = -4					; size = 2
?AssignTerrainPtr@CMapOutdoor@@IAEXXZ PROC		; CMapOutdoor::AssignTerrainPtr, COMDAT
; _this$ = ecx

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 107  : 	OnPreAssignTerrainPtr();

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
  0000d	ff 50 34	 call	 DWORD PTR [eax+52]

; 108  : 
; 109  : 	short sReferenceCoordMinX, sReferenceCoordMaxX, sReferenceCoordMinY, sReferenceCoordMaxY;
; 110  : 	sReferenceCoordMinX = max(m_CurCoordinate.m_sTerrainCoordX - LOAD_SIZE_WIDTH, 0);

  00010	0f b7 46 74	 movzx	 eax, WORD PTR [esi+116]

; 111  : 	sReferenceCoordMaxX = min(m_CurCoordinate.m_sTerrainCoordX + LOAD_SIZE_WIDTH, m_sTerrainCountX - 1);

  00014	0f b7 4e 70	 movzx	 ecx, WORD PTR [esi+112]
  00018	0f bf d0	 movsx	 edx, ax
  0001b	89 45 f4	 mov	 DWORD PTR tv1345[ebp], eax

; 112  : 	sReferenceCoordMinY = max(m_CurCoordinate.m_sTerrainCoordY - LOAD_SIZE_WIDTH, 0);

  0001e	40		 inc	 eax
  0001f	0f bf d9	 movsx	 ebx, cx
  00022	49		 dec	 ecx
  00023	4b		 dec	 ebx
  00024	89 55 f8	 mov	 DWORD PTR tv1360[ebp], edx
  00027	8d 7a 01	 lea	 edi, DWORD PTR [edx+1]
  0002a	0f b7 d0	 movzx	 edx, ax
  0002d	3b fb		 cmp	 edi, ebx
  0002f	0f b7 c1	 movzx	 eax, cx
  00032	0f 4d d0	 cmovge	 edx, eax

; 113  : 	sReferenceCoordMaxY = min(m_CurCoordinate.m_sTerrainCoordY + LOAD_SIZE_WIDTH, m_sTerrainCountY - 1);

  00035	33 c9		 xor	 ecx, ecx
  00037	0f b7 c2	 movzx	 eax, dx
  0003a	0f b7 56 76	 movzx	 edx, WORD PTR [esi+118]
  0003e	89 45 f0	 mov	 DWORD PTR tv1350[ebp], eax
  00041	0f bf fa	 movsx	 edi, dx
  00044	83 ff 01	 cmp	 edi, 1
  00047	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  0004a	0f b7 c0	 movzx	 eax, ax
  0004d	0f 4e c1	 cmovle	 eax, ecx
  00050	0f b7 4e 72	 movzx	 ecx, WORD PTR [esi+114]
  00054	0f b7 c0	 movzx	 eax, ax
  00057	47		 inc	 edi
  00058	89 45 ec	 mov	 DWORD PTR tv1349[ebp], eax

; 114  : 
; 115  : 	DWORD i;
; 116  : 	for (i = 0; i < AROUND_AREA_NUM; ++i)

  0005b	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0005e	0f b7 d0	 movzx	 edx, ax
  00061	0f bf d9	 movsx	 ebx, cx
  00064	49		 dec	 ecx
  00065	4b		 dec	 ebx
  00066	0f b7 c1	 movzx	 eax, cx
  00069	3b fb		 cmp	 edi, ebx

; 117  : 	{
; 118  : 		m_pArea[i] = NULL;

  0006b	c7 86 e0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+224], 0

; 119  : 		m_pTerrain[i] = NULL;

  00075	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
  0007c	0f 4d d0	 cmovge	 edx, eax
  0007f	c7 86 e4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+228], 0
  00089	0f b7 c2	 movzx	 eax, dx
  0008c	33 ff		 xor	 edi, edi
  0008e	89 45 e8	 mov	 DWORD PTR tv1346[ebp], eax

; 122  : 	for (i = 0; i < m_TerrainVector.size(); ++i)

  00091	33 d2		 xor	 edx, edx
  00093	8b 45 f4	 mov	 eax, DWORD PTR tv1345[ebp]
  00096	48		 dec	 eax
  00097	c7 46 44 00 00
	00 00		 mov	 DWORD PTR [esi+68], 0
  0009e	83 7d f8 01	 cmp	 DWORD PTR tv1360[ebp], 1
  000a2	0f b7 c0	 movzx	 eax, ax
  000a5	0f 4e c7	 cmovle	 eax, edi
  000a8	c7 86 e8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+232], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000b2	0f bf d8	 movsx	 ebx, ax
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 119  : 		m_pTerrain[i] = NULL;

  000b5	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [esi+72], 0
  000bc	c7 86 ec 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+236], 0
  000c6	c7 46 4c 00 00
	00 00		 mov	 DWORD PTR [esi+76], 0
  000cd	c7 86 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+240], 0
  000d7	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0
  000de	c7 86 f4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+244], 0
  000e8	c7 46 54 00 00
	00 00		 mov	 DWORD PTR [esi+84], 0
  000ef	c7 86 f8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+248], 0
  000f9	c7 46 58 00 00
	00 00		 mov	 DWORD PTR [esi+88], 0
  00100	c7 86 fc 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+252], 0
  0010a	c7 46 5c 00 00
	00 00		 mov	 DWORD PTR [esi+92], 0
  00111	c7 86 00 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+256], 0
  0011b	c7 46 60 00 00
	00 00		 mov	 DWORD PTR [esi+96], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00122	8b 86 1c 09 00
	00		 mov	 eax, DWORD PTR [esi+2332]
  00128	8b 8e 18 09 00
	00		 mov	 ecx, DWORD PTR [esi+2328]
  0012e	2b c1		 sub	 eax, ecx
  00130	c1 f8 02	 sar	 eax, 2
  00133	89 5d f4	 mov	 DWORD PTR $T1[ebp], ebx
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 122  : 	for (i = 0; i < m_TerrainVector.size(); ++i)

  00136	85 c0		 test	 eax, eax
  00138	74 61		 je	 SHORT $LN51@AssignTerr
  0013a	66 0f 1f 44 00
	00		 npad	 6
$LL7@AssignTerr:

; 123  : 	{
; 124  : 		CTerrain * pTerrain = m_TerrainVector[i];

  00140	8b 1c 91	 mov	 ebx, DWORD PTR [ecx+edx*4]

; 125  : 		WORD usCoordX, usCoordY;
; 126  : 		pTerrain->GetCoordinate(&usCoordX, &usCoordY);
; 127  : 
; 128  : 		if (usCoordX >= sReferenceCoordMinX &&
; 129  : 			usCoordX <= sReferenceCoordMaxX &&
; 130  : 			usCoordY >= sReferenceCoordMinY &&

  00143	0f b7 bb 6c a5
	06 00		 movzx	 edi, WORD PTR [ebx+435564]
  0014a	3b 7d f4	 cmp	 edi, DWORD PTR $T1[ebp]
  0014d	7c 34		 jl	 SHORT $LN5@AssignTerr
  0014f	8b 45 f0	 mov	 eax, DWORD PTR tv1350[ebp]
  00152	98		 cwde
  00153	3b f8		 cmp	 edi, eax
  00155	7f 2c		 jg	 SHORT $LN5@AssignTerr
  00157	8b 45 ec	 mov	 eax, DWORD PTR tv1349[ebp]
  0015a	0f b7 8b 6e a5
	06 00		 movzx	 ecx, WORD PTR [ebx+435566]
  00161	98		 cwde
  00162	3b c8		 cmp	 ecx, eax
  00164	7c 1d		 jl	 SHORT $LN5@AssignTerr
  00166	8b 45 e8	 mov	 eax, DWORD PTR tv1346[ebp]
  00169	98		 cwde
  0016a	3b c8		 cmp	 ecx, eax
  0016c	7f 15		 jg	 SHORT $LN5@AssignTerr

; 131  : 			usCoordY <= sReferenceCoordMaxY)
; 132  : 		{
; 133  : 			m_pTerrain[(usCoordY - m_CurCoordinate.m_sTerrainCoordY + LOAD_SIZE_WIDTH) * 3 +

  0016e	0f bf 46 76	 movsx	 eax, WORD PTR [esi+118]
  00172	2b c8		 sub	 ecx, eax
  00174	0f bf 46 74	 movsx	 eax, WORD PTR [esi+116]
  00178	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  0017b	2b c8		 sub	 ecx, eax
  0017d	03 cf		 add	 ecx, edi
  0017f	89 5c 8e 50	 mov	 DWORD PTR [esi+ecx*4+80], ebx
$LN5@AssignTerr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00183	8b 86 1c 09 00
	00		 mov	 eax, DWORD PTR [esi+2332]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 122  : 	for (i = 0; i < m_TerrainVector.size(); ++i)

  00189	42		 inc	 edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0018a	8b 8e 18 09 00
	00		 mov	 ecx, DWORD PTR [esi+2328]
  00190	2b c1		 sub	 eax, ecx
  00192	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 122  : 	for (i = 0; i < m_TerrainVector.size(); ++i)

  00195	3b d0		 cmp	 edx, eax
  00197	72 a7		 jb	 SHORT $LL7@AssignTerr
  00199	eb 03		 jmp	 SHORT $LN6@AssignTerr
$LN51@AssignTerr:
  0019b	89 5d f4	 mov	 DWORD PTR $T1[ebp], ebx
$LN6@AssignTerr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0019e	8b 86 50 09 00
	00		 mov	 eax, DWORD PTR [esi+2384]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 138  : 	for (i = 0; i < m_AreaVector.size(); ++i)

  001a4	33 ff		 xor	 edi, edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001a6	8b 8e 4c 09 00
	00		 mov	 ecx, DWORD PTR [esi+2380]
  001ac	2b c1		 sub	 eax, ecx
  001ae	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 138  : 	for (i = 0; i < m_AreaVector.size(); ++i)

  001b1	85 c0		 test	 eax, eax
  001b3	74 64		 je	 SHORT $LN9@AssignTerr
$LL10@AssignTerr:

; 139  : 	{
; 140  : 		CArea * pArea = m_AreaVector[i];

  001b5	8b 1c b9	 mov	 ebx, DWORD PTR [ecx+edi*4]

; 141  : 		WORD usCoordX, usCoordY;
; 142  : 		pArea->GetCoordinate(&usCoordX, &usCoordY);

  001b8	8d 45 f8	 lea	 eax, DWORD PTR _usCoordY$2[ebp]
  001bb	50		 push	 eax
  001bc	8d 45 fc	 lea	 eax, DWORD PTR _usCoordX$3[ebp]
  001bf	8b cb		 mov	 ecx, ebx
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 ?GetCoordinate@CArea@@QAEXPAG0@Z ; CArea::GetCoordinate

; 143  : 
; 144  : 		if (usCoordX >= sReferenceCoordMinX &&
; 145  : 			usCoordX <= sReferenceCoordMaxX &&
; 146  : 			usCoordY >= sReferenceCoordMinY &&

  001c7	0f b7 55 fc	 movzx	 edx, WORD PTR _usCoordX$3[ebp]
  001cb	3b 55 f4	 cmp	 edx, DWORD PTR $T1[ebp]
  001ce	7c 33		 jl	 SHORT $LN8@AssignTerr
  001d0	8b 45 f0	 mov	 eax, DWORD PTR tv1350[ebp]
  001d3	98		 cwde
  001d4	3b d0		 cmp	 edx, eax
  001d6	7f 2b		 jg	 SHORT $LN8@AssignTerr
  001d8	8b 45 ec	 mov	 eax, DWORD PTR tv1349[ebp]
  001db	0f b7 4d f8	 movzx	 ecx, WORD PTR _usCoordY$2[ebp]
  001df	98		 cwde
  001e0	3b c8		 cmp	 ecx, eax
  001e2	7c 1f		 jl	 SHORT $LN8@AssignTerr
  001e4	8b 45 e8	 mov	 eax, DWORD PTR tv1346[ebp]
  001e7	98		 cwde
  001e8	3b c8		 cmp	 ecx, eax
  001ea	7f 17		 jg	 SHORT $LN8@AssignTerr

; 147  : 			usCoordY <= sReferenceCoordMaxY)
; 148  : 		{
; 149  : 			m_pArea[(usCoordY - m_CurCoordinate.m_sTerrainCoordY + LOAD_SIZE_WIDTH) * 3 +

  001ec	0f bf 46 76	 movsx	 eax, WORD PTR [esi+118]
  001f0	2b c8		 sub	 ecx, eax
  001f2	0f bf 46 74	 movsx	 eax, WORD PTR [esi+116]
  001f6	83 c1 14	 add	 ecx, 20			; 00000014H
  001f9	8d 0c 49	 lea	 ecx, DWORD PTR [ecx+ecx*2]
  001fc	2b c8		 sub	 ecx, eax
  001fe	03 ca		 add	 ecx, edx
  00200	89 1c 8e	 mov	 DWORD PTR [esi+ecx*4], ebx
$LN8@AssignTerr:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00203	8b 86 50 09 00
	00		 mov	 eax, DWORD PTR [esi+2384]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 138  : 	for (i = 0; i < m_AreaVector.size(); ++i)

  00209	47		 inc	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0020a	8b 8e 4c 09 00
	00		 mov	 ecx, DWORD PTR [esi+2380]
  00210	2b c1		 sub	 eax, ecx
  00212	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 138  : 	for (i = 0; i < m_AreaVector.size(); ++i)

  00215	3b f8		 cmp	 edi, eax
  00217	72 9c		 jb	 SHORT $LL10@AssignTerr
$LN9@AssignTerr:
  00219	5f		 pop	 edi

; 150  : 				(usCoordX - m_CurCoordinate.m_sTerrainCoordX + LOAD_SIZE_WIDTH) ] = pArea;
; 151  : 		}
; 152  : 	}
; 153  : }

  0021a	5e		 pop	 esi
  0021b	5b		 pop	 ebx
  0021c	8b e5		 mov	 esp, ebp
  0021e	5d		 pop	 ebp
  0021f	c3		 ret	 0
?AssignTerrainPtr@CMapOutdoor@@IAEXXZ ENDP		; CMapOutdoor::AssignTerrainPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
;	COMDAT ?isAreaLoaded@CMapOutdoor@@IAE_NGG@Z
_TEXT	SEGMENT
_usCoordY$1 = -4					; size = 2
_wX$ = 8						; size = 2
_usCoordX$2 = 12					; size = 2
_wY$ = 12						; size = 2
?isAreaLoaded@CMapOutdoor@@IAE_NGG@Z PROC		; CMapOutdoor::isAreaLoaded, COMDAT
; _this$ = ecx

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx

; 92   : 	for (DWORD i = 0; i < m_AreaVector.size(); ++i)

  00009	33 f6		 xor	 esi, esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000b	8b 87 50 09 00
	00		 mov	 eax, DWORD PTR [edi+2384]
  00011	8b 8f 4c 09 00
	00		 mov	 ecx, DWORD PTR [edi+2380]
  00017	2b c1		 sub	 eax, ecx
  00019	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 92   : 	for (DWORD i = 0; i < m_AreaVector.size(); ++i)

  0001c	85 c0		 test	 eax, eax
  0001e	74 3a		 je	 SHORT $LN16@isAreaLoad
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1868 :         auto& _My_data = _Mypair._Myval2;

  00020	66 8b 5d 0c	 mov	 bx, WORD PTR _wY$[ebp]
$LL4@isAreaLoad:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 96   : 		pArea->GetCoordinate(&usCoordX, &usCoordY);

  00024	8b 0c b1	 mov	 ecx, DWORD PTR [ecx+esi*4]
  00027	8d 45 fc	 lea	 eax, DWORD PTR _usCoordY$1[ebp]
  0002a	50		 push	 eax
  0002b	8d 45 0c	 lea	 eax, DWORD PTR _usCoordX$2[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ?GetCoordinate@CArea@@QAEXPAG0@Z ; CArea::GetCoordinate

; 97   : 
; 98   : 		if (usCoordX == wX && usCoordY == wY)

  00034	66 8b 45 08	 mov	 ax, WORD PTR _wX$[ebp]
  00038	66 39 45 0c	 cmp	 WORD PTR _usCoordX$2[ebp], ax
  0003c	75 06		 jne	 SHORT $LN2@isAreaLoad
  0003e	66 39 5d fc	 cmp	 WORD PTR _usCoordY$1[ebp], bx
  00042	74 21		 je	 SHORT $LN12@isAreaLoad
$LN2@isAreaLoad:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00044	8b 87 50 09 00
	00		 mov	 eax, DWORD PTR [edi+2384]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 92   : 	for (DWORD i = 0; i < m_AreaVector.size(); ++i)

  0004a	46		 inc	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0004b	8b 8f 4c 09 00
	00		 mov	 ecx, DWORD PTR [edi+2380]
  00051	2b c1		 sub	 eax, ecx
  00053	c1 f8 02	 sar	 eax, 2
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 92   : 	for (DWORD i = 0; i < m_AreaVector.size(); ++i)

  00056	3b f0		 cmp	 esi, eax
  00058	72 ca		 jb	 SHORT $LL4@isAreaLoad
$LN16@isAreaLoad:
  0005a	5f		 pop	 edi

; 99   : 			return true;
; 100  : 	}
; 101  : 	return false;
; 102  : }

  0005b	5e		 pop	 esi
  0005c	32 c0		 xor	 al, al
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
$LN12@isAreaLoad:
  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	b0 01		 mov	 al, 1
  00069	5b		 pop	 ebx
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c2 08 00	 ret	 8
?isAreaLoaded@CMapOutdoor@@IAE_NGG@Z ENDP		; CMapOutdoor::isAreaLoaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
;	COMDAT ?isTerrainLoaded@CMapOutdoor@@IAE_NGG@Z
_TEXT	SEGMENT
_wX$ = 8						; size = 2
_wY$ = 12						; size = 2
?isTerrainLoaded@CMapOutdoor@@IAE_NGG@Z PROC		; CMapOutdoor::isTerrainLoaded, COMDAT
; _this$ = ecx

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00003	8b 81 18 09 00
	00		 mov	 eax, DWORD PTR [ecx+2328]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 78   : 	for (DWORD i = 0; i < m_TerrainVector.size(); ++i)

  00009	33 d2		 xor	 edx, edx
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1869 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0000d	8b b1 1c 09 00
	00		 mov	 esi, DWORD PTR [ecx+2332]
  00013	2b f0		 sub	 esi, eax
  00015	c1 fe 02	 sar	 esi, 2
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 77   : {

  00018	57		 push	 edi

; 78   : 	for (DWORD i = 0; i < m_TerrainVector.size(); ++i)

  00019	85 f6		 test	 esi, esi
  0001b	74 24		 je	 SHORT $LN18@isTerrainL
  0001d	66 8b 7d 0c	 mov	 di, WORD PTR _wY$[ebp]
  00021	66 8b 5d 08	 mov	 bx, WORD PTR _wX$[ebp]
$LL4@isTerrainL:

; 79   : 	{
; 80   : 		CTerrain * pTerrain = m_TerrainVector[i];

  00025	8b 08		 mov	 ecx, DWORD PTR [eax]

; 81   : 		WORD usCoordX, usCoordY;
; 82   : 		pTerrain->GetCoordinate(&usCoordX, &usCoordY);
; 83   : 
; 84   : 		if (usCoordX == wX && usCoordY == wY)

  00027	66 39 99 6c a5
	06 00		 cmp	 WORD PTR [ecx+435564], bx
  0002e	75 09		 jne	 SHORT $LN2@isTerrainL
  00030	66 39 b9 6e a5
	06 00		 cmp	 WORD PTR [ecx+435566], di
  00037	74 11		 je	 SHORT $LN14@isTerrainL
$LN2@isTerrainL:

; 78   : 	for (DWORD i = 0; i < m_TerrainVector.size(); ++i)

  00039	42		 inc	 edx
  0003a	83 c0 04	 add	 eax, 4
  0003d	3b d6		 cmp	 edx, esi
  0003f	72 e4		 jb	 SHORT $LL4@isTerrainL
$LN18@isTerrainL:
  00041	5f		 pop	 edi

; 85   : 			return true;
; 86   : 	}
; 87   : 	return false;
; 88   : }

  00042	5e		 pop	 esi
  00043	32 c0		 xor	 al, al
  00045	5b		 pop	 ebx
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
$LN14@isTerrainL:
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	b0 01		 mov	 al, 1
  0004e	5b		 pop	 ebx
  0004f	5d		 pop	 ebp
  00050	c2 08 00	 ret	 8
?isTerrainLoaded@CMapOutdoor@@IAE_NGG@Z ENDP		; CMapOutdoor::isTerrainLoaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
;	COMDAT ?LoadArea@CMapOutdoor@@MAE_NGGGG@Z
_TEXT	SEGMENT
_pArea$ = -76						; size = 4
_szAreaPathName$ = -72					; size = 65
__$ArrayPad$ = -4					; size = 4
_wAreaCoordX$ = 8					; size = 2
_wAreaCoordY$ = 12					; size = 2
_wCellCoordX$ = 16					; size = 2
_wCellCoordY$ = 20					; size = 2
?LoadArea@CMapOutdoor@@MAE_NGGGG@Z PROC			; CMapOutdoor::LoadArea, COMDAT
; _this$ = ecx

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 157  : 	if (isAreaLoaded(wAreaCoordX, wAreaCoordY))

  00011	ff 75 0c	 push	 DWORD PTR _wAreaCoordY$[ebp]
  00014	8b f1		 mov	 esi, ecx
  00016	ff 75 08	 push	 DWORD PTR _wAreaCoordX$[ebp]
  00019	e8 00 00 00 00	 call	 ?isAreaLoaded@CMapOutdoor@@IAE_NGG@Z ; CMapOutdoor::isAreaLoaded
  0001e	84 c0		 test	 al, al
  00020	0f 85 b7 00 00
	00		 jne	 $LN29@LoadArea

; 158  : 		return true;
; 159  : #ifdef _DEBUG
; 160  : 	DWORD dwStartTime = ELTimer_GetMSec();
; 161  : #endif
; 162  : 	unsigned long ulID = (unsigned long) (wAreaCoordX) * 1000L + (unsigned long) (wAreaCoordY);

  00026	0f b7 45 08	 movzx	 eax, WORD PTR _wAreaCoordX$[ebp]
  0002a	69 c8 e8 03 00
	00		 imul	 ecx, eax, 1000
  00030	0f b7 45 0c	 movzx	 eax, WORD PTR _wAreaCoordY$[ebp]
  00034	03 c8		 add	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

  00036	33 c0		 xor	 eax, eax
  00038	3b 46 30	 cmp	 eax, DWORD PTR [esi+48]
  0003b	1b c0		 sbb	 eax, eax
  0003d	83 e0 18	 and	 eax, 24			; 00000018H
  00040	83 c0 08	 add	 eax, 8
  00043	03 c6		 add	 eax, esi

; 2244 :         return _BUF_SIZE <= _Myres;

  00045	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H

; 2236 :         if (_Large_string_engaged()) {

  00049	72 02		 jb	 SHORT $LN14@LoadArea

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN14@LoadArea:
  0004d	57		 push	 edi
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 164  : 	_snprintf(szAreaPathName, sizeof(szAreaPathName), "%s\\%06u\\", GetMapDataDirectory().c_str(), ulID);

  0004e	51		 push	 ecx
  0004f	50		 push	 eax
  00050	68 00 00 00 00	 push	 OFFSET ??_C@_08HAAOAKJA@?$CFs?2?$CF06u?2@
  00055	8d 45 b8	 lea	 eax, DWORD PTR _szAreaPathName$[ebp]
  00058	6a 41		 push	 65			; 00000041H
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 __snprintf
  00060	83 c4 14	 add	 esp, 20			; 00000014H

; 165  : 
; 166  : 	CArea * pArea = CArea::New();

  00063	e8 00 00 00 00	 call	 ?New@CArea@@SAPAV1@XZ	; CArea::New
  00068	8b f8		 mov	 edi, eax

; 167  : 	pArea->SetMapOutDoor(this);

  0006a	56		 push	 esi
  0006b	8b cf		 mov	 ecx, edi
  0006d	89 7d b4	 mov	 DWORD PTR _pArea$[ebp], edi
  00070	e8 00 00 00 00	 call	 ?SetMapOutDoor@CArea@@QAEXPAVCMapOutdoor@@@Z ; CArea::SetMapOutDoor

; 168  : #ifdef _DEBUG
; 169  : 	Tracef("CMapOutdoor::LoadArea1 %d\n", ELTimer_GetMSec() - dwStartTime);
; 170  : 	dwStartTime = ELTimer_GetMSec();
; 171  : #endif
; 172  : 
; 173  : 	pArea->SetCoordinate(wAreaCoordX, wAreaCoordY);

  00075	8d 45 0c	 lea	 eax, DWORD PTR _wAreaCoordY$[ebp]
  00078	8b cf		 mov	 ecx, edi
  0007a	50		 push	 eax
  0007b	8d 45 08	 lea	 eax, DWORD PTR _wAreaCoordX$[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ?SetCoordinate@CArea@@QAEXABG0@Z ; CArea::SetCoordinate

; 174  : 	if ( !pArea->Load(szAreaPathName) )

  00084	8d 45 b8	 lea	 eax, DWORD PTR _szAreaPathName$[ebp]
  00087	8b cf		 mov	 ecx, edi
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?Load@CArea@@QAE_NPBD@Z	; CArea::Load
  0008f	84 c0		 test	 al, al
  00091	75 17		 jne	 SHORT $LN3@LoadArea

; 175  : 		TraceError(" CMapOutdoor::LoadArea(%d, %d) LoadShadowMap ERROR", wAreaCoordX, wAreaCoordY);

  00093	0f b7 45 0c	 movzx	 eax, WORD PTR _wAreaCoordY$[ebp]
  00097	50		 push	 eax
  00098	0f b7 45 08	 movzx	 eax, WORD PTR _wAreaCoordX$[ebp]
  0009c	50		 push	 eax
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@GDFLJGIN@?5CMapOutdoor?3?3LoadArea?$CI?$CFd?0?5?$CFd?$CJ?5@
  000a2	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@LoadArea:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

  000aa	8b 86 50 09 00
	00		 mov	 eax, DWORD PTR [esi+2384]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 182  : 	m_AreaVector.push_back(pArea);

  000b0	8d 8e 4c 09 00
	00		 lea	 ecx, DWORD PTR [esi+2380]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

  000b6	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  000b9	74 08		 je	 SHORT $LN21@LoadArea

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  000bb	89 38		 mov	 DWORD PTR [eax], edi

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

  000bd	83 41 04 04	 add	 DWORD PTR [ecx+4], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  000c1	eb 0a		 jmp	 SHORT $LN20@LoadArea
$LN21@LoadArea:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  000c3	8d 55 b4	 lea	 edx, DWORD PTR _pArea$[ebp]
  000c6	52		 push	 edx
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEPAPAVCArea@@QAPAV2@ABQAV2@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_reallocate<CArea * const &>
$LN20@LoadArea:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 184  : 	pArea->EnablePortal(m_bEnablePortal);

  000cd	0f b6 86 b7 0e
	00 00		 movzx	 eax, BYTE PTR [esi+3767]
  000d4	8b cf		 mov	 ecx, edi
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ?EnablePortal@CArea@@QAEXH@Z ; CArea::EnablePortal

; 185  : #ifdef _DEBUG
; 186  : 	Tracef("CMapOutdoor::LoadArea3 %d\n", ELTimer_GetMSec() - dwStartTime);
; 187  : #endif
; 188  : 
; 189  : 	return true;

  000dc	5f		 pop	 edi
$LN29@LoadArea:

; 190  : }

  000dd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e0	b0 01		 mov	 al, 1
  000e2	33 cd		 xor	 ecx, ebp
  000e4	5e		 pop	 esi
  000e5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c2 10 00	 ret	 16			; 00000010H
?LoadArea@CMapOutdoor@@MAE_NGGGG@Z ENDP			; CMapOutdoor::LoadArea
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\AreaTerrain.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\AreaTerrain.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
;	COMDAT ?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z
_TEXT	SEGMENT
_dwStartTime$1$ = -836					; size = 4
__Result$1$ = -832					; size = 4
_pTerrain$ = -828					; size = 4
$T2 = -828						; size = 4
tv2577 = -824						; size = 4
_stTokenVectorMap$ = -820				; size = 8
_ulID$1$ = -812						; size = 4
_this$GSCopy$1$ = -808					; size = 4
_stTokenVectorMap$1$ = -804				; size = 4
tv2588 = -804						; size = 4
$T3 = -797						; size = 1
$T4 = -796						; size = 24
$T5 = -796						; size = 24
__Loc$6 = -784						; size = 12
$T7 = -772						; size = 24
$T8 = -772						; size = 24
$T9 = -772						; size = 24
_filename$ = -748					; size = 256
_szMiniMapTexName$ = -492				; size = 65
_szShadowMapName$ = -424				; size = 65
_szShadowTexName$ = -356				; size = 65
_szSplatName$ = -288					; size = 65
_szAttrMapName$ = -220					; size = 65
_szRawHeightFieldname$ = -152				; size = 65
_szWaterMapName$ = -84					; size = 65
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wTerrainCoordX$ = 8					; size = 2
_wTerrainCoordY$ = 12					; size = 2
_wCellCoordX$ = 16					; size = 2
_wCellCoordY$ = 20					; size = 2
?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z PROC		; CMapOutdoor::LoadTerrain, COMDAT
; _this$ = ecx

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 38 03 00
	00		 sub	 esp, 824		; 00000338H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx
  0002f	89 bd d8 fc ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi

; 194  : 	if (isTerrainLoaded(wTerrainCoordX, wTerrainCoordY))

  00035	8b 75 0c	 mov	 esi, DWORD PTR _wTerrainCoordY$[ebp]
  00038	56		 push	 esi
  00039	ff 75 08	 push	 DWORD PTR _wTerrainCoordX$[ebp]
  0003c	e8 00 00 00 00	 call	 ?isTerrainLoaded@CMapOutdoor@@IAE_NGG@Z ; CMapOutdoor::isTerrainLoaded
  00041	84 c0		 test	 al, al
  00043	74 07		 je	 SHORT $LN2@LoadTerrai

; 195  : 		return true;

  00045	b0 01		 mov	 al, 1
  00047	e9 c9 06 00 00	 jmp	 $LN1@LoadTerrai
$LN2@LoadTerrai:

; 196  : 
; 197  : 	//////////////////////////////////////////////////////////////////////////
; 198  : 	DWORD dwStartTime = ELTimer_GetMSec();

  0004c	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00051	89 85 bc fc ff
	ff		 mov	 DWORD PTR _dwStartTime$1$[ebp], eax

; 200  : 	unsigned long ulID = (unsigned long) (wTerrainCoordX) * 1000L + (unsigned long) (wTerrainCoordY);

  00057	8b 45 08	 mov	 eax, DWORD PTR _wTerrainCoordX$[ebp]
  0005a	0f b7 c8	 movzx	 ecx, ax
  0005d	89 8d c8 fc ff
	ff		 mov	 DWORD PTR tv2577[ebp], ecx
  00063	69 c9 e8 03 00
	00		 imul	 ecx, ecx, 1000
  00069	0f b7 c6	 movzx	 eax, si
  0006c	03 c8		 add	 ecx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

  0006e	33 c0		 xor	 eax, eax
  00070	3b 47 30	 cmp	 eax, DWORD PTR [edi+48]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 200  : 	unsigned long ulID = (unsigned long) (wTerrainCoordX) * 1000L + (unsigned long) (wTerrainCoordY);

  00073	89 8d d4 fc ff
	ff		 mov	 DWORD PTR _ulID$1$[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

  00079	1b c0		 sbb	 eax, eax
  0007b	83 e0 18	 and	 eax, 24			; 00000018H
  0007e	83 c0 08	 add	 eax, 8
  00081	03 c7		 add	 eax, edi

; 2236 :         if (_Large_string_engaged()) {

  00083	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00087	72 02		 jb	 SHORT $LN32@LoadTerrai

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00089	8b 00		 mov	 eax, DWORD PTR [eax]
$LN32@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 202  : 	sprintf(filename, "%s\\%06u\\AreaProperty.txt", GetMapDataDirectory().c_str(), ulID);

  0008b	51		 push	 ecx
  0008c	50		 push	 eax
  0008d	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  00093	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@PNPPDMHN@?$CFs?2?$CF06u?2AreaProperty?4txt@
  00098	50		 push	 eax
  00099	e8 00 00 00 00	 call	 _sprintf
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

  0009e	6a 34		 push	 52			; 00000034H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  000a0	c7 85 cc fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVectorMap$[ebp], 0
  000aa	c7 85 d0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVectorMap$[ebp+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

  000b4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  000b9	89 00		 mov	 DWORD PTR [eax], eax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  000bb	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  000be	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 350  :         _Pnode->_Color = _Black;

  000c1	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  000c7	89 85 cc fc ff
	ff		 mov	 DWORD PTR _stTokenVectorMap$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 206  : 	if (!LoadMultipleTextData(filename, stTokenVectorMap))

  000cd	8d 85 cc fc ff
	ff		 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  000d3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000da	50		 push	 eax
  000db	8d 85 14 fd ff
	ff		 lea	 eax, DWORD PTR _filename$[ebp]
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?LoadMultipleTextData@@YA_NPBDAAV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@@Z ; LoadMultipleTextData
  000e7	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ea	84 c0		 test	 al, al
  000ec	75 1a		 jne	 SHORT $LN3@LoadTerrai

; 207  : 	{
; 208  : 		TraceError("CMapOutdoor::LoadTerrain AreaProperty Read Error\n");

  000ee	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DC@PJKFCPIK@CMapOutdoor?3?3LoadTerrain?5AreaPr@
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000f9	83 c4 04	 add	 esp, 4
  000fc	c6 85 e3 fc ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
  00103	e9 e0 05 00 00	 jmp	 $LN22@LoadTerrai
$LN3@LoadTerrai:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00108	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@PCFMFEAG@scripttype@+8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0010e	8d 8d cc fc ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00114	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2629 :             _My_data._Mysize = _Count;

  00117	c7 85 0c fd ff
	ff 0a 00 00 00	 mov	 DWORD PTR $T9[ebp+16], 10 ; 0000000aH

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00121	0f 11 85 fc fc
	ff ff		 movups	 XMMWORD PTR $T9[ebp], xmm0

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00128	66 89 85 04 fd
	ff ff		 mov	 WORD PTR $T9[ebp+8], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0012f	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00135	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@PCFMFEAG@scripttype@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0013d	50		 push	 eax
  0013e	8d 85 f0 fc ff
	ff		 lea	 eax, DWORD PTR __Loc$6[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  00144	c7 85 10 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T9[ebp+20], 15 ; 0000000fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0014e	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0014f	66 0f d6 85 fc
	fc ff ff	 movq	 QWORD PTR $T9[ebp], xmm0

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00157	c6 85 06 fd ff
	ff 00		 mov	 BYTE PTR $T9[ebp+10], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0015e	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00163	8b b5 f8 fc ff
	ff		 mov	 esi, DWORD PTR __Loc$6[ebp+8]
  00169	8b 85 cc fc ff
	ff		 mov	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  0016f	89 85 dc fc ff
	ff		 mov	 DWORD PTR _stTokenVectorMap$1$[ebp], eax
  00175	80 7e 0d 00	 cmp	 BYTE PTR [esi+13], 0
  00179	75 1d		 jne	 SHORT $LN138@LoadTerrai
  0017b	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

  0017e	50		 push	 eax
  0017f	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00185	50		 push	 eax
  00186	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0018b	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0018e	84 c0		 test	 al, al
  00190	8b 85 dc fc ff
	ff		 mov	 eax, DWORD PTR _stTokenVectorMap$1$[ebp]
  00196	74 02		 je	 SHORT $LN137@LoadTerrai
$LN138@LoadTerrai:

; 1373 :         return _Get_scary()->_Myhead;

  00198	8b f0		 mov	 esi, eax
$LN137@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 212  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("scripttype"))

  0019a	3b c6		 cmp	 eax, esi
  0019c	75 1a		 jne	 SHORT $LN4@LoadTerrai

; 213  : 	{
; 214  : 		TraceError("CMapOutdoor::LoadTerrain AreaProperty FileFormat Error 1\n");
; 215  : 		return false;

  0019e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DK@IGMBLPHB@CMapOutdoor?3?3LoadTerrain?5AreaPr@
  001a3	50		 push	 eax
  001a4	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001a9	83 c4 04	 add	 esp, 4
  001ac	c6 85 e3 fc ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
  001b3	e9 30 05 00 00	 jmp	 $LN22@LoadTerrai
$LN4@LoadTerrai:

; 218  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areaname"))

  001b8	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2629 :             _My_data._Mysize = _Count;

  001be	c7 85 0c fd ff
	ff 08 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 8
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 218  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areaname"))

  001c8	50		 push	 eax
  001c9	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  001cc	c7 85 10 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T8[ebp+20], 15 ; 0000000fH

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  001d6	0f 11 85 fc fc
	ff ff		 movups	 XMMWORD PTR $T8[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 218  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areaname"))

  001dd	8d 85 c4 fc ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001e3	c7 85 fc fc ff
	ff 61 72 65 61	 mov	 DWORD PTR $T8[ebp], 1634038369 ; 61657261H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 218  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areaname"))

  001ed	50		 push	 eax
  001ee	8d 8d cc fc ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001f4	c7 85 00 fd ff
	ff 6e 61 6d 65	 mov	 DWORD PTR $T8[ebp+4], 1701667182 ; 656d616eH

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  001fe	c6 85 04 fd ff
	ff 00		 mov	 BYTE PTR $T8[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 218  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areaname"))

  00205	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  0020a	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 233  :         return this->_Ptr == _Right._Ptr;

  00210	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 218  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areaname"))

  00212	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00217	39 b5 dc fc ff
	ff		 cmp	 DWORD PTR _stTokenVectorMap$1$[ebp], esi
  0021d	75 1a		 jne	 SHORT $LN5@LoadTerrai

; 219  : 	{
; 220  : 		TraceError("CMapOutdoor::LoadTerrain AreaProperty FileFormat Error 2\n");
; 221  : 		return false;

  0021f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DK@IEIHABCI@CMapOutdoor?3?3LoadTerrain?5AreaPr@
  00224	50		 push	 eax
  00225	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0022a	83 c4 04	 add	 esp, 4
  0022d	c6 85 e3 fc ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
  00234	e9 af 04 00 00	 jmp	 $LN22@LoadTerrai
$LN5@LoadTerrai:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00239	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@PCFMFEAG@scripttype@+8
  0023f	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00242	0f 11 85 e4 fc
	ff ff		 movups	 XMMWORD PTR $T5[ebp], xmm0

; 2629 :             _My_data._Mysize = _Count;

  00249	c7 85 f4 fc ff
	ff 0a 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 10 ; 0000000aH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00253	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@PCFMFEAG@scripttype@

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  0025b	c7 85 f8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00265	66 0f d6 85 e4
	fc ff ff	 movq	 QWORD PTR $T5[ebp], xmm0
  0026d	66 89 85 ec fc
	ff ff		 mov	 WORD PTR $T5[ebp+8], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00274	c6 85 ee fc ff
	ff 00		 mov	 BYTE PTR $T5[ebp+10], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 224  : 	const std::string & c_rstrType = stTokenVectorMap["scripttype"][0];

  0027b	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00281	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00285	50		 push	 eax
  00286	8d 8d cc fc ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  0028c	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00291	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 224  : 	const std::string & c_rstrType = stTokenVectorMap["scripttype"][0];

  00297	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  0029b	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  0029d	83 f9 10	 cmp	 ecx, 16			; 00000010H
  002a0	72 2f		 jb	 SHORT $LN289@LoadTerrai
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002a2	8b 95 e4 fc ff
	ff		 mov	 edx, DWORD PTR $T5[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  002a8	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  002a9	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  002ab	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  002b1	72 14		 jb	 SHORT $LN299@LoadTerrai

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  002b3	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  002b6	83 c1 23	 add	 ecx, 35			; 00000023H
  002b9	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  002bb	83 c0 fc	 add	 eax, -4			; fffffffcH
  002be	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  002c1	0f 87 6b 04 00
	00		 ja	 $LN488@LoadTerrai
$LN299@LoadTerrai:

; 265  :         ::operator delete(_Ptr, _Bytes);

  002c7	51		 push	 ecx
  002c8	52		 push	 edx
  002c9	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  002ce	83 c4 08	 add	 esp, 8
$LN289@LoadTerrai:
  002d1	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

  002d4	c7 85 f4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  002de	0f 11 85 fc fc
	ff ff		 movups	 XMMWORD PTR $T7[ebp], xmm0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  002e5	c7 85 f8 fc ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  002ef	c6 85 e4 fc ff
	ff 00		 mov	 BYTE PTR $T5[ebp], 0

; 2629 :             _My_data._Mysize = _Count;

  002f6	c7 85 0c fd ff
	ff 08 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 8

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  00300	c7 85 10 fd ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0030a	c7 85 fc fc ff
	ff 61 72 65 61	 mov	 DWORD PTR $T7[ebp], 1634038369 ; 61657261H
  00314	c7 85 00 fd ff
	ff 6e 61 6d 65	 mov	 DWORD PTR $T7[ebp+4], 1701667182 ; 656d616eH

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  0031e	c6 85 04 fd ff
	ff 00		 mov	 BYTE PTR $T7[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 225  : 	const std::string & c_rstrAreaName = stTokenVectorMap["areaname"][0];

  00325	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  0032b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0032f	50		 push	 eax
  00330	8d 8d cc fc ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00336	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
  0033b	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00341	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  00345	8b 00		 mov	 eax, DWORD PTR [eax]
  00347	89 85 c0 fc ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 225  : 	const std::string & c_rstrAreaName = stTokenVectorMap["areaname"][0];

  0034d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 226  : 
; 227  : 	if (c_rstrType != "AreaProperty")

  00352	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JAFNMPED@AreaProperty@
  00357	56		 push	 esi
  00358	e8 00 00 00 00	 call	 ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
  0035d	83 c4 08	 add	 esp, 8
  00360	84 c0		 test	 al, al
  00362	74 1a		 je	 SHORT $LN6@LoadTerrai

; 228  : 	{
; 229  : 		TraceError("CMapOutdoor::LoadTerrain AreaProperty FileFormat Error 3\n");
; 230  : 		return false;

  00364	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DK@IFEFGLBP@CMapOutdoor?3?3LoadTerrain?5AreaPr@
  00369	50		 push	 eax
  0036a	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0036f	83 c4 04	 add	 esp, 4
  00372	c6 85 e3 fc ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
  00379	e9 6a 03 00 00	 jmp	 $LN22@LoadTerrai
$LN6@LoadTerrai:

; 231  : 	}
; 232  : 
; 233  : 	CTerrain * pTerrain = CTerrain::New();

  0037e	e8 00 00 00 00	 call	 ?New@CTerrain@@SAPAV1@XZ ; CTerrain::New
  00383	8b f0		 mov	 esi, eax

; 234  : 
; 235  : 	pTerrain->Clear();

  00385	8b ce		 mov	 ecx, esi
  00387	89 b5 c4 fc ff
	ff		 mov	 DWORD PTR _pTerrain$[ebp], esi
  0038d	8b 16		 mov	 edx, DWORD PTR [esi]
  0038f	ff 52 04	 call	 DWORD PTR [edx+4]

; 236  : 	pTerrain->SetMapOutDoor(this);

  00392	57		 push	 edi
  00393	8b ce		 mov	 ecx, esi
  00395	e8 00 00 00 00	 call	 ?SetMapOutDoor@CTerrain@@QAEXPAVCMapOutdoor@@@Z ; CTerrain::SetMapOutDoor

; 237  : 
; 238  : 	pTerrain->SetCoordinate(wTerrainCoordX, wTerrainCoordY);

  0039a	ff 75 0c	 push	 DWORD PTR _wTerrainCoordY$[ebp]
  0039d	8b ce		 mov	 ecx, esi
  0039f	ff 75 08	 push	 DWORD PTR _wTerrainCoordX$[ebp]
  003a2	e8 00 00 00 00	 call	 ?SetCoordinate@CTerrain@@QAEXGG@Z ; CTerrain::SetCoordinate

; 239  : 
; 240  : 	pTerrain->CopySettingFromGlobalSetting();

  003a7	8b ce		 mov	 ecx, esi
  003a9	e8 00 00 00 00	 call	 ?CopySettingFromGlobalSetting@CTerrain@@QAEXXZ ; CTerrain::CopySettingFromGlobalSetting
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  003ae	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
  003b4	83 c7 08	 add	 edi, 8
  003b7	8d 48 20	 lea	 ecx, DWORD PTR [eax+32]
  003ba	89 8d dc fc ff
	ff		 mov	 DWORD PTR tv2588[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2235 :         const value_type* _Result = _Bx._Buf;

  003c0	33 c9		 xor	 ecx, ecx
  003c2	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  003c5	1b c9		 sbb	 ecx, ecx
  003c7	83 e1 18	 and	 ecx, 24			; 00000018H
  003ca	83 c1 08	 add	 ecx, 8
  003cd	03 c8		 add	 ecx, eax

; 2236 :         if (_Large_string_engaged()) {

  003cf	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  003d3	72 02		 jb	 SHORT $LN350@LoadTerrai

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  003d5	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN350@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 250  : 	_snprintf(szRawHeightFieldname, sizeof(szRawHeightFieldname), "%s\\%06u\\height.raw", GetMapDataDirectory().c_str(), ulID);

  003d7	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _ulID$1$[ebp]
  003dd	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szRawHeightFieldname$[ebp]
  003e3	51		 push	 ecx
  003e4	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OEBGBMHL@?$CFs?2?$CF06u?2height?4raw@
  003e9	6a 41		 push	 65			; 00000041H
  003eb	50		 push	 eax
  003ec	e8 00 00 00 00	 call	 __snprintf
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  003f1	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 250  : 	_snprintf(szRawHeightFieldname, sizeof(szRawHeightFieldname), "%s\\%06u\\height.raw", GetMapDataDirectory().c_str(), ulID);

  003f7	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  003fa	8b cf		 mov	 ecx, edi

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  003fc	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  00400	0f 47 8d dc fc
	ff ff		 cmova	 ecx, DWORD PTR tv2588[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00407	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0040b	72 02		 jb	 SHORT $LN363@LoadTerrai

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0040d	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN363@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 251  : 	_snprintf(szSplatName, sizeof(szSplatName), "%s\\%06u\\tile.raw", GetMapDataDirectory().c_str(), ulID);

  0040f	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _ulID$1$[ebp]
  00415	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _szSplatName$[ebp]
  0041b	51		 push	 ecx
  0041c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KIEAEMGF@?$CFs?2?$CF06u?2tile?4raw@
  00421	6a 41		 push	 65			; 00000041H
  00423	50		 push	 eax
  00424	e8 00 00 00 00	 call	 __snprintf
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  00429	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 251  : 	_snprintf(szSplatName, sizeof(szSplatName), "%s\\%06u\\tile.raw", GetMapDataDirectory().c_str(), ulID);

  0042f	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  00432	8b cf		 mov	 ecx, edi

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  00434	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  00438	0f 47 8d dc fc
	ff ff		 cmova	 ecx, DWORD PTR tv2588[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0043f	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00443	72 02		 jb	 SHORT $LN376@LoadTerrai

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00445	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN376@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 252  : 	_snprintf(szAttrMapName, sizeof(szAttrMapName), "%s\\%06u\\attr.atr", GetMapDataDirectory().c_str(), ulID);

  00447	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _ulID$1$[ebp]
  0044d	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _szAttrMapName$[ebp]
  00453	51		 push	 ecx
  00454	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@MGHNOCIE@?$CFs?2?$CF06u?2attr?4atr@
  00459	6a 41		 push	 65			; 00000041H
  0045b	50		 push	 eax
  0045c	e8 00 00 00 00	 call	 __snprintf
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  00461	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 252  : 	_snprintf(szAttrMapName, sizeof(szAttrMapName), "%s\\%06u\\attr.atr", GetMapDataDirectory().c_str(), ulID);

  00467	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  0046a	8b cf		 mov	 ecx, edi

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  0046c	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  00470	0f 47 8d dc fc
	ff ff		 cmova	 ecx, DWORD PTR tv2588[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00477	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  0047b	72 02		 jb	 SHORT $LN389@LoadTerrai

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0047d	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN389@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 253  : 	_snprintf(szWaterMapName, sizeof(szWaterMapName), "%s\\%06u\\water.wtr", GetMapDataDirectory().c_str(), ulID);

  0047f	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _ulID$1$[ebp]
  00485	8d 45 ac	 lea	 eax, DWORD PTR _szWaterMapName$[ebp]
  00488	51		 push	 ecx
  00489	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@COFDKBDG@?$CFs?2?$CF06u?2water?4wtr@
  0048e	6a 41		 push	 65			; 00000041H
  00490	50		 push	 eax
  00491	e8 00 00 00 00	 call	 __snprintf
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  00496	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 253  : 	_snprintf(szWaterMapName, sizeof(szWaterMapName), "%s\\%06u\\water.wtr", GetMapDataDirectory().c_str(), ulID);

  0049c	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  0049f	8b cf		 mov	 ecx, edi

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  004a1	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  004a5	0f 47 8d dc fc
	ff ff		 cmova	 ecx, DWORD PTR tv2588[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  004ac	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  004b0	72 02		 jb	 SHORT $LN428@LoadTerrai

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  004b2	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN428@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 254  : 	_snprintf(szShadowTexName, sizeof(szShadowTexName), "%s\\%06u\\shadowmap.dds", GetMapDataDirectory().c_str(), ulID);

  004b4	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _ulID$1$[ebp]
  004ba	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _szShadowTexName$[ebp]
  004c0	51		 push	 ecx
  004c1	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JDDLCJKB@?$CFs?2?$CF06u?2shadowmap?4dds@
  004c6	6a 41		 push	 65			; 00000041H
  004c8	50		 push	 eax
  004c9	e8 00 00 00 00	 call	 __snprintf
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  004ce	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 254  : 	_snprintf(szShadowTexName, sizeof(szShadowTexName), "%s\\%06u\\shadowmap.dds", GetMapDataDirectory().c_str(), ulID);

  004d4	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  004d7	8b cf		 mov	 ecx, edi

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  004d9	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  004dd	0f 47 8d dc fc
	ff ff		 cmova	 ecx, DWORD PTR tv2588[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  004e4	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  004e8	72 02		 jb	 SHORT $LN408@LoadTerrai

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  004ea	8b 09		 mov	 ecx, DWORD PTR [ecx]
$LN408@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 255  : 	_snprintf(szShadowMapName, sizeof(szShadowMapName), "%s\\%06u\\shadowmap.raw", GetMapDataDirectory().c_str(), ulID);

  004ec	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _ulID$1$[ebp]
  004f2	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _szShadowMapName$[ebp]
  004f8	51		 push	 ecx
  004f9	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IEOOCGAN@?$CFs?2?$CF06u?2shadowmap?4raw@
  004fe	6a 41		 push	 65			; 00000041H
  00500	50		 push	 eax
  00501	e8 00 00 00 00	 call	 __snprintf
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  00506	8b 85 d8 fc ff
	ff		 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 255  : 	_snprintf(szShadowMapName, sizeof(szShadowMapName), "%s\\%06u\\shadowmap.raw", GetMapDataDirectory().c_str(), ulID);

  0050c	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  0050f	83 78 30 00	 cmp	 DWORD PTR [eax+48], 0

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  00513	0f 47 bd dc fc
	ff ff		 cmova	 edi, DWORD PTR tv2588[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0051a	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  0051e	72 02		 jb	 SHORT $LN421@LoadTerrai

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00520	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN421@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 256  : 	_snprintf(szMiniMapTexName, sizeof(szMiniMapTexName), "%s\\%06u\\minimap.dds", GetMapDataDirectory().c_str(), ulID);

  00522	ff b5 d4 fc ff
	ff		 push	 DWORD PTR _ulID$1$[ebp]
  00528	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _szMiniMapTexName$[ebp]
  0052e	57		 push	 edi
  0052f	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@OEFJKKPK@?$CFs?2?$CF06u?2minimap?4dds@
  00534	6a 41		 push	 65			; 00000041H
  00536	50		 push	 eax
  00537	e8 00 00 00 00	 call	 __snprintf
  0053c	83 c4 14	 add	 esp, 20			; 00000014H

; 257  : 
; 258  : 	if(!pTerrain->LoadWaterMap(szWaterMapName))

  0053f	8d 45 ac	 lea	 eax, DWORD PTR _szWaterMapName$[ebp]
  00542	8b ce		 mov	 ecx, esi
  00544	50		 push	 eax
  00545	e8 00 00 00 00	 call	 ?LoadWaterMap@CTerrainImpl@@QAE_NPBD@Z ; CTerrainImpl::LoadWaterMap
  0054a	8b bd c8 fc ff
	ff		 mov	 edi, DWORD PTR tv2577[ebp]
  00550	84 c0		 test	 al, al
  00552	75 15		 jne	 SHORT $LN7@LoadTerrai

; 259  : 		TraceError(" CMapOutdoor::LoadTerrain(%d, %d) LoadWaterMap ERROR", wTerrainCoordX, wTerrainCoordY);

  00554	8b 4d 0c	 mov	 ecx, DWORD PTR _wTerrainCoordY$[ebp]
  00557	0f b7 c1	 movzx	 eax, cx
  0055a	50		 push	 eax
  0055b	57		 push	 edi
  0055c	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@FPDAHDEG@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@
  00561	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00566	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@LoadTerrai:

; 260  : 
; 261  : 	if (!pTerrain->LoadHeightMap(szRawHeightFieldname))

  00569	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _szRawHeightFieldname$[ebp]
  0056f	8b ce		 mov	 ecx, esi
  00571	50		 push	 eax
  00572	e8 00 00 00 00	 call	 ?LoadHeightMap@CTerrain@@QAE_NPBD@Z ; CTerrain::LoadHeightMap
  00577	84 c0		 test	 al, al
  00579	75 15		 jne	 SHORT $LN8@LoadTerrai

; 262  : 		TraceError(" CMapOutdoor::LoadTerrain(%d, %d) LoadHeightMap ERROR", wTerrainCoordX, wTerrainCoordY);

  0057b	8b 4d 0c	 mov	 ecx, DWORD PTR _wTerrainCoordY$[ebp]
  0057e	0f b7 c1	 movzx	 eax, cx
  00581	50		 push	 eax
  00582	57		 push	 edi
  00583	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@DLOMPGBF@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@
  00588	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0058d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@LoadTerrai:

; 263  : 
; 264  : 	if (!pTerrain->LoadAttrMap(szAttrMapName))

  00590	8d 85 24 ff ff
	ff		 lea	 eax, DWORD PTR _szAttrMapName$[ebp]
  00596	8b ce		 mov	 ecx, esi
  00598	50		 push	 eax
  00599	e8 00 00 00 00	 call	 ?LoadAttrMap@CTerrain@@QAE_NPBD@Z ; CTerrain::LoadAttrMap
  0059e	84 c0		 test	 al, al
  005a0	75 15		 jne	 SHORT $LN9@LoadTerrai

; 265  : 		TraceError(" CMapOutdoor::LoadTerrain(%d, %d) LoadAttrMap ERROR", wTerrainCoordX, wTerrainCoordY);

  005a2	8b 4d 0c	 mov	 ecx, DWORD PTR _wTerrainCoordY$[ebp]
  005a5	0f b7 c1	 movzx	 eax, cx
  005a8	50		 push	 eax
  005a9	57		 push	 edi
  005aa	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@PJJDEPO@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@
  005af	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  005b4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@LoadTerrai:

; 266  : 
; 267  : 	if (!pTerrain->RAW_LoadTileMap(szSplatName))

  005b7	6a 00		 push	 0
  005b9	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR _szSplatName$[ebp]
  005bf	8b ce		 mov	 ecx, esi
  005c1	50		 push	 eax
  005c2	e8 00 00 00 00	 call	 ?RAW_LoadTileMap@CTerrain@@QAE_NPBD_N@Z ; CTerrain::RAW_LoadTileMap
  005c7	84 c0		 test	 al, al
  005c9	75 15		 jne	 SHORT $LN10@LoadTerrai

; 268  : 		TraceError(" CMapOutdoor::LoadTerrain(%d, %d) RAW_LoadTileMap ERROR", wTerrainCoordX, wTerrainCoordY);

  005cb	8b 4d 0c	 mov	 ecx, DWORD PTR _wTerrainCoordY$[ebp]
  005ce	0f b7 c1	 movzx	 eax, cx
  005d1	50		 push	 eax
  005d2	57		 push	 edi
  005d3	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@CJHIDJBM@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@
  005d8	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  005dd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN10@LoadTerrai:

; 269  : 
; 270  : 	pTerrain->LoadShadowTexture(szShadowTexName);

  005e0	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR _szShadowTexName$[ebp]
  005e6	8b ce		 mov	 ecx, esi
  005e8	50		 push	 eax
  005e9	e8 00 00 00 00	 call	 ?LoadShadowTexture@CTerrain@@QAEXPBD@Z ; CTerrain::LoadShadowTexture

; 271  : 
; 272  : 	if (!pTerrain->LoadShadowMap(szShadowMapName))

  005ee	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR _szShadowMapName$[ebp]
  005f4	8b ce		 mov	 ecx, esi
  005f6	50		 push	 eax
  005f7	e8 00 00 00 00	 call	 ?LoadShadowMap@CTerrain@@QAE_NPBD@Z ; CTerrain::LoadShadowMap
  005fc	84 c0		 test	 al, al
  005fe	75 15		 jne	 SHORT $LN11@LoadTerrai

; 273  : 		TraceError(" CMapOutdoor::LoadTerrain(%d, %d) LoadShadowMap ERROR", wTerrainCoordX, wTerrainCoordY);

  00600	8b 4d 0c	 mov	 ecx, DWORD PTR _wTerrainCoordY$[ebp]
  00603	0f b7 c1	 movzx	 eax, cx
  00606	50		 push	 eax
  00607	57		 push	 edi
  00608	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@BIPHGMEM@?5CMapOutdoor?3?3LoadTerrain?$CI?$CFd?0?5?$CF@
  0060d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00612	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN11@LoadTerrai:

; 274  : 
; 275  : 	pTerrain->LoadMiniMapTexture(szMiniMapTexName);

  00615	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR _szMiniMapTexName$[ebp]
  0061b	8b ce		 mov	 ecx, esi
  0061d	50		 push	 eax
  0061e	e8 00 00 00 00	 call	 ?LoadMiniMapTexture@CTerrain@@QAEXPBD@Z ; CTerrain::LoadMiniMapTexture
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00623	8b 85 c0 fc ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]
  00629	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0062d	72 02		 jb	 SHORT $LN473@LoadTerrai

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0062f	8b 00		 mov	 eax, DWORD PTR [eax]
$LN473@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 276  : 	pTerrain->SetName(c_rstrAreaName.c_str());

  00631	50		 push	 eax
  00632	8d 8d e4 fc ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00638	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Marty 5.5\Src-Client\Client\GameLib\AreaTerrain.h

; 99   : 		void			SetName(const std::string c_strName) { m_strName = c_strName; }

  0063d	8d 85 e4 fc ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00643	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00647	50		 push	 eax
  00648	8d 8e 54 a5 06
	00		 lea	 ecx, DWORD PTR [esi+435540]
  0064e	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  00653	8b 8d f8 fc ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\AreaTerrain.h

; 99   : 		void			SetName(const std::string c_strName) { m_strName = c_strName; }

  00659	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  0065d	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  00660	72 2f		 jb	 SHORT $LN447@LoadTerrai
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00662	8b 95 e4 fc ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00668	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00669	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0066b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00671	72 14		 jb	 SHORT $LN457@LoadTerrai

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00673	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00676	83 c1 23	 add	 ecx, 35			; 00000023H
  00679	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0067b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0067e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00681	0f 87 b0 00 00
	00		 ja	 $LN489@LoadTerrai
$LN457@LoadTerrai:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00687	51		 push	 ecx
  00688	52		 push	 edx
  00689	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0068e	83 c4 08	 add	 esp, 8
$LN447@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 277  : 	pTerrain->CalculateTerrainPatch();

  00691	8b ce		 mov	 ecx, esi
  00693	e8 00 00 00 00	 call	 ?CalculateTerrainPatch@CTerrain@@QAEXXZ ; CTerrain::CalculateTerrainPatch

; 278  : 
; 279  : 	pTerrain->SetReady();

  00698	c6 86 70 a5 06
	00 01		 mov	 BYTE PTR [esi+435568], 1

; 280  : 
; 281  : 	Tracef("CMapOutdoor::LoadTerrain %d\n", ELTimer_GetMSec() - dwStartTime);

  0069f	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  006a4	2b 85 bc fc ff
	ff		 sub	 eax, DWORD PTR _dwStartTime$1$[ebp]
  006aa	50		 push	 eax
  006ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@GEPFPGEO@CMapOutdoor?3?3LoadTerrain?5?$CFd?6@
  006b0	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef

; 282  : 
; 283  : 	m_TerrainVector.push_back(pTerrain);

  006b5	8b 8d d8 fc ff
	ff		 mov	 ecx, DWORD PTR _this$GSCopy$1$[ebp]
  006bb	83 c4 08	 add	 esp, 8
  006be	81 c1 18 09 00
	00		 add	 ecx, 2328		; 00000918H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 781  :         if (_Mylast != _My_data._Myend) {

  006c4	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  006c7	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  006ca	74 08		 je	 SHORT $LN466@LoadTerrai

; 797  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  006cc	89 30		 mov	 DWORD PTR [eax], esi

; 798  :         } else {
; 799  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 800  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 801  :             _ASAN_VECTOR_RELEASE_GUARD;
; 802  :         }
; 803  : 
; 804  :         _Orphan_range(_Mylast, _Mylast);
; 805  :         _Ty& _Result = *_Mylast;
; 806  :         ++_Mylast;

  006ce	83 41 04 04	 add	 DWORD PTR [ecx+4], 4

; 782  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  006d2	eb 0d		 jmp	 SHORT $LN465@LoadTerrai
$LN466@LoadTerrai:

; 783  :         }
; 784  : 
; 785  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  006d4	8d 95 c4 fc ff
	ff		 lea	 edx, DWORD PTR _pTerrain$[ebp]
  006da	52		 push	 edx
  006db	50		 push	 eax
  006dc	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_reallocate<CTerrain * const &>
$LN465@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 285  : 	return true;

  006e1	c6 85 e3 fc ff
	ff 01		 mov	 BYTE PTR $T3[ebp], 1
$LN22@LoadTerrai:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

  006e8	8b 85 cc fc ff
	ff		 mov	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  006ee	ff 70 04	 push	 DWORD PTR [eax+4]
  006f1	8d 85 cc fc ff
	ff		 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  006f7	50		 push	 eax
  006f8	8b c8		 mov	 ecx, eax
  006fa	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

  006ff	6a 34		 push	 52			; 00000034H
  00701	ff b5 cc fc ff
	ff		 push	 DWORD PTR _stTokenVectorMap$[ebp]
  00707	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 285  : 	return true;

  0070c	8a 85 e3 fc ff
	ff		 mov	 al, BYTE PTR $T3[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

  00712	83 c4 08	 add	 esp, 8
$LN1@LoadTerrai:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 286  : }

  00715	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00718	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0071f	59		 pop	 ecx
  00720	5f		 pop	 edi
  00721	5e		 pop	 esi
  00722	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00725	33 cd		 xor	 ecx, ebp
  00727	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0072c	8b e5		 mov	 esp, ebp
  0072e	5d		 pop	 ebp
  0072f	c2 10 00	 ret	 16			; 00000010H
$LN488@LoadTerrai:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00732	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN489@LoadTerrai:
  00737	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN486@LoadTerrai:
  0073c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z$0:
  00000	8d 8d cc fc ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z$3:
  0000b	8d 8d e4 fc ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z$4:
  00016	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z$18:
  00021	8d 8d e4 fc ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002c	cc		 int	 3
  0002d	cc		 int	 3
  0002e	cc		 int	 3
  0002f	cc		 int	 3
  00030	cc		 int	 3
__ehhandler$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z:
  00031	90		 npad	 1
  00032	90		 npad	 1
  00033	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00037	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003a	8b 8a bc fc ff
	ff		 mov	 ecx, DWORD PTR [edx-836]
  00040	33 c8		 xor	 ecx, eax
  00042	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00047	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0004a	33 c8		 xor	 ecx, eax
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z
  00056	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z ENDP		; CMapOutdoor::LoadTerrain
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
;	COMDAT ?LoadSetting@CMapOutdoor@@QAE_NPBD@Z
_TEXT	SEGMENT
__Result$1$ = -508					; size = 4
__Result$1$ = -504					; size = 4
__Result$1$ = -500					; size = 4
_c_rstrType$1$ = -496					; size = 4
_rkVec_strToken$1$ = -492				; size = 4
$T2 = -488						; size = 4
_this$GSCopy$1$ = -484					; size = 4
_stTokenVectorMap$ = -480				; size = 8
__Result$2$ = -472					; size = 4
__Result$1$ = -472					; size = 4
__Result$2$ = -472					; size = 4
$T3 = -472						; size = 1
$T4 = -472						; size = 4
$T5 = -472						; size = 4
$T6 = -472						; size = 4
$T7 = -472						; size = 4
$T8 = -472						; size = 4
$T9 = -472						; size = 4
$T10 = -472						; size = 4
$T11 = -465						; size = 1
__Matches$12 = -464					; size = 256
$T13 = -208						; size = 24
$T14 = -208						; size = 24
$T15 = -184						; size = 24
$T16 = -160						; size = 24
_strTextureSet$ = -136					; size = 24
$T17 = -112						; size = 24
__Loc$18 = -100						; size = 12
__Loc$19 = -100						; size = 12
$T20 = -88						; size = 24
$T21 = -88						; size = 24
_stTextureSetFileName$ = -64				; size = 24
$T22 = -40						; size = 24
$T23 = -40						; size = 24
$T24 = -40						; size = 24
$T25 = -40						; size = 24
$T26 = -40						; size = 24
$T27 = -40						; size = 24
$T28 = -40						; size = 24
$T29 = -40						; size = 24
$T30 = -40						; size = 24
$T31 = -40						; size = 24
$T32 = -40						; size = 24
$T33 = -40						; size = 24
$T34 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFileName$ = 8					; size = 4
?LoadSetting@CMapOutdoor@@QAE_NPBD@Z PROC		; CMapOutdoor::LoadSetting, COMDAT
; _this$ = ecx

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec f0 01 00
	00		 sub	 esp, 496		; 000001f0H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 8d 1c fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ecx
  00033	8b 75 08	 mov	 esi, DWORD PTR _c_szFileName$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

  00036	6a 34		 push	 52			; 00000034H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 289  : {

  00038	89 b5 18 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], esi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 437  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  0003e	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVectorMap$[ebp], 0
  00048	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _stTokenVectorMap$[ebp+4], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

  00052	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 347  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  00057	89 00		 mov	 DWORD PTR [eax], eax

; 348  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00059	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 349  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005c	89 40 08	 mov	 DWORD PTR [eax+8], eax

; 350  :         _Pnode->_Color = _Black;

  0005f	66 c7 40 0c 01
	01		 mov	 WORD PTR [eax+12], 257	; 00000101H

; 1943 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00065	89 85 20 fe ff
	ff		 mov	 DWORD PTR _stTokenVectorMap$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 292  : 	if (!LoadMultipleTextData(c_szFileName, stTokenVectorMap))

  0006b	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  00071	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00078	50		 push	 eax
  00079	56		 push	 esi
  0007a	e8 00 00 00 00	 call	 ?LoadMultipleTextData@@YA_NPBDAAV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@@Z ; LoadMultipleTextData
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	84 c0		 test	 al, al
  00084	75 18		 jne	 SHORT $LN2@LoadSettin

; 293  : 	{
; 294  : 		TraceError("MapOutdoor::LoadSetting(c_szFileName=%s) - LoadMultipleTextData", c_szFileName);

  00086	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EA@IGDFIJCO@MapOutdoor?3?3LoadSetting?$CIc_szFil@
  0008b	56		 push	 esi
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00092	c6 85 2f fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  00099	e9 ef 0c 00 00	 jmp	 $LN1309@LoadSettin
$LN2@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0009e	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@PCFMFEAG@scripttype@+8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  000a4	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  000aa	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2629 :             _My_data._Mysize = _Count;

  000ad	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR $T34[ebp+16], 10 ; 0000000aH

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  000b4	0f 11 45 d8	 movups	 XMMWORD PTR $T34[ebp], xmm0

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b8	66 89 45 e0	 mov	 WORD PTR $T34[ebp+8], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  000bc	8d 45 d8	 lea	 eax, DWORD PTR $T34[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bf	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@PCFMFEAG@scripttype@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  000c7	50		 push	 eax
  000c8	8d 45 9c	 lea	 eax, DWORD PTR __Loc$19[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  000cb	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T34[ebp+20], 15 ; 0000000fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  000d2	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d3	66 0f d6 45 d8	 movq	 QWORD PTR $T34[ebp], xmm0

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  000d8	c6 45 e2 00	 mov	 BYTE PTR $T34[ebp+10], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  000dc	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  000e1	8b 45 a4	 mov	 eax, DWORD PTR __Loc$19[ebp+8]
  000e4	8b bd 20 fe ff
	ff		 mov	 edi, DWORD PTR _stTokenVectorMap$[ebp]
  000ea	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  000ee	75 17		 jne	 SHORT $LN158@LoadSettin
  000f0	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

  000f3	50		 push	 eax
  000f4	8d 45 d8	 lea	 eax, DWORD PTR $T34[ebp]
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  000fd	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00100	84 c0		 test	 al, al

; 1370 :             return _Loc._Bound;

  00102	8b 45 a4	 mov	 eax, DWORD PTR __Loc$19[ebp+8]

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00105	74 02		 je	 SHORT $LN157@LoadSettin
$LN158@LoadSettin:

; 1373 :         return _Get_scary()->_Myhead;

  00107	8b c7		 mov	 eax, edi
$LN157@LoadSettin:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 298  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("scripttype"))

  00109	3b f8		 cmp	 edi, eax
  0010b	75 18		 jne	 SHORT $LN3@LoadSettin

; 299  : 	{
; 300  : 		TraceError("MapOutdoor::LoadSetting(c_szFileName=%s) - FIND 'scripttype' - FAILED", c_szFileName);
; 301  : 		return false;

  0010d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EG@NNBBNFDL@MapOutdoor?3?3LoadSetting?$CIc_szFil@
  00112	56		 push	 esi
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00119	c6 85 2f fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  00120	e9 68 0c 00 00	 jmp	 $LN1309@LoadSettin
$LN3@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00125	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@NLJHFBAM@viewradius@+8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0012b	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00131	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2629 :             _My_data._Mysize = _Count;

  00134	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR $T33[ebp+16], 10 ; 0000000aH

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0013b	0f 11 45 d8	 movups	 XMMWORD PTR $T33[ebp], xmm0

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0013f	66 89 45 e0	 mov	 WORD PTR $T33[ebp+8], ax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00143	8d 45 d8	 lea	 eax, DWORD PTR $T33[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00146	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@NLJHFBAM@viewradius@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  0014e	50		 push	 eax
  0014f	8d 45 9c	 lea	 eax, DWORD PTR __Loc$18[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  00152	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T33[ebp+20], 15 ; 0000000fH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00159	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0015a	66 0f d6 45 d8	 movq	 QWORD PTR $T33[ebp], xmm0

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  0015f	c6 45 e2 00	 mov	 BYTE PTR $T33[ebp+10], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1368 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00163	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00168	8b 45 a4	 mov	 eax, DWORD PTR __Loc$18[ebp+8]
  0016b	80 78 0d 00	 cmp	 BYTE PTR [eax+13], 0
  0016f	75 17		 jne	 SHORT $LN249@LoadSettin
  00171	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\type_traits

; 2465 :         return _Left < _Right;

  00174	50		 push	 eax
  00175	8d 45 d8	 lea	 eax, DWORD PTR $T33[ebp]
  00178	50		 push	 eax
  00179	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0017e	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00181	84 c0		 test	 al, al

; 1370 :             return _Loc._Bound;

  00183	8b 45 a4	 mov	 eax, DWORD PTR __Loc$18[ebp+8]

; 1607 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00186	74 02		 je	 SHORT $LN248@LoadSettin
$LN249@LoadSettin:

; 1373 :         return _Get_scary()->_Myhead;

  00188	8b c7		 mov	 eax, edi
$LN248@LoadSettin:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 304  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("viewradius"))

  0018a	3b f8		 cmp	 edi, eax
  0018c	75 18		 jne	 SHORT $LN4@LoadSettin

; 305  : 	{
; 306  : 		TraceError("MapOutdoor::LoadSetting(c_szFileName=%s) - FIND 'viewradius' - FAILED", c_szFileName);
; 307  : 		return false;

  0018e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EG@PNENCHJD@MapOutdoor?3?3LoadSetting?$CIc_szFil@
  00193	56		 push	 esi
  00194	50		 push	 eax
  00195	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0019a	c6 85 2f fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  001a1	e9 e7 0b 00 00	 jmp	 $LN1309@LoadSettin
$LN4@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001a6	a0 08 00 00 00	 mov	 al, BYTE PTR ??_C@_09HCPKDAEG@cellscale@+8
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 310  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("cellscale"))

  001ab	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  001b1	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2629 :             _My_data._Mysize = _Count;

  001b4	c7 45 e8 09 00
	00 00		 mov	 DWORD PTR $T32[ebp+16], 9

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  001bb	0f 11 45 d8	 movups	 XMMWORD PTR $T32[ebp], xmm0

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001bf	88 45 e0	 mov	 BYTE PTR $T32[ebp+8], al
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 310  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("cellscale"))

  001c2	8d 45 d8	 lea	 eax, DWORD PTR $T32[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001c5	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_09HCPKDAEG@cellscale@
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 310  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("cellscale"))

  001cd	50		 push	 eax
  001ce	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  001d4	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T32[ebp+20], 15 ; 0000000fH
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 310  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("cellscale"))

  001db	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  001dc	66 0f d6 45 d8	 movq	 QWORD PTR $T32[ebp], xmm0

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  001e1	c6 45 e1 00	 mov	 BYTE PTR $T32[ebp+9], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 310  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("cellscale"))

  001e5	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  001ea	3b 38		 cmp	 edi, DWORD PTR [eax]
  001ec	75 18		 jne	 SHORT $LN5@LoadSettin

; 311  : 	{
; 312  : 		TraceError("MapOutdoor::LoadSetting(c_szFileName=%s) - FIND 'cellscale' - FAILED", c_szFileName);
; 313  : 		return false;

  001ee	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EF@BILODNMF@MapOutdoor?3?3LoadSetting?$CIc_szFil@
  001f3	56		 push	 esi
  001f4	50		 push	 eax
  001f5	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001fa	c6 85 2f fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  00201	e9 87 0b 00 00	 jmp	 $LN1309@LoadSettin
$LN5@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00206	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0M@MNHNKMP@heightscale@+8
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 316  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("heightscale"))

  0020c	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00212	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0M@MNHNKMP@heightscale@
  0021a	66 89 45 e0	 mov	 WORD PTR $T31[ebp+8], ax
  0021e	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0M@MNHNKMP@heightscale@+10
  00223	88 45 e2	 mov	 BYTE PTR $T31[ebp+10], al
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 316  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("heightscale"))

  00226	8d 45 d8	 lea	 eax, DWORD PTR $T31[ebp]
  00229	50		 push	 eax
  0022a	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00230	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T31[ebp+12], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 316  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("heightscale"))

  00237	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2629 :             _My_data._Mysize = _Count;

  00238	c7 45 e8 0b 00
	00 00		 mov	 DWORD PTR $T31[ebp+16], 11 ; 0000000bH

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  0023f	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T31[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00246	66 0f d6 45 d8	 movq	 QWORD PTR $T31[ebp], xmm0

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  0024b	c6 45 e3 00	 mov	 BYTE PTR $T31[ebp+11], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 316  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("heightscale"))

  0024f	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  00254	3b 38		 cmp	 edi, DWORD PTR [eax]
  00256	75 18		 jne	 SHORT $LN6@LoadSettin

; 317  : 	{
; 318  : 		TraceError("MapOutdoor::LoadSetting(c_szFileName=%s) - FIND 'heightscale' - FAILED", c_szFileName);
; 319  : 		return false;

  00258	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EH@FNDNEACP@MapOutdoor?3?3LoadSetting?$CIc_szFil@
  0025d	56		 push	 esi
  0025e	50		 push	 eax
  0025f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00264	c6 85 2f fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  0026b	e9 1d 0b 00 00	 jmp	 $LN1309@LoadSettin
$LN6@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00270	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07EOGAIPJO@mapsize@
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 322  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("mapsize"))

  00275	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0027b	89 45 d8	 mov	 DWORD PTR $T30[ebp], eax
  0027e	0f 57 c0	 xorps	 xmm0, xmm0
  00281	66 a1 04 00 00
	00		 mov	 ax, WORD PTR ??_C@_07EOGAIPJO@mapsize@+4
  00287	66 89 45 dc	 mov	 WORD PTR $T30[ebp+4], ax
  0028b	a0 06 00 00 00	 mov	 al, BYTE PTR ??_C@_07EOGAIPJO@mapsize@+6
  00290	88 45 de	 mov	 BYTE PTR $T30[ebp+6], al
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 322  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("mapsize"))

  00293	8d 45 d8	 lea	 eax, DWORD PTR $T30[ebp]
  00296	50		 push	 eax
  00297	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0029d	66 0f 13 45 e0	 movlpd	 QWORD PTR $T30[ebp+8], xmm0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 322  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("mapsize"))

  002a2	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2629 :             _My_data._Mysize = _Count;

  002a3	c7 45 e8 07 00
	00 00		 mov	 DWORD PTR $T30[ebp+16], 7

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  002aa	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T30[ebp+20], 15 ; 0000000fH

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  002b1	c6 45 df 00	 mov	 BYTE PTR $T30[ebp+7], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 322  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("mapsize"))

  002b5	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  002ba	3b 38		 cmp	 edi, DWORD PTR [eax]
  002bc	75 18		 jne	 SHORT $LN7@LoadSettin

; 323  : 	{
; 324  : 		TraceError("MapOutdoor::LoadSetting(c_szFileName=%s) - FIND 'mapsize' - FAILED", c_szFileName);
; 325  : 		return false;

  002be	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0ED@JGKHJMHO@MapOutdoor?3?3LoadSetting?$CIc_szFil@
  002c3	56		 push	 esi
  002c4	50		 push	 eax
  002c5	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  002ca	c6 85 2f fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  002d1	e9 b7 0a 00 00	 jmp	 $LN1309@LoadSettin
$LN7@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  002d6	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@FLIBEPMB@textureset@+8
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 328  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("textureset"))

  002dc	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  002e2	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2629 :             _My_data._Mysize = _Count;

  002e5	c7 45 e8 0a 00
	00 00		 mov	 DWORD PTR $T29[ebp+16], 10 ; 0000000aH

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  002ec	0f 11 45 d8	 movups	 XMMWORD PTR $T29[ebp], xmm0

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  002f0	66 89 45 e0	 mov	 WORD PTR $T29[ebp+8], ax
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 328  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("textureset"))

  002f4	8d 45 d8	 lea	 eax, DWORD PTR $T29[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  002f7	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@FLIBEPMB@textureset@
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 328  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("textureset"))

  002ff	50		 push	 eax
  00300	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  00306	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T29[ebp+20], 15 ; 0000000fH
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 328  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("textureset"))

  0030d	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0030e	66 0f d6 45 d8	 movq	 QWORD PTR $T29[ebp], xmm0

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00313	c6 45 e2 00	 mov	 BYTE PTR $T29[ebp+10], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 328  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("textureset"))

  00317	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  0031c	3b 38		 cmp	 edi, DWORD PTR [eax]
  0031e	75 18		 jne	 SHORT $LN8@LoadSettin

; 329  : 	{
; 330  : 		TraceError("MapOutdoor::LoadSetting(c_szFileName=%s) - FIND 'textureset' - FAILED", c_szFileName);
; 331  : 		return false;

  00320	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EG@CGMMOJDP@MapOutdoor?3?3LoadSetting?$CIc_szFil@
  00325	56		 push	 esi
  00326	50		 push	 eax
  00327	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0032c	c6 85 2f fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  00333	e9 55 0a 00 00	 jmp	 $LN1309@LoadSettin
$LN8@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00338	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0P@DDEPCBBP@terrainvisible@+8
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 334  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("terrainvisible"))

  0033d	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00343	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0P@DDEPCBBP@terrainvisible@
  0034b	89 45 e0	 mov	 DWORD PTR $T28[ebp+8], eax
  0034e	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0P@DDEPCBBP@terrainvisible@+12
  00354	66 89 45 e4	 mov	 WORD PTR $T28[ebp+12], ax
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 334  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("terrainvisible"))

  00358	8d 45 d8	 lea	 eax, DWORD PTR $T28[ebp]
  0035b	50		 push	 eax
  0035c	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00362	66 c7 45 e6 00
	00		 mov	 WORD PTR $T28[ebp+14], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 334  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("terrainvisible"))

  00368	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2629 :             _My_data._Mysize = _Count;

  00369	c7 45 e8 0e 00
	00 00		 mov	 DWORD PTR $T28[ebp+16], 14 ; 0000000eH

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  00370	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T28[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00377	66 0f d6 45 d8	 movq	 QWORD PTR $T28[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 334  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("terrainvisible"))

  0037c	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  00381	3b 38		 cmp	 edi, DWORD PTR [eax]
  00383	74 7e		 je	 SHORT $LN9@LoadSettin
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00385	a1 08 00 00 00	 mov	 eax, DWORD PTR ??_C@_0P@DDEPCBBP@terrainvisible@+8
  0038a	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0038d	0f 11 45 a8	 movups	 XMMWORD PTR $T21[ebp], xmm0

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00391	89 45 b0	 mov	 DWORD PTR $T21[ebp+8], eax
  00394	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0P@DDEPCBBP@terrainvisible@
  0039c	66 a1 0c 00 00
	00		 mov	 ax, WORD PTR ??_C@_0P@DDEPCBBP@terrainvisible@+12

; 2629 :             _My_data._Mysize = _Count;

  003a2	c7 45 b8 0e 00
	00 00		 mov	 DWORD PTR $T21[ebp+16], 14 ; 0000000eH

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  003a9	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR $T21[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003b0	66 0f d6 45 a8	 movq	 QWORD PTR $T21[ebp], xmm0
  003b5	66 89 45 b4	 mov	 WORD PTR $T21[ebp+12], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  003b9	c6 45 b6 00	 mov	 BYTE PTR $T21[ebp+14], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 336  : 		m_bSettingTerrainVisible = (bool) (atoi(stTokenVectorMap["terrainvisible"][0].c_str()) != 0);

  003bd	8d 45 a8	 lea	 eax, DWORD PTR $T21[ebp]
  003c0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  003c4	50		 push	 eax
  003c5	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  003cb	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4107 :         return _Mypair._Myval2._Myptr();

  003d0	8b 00		 mov	 eax, DWORD PTR [eax]

; 2236 :         if (_Large_string_engaged()) {

  003d2	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  003d6	72 02		 jb	 SHORT $LN1068@LoadSettin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  003d8	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1068@LoadSettin:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 336  : 		m_bSettingTerrainVisible = (bool) (atoi(stTokenVectorMap["terrainvisible"][0].c_str()) != 0);

  003da	50		 push	 eax
  003db	e8 00 00 00 00	 call	 __atoi64
  003e0	83 c4 04	 add	 esp, 4
  003e3	0b c2		 or	 eax, edx
  003e5	74 04		 je	 SHORT $LN21@LoadSettin
  003e7	b0 01		 mov	 al, 1
  003e9	eb 02		 jmp	 SHORT $LN22@LoadSettin
$LN21@LoadSettin:
  003eb	32 c0		 xor	 al, al
$LN22@LoadSettin:
  003ed	8b bd 1c fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  003f3	8d 4d a8	 lea	 ecx, DWORD PTR $T21[ebp]
  003f6	88 87 ac 13 00
	00		 mov	 BYTE PTR [edi+5036], al
  003fc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 337  : 	}

  00401	eb 0d		 jmp	 SHORT $LN10@LoadSettin
$LN9@LoadSettin:

; 338  : 	else
; 339  : 	{
; 340  : 		m_bSettingTerrainVisible = true;

  00403	8b bd 1c fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00409	c6 87 ac 13 00
	00 01		 mov	 BYTE PTR [edi+5036], 1
$LN10@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00410	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@PCFMFEAG@scripttype@+8
  00416	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00419	0f 11 85 60 ff
	ff ff		 movups	 XMMWORD PTR $T16[ebp], xmm0

; 2629 :             _My_data._Mysize = _Count;

  00420	c7 85 70 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR $T16[ebp+16], 10 ; 0000000aH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0042a	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@PCFMFEAG@scripttype@

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  00432	c7 85 74 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0043c	66 0f d6 85 60
	ff ff ff	 movq	 QWORD PTR $T16[ebp], xmm0
  00444	66 89 85 68 ff
	ff ff		 mov	 WORD PTR $T16[ebp+8], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  0044b	c6 85 6a ff ff
	ff 00		 mov	 BYTE PTR $T16[ebp+10], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 343  : 	const std::string & c_rstrType = stTokenVectorMap["scripttype"][0];

  00452	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  00458	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0045c	50		 push	 eax
  0045d	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00463	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00468	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 343  : 	const std::string & c_rstrType = stTokenVectorMap["scripttype"][0];

  0046e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  00472	8b 00		 mov	 eax, DWORD PTR [eax]
  00474	89 85 10 fe ff
	ff		 mov	 DWORD PTR _c_rstrType$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  0047a	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0047d	72 2f		 jb	 SHORT $LN816@LoadSettin
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0047f	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR $T16[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00485	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00486	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00488	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0048e	72 14		 jb	 SHORT $LN826@LoadSettin

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00490	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00493	83 c1 23	 add	 ecx, 35			; 00000023H
  00496	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00498	83 c0 fc	 add	 eax, -4			; fffffffcH
  0049b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0049e	0f 87 3b 09 00
	00		 ja	 $LN1312@LoadSettin
$LN826@LoadSettin:

; 265  :         ::operator delete(_Ptr, _Bytes);

  004a4	51		 push	 ecx
  004a5	52		 push	 edx
  004a6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  004ab	83 c4 08	 add	 esp, 8
$LN816@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  004ae	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@NLJHFBAM@viewradius@+8
  004b4	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  004b7	0f 11 85 48 ff
	ff ff		 movups	 XMMWORD PTR $T15[ebp], xmm0

; 4841 :         _My_data._Mysize = 0;

  004be	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+16], 0

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  004c8	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@NLJHFBAM@viewradius@

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  004d0	c7 85 74 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T16[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  004da	c6 85 60 ff ff
	ff 00		 mov	 BYTE PTR $T16[ebp], 0

; 2629 :             _My_data._Mysize = _Count;

  004e1	c7 85 58 ff ff
	ff 0a 00 00 00	 mov	 DWORD PTR $T15[ebp+16], 10 ; 0000000aH

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  004eb	c7 85 5c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T15[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  004f5	66 0f d6 85 48
	ff ff ff	 movq	 QWORD PTR $T15[ebp], xmm0
  004fd	66 89 85 50 ff
	ff ff		 mov	 WORD PTR $T15[ebp+8], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00504	c6 85 52 ff ff
	ff 00		 mov	 BYTE PTR $T15[ebp+10], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 344  : 	const std::string & c_rstrViewRadius = stTokenVectorMap["viewradius"][0];

  0050b	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00511	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00515	50		 push	 eax
  00516	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  0051c	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00521	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR $T15[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 344  : 	const std::string & c_rstrViewRadius = stTokenVectorMap["viewradius"][0];

  00527	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  0052b	8b 00		 mov	 eax, DWORD PTR [eax]
  0052d	89 85 0c fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00533	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00536	72 2f		 jb	 SHORT $LN882@LoadSettin
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00538	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR $T15[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0053e	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0053f	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00541	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00547	72 14		 jb	 SHORT $LN892@LoadSettin

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00549	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0054c	83 c1 23	 add	 ecx, 35			; 00000023H
  0054f	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00551	83 c0 fc	 add	 eax, -4			; fffffffcH
  00554	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00557	0f 87 87 08 00
	00		 ja	 $LN1313@LoadSettin
$LN892@LoadSettin:

; 265  :         ::operator delete(_Ptr, _Bytes);

  0055d	51		 push	 ecx
  0055e	52		 push	 edx
  0055f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00564	83 c4 08	 add	 esp, 8
$LN882@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00567	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0M@MNHNKMP@heightscale@+8
  0056e	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00571	0f 11 85 30 ff
	ff ff		 movups	 XMMWORD PTR $T14[ebp], xmm0

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00578	66 89 85 38 ff
	ff ff		 mov	 WORD PTR $T14[ebp+8], ax
  0057f	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0M@MNHNKMP@heightscale@
  00587	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0M@MNHNKMP@heightscale@+10

; 4841 :         _My_data._Mysize = 0;

  0058c	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00596	c7 85 5c ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T15[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  005a0	c6 85 48 ff ff
	ff 00		 mov	 BYTE PTR $T15[ebp], 0

; 2629 :             _My_data._Mysize = _Count;

  005a7	c7 85 40 ff ff
	ff 0b 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 11 ; 0000000bH

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  005b1	c7 85 44 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  005bb	66 0f d6 85 30
	ff ff ff	 movq	 QWORD PTR $T14[ebp], xmm0
  005c3	88 85 3a ff ff
	ff		 mov	 BYTE PTR $T14[ebp+10], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  005c9	c6 85 3b ff ff
	ff 00		 mov	 BYTE PTR $T14[ebp+11], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 346  : 	const std::string & c_rstrHeightScale = stTokenVectorMap["heightscale"][0];

  005d0	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  005d6	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  005da	50		 push	 eax
  005db	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  005e1	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
  005e6	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  005ec	8b 00		 mov	 eax, DWORD PTR [eax]
  005ee	89 85 08 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 346  : 	const std::string & c_rstrHeightScale = stTokenVectorMap["heightscale"][0];

  005f4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  005f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07EOGAIPJO@mapsize@
  005fe	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00601	0f 11 45 90	 movups	 XMMWORD PTR $T17[ebp], xmm0

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00605	89 45 90	 mov	 DWORD PTR $T17[ebp], eax
  00608	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_07EOGAIPJO@mapsize@+4
  0060f	66 89 45 94	 mov	 WORD PTR $T17[ebp+4], ax
  00613	a0 06 00 00 00	 mov	 al, BYTE PTR ??_C@_07EOGAIPJO@mapsize@+6

; 2629 :             _My_data._Mysize = _Count;

  00618	c7 45 a0 07 00
	00 00		 mov	 DWORD PTR $T17[ebp+16], 7

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  0061f	c7 45 a4 0f 00
	00 00		 mov	 DWORD PTR $T17[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00626	88 45 96	 mov	 BYTE PTR $T17[ebp+6], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00629	c6 45 97 00	 mov	 BYTE PTR $T17[ebp+7], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 347  : 	const std::string & c_rstrMapSizeX = stTokenVectorMap["mapsize"][0];

  0062d	8d 45 90	 lea	 eax, DWORD PTR $T17[ebp]
  00630	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00634	50		 push	 eax
  00635	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  0063b	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00640	8b 4d a4	 mov	 ecx, DWORD PTR $T17[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 347  : 	const std::string & c_rstrMapSizeX = stTokenVectorMap["mapsize"][0];

  00643	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  00647	8b 00		 mov	 eax, DWORD PTR [eax]
  00649	89 85 28 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  0064f	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00652	72 2c		 jb	 SHORT $LN1012@LoadSettin
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00654	8b 55 90	 mov	 edx, DWORD PTR $T17[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00657	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00658	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0065a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00660	72 14		 jb	 SHORT $LN1022@LoadSettin

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00662	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00665	83 c1 23	 add	 ecx, 35			; 00000023H
  00668	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0066a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0066d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00670	0f 87 73 07 00
	00		 ja	 $LN1314@LoadSettin
$LN1022@LoadSettin:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00676	51		 push	 ecx
  00677	52		 push	 edx
  00678	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0067d	83 c4 08	 add	 esp, 8
$LN1012@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00680	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_07EOGAIPJO@mapsize@
  00685	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00688	0f 11 45 d8	 movups	 XMMWORD PTR $T27[ebp], xmm0

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0068c	89 45 d8	 mov	 DWORD PTR $T27[ebp], eax
  0068f	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_07EOGAIPJO@mapsize@+4
  00696	66 89 45 dc	 mov	 WORD PTR $T27[ebp+4], ax
  0069a	a0 06 00 00 00	 mov	 al, BYTE PTR ??_C@_07EOGAIPJO@mapsize@+6

; 4841 :         _My_data._Mysize = 0;

  0069f	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T17[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  006a6	c7 45 a4 0f 00
	00 00		 mov	 DWORD PTR $T17[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  006ad	c6 45 90 00	 mov	 BYTE PTR $T17[ebp], 0

; 2629 :             _My_data._Mysize = _Count;

  006b1	c7 45 e8 07 00
	00 00		 mov	 DWORD PTR $T27[ebp+16], 7

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  006b8	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T27[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  006bf	88 45 de	 mov	 BYTE PTR $T27[ebp+6], al

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  006c2	c6 45 df 00	 mov	 BYTE PTR $T27[ebp+7], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 348  : 	const std::string & c_rstrMapSizeY = stTokenVectorMap["mapsize"][1];

  006c6	8d 45 d8	 lea	 eax, DWORD PTR $T27[ebp]
  006c9	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  006cd	50		 push	 eax
  006ce	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  006d4	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
  006d9	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  006dc	8b 00		 mov	 eax, DWORD PTR [eax]
  006de	83 c0 18	 add	 eax, 24			; 00000018H
  006e1	89 85 04 fe ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], eax
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 348  : 	const std::string & c_rstrMapSizeY = stTokenVectorMap["mapsize"][1];

  006e7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  006ec	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

  006ef	c7 45 8c 0f 00
	00 00		 mov	 DWORD PTR _strTextureSet$[ebp+20], 15 ; 0000000fH
  006f6	33 c9		 xor	 ecx, ecx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  006f8	0f 11 85 78 ff
	ff ff		 movups	 XMMWORD PTR _strTextureSet$[ebp], xmm0

; 4821 :         _My_data._Mysize = 0;

  006ff	89 4d 88	 mov	 DWORD PTR _strTextureSet$[ebp+16], ecx

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00702	88 8d 78 ff ff
	ff		 mov	 BYTE PTR _strTextureSet$[ebp], cl

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00708	0f b7 05 08 00
	00 00		 movzx	 eax, WORD PTR ??_C@_0L@FLIBEPMB@textureset@+8

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0070f	0f 11 45 a8	 movups	 XMMWORD PTR $T20[ebp], xmm0

; 2629 :             _My_data._Mysize = _Count;

  00713	c7 45 b8 0a 00
	00 00		 mov	 DWORD PTR $T20[ebp+16], 10 ; 0000000aH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0071a	f3 0f 7e 05 00
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0L@FLIBEPMB@textureset@

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;

  00722	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR $T20[ebp+20], 15 ; 0000000fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00729	66 0f d6 45 a8	 movq	 QWORD PTR $T20[ebp], xmm0
  0072e	66 89 45 b0	 mov	 WORD PTR $T20[ebp+8], ax

; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00732	88 4d b2	 mov	 BYTE PTR $T20[ebp+10], cl
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 351  : 	TTokenVector & rkVec_strToken = stTokenVectorMap["textureset"];

  00735	8d 45 a8	 lea	 eax, DWORD PTR $T20[ebp]
  00738	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0073c	50		 push	 eax
  0073d	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00743	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
  00748	8b c8		 mov	 ecx, eax
  0074a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  0074e	8b 45 bc	 mov	 eax, DWORD PTR $T20[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 351  : 	TTokenVector & rkVec_strToken = stTokenVectorMap["textureset"];

  00751	89 8d 14 fe ff
	ff		 mov	 DWORD PTR _rkVec_strToken$1$[ebp], ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  00757	83 f8 10	 cmp	 eax, 16			; 00000010H
  0075a	72 34		 jb	 SHORT $LN983@LoadSettin
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0075c	8b 55 a8	 mov	 edx, DWORD PTR $T20[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0075f	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00762	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00764	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0076a	72 14		 jb	 SHORT $LN993@LoadSettin

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0076c	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0076f	83 c1 23	 add	 ecx, 35			; 00000023H
  00772	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00774	83 c0 fc	 add	 eax, -4			; fffffffcH
  00777	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0077a	0f 87 6e 06 00
	00		 ja	 $LN1315@LoadSettin
$LN993@LoadSettin:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00780	51		 push	 ecx
  00781	52		 push	 edx
  00782	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00787	8b 8d 14 fe ff
	ff		 mov	 ecx, DWORD PTR _rkVec_strToken$1$[ebp]
  0078d	83 c4 08	 add	 esp, 8
$LN983@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

  00790	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T20[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00797	c7 45 bc 0f 00
	00 00		 mov	 DWORD PTR $T20[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0079e	c6 45 a8 00	 mov	 BYTE PTR $T20[ebp], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1864 :         return _My_data._Myfirst == _My_data._Mylast;

  007a2	8b 01		 mov	 eax, DWORD PTR [ecx]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 352  : 	if (!rkVec_strToken.empty())

  007a4	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  007a7	74 0c		 je	 SHORT $LN11@LoadSettin

; 353  : 	{
; 354  : 		strTextureSet = rkVec_strToken[0];

  007a9	50		 push	 eax
  007aa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _strTextureSet$[ebp]
  007b0	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
$LN11@LoadSettin:

; 355  : 	}
; 356  : 
; 357  : 	if (c_rstrType != "MapSetting")

  007b5	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PHDPILBM@MapSetting@
  007ba	ff b5 10 fe ff
	ff		 push	 DWORD PTR _c_rstrType$1$[ebp]
  007c0	e8 00 00 00 00	 call	 ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
  007c5	83 c4 08	 add	 esp, 8
  007c8	84 c0		 test	 al, al
  007ca	74 1b		 je	 SHORT $LN12@LoadSettin

; 358  : 	{
; 359  : 		TraceError("MapOutdoor::LoadSetting(c_szFileName=%s) - Resourse Type ERROR", c_szFileName);

  007cc	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0DP@BHJEEKBL@MapOutdoor?3?3LoadSetting?$CIc_szFil@
  007d1	56		 push	 esi
  007d2	50		 push	 eax
  007d3	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  007d8	83 c4 08	 add	 esp, 8
  007db	c6 85 2f fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  007e2	e9 74 05 00 00	 jmp	 $LN1310@LoadSettin
$LN12@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  007e7	8b 85 0c fe ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]
  007ed	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  007f1	72 02		 jb	 SHORT $LN1061@LoadSettin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  007f3	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1061@LoadSettin:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 363  : 	m_lViewRadius = atol(c_rstrViewRadius.c_str());

  007f5	50		 push	 eax
  007f6	e8 00 00 00 00	 call	 _atol
  007fb	83 c4 04	 add	 esp, 4
  007fe	89 47 68	 mov	 DWORD PTR [edi+104], eax

; 364  : 
; 365  : #ifdef WORLD_EDITOR
; 366  : 	m_lViewRadius <<= 1;
; 367  : #endif
; 368  : 
; 369  : 	if (0L >= m_lViewRadius)

  00801	85 c0		 test	 eax, eax
  00803	7f 1b		 jg	 SHORT $LN13@LoadSettin

; 370  : 	{
; 371  : 		TraceError("MapOutdoor::LoadSetting(c_szFileName=%s) - VIEWRADIUS IS NOT GREATER THAN 0", c_szFileName);
; 372  : 		return false;

  00805	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0EM@PIICKGLP@MapOutdoor?3?3LoadSetting?$CIc_szFil@
  0080a	56		 push	 esi
  0080b	50		 push	 eax
  0080c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00811	83 c4 08	 add	 esp, 8
  00814	c6 85 2f fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  0081b	e9 3b 05 00 00	 jmp	 $LN1310@LoadSettin
$LN13@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00820	8b 85 08 fe ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]
  00826	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0082a	72 02		 jb	 SHORT $LN1154@LoadSettin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0082c	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1154@LoadSettin:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 375  : 	m_fHeightScale = atof(c_rstrHeightScale.c_str());

  0082e	50		 push	 eax
  0082f	e8 00 00 00 00	 call	 _atof
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00834	8b 85 04 fe ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 375  : 	m_fHeightScale = atof(c_rstrHeightScale.c_str());

  0083a	83 c4 04	 add	 esp, 4
  0083d	d9 5f 6c	 fstp	 DWORD PTR [edi+108]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00840	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00844	72 02		 jb	 SHORT $LN1161@LoadSettin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00846	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1161@LoadSettin:

; 2236 :         if (_Large_string_engaged()) {

  00848	8b b5 28 fe ff
	ff		 mov	 esi, DWORD PTR __Result$1$[ebp]
  0084e	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00852	72 02		 jb	 SHORT $LN1168@LoadSettin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00854	8b 36		 mov	 esi, DWORD PTR [esi]
$LN1168@LoadSettin:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 377  : 	SetTerrainCount(atoi(c_rstrMapSizeX.c_str()), atoi(c_rstrMapSizeY.c_str()));

  00856	50		 push	 eax
  00857	e8 00 00 00 00	 call	 __atoi64
  0085c	83 c4 04	 add	 esp, 4
  0085f	0f b7 c0	 movzx	 eax, ax
  00862	50		 push	 eax
  00863	56		 push	 esi
  00864	e8 00 00 00 00	 call	 __atoi64
  00869	83 c4 04	 add	 esp, 4
  0086c	0f b7 c0	 movzx	 eax, ax
  0086f	8b cf		 mov	 ecx, edi
  00871	50		 push	 eax
  00872	e8 00 00 00 00	 call	 ?SetTerrainCount@CMapOutdoor@@QAE_NFF@Z ; CMapOutdoor::SetTerrainCount

; 381  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("baseposition"))

  00877	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IEEHNMJN@baseposition@
  0087c	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
  0087f	c7 87 08 09 00
	00 0a d7 a3 39	 mov	 DWORD PTR [edi+2312], 967038730 ; 39a3d70aH
  00889	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0088e	8b bd 20 fe ff
	ff		 mov	 edi, DWORD PTR _stTokenVectorMap$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 381  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("baseposition"))

  00894	8d 45 d8	 lea	 eax, DWORD PTR $T26[ebp]
  00897	50		 push	 eax
  00898	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0089e	50		 push	 eax
  0089f	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  008a5	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  008aa	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 233  :         return this->_Ptr == _Right._Ptr;

  008ad	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 381  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("baseposition"))

  008af	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  008b4	3b fe		 cmp	 edi, esi
  008b6	0f 84 9b 00 00
	00		 je	 $LN1305@LoadSettin

; 383  : 		const std::string & c_rstrMapBaseX = stTokenVectorMap["baseposition"][0];

  008bc	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IEEHNMJN@baseposition@
  008c1	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  008c4	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  008c9	8d 45 d8	 lea	 eax, DWORD PTR $T25[ebp]
  008cc	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  008d0	50		 push	 eax
  008d1	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  008d7	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
  008dc	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  008df	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  008e3	8b 38		 mov	 edi, DWORD PTR [eax]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 383  : 		const std::string & c_rstrMapBaseX = stTokenVectorMap["baseposition"][0];

  008e5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 384  : 		const std::string & c_rstrMapBaseY = stTokenVectorMap["baseposition"][1];

  008ea	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IEEHNMJN@baseposition@
  008ef	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  008f5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  008fa	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00900	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00904	50		 push	 eax
  00905	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  0090b	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
  00910	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00916	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1889 :         return _My_data._Myfirst[_Pos];

  0091a	8b 30		 mov	 esi, DWORD PTR [eax]
  0091c	83 c6 18	 add	 esi, 24			; 00000018H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 384  : 		const std::string & c_rstrMapBaseY = stTokenVectorMap["baseposition"][1];

  0091f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00924	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00928	72 02		 jb	 SHORT $LN1226@LoadSettin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0092a	8b 36		 mov	 esi, DWORD PTR [esi]
$LN1226@LoadSettin:

; 2236 :         if (_Large_string_engaged()) {

  0092c	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00930	72 02		 jb	 SHORT $LN1249@LoadSettin

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00932	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN1249@LoadSettin:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 385  : 		SetBaseXY((DWORD)atol(c_rstrMapBaseX.c_str()), (DWORD)atol(c_rstrMapBaseY.c_str()));

  00934	56		 push	 esi
  00935	e8 00 00 00 00	 call	 _atol
  0093a	83 c4 04	 add	 esp, 4
  0093d	50		 push	 eax
  0093e	57		 push	 edi
  0093f	e8 00 00 00 00	 call	 _atol
  00944	8b bd 1c fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  0094a	83 c4 04	 add	 esp, 4
  0094d	8b cf		 mov	 ecx, edi
  0094f	50		 push	 eax
  00950	e8 00 00 00 00	 call	 ?SetBaseXY@CMapOutdoor@@QAEXKK@Z ; CMapOutdoor::SetBaseXY
  00955	eb 06		 jmp	 SHORT $LN14@LoadSettin
$LN1305@LoadSettin:

; 381  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("baseposition"))

  00957	8b bd 1c fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN14@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0095d	83 7d 8c 10	 cmp	 DWORD PTR _strTextureSet$[ebp+20], 16 ; 00000010H
  00961	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _strTextureSet$[ebp]

; 2620 :         if (_Count > max_size()) {

  00967	8b 75 88	 mov	 esi, DWORD PTR _strTextureSet$[ebp+16]
  0096a	0f 57 c0	 xorps	 xmm0, xmm0

; 2236 :         if (_Large_string_engaged()) {

  0096d	0f 43 85 78 ff
	ff ff		 cmovae	 eax, DWORD PTR _strTextureSet$[ebp]

; 2293 :     size_type _Mysize = 0; // current length of string

  00974	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _stTextureSetFileName$[ebp+16], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  0097b	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _stTextureSetFileName$[ebp+20], 0

; 2236 :         if (_Large_string_engaged()) {

  00982	89 85 28 fe ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00988	0f 11 45 c0	 movups	 XMMWORD PTR _stTextureSetFileName$[ebp], xmm0

; 2620 :         if (_Count > max_size()) {

  0098c	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00992	0f 87 42 04 00
	00		 ja	 $LN1303@LoadSettin

; 2621 :             _Xlen_string(); // result too long
; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

  00998	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _stTextureSetFileName$[ebp+20], 15 ; 0000000fH
  0099f	83 fe 10	 cmp	 esi, 16			; 00000010H
  009a2	73 0e		 jae	 SHORT $LN1189@LoadSettin

; 2629 :             _My_data._Mysize = _Count;

  009a4	8b ce		 mov	 ecx, esi
  009a6	89 4d d0	 mov	 DWORD PTR _stTextureSetFileName$[ebp+16], ecx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  009a9	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  009ac	0f 11 45 c0	 movups	 XMMWORD PTR _stTextureSetFileName$[ebp], xmm0

; 2647 :             return;

  009b0	eb 4c		 jmp	 SHORT $LN1202@LoadSettin
$LN1189@LoadSettin:

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  009b2	83 ce 0f	 or	 esi, 15			; 0000000fH
  009b5	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  009bb	76 07		 jbe	 SHORT $LN1196@LoadSettin

; 4716 :             return _Max;

  009bd	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  009c2	eb 0a		 jmp	 SHORT $LN1195@LoadSettin
$LN1196@LoadSettin:

; 4717 :         }
; 4718 : 
; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4720 :             return _Max;
; 4721 :         }
; 4722 : 
; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

  009c4	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  009c9	3b f0		 cmp	 esi, eax
  009cb	0f 42 f0	 cmovb	 esi, eax
$LN1195@LoadSettin:

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  009ce	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  009d1	50		 push	 eax
  009d2	8d 4d c0	 lea	 ecx, DWORD PTR _stTextureSetFileName$[ebp]
  009d5	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

  009da	8b 4d 88	 mov	 ecx, DWORD PTR _strTextureSet$[ebp+16]

; 2658 :         _My_data._Myres  = _New_capacity;

  009dd	89 75 d4	 mov	 DWORD PTR _stTextureSetFileName$[ebp+20], esi

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  009e0	8b f1		 mov	 esi, ecx
  009e2	89 4d d0	 mov	 DWORD PTR _stTextureSetFileName$[ebp+16], ecx
  009e5	89 45 c0	 mov	 DWORD PTR _stTextureSetFileName$[ebp], eax
  009e8	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  009eb	51		 push	 ecx
  009ec	ff b5 28 fe ff
	ff		 push	 DWORD PTR __Result$2$[ebp]
  009f2	50		 push	 eax
  009f3	e8 00 00 00 00	 call	 _memcpy
  009f8	8b 4d d0	 mov	 ecx, DWORD PTR _stTextureSetFileName$[ebp+16]
  009fb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1202@LoadSettin:

; 2236 :         if (_Large_string_engaged()) {

  009fe	83 7d d4 10	 cmp	 DWORD PTR _stTextureSetFileName$[ebp+20], 16 ; 00000010H
  00a02	8d 45 c0	 lea	 eax, DWORD PTR _stTextureSetFileName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 388  : 	std::string stTextureSetFileName = strTextureSet;

  00a05	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00a09	0f 43 45 c0	 cmovae	 eax, DWORD PTR _stTextureSetFileName$[ebp]
  00a0d	89 85 28 fe ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], eax

; 719  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it

  00a13	85 c9		 test	 ecx, ecx
  00a15	74 6d		 je	 SHORT $LN1300@LoadSettin
  00a17	68 00 01 00 00	 push	 256			; 00000100H
  00a1c	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR __Matches$12[ebp]
  00a22	6a 00		 push	 0
  00a24	50		 push	 eax
  00a25	e8 00 00 00 00	 call	 _memset
  00a2a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 720  :         if constexpr (_Special) {
; 721  :             _String_bitmap<typename _Traits::char_type> _Matches;
; 722  :             if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the

  00a2d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@FLIBEPMB@textureset@
$LL1138@LoadSettin:

; 670  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00a32	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00a35	41		 inc	 ecx
  00a36	c6 84 05 30 fe
	ff ff 01	 mov	 BYTE PTR __Matches$12[ebp+eax], 1
  00a3e	81 f9 0a 00 00
	00		 cmp	 ecx, OFFSET ??_C@_0L@FLIBEPMB@textureset@+10
  00a44	75 ec		 jne	 SHORT $LL1138@LoadSettin

; 728  :             for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  00a46	8b 95 28 fe ff
	ff		 mov	 edx, DWORD PTR __Result$2$[ebp]
  00a4c	8b ca		 mov	 ecx, edx
  00a4e	8b 45 d0	 mov	 eax, DWORD PTR _stTextureSetFileName$[ebp+16]
  00a51	03 c2		 add	 eax, edx
  00a53	3b d0		 cmp	 edx, eax
  00a55	73 2d		 jae	 SHORT $LN1300@LoadSettin
  00a57	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL1128@LoadSettin:

; 677  :         return _Matches[static_cast<unsigned char>(_Ch)];

  00a60	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00a63	8a 84 05 30 fe
	ff ff		 mov	 al, BYTE PTR __Matches$12[ebp+eax]

; 729  :                 if (_Matches._Match(*_Match_try)) {

  00a6a	84 c0		 test	 al, al
  00a6c	75 12		 jne	 SHORT $LN1275@LoadSettin

; 723  :                                                                     // bitmap, fall back to the serial algorithm
; 724  :                 return _Traits_find_first_of<_Traits, false>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size);
; 725  :             }
; 726  : 
; 727  :             const auto _End = _Haystack + _Hay_size;
; 728  :             for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  00a6e	8b 45 d0	 mov	 eax, DWORD PTR _stTextureSetFileName$[ebp+16]
  00a71	41		 inc	 ecx
  00a72	8b bd 1c fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  00a78	03 c2		 add	 eax, edx
  00a7a	3b c8		 cmp	 ecx, eax
  00a7c	72 e2		 jb	 SHORT $LL1128@LoadSettin

; 729  :                 if (_Matches._Match(*_Match_try)) {

  00a7e	eb 04		 jmp	 SHORT $LN1300@LoadSettin
$LN1275@LoadSettin:

; 730  :                     return static_cast<size_t>(_Match_try - _Haystack); // found a match

  00a80	2b ca		 sub	 ecx, edx
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 390  : 	if (0 != stTextureSetFileName.find_first_of("textureset", 0))

  00a82	74 59		 je	 SHORT $LN15@LoadSettin
$LN1300@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4916 :     if (_Right.max_size() - _Right_size < _Left_size) {

  00a84	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00a89	2b c6		 sub	 eax, esi
  00a8b	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00a8e	0f 82 46 03 00
	00		 jb	 $LN1303@LoadSettin

; 2236 :         if (_Large_string_engaged()) {

  00a94	83 7d 8c 10	 cmp	 DWORD PTR _strTextureSet$[ebp+20], 16 ; 00000010H
  00a98	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _strTextureSet$[ebp]

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

  00a9e	56		 push	 esi

; 2236 :         if (_Large_string_engaged()) {

  00a9f	0f 43 85 78 ff
	ff ff		 cmovae	 eax, DWORD PTR _strTextureSet$[ebp]

; 4920 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

  00aa6	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  00aa9	50		 push	 eax
  00aaa	6a 0b		 push	 11			; 0000000bH
  00aac	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PKDGGBDB@textureset?2@
  00ab1	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _strTextureSet$[ebp]
  00ab7	50		 push	 eax
  00ab8	ff b5 28 fe ff
	ff		 push	 DWORD PTR $T3[ebp]
  00abe	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 391  : 		stTextureSetFileName = "textureset\\"+strTextureSet;

  00ac3	8d 45 d8	 lea	 eax, DWORD PTR $T24[ebp]
  00ac6	50		 push	 eax
  00ac7	8d 4d c0	 lea	 ecx, DWORD PTR _stTextureSetFileName$[ebp]
  00aca	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  00acf	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  00ad2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ad7	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _strTextureSet$[ebp]
$LN15@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00add	83 7d d4 10	 cmp	 DWORD PTR _stTextureSetFileName$[ebp+20], 16 ; 00000010H
  00ae1	8d 45 c0	 lea	 eax, DWORD PTR _stTextureSetFileName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 393  :  	if (!m_TextureSet.Load(stTextureSetFileName.c_str(), m_fTerrainTexCoordBase))

  00ae4	f3 0f 10 87 08
	09 00 00	 movss	 xmm0, DWORD PTR [edi+2312]
  00aec	8d b7 7c 02 00
	00		 lea	 esi, DWORD PTR [edi+636]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00af2	0f 43 45 c0	 cmovae	 eax, DWORD PTR _stTextureSetFileName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 393  :  	if (!m_TextureSet.Load(stTextureSetFileName.c_str(), m_fTerrainTexCoordBase))

  00af6	51		 push	 ecx
  00af7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00afc	8b ce		 mov	 ecx, esi
  00afe	50		 push	 eax
  00aff	e8 00 00 00 00	 call	 ?Load@CTextureSet@@QAE_NPBDM@Z ; CTextureSet::Load
  00b04	84 c0		 test	 al, al
  00b06	75 2b		 jne	 SHORT $LN16@LoadSettin
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  00b08	83 7d d4 10	 cmp	 DWORD PTR _stTextureSetFileName$[ebp+20], 16 ; 00000010H

; 2235 :         const value_type* _Result = _Bx._Buf;

  00b0c	8d 45 c0	 lea	 eax, DWORD PTR _stTextureSetFileName$[ebp]

; 2236 :         if (_Large_string_engaged()) {

  00b0f	0f 43 45 c0	 cmovae	 eax, DWORD PTR _stTextureSetFileName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 398  : 		TraceError("MapOutdoor::LoadSetting(c_szFileName=%s) - LOAD TEXTURE SET(%s) ERROR", c_szFileName, stTextureSetFileName.c_str());

  00b13	50		 push	 eax
  00b14	ff b5 18 fe ff
	ff		 push	 DWORD PTR $T2[ebp]
  00b1a	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@MFMOCBKJ@MapOutdoor?3?3LoadSetting?$CIc_szFil@
  00b1f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00b24	83 c4 0c	 add	 esp, 12			; 0000000cH
  00b27	c6 85 2f fe ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  00b2e	e9 20 02 00 00	 jmp	 $LN55@LoadSettin
$LN16@LoadSettin:

; 399  : 		return false;
; 400  : #endif
; 401  : 	}
; 402  : 
; 403  : 	CTerrain::SetTextureSet(&m_TextureSet);

  00b33	56		 push	 esi
  00b34	e8 00 00 00 00	 call	 ?SetTextureSet@CTerrainImpl@@SAXPAVCTextureSet@@@Z ; CTerrainImpl::SetTextureSet
  00b39	83 c4 04	 add	 esp, 4

; 405  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("environment"))

  00b3c	8d 4d d8	 lea	 ecx, DWORD PTR $T23[ebp]
  00b3f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PINLHHEI@environment@
  00b44	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 38   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00b49	8b bd 20 fe ff
	ff		 mov	 edi, DWORD PTR _stTokenVectorMap$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 405  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("environment"))

  00b4f	8d 45 d8	 lea	 eax, DWORD PTR $T23[ebp]
  00b52	50		 push	 eax
  00b53	8d 85 28 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00b59	50		 push	 eax
  00b5a	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00b60	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  00b65	8d 4d d8	 lea	 ecx, DWORD PTR $T23[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 233  :         return this->_Ptr == _Right._Ptr;

  00b68	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 405  : 	if (stTokenVectorMap.end() != stTokenVectorMap.find("environment"))

  00b6a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b6f	3b fe		 cmp	 edi, esi
  00b71	74 5c		 je	 SHORT $LN1306@LoadSettin

; 406  : 	{
; 407  : 		const CTokenVector & c_rEnvironmentVector = stTokenVectorMap["environment"];

  00b73	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PINLHHEI@environment@
  00b78	8d 4d d8	 lea	 ecx, DWORD PTR $T22[ebp]
  00b7b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b80	8d 45 d8	 lea	 eax, DWORD PTR $T22[ebp]
  00b83	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  00b87	50		 push	 eax
  00b88	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00b8e	e8 00 00 00 00	 call	 ??A?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAEAAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::operator[]
  00b93	8d 4d d8	 lea	 ecx, DWORD PTR $T22[ebp]
  00b96	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00b9a	8b f0		 mov	 esi, eax
  00b9c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 1864 :         return _My_data._Myfirst == _My_data._Mylast;

  00ba1	8b 06		 mov	 eax, DWORD PTR [esi]
  00ba3	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 408  : 		if (!c_rEnvironmentVector.empty())

  00ba6	74 14		 je	 SHORT $LN18@LoadSettin

; 409  : 			m_settings_envDataName = c_rEnvironmentVector[0];

  00ba8	8b b5 1c fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  00bae	50		 push	 eax
  00baf	8d 8e 7c 13 00
	00		 lea	 ecx, DWORD PTR [esi+4988]
  00bb5	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  00bba	eb 19		 jmp	 SHORT $LN19@LoadSettin
$LN18@LoadSettin:

; 410  : 		else
; 411  : 			TraceError("CMapOutdoor::LoadSetting(c_szFileName=%s) - Failed to load environment data\n", c_szFileName);

  00bbc	ff b5 18 fe ff
	ff		 push	 DWORD PTR $T2[ebp]
  00bc2	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@PIOHNJHJ@CMapOutdoor?3?3LoadSetting?$CIc_szFi@
  00bc7	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00bcc	83 c4 08	 add	 esp, 8
$LN1306@LoadSettin:

; 412  : 	}
; 413  : 
; 414  : 	m_fWaterTexCoordBase = 1.0f / (float)(CTerrainImpl::CELLSCALE * 4);

  00bcf	8b b5 1c fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
$LN19@LoadSettin:

; 415  : 
; 416  : 	D3DXMatrixScaling(&m_matSplatAlpha,

  00bd5	f3 0f 10 9e 08
	09 00 00	 movss	 xmm3, DWORD PTR [esi+2312]
  00bdd	8d 86 c8 07 00
	00		 lea	 eax, DWORD PTR [esi+1992]
  00be3	0f 28 d3	 movaps	 xmm2, xmm3
  00be6	c7 86 0c 09 00
	00 0a d7 a3 3a	 mov	 DWORD PTR [esi+2316], 983815946 ; 3aa3d70aH
  00bf0	0f 57 15 00 00
	00 00		 xorps	 xmm2, DWORD PTR __xmm@80000000800000008000000080000000
  00bf7	f3 0f 58 db	 addss	 xmm3, xmm3
  00bfb	f3 0f 58 d2	 addss	 xmm2, xmm2
  00bff	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00c02	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@41800000
  00c0a	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  00c12	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@41800000
  00c1a	f3 0f 59 1d 00
	00 00 00	 mulss	 xmm3, DWORD PTR __real@3b800000
  00c22	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@3b800000
  00c2a	f3 0f 11 54 24
	04		 movss	 DWORD PTR [esp+4], xmm2
  00c30	f3 0f 11 1c 24	 movss	 DWORD PTR [esp], xmm3
  00c35	50		 push	 eax
  00c36	e8 00 00 00 00	 call	 _D3DXMatrixScaling@16

; 417  : 		+m_fTerrainTexCoordBase * 2.0f * (float)(CTerrainImpl::PATCH_XSIZE) / (float)(CTerrainImpl::SPLATALPHA_RAW_XSIZE-2),
; 418  : 		-m_fTerrainTexCoordBase * 2.0f * (float)(CTerrainImpl::PATCH_YSIZE) / (float)(CTerrainImpl::SPLATALPHA_RAW_XSIZE-2),
; 419  : 		0.0f);
; 420  : 	m_matSplatAlpha._41 = m_fTerrainTexCoordBase * 4.6f;

  00c3b	f3 0f 10 96 08
	09 00 00	 movss	 xmm2, DWORD PTR [esi+2312]

; 421  : 	m_matSplatAlpha._42 = m_fTerrainTexCoordBase * 4.6f;
; 422  : 
; 423  : 	D3DXMatrixScaling(&m_matStaticShadow,

  00c43	8d 86 08 08 00
	00		 lea	 eax, DWORD PTR [esi+2056]
  00c49	0f 28 c2	 movaps	 xmm0, xmm2
  00c4c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00c4f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40933333
  00c57	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  00c5f	f3 0f 11 86 f8
	07 00 00	 movss	 DWORD PTR [esi+2040], xmm0
  00c67	f3 0f 11 86 fc
	07 00 00	 movss	 DWORD PTR [esi+2044], xmm0
  00c6f	0f 28 c2	 movaps	 xmm0, xmm2
  00c72	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00c79	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e000000
  00c81	f3 0f 59 15 00
	00 00 00	 mulss	 xmm2, DWORD PTR __real@3e000000
  00c89	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  00c8f	f3 0f 11 14 24	 movss	 DWORD PTR [esp], xmm2
  00c94	50		 push	 eax
  00c95	e8 00 00 00 00	 call	 _D3DXMatrixScaling@16

; 424  : 		+m_fTerrainTexCoordBase * ((float) CTerrainImpl::PATCH_XSIZE / CTerrainImpl::XSIZE),
; 425  : 		-m_fTerrainTexCoordBase * ((float) CTerrainImpl::PATCH_YSIZE / CTerrainImpl::XSIZE),
; 426  : 		0.0f);
; 427  : 	m_matStaticShadow._41 = 0.0f;
; 428  : 	m_matStaticShadow._42 = 0.0f;
; 429  : 
; 430  : 	D3DXMatrixScaling(&m_matDynamicShadowScale, 1.0f / 2550.0f, -1.0f / 2550.0f, 1.0f);

  00c9a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00c9d	c7 86 38 08 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2104], 0
  00ca7	8d 86 88 08 00
	00		 lea	 eax, DWORD PTR [esi+2184]
  00cad	c7 86 3c 08 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+2108], 0
  00cb7	c7 44 24 08 00
	00 80 3f	 mov	 DWORD PTR [esp+8], 1065353216 ; 3f800000H
  00cbf	c7 44 24 04 67
	9a cd b9	 mov	 DWORD PTR [esp+4], -1177707929 ; b9cd9a67H
  00cc7	c7 04 24 67 9a
	cd 39		 mov	 DWORD PTR [esp], 969775719 ; 39cd9a67H
  00cce	50		 push	 eax
  00ccf	e8 00 00 00 00	 call	 _D3DXMatrixScaling@16

; 431  : 	m_matDynamicShadowScale._41 = 0.5f;
; 432  : 	m_matDynamicShadowScale._42 = 0.5f;
; 433  : 
; 434  : 	// Transform
; 435  : 	D3DXMatrixScaling(&m_matBuildingTransparent, 1.0f / ((float)ms_iWidth), -1.0f / ((float)ms_iHeight), 1.0f);

  00cd4	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  00cdc	8d 86 2c 0e 00
	00		 lea	 eax, DWORD PTR [esi+3628]
  00ce2	c7 86 b8 08 00
	00 00 00 00 3f	 mov	 DWORD PTR [esi+2232], 1056964608 ; 3f000000H
  00cec	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00cef	c7 86 bc 08 00
	00 00 00 00 3f	 mov	 DWORD PTR [esi+2236], 1056964608 ; 3f000000H
  00cf9	66 0f 6e 05 00
	00 00 00	 movd	 xmm0, DWORD PTR ?ms_iHeight@CGraphicBase@@1HA ; CGraphicBase::ms_iHeight
  00d01	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00d04	c7 44 24 08 00
	00 80 3f	 mov	 DWORD PTR [esp+8], 1065353216 ; 3f800000H
  00d0c	f3 0f 5e c8	 divss	 xmm1, xmm0
  00d10	66 0f 6e 05 00
	00 00 00	 movd	 xmm0, DWORD PTR ?ms_iWidth@CGraphicBase@@1HA ; CGraphicBase::ms_iWidth
  00d18	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00d1b	f3 0f 11 4c 24
	04		 movss	 DWORD PTR [esp+4], xmm1
  00d21	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00d29	f3 0f 5e c8	 divss	 xmm1, xmm0
  00d2d	f3 0f 11 0c 24	 movss	 DWORD PTR [esp], xmm1
  00d32	50		 push	 eax
  00d33	e8 00 00 00 00	 call	 _D3DXMatrixScaling@16

; 436  : 	m_matBuildingTransparent._41 = 0.5f;

  00d38	c7 86 5c 0e 00
	00 00 00 00 3f	 mov	 DWORD PTR [esi+3676], 1056964608 ; 3f000000H

; 437  : 	m_matBuildingTransparent._42 = 0.5f;

  00d42	c7 86 60 0e 00
	00 00 00 00 3f	 mov	 DWORD PTR [esi+3680], 1056964608 ; 3f000000H

; 438  : 	return true;

  00d4c	c6 85 2f fe ff
	ff 01		 mov	 BYTE PTR $T11[ebp], 1
$LN55@LoadSettin:
  00d53	8d 4d c0	 lea	 ecx, DWORD PTR _stTextureSetFileName$[ebp]
  00d56	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1310@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  00d5b	8b 45 8c	 mov	 eax, DWORD PTR _strTextureSet$[ebp+20]
  00d5e	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _strTextureSet$[ebp]
  00d64	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  00d67	72 27		 jb	 SHORT $LN1039@LoadSettin

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00d69	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d6c	8b c1		 mov	 eax, ecx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00d6e	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00d74	72 10		 jb	 SHORT $LN1049@LoadSettin

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00d76	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  00d79	83 c2 23	 add	 edx, 35			; 00000023H
  00d7c	2b c1		 sub	 eax, ecx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00d7e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00d81	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00d84	77 6d		 ja	 SHORT $LN1316@LoadSettin
$LN1049@LoadSettin:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00d86	52		 push	 edx
  00d87	51		 push	 ecx
  00d88	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
$LN1309@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree

; 754  :         _Erase_tree(_Al, _Myhead->_Parent);

  00d8d	83 c4 08	 add	 esp, 8
$LN1039@LoadSettin:
  00d90	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  00d96	ff 70 04	 push	 DWORD PTR [eax+4]
  00d99	8d 85 20 fe ff
	ff		 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  00d9f	50		 push	 eax
  00da0	8b c8		 mov	 ecx, eax
  00da2	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

  00da7	6a 34		 push	 52			; 00000034H
  00da9	ff b5 20 fe ff
	ff		 push	 DWORD PTR _stTokenVectorMap$[ebp]
  00daf	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 438  : 	return true;

  00db4	8a 85 2f fe ff
	ff		 mov	 al, BYTE PTR $T11[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

  00dba	83 c4 08	 add	 esp, 8
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 439  : }

  00dbd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00dc0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00dc7	59		 pop	 ecx
  00dc8	5f		 pop	 edi
  00dc9	5e		 pop	 esi
  00dca	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00dcd	33 cd		 xor	 ecx, ebp
  00dcf	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00dd4	8b e5		 mov	 esp, ebp
  00dd6	5d		 pop	 ebp
  00dd7	c2 04 00	 ret	 4
$LN1303@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4917 :         _Xlen_string();

  00dda	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN1312@LoadSettin:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00ddf	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1313@LoadSettin:
  00de4	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1314@LoadSettin:
  00de9	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1315@LoadSettin:
  00dee	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1316@LoadSettin:
  00df3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1308@LoadSettin:
  00df8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$0:
  00000	8d 8d 20 fe ff
	ff		 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$8:
  0000b	8d 4d a8	 lea	 ecx, DWORD PTR $T21[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$9:
  00013	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$10:
  0001e	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00024	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$11:
  00029	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  0002f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$12:
  00034	8d 4d 90	 lea	 ecx, DWORD PTR $T17[ebp]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$13:
  0003c	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$14:
  00044	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _strTextureSet$[ebp]
  0004a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$15:
  0004f	8d 4d a8	 lea	 ecx, DWORD PTR $T20[ebp]
  00052	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$17:
  00057	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  0005a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$18:
  0005f	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00065	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$19:
  0006a	8d 4d c0	 lea	 ecx, DWORD PTR _stTextureSetFileName$[ebp]
  0006d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z$22:
  00072	8d 4d d8	 lea	 ecx, DWORD PTR $T22[ebp]
  00075	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0007a	cc		 int	 3
  0007b	cc		 int	 3
  0007c	cc		 int	 3
  0007d	cc		 int	 3
  0007e	cc		 int	 3
__ehhandler$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z:
  0007f	90		 npad	 1
  00080	90		 npad	 1
  00081	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00085	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00088	8b 8a 04 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-508]
  0008e	33 c8		 xor	 ecx, eax
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00098	33 c8		 xor	 ecx, eax
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadSetting@CMapOutdoor@@QAE_NPBD@Z
  000a4	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadSetting@CMapOutdoor@@QAE_NPBD@Z ENDP		; CMapOutdoor::LoadSetting
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp
;	COMDAT ?Load@CMapOutdoor@@UAE_NMMM@Z
_TEXT	SEGMENT
$T2 = -224						; size = 16
__Result$2$ = -208					; size = 4
$T3 = -204						; size = 8
__Old$1$ = -200						; size = 4
$T4 = -200						; size = 1
$T5 = -200						; size = 1
$T6 = -200						; size = 1
$T7 = -200						; size = 1
$T8 = -200						; size = 1
__Count$1$ = -196					; size = 4
_rkPackMgr$1$ = -196					; size = 4
$T9 = -192						; size = 4
__Result$1$ = -192					; size = 4
$T10 = -188						; size = 24
$T11 = -164						; size = 24
$T12 = -140						; size = 24
_strFileName$ = -116					; size = 24
_$S1$13 = -92						; size = 24
_local_envDataName$ = -64				; size = 24
_$S2$14 = -40						; size = 24
$T15 = -40						; size = 24
_c_rstrNewPathName$16 = -40				; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?Load@CMapOutdoor@@UAE_NMMM@Z PROC			; CMapOutdoor::Load, COMDAT
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Load@CMapOutdoor@@UAE_NMMM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f1		 mov	 esi, ecx

; 12   : 	Destroy();

  0002f	8b 06		 mov	 eax, DWORD PTR [esi]
  00031	ff 50 0c	 call	 DWORD PTR [eax+12]

; 13   : 
; 14   : 	CEterPackManager& rkPackMgr=CEterPackManager::Instance();

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton

; 15   : 	{
; 16   : 		static std::string s_strOldPathName="";

  00039	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __tls_index
  0003f	89 85 3c ff ff
	ff		 mov	 DWORD PTR _rkPackMgr$1$[ebp], eax
  00045	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__tls_array
  0004b	8b 0c 88	 mov	 ecx, DWORD PTR [eax+ecx*4]
  0004e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?$TSS0@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4HA
  00053	3b 81 00 00 00
	00		 cmp	 eax, DWORD PTR __Init_thread_epoch[ecx]
  00059	0f 8f 73 07 00
	00		 jg	 $LN668@Load
$LN2@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

  0005f	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 18   : 		std::string c_rstrNewPathName=GetName()+"\\cache";

  00062	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

  00065	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0006a	2b c1		 sub	 eax, ecx
  0006c	83 f8 06	 cmp	 eax, 6
  0006f	0f 82 9a 07 00
	00		 jb	 $LN657@Load

; 2236 :         if (_Large_string_engaged()) {

  00075	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00079	8b c7		 mov	 eax, edi
  0007b	72 02		 jb	 SHORT $LN56@Load

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0007d	8b 07		 mov	 eax, DWORD PTR [edi]
$LN56@Load:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  0007f	6a 06		 push	 6
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_06NLAJNNNM@?2cache@
  00086	51		 push	 ecx
  00087	50		 push	 eax
  00088	57		 push	 edi
  00089	ff b5 38 ff ff
	ff		 push	 DWORD PTR $T8[ebp]
  0008f	8d 4d d8	 lea	 ecx, DWORD PTR _c_rstrNewPathName$16[ebp]
  00092	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 20   : 		s_strOldPathName=c_rstrNewPathName;

  00097	8d 45 d8	 lea	 eax, DWORD PTR _c_rstrNewPathName$16[ebp]
  0009a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000a1	50		 push	 eax
  000a2	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  000a7	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  000ac	8b 4d ec	 mov	 ecx, DWORD PTR _c_rstrNewPathName$16[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 21   : 	}

  000af	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  000b6	83 f9 10	 cmp	 ecx, 16			; 00000010H
  000b9	72 2c		 jb	 SHORT $LN72@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bb	8b 55 d8	 mov	 edx, DWORD PTR _c_rstrNewPathName$16[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  000be	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bf	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000c1	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000c7	72 14		 jb	 SHORT $LN82@Load

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000c9	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000cc	83 c1 23	 add	 ecx, 35			; 00000023H
  000cf	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000d1	83 c0 fc	 add	 eax, -4			; fffffffcH
  000d4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000d7	0f 87 55 07 00
	00		 ja	 $LN37@Load
$LN82@Load:

; 265  :         ::operator delete(_Ptr, _Bytes);

  000dd	51		 push	 ecx
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000e4	83 c4 08	 add	 esp, 8
$LN72@Load:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  000e7	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  000eb	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  000ee	77 02		 ja	 SHORT $LN90@Load
  000f0	8b cf		 mov	 ecx, edi
$LN90@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

  000f2	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]

; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

  000f5	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000fa	2b c2		 sub	 eax, edx
  000fc	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  000ff	0f 82 0a 07 00
	00		 jb	 $LN657@Load

; 2236 :         if (_Large_string_engaged()) {

  00105	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  00109	8b c1		 mov	 eax, ecx
  0010b	72 02		 jb	 SHORT $LN103@Load

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0010d	8b 01		 mov	 eax, DWORD PTR [ecx]
$LN103@Load:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  0010f	6a 0c		 push	 12			; 0000000cH
  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0N@NBPBKCDE@?2Setting?4txt@
  00116	52		 push	 edx
  00117	50		 push	 eax
  00118	51		 push	 ecx
  00119	ff b5 38 ff ff
	ff		 push	 DWORD PTR $T7[ebp]
  0011f	8d 4d 8c	 lea	 ecx, DWORD PTR _strFileName$[ebp]
  00122	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 2236 :         if (_Large_string_engaged()) {

  00127	83 7d a0 10	 cmp	 DWORD PTR _strFileName$[ebp+20], 16 ; 00000010H
  0012b	8d 45 8c	 lea	 eax, DWORD PTR _strFileName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 25   : 	if (!LoadSetting(strFileName.c_str()))

  0012e	8b ce		 mov	 ecx, esi
  00130	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00137	0f 43 45 8c	 cmovae	 eax, DWORD PTR _strFileName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 25   : 	if (!LoadSetting(strFileName.c_str()))

  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 ?LoadSetting@CMapOutdoor@@QAE_NPBD@Z ; CMapOutdoor::LoadSetting
  00141	84 c0		 test	 al, al
  00143	75 19		 jne	 SHORT $LN3@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00145	83 7d a0 10	 cmp	 DWORD PTR _strFileName$[ebp+20], 16 ; 00000010H
  00149	8d 45 8c	 lea	 eax, DWORD PTR _strFileName$[ebp]
  0014c	0f 43 45 8c	 cmovae	 eax, DWORD PTR _strFileName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 27   : 		TraceError("CMapOutdoor::Load : LoadSetting(%s) Failed", strFileName.c_str());

  00150	50		 push	 eax
  00151	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@PFEFOJBM@CMapOutdoor?3?3Load?5?3?5LoadSetting@
  00156	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0015b	83 c4 08	 add	 esp, 8
$LN3@Load:

; 28   : 	}
; 29   : 
; 30   : #ifdef WORLD_EDITOR // @fixme015
; 31   : 	if (!LoadMonsterAreaInfo())
; 32   : 		TraceError("CMapOutdoor::Load - LoadMonsterAreaInfo ERROR");
; 33   : #endif
; 34   : 
; 35   : 	CreateTerrainPatchProxyList();

  0015e	8b ce		 mov	 ecx, esi
  00160	e8 00 00 00 00	 call	 ?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ ; CMapOutdoor::CreateTerrainPatchProxyList

; 36   : 	BuildQuadTree();

  00165	8b ce		 mov	 ecx, esi
  00167	e8 00 00 00 00	 call	 ?BuildQuadTree@CMapOutdoor@@IAEXXZ ; CMapOutdoor::BuildQuadTree

; 37   : 	LoadWaterTexture();

  0016c	8b ce		 mov	 ecx, esi
  0016e	e8 00 00 00 00	 call	 ?LoadWaterTexture@CMapOutdoor@@IAEXXZ ; CMapOutdoor::LoadWaterTexture

; 38   : 	CreateCharacterShadowTexture();

  00173	8b ce		 mov	 ecx, esi
  00175	e8 00 00 00 00	 call	 ?CreateCharacterShadowTexture@CMapOutdoor@@QAEXXZ ; CMapOutdoor::CreateCharacterShadowTexture

; 39   : 
; 40   : 	m_lOldReadX = -1;

  0017a	c7 86 0c 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [esi+268], -1

; 41   : 
; 42   : 	CSpeedTreeForestDirectX8::Instance().SetRenderingDevice(ms_lpd3dDevice);

  00184	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0018a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  00190	e8 00 00 00 00	 call	 ?SetRenderingDevice@CSpeedTreeForestDirectX8@@QAE_NPAUIDirect3DDevice8@@@Z ; CSpeedTreeForestDirectX8::SetRenderingDevice

; 43   : 
; 44   : 	Update(x, y, z);

  00195	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  0019a	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0019d	8b 06		 mov	 eax, DWORD PTR [esi]
  0019f	8b ce		 mov	 ecx, esi
  001a1	f3 0f 11 44 24
	08		 movss	 DWORD PTR [esp+8], xmm0
  001a7	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  001ac	f3 0f 11 44 24
	04		 movss	 DWORD PTR [esp+4], xmm0
  001b2	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  001b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001bc	ff 50 14	 call	 DWORD PTR [eax+20]

; 45   : 
; 46   : 	__HeightCache_Init();

  001bf	8b ce		 mov	 ecx, esi
  001c1	e8 00 00 00 00	 call	 ?__HeightCache_Init@CMapOutdoor@@AAEXXZ ; CMapOutdoor::__HeightCache_Init
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapBase.h

; 53   : 		bool IsCopiedMap() const { return m_strParentMapName.length() > 0; }

  001c6	83 7e 30 00	 cmp	 DWORD PTR [esi+48], 0

; 55   : 		const std::string& GetMapDataDirectory() const { return IsCopiedMap() ? m_strParentMapName : m_strName; }

  001ca	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  001cd	77 02		 ja	 SHORT $LN144@Load
  001cf	8b cf		 mov	 ecx, edi
$LN144@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4938 :     const auto _Left_size  = _Left.size();

  001d1	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]

; 4940 :     if (_Left.max_size() - _Left_size < _Right_size) {

  001d4	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  001d9	2b c2		 sub	 eax, edx
  001db	83 f8 01	 cmp	 eax, 1
  001de	0f 82 2b 06 00
	00		 jb	 $LN657@Load

; 2236 :         if (_Large_string_engaged()) {

  001e4	83 79 14 10	 cmp	 DWORD PTR [ecx+20], 16	; 00000010H
  001e8	8b c1		 mov	 eax, ecx
  001ea	72 02		 jb	 SHORT $LN157@Load

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  001ec	8b 01		 mov	 eax, DWORD PTR [ecx]
$LN157@Load:

; 4944 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  001ee	6a 01		 push	 1
  001f0	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@
  001f5	52		 push	 edx
  001f6	50		 push	 eax
  001f7	51		 push	 ecx
  001f8	ff b5 38 ff ff
	ff		 push	 DWORD PTR $T6[ebp]
  001fe	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  00201	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 2236 :         if (_Large_string_engaged()) {

  00206	83 be 90 13 00
	00 10		 cmp	 DWORD PTR [esi+5008], 16 ; 00000010H
  0020d	8d 8e 7c 13 00
	00		 lea	 ecx, DWORD PTR [esi+4988]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 49   : 	std::string local_envDataName = GetMapDataDirectory() + "\\" + m_settings_envDataName;

  00213	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  00217	72 06		 jb	 SHORT $LN654@Load

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00219	8b 8e 7c 13 00
	00		 mov	 ecx, DWORD PTR [esi+4988]
$LN654@Load:

; 3241 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0021f	ff b6 8c 13 00
	00		 push	 DWORD PTR [esi+5004]
  00225	51		 push	 ecx
  00226	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  00229	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2293 :     size_type _Mysize = 0; // current length of string

  0022e	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _local_envDataName$[ebp+16], 0
  00235	0f 57 c0	 xorps	 xmm0, xmm0

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00238	0f 11 45 c0	 movups	 XMMWORD PTR _local_envDataName$[ebp], xmm0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  0023c	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _local_envDataName$[ebp+20], 0

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00243	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  00246	0f 11 45 c0	 movups	 XMMWORD PTR _local_envDataName$[ebp], xmm0
  0024a	f3 0f 7e 40 10	 movq	 xmm0, QWORD PTR [eax+16]
  0024f	66 0f d6 45 d0	 movq	 QWORD PTR _local_envDataName$[ebp+16], xmm0

; 4821 :         _My_data._Mysize = 0;

  00254	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

  0025b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00262	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4832 :         if (_My_data._Large_string_engaged()) {

  00265	8b 4d ec	 mov	 ecx, DWORD PTR $T15[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 49   : 	std::string local_envDataName = GetMapDataDirectory() + "\\" + m_settings_envDataName;

  00268	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4832 :         if (_My_data._Large_string_engaged()) {

  0026c	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0026f	72 2c		 jb	 SHORT $LN209@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00271	8b 55 d8	 mov	 edx, DWORD PTR $T15[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00274	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00275	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00277	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0027d	72 14		 jb	 SHORT $LN219@Load

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0027f	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00282	83 c1 23	 add	 ecx, 35			; 00000023H
  00285	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00287	83 c0 fc	 add	 eax, -4			; fffffffcH
  0028a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0028d	0f 87 81 05 00
	00		 ja	 $LN669@Load
$LN219@Load:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00293	51		 push	 ecx
  00294	52		 push	 edx
  00295	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0029a	83 c4 08	 add	 esp, 8
$LN209@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0029d	83 7d d4 10	 cmp	 DWORD PTR _local_envDataName$[ebp+20], 16 ; 00000010H
  002a1	8d 45 c0	 lea	 eax, DWORD PTR _local_envDataName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 50   : 	if (rkPackMgr.isExist(local_envDataName.c_str()))

  002a4	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _rkPackMgr$1$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  002aa	0f 43 45 c0	 cmovae	 eax, DWORD PTR _local_envDataName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 50   : 	if (rkPackMgr.isExist(local_envDataName.c_str()))

  002ae	50		 push	 eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

  002af	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T15[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  002b6	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR $T15[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  002bd	c6 45 d8 00	 mov	 BYTE PTR $T15[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 50   : 	if (rkPackMgr.isExist(local_envDataName.c_str()))

  002c1	e8 00 00 00 00	 call	 ?isExist@CEterPackManager@@QAE_NPBD@Z ; CEterPackManager::isExist
  002c6	84 c0		 test	 al, al
  002c8	0f 84 5b 01 00
	00		 je	 $LN4@Load

; 51   : 	{
; 52   : 		m_envDataName = local_envDataName;

  002ce	8d be 94 13 00
	00		 lea	 edi, DWORD PTR [esi+5012]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3156 :         if (this == _STD addressof(_Right)) {

  002d4	8d 45 c0	 lea	 eax, DWORD PTR _local_envDataName$[ebp]
  002d7	3b f8		 cmp	 edi, eax
  002d9	0f 84 5a 04 00
	00		 je	 $LN325@Load

; 2244 :         return _BUF_SIZE <= _Myres;

  002df	83 7d d4 10	 cmp	 DWORD PTR _local_envDataName$[ebp+20], 16 ; 00000010H

; 2235 :         const value_type* _Result = _Bx._Buf;

  002e3	8b d0		 mov	 edx, eax

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  002e5	8b 75 d0	 mov	 esi, DWORD PTR _local_envDataName$[ebp+16]

; 2236 :         if (_Large_string_engaged()) {

  002e8	0f 43 55 c0	 cmovae	 edx, DWORD PTR _local_envDataName$[ebp]

; 3376 :         if (_Count <= _Mypair._Myval2._Myres) {

  002ec	8b 47 14	 mov	 eax, DWORD PTR [edi+20]

; 2236 :         if (_Large_string_engaged()) {

  002ef	89 95 30 ff ff
	ff		 mov	 DWORD PTR __Result$2$[ebp], edx

; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  002f5	89 b5 3c ff ff
	ff		 mov	 DWORD PTR __Count$1$[ebp], esi

; 3376 :         if (_Count <= _Mypair._Myval2._Myres) {

  002fb	89 85 38 ff ff
	ff		 mov	 DWORD PTR __Old$1$[ebp], eax
  00301	3b f0		 cmp	 esi, eax
  00303	77 32		 ja	 SHORT $LN386@Load

; 2226 :         value_type* _Result = _Bx._Buf;

  00305	89 bd 40 ff ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], edi
  0030b	8b cf		 mov	 ecx, edi

; 2244 :         return _BUF_SIZE <= _Myres;

  0030d	83 f8 10	 cmp	 eax, 16			; 00000010H

; 2227 :         if (_Large_string_engaged()) {

  00310	72 08		 jb	 SHORT $LN389@Load

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  00312	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00314	89 8d 40 ff ff
	ff		 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN389@Load:

; 3379 :             _Mypair._Myval2._Mysize = _Count;

  0031a	56		 push	 esi

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0031b	52		 push	 edx
  0031c	51		 push	 ecx

; 3379 :             _Mypair._Myval2._Mysize = _Count;

  0031d	89 77 10	 mov	 DWORD PTR [edi+16], esi

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00320	e8 00 00 00 00	 call	 _memmove

; 3381 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00325	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR __Result$1$[ebp]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0032b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3381 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0032e	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0

; 3382 :             return *this;

  00332	e9 02 04 00 00	 jmp	 $LN325@Load
$LN386@Load:

; 4734 :         if (_New_size > max_size()) {

  00337	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  0033d	0f 87 d6 04 00
	00		 ja	 $LN670@Load

; 4727 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00343	83 ce 0f	 or	 esi, 15			; 0000000fH

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00346	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0034c	76 15		 jbe	 SHORT $LN403@Load

; 4716 :             return _Max;

  0034e	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00353	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00358	50		 push	 eax
  00359	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0035e	83 c4 04	 add	 esp, 4
  00361	eb 51		 jmp	 SHORT $LN665@Load
$LN403@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00363	8b d0		 mov	 edx, eax
  00365	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0036a	d1 ea		 shr	 edx, 1
  0036c	2b ca		 sub	 ecx, edx
  0036e	3b c1		 cmp	 eax, ecx
  00370	76 15		 jbe	 SHORT $LN404@Load

; 4720 :             return _Max;

  00372	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00377	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0037c	50		 push	 eax
  0037d	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00382	83 c4 04	 add	 esp, 4
  00385	eb 2d		 jmp	 SHORT $LN665@Load
$LN404@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00387	03 c2		 add	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

  00389	3b f0		 cmp	 esi, eax
  0038b	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0038e	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00391	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00396	72 0b		 jb	 SHORT $LN411@Load

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00398	50		 push	 eax
  00399	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0039e	83 c4 04	 add	 esp, 4
  003a1	eb 11		 jmp	 SHORT $LN665@Load
$LN411@Load:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

  003a3	85 c0		 test	 eax, eax
  003a5	74 0b		 je	 SHORT $LN412@Load

; 87   :         return ::operator new(_Bytes);

  003a7	50		 push	 eax
  003a8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  003ad	83 c4 04	 add	 esp, 4

; 245  :         return _Traits::_Allocate(_Bytes);

  003b0	eb 02		 jmp	 SHORT $LN665@Load
$LN412@Load:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

  003b2	33 c0		 xor	 eax, eax
$LN665@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4746 :         _Mypair._Myval2._Mysize = _New_size;

  003b4	89 85 40 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  003ba	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR __Count$1$[ebp]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003c0	50		 push	 eax
  003c1	ff b5 30 ff ff
	ff		 push	 DWORD PTR __Result$2$[ebp]

; 4747 :         _Mypair._Myval2._Myres  = _New_capacity;

  003c7	89 77 14	 mov	 DWORD PTR [edi+20], esi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003ca	8b b5 40 ff ff
	ff		 mov	 esi, DWORD PTR $T9[ebp]
  003d0	56		 push	 esi

; 4746 :         _Mypair._Myval2._Mysize = _New_size;

  003d1	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003d4	e8 00 00 00 00	 call	 _memcpy

; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  003d9	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR __Count$1$[ebp]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  003df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  003e2	c6 04 06 00	 mov	 BYTE PTR [esi+eax], 0

; 4749 :         if (_BUF_SIZE <= _Old_capacity) {

  003e6	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR __Old$1$[ebp]
  003ec	83 f8 10	 cmp	 eax, 16			; 00000010H
  003ef	72 31		 jb	 SHORT $LN397@Load

; 4750 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  003f1	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  003f4	8b 07		 mov	 eax, DWORD PTR [edi]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  003f6	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  003fc	72 16		 jb	 SHORT $LN434@Load

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  003fe	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00401	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00404	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00406	83 c0 fc	 add	 eax, -4			; fffffffcH
  00409	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0040c	0f 87 20 04 00
	00		 ja	 $LN37@Load

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00412	8b c2		 mov	 eax, edx
$LN434@Load:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00414	51		 push	 ecx
  00415	50		 push	 eax
  00416	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4751 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  0041b	89 37		 mov	 DWORD PTR [edi], esi

; 4752 :         } else {

  0041d	e9 14 03 00 00	 jmp	 $LN666@Load
$LN397@Load:

; 4753 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00422	89 37		 mov	 DWORD PTR [edi], esi
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 53   : 	}

  00424	e9 10 03 00 00	 jmp	 $LN325@Load
$LN4@Load:
  00429	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

  0042c	6a 20		 push	 32			; 00000020H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0042e	0f 11 45 a4	 movups	 XMMWORD PTR _$S1$13[ebp], xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

  00432	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00437	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0BK@PHKPBKKC@d?3?1ymir?5work?1environment?1@
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 245  :         return _Traits::_Allocate(_Bytes);

  0043e	8b d0		 mov	 edx, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2657 :         _My_data._Mysize = _Count;

  00440	c7 45 b4 19 00
	00 00		 mov	 DWORD PTR _$S1$13[ebp+16], 25 ; 00000019H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 87   :         return ::operator new(_Bytes);

  00447	83 c4 04	 add	 esp, 4
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0044a	89 55 a4	 mov	 DWORD PTR _$S1$13[ebp], edx

; 2658 :         _My_data._Myres  = _New_capacity;

  0044d	c7 45 b8 1f 00
	00 00		 mov	 DWORD PTR _$S1$13[ebp+20], 31 ; 0000001fH

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00454	0f 11 02	 movups	 XMMWORD PTR [edx], xmm0
  00457	f3 0f 7e 05 10
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0BK@PHKPBKKC@d?3?1ymir?5work?1environment?1@+16
  0045f	66 0f d6 42 10	 movq	 QWORD PTR [edx+16], xmm0
  00464	8a 0d 18 00 00
	00		 mov	 cl, BYTE PTR ??_C@_0BK@PHKPBKKC@d?3?1ymir?5work?1environment?1@+24
  0046a	88 4a 18	 mov	 BYTE PTR [edx+24], cl

; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  0046d	c6 42 19 00	 mov	 BYTE PTR [edx+25], 0

; 4902 :     const auto _Right_size = _Right.size();

  00471	8b 8e 8c 13 00
	00		 mov	 ecx, DWORD PTR [esi+5004]
  00477	8d 86 7c 13 00
	00		 lea	 eax, DWORD PTR [esi+4988]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 56   : 		const std::string& c_rstrEnvironmentRoot = "d:/ymir work/environment/";

  0047d	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4903 :     if (_Left.max_size() - _Left_size < _Right_size) {

  00481	81 f9 e6 ff ff
	7f		 cmp	 ecx, 2147483622		; 7fffffe6H
  00487	0f 87 91 03 00
	00		 ja	 $LN671@Load

; 2236 :         if (_Large_string_engaged()) {

  0048d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00491	72 02		 jb	 SHORT $LN253@Load

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00493	8b 00		 mov	 eax, DWORD PTR [eax]
$LN253@Load:

; 4907 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size};

  00495	51		 push	 ecx
  00496	50		 push	 eax
  00497	6a 19		 push	 25			; 00000019H
  00499	52		 push	 edx
  0049a	8d 45 a4	 lea	 eax, DWORD PTR _$S1$13[ebp]
  0049d	50		 push	 eax
  0049e	ff b5 38 ff ff
	ff		 push	 DWORD PTR $T5[ebp]
  004a4	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  004aa	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 58   : 		m_envDataName = c_rstrEnvironmentRoot + m_settings_envDataName;

  004af	81 c6 94 13 00
	00		 add	 esi, 5012		; 00001394H
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2961 :         if (this == _STD addressof(_Right)) {

  004b5	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  004bb	3b f0		 cmp	 esi, eax
  004bd	74 29		 je	 SHORT $LN659@Load

; 2962 :             return *this;
; 2963 :         }
; 2964 : 
; 2965 :         auto& _Al                 = _Getal();
; 2966 :         auto& _Right_al           = _Right._Getal();
; 2967 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
; 2968 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 2969 :             if (_Al != _Right_al) {
; 2970 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2971 :                 _Mypair._Myval2._Orphan_all();
; 2972 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 2973 :             }
; 2974 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 2975 :             if (_Al != _Right_al) {
; 2976 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2977 :                 return *this;
; 2978 :             }
; 2979 :         }
; 2980 : 
; 2981 :         _Tidy_deallocate();

  004bf	8b ce		 mov	 ecx, esi
  004c1	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  004c6	0f 10 85 74 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T12[ebp]

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

  004cd	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  004d2	c6 85 74 ff ff
	ff 00		 mov	 BYTE PTR $T12[ebp], 0

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  004d9	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  004dc	f3 0f 7e 45 84	 movq	 xmm0, QWORD PTR $T12[ebp+16]
  004e1	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 2961 :         if (this == _STD addressof(_Right)) {

  004e6	eb 03		 jmp	 SHORT $LN273@Load
$LN659@Load:
  004e8	8b 4d 88	 mov	 ecx, DWORD PTR $T12[ebp+20]
$LN273@Load:

; 4832 :         if (_My_data._Large_string_engaged()) {

  004eb	83 f9 10	 cmp	 ecx, 16			; 00000010H
  004ee	72 2f		 jb	 SHORT $LN286@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004f0	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR $T12[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  004f6	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004f7	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  004f9	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  004ff	72 14		 jb	 SHORT $LN296@Load

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00501	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00504	83 c1 23	 add	 ecx, 35			; 00000023H
  00507	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00509	83 c0 fc	 add	 eax, -4			; fffffffcH
  0050c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0050f	0f 87 1d 03 00
	00		 ja	 $LN37@Load
$LN296@Load:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00515	51		 push	 ecx
  00516	52		 push	 edx
  00517	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0051c	83 c4 08	 add	 esp, 8
$LN286@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2236 :         if (_Large_string_engaged()) {

  0051f	83 7d b8 10	 cmp	 DWORD PTR _$S1$13[ebp+20], 16 ; 00000010H
  00523	8d 45 a4	 lea	 eax, DWORD PTR _$S1$13[ebp]

; 2235 :         const value_type* _Result = _Bx._Buf;

  00526	8b ce		 mov	 ecx, esi

; 2236 :         if (_Large_string_engaged()) {

  00528	0f 43 45 a4	 cmovae	 eax, DWORD PTR _$S1$13[ebp]
  0052c	83 7e 14 10	 cmp	 DWORD PTR [esi+20], 16	; 00000010H
  00530	72 02		 jb	 SHORT $LN655@Load

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00532	8b 0e		 mov	 ecx, DWORD PTR [esi]
$LN655@Load:

; 4626 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00534	ff 75 b4	 push	 DWORD PTR _$S1$13[ebp+16]
  00537	50		 push	 eax
  00538	ff 76 10	 push	 DWORD PTR [esi+16]
  0053b	51		 push	 ecx
  0053c	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ; std::_Traits_compare<std::char_traits<char> >
  00541	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 60   : 		if (0 == m_envDataName.compare(c_rstrEnvironmentRoot))

  00544	85 c0		 test	 eax, eax
  00546	0f 85 b7 01 00
	00		 jne	 $LN662@Load

; 62   : 			const std::string& strAppendName = c_rstrMapName.substr(c_rstrMapName.size() - 2, 2);

  0054c	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  0054f	0f 57 c0	 xorps	 xmm0, xmm0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00552	0f 11 45 d8	 movups	 XMMWORD PTR _$S2$14[ebp], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

  00556	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _$S2$14[ebp+16], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  0055d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _$S2$14[ebp+20], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 62   : 			const std::string& strAppendName = c_rstrMapName.substr(c_rstrMapName.size() - 2, 2);

  00564	8d 48 fe	 lea	 ecx, DWORD PTR [eax-2]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2260 :         if (_Mysize < _Off) {

  00567	3b c1		 cmp	 eax, ecx
  00569	0f 82 b4 02 00
	00		 jb	 $LN672@Load

; 2236 :         if (_Large_string_engaged()) {

  0056f	83 7f 14 10	 cmp	 DWORD PTR [edi+20], 16	; 00000010H
  00573	72 02		 jb	 SHORT $LN500@Load

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00575	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN500@Load:

; 2511 :         _Construct<_Construct_strategy::_From_ptr>(

  00577	8d 04 0f	 lea	 eax, DWORD PTR [edi+ecx]
  0057a	6a 02		 push	 2
  0057c	50		 push	 eax
  0057d	8d 4d d8	 lea	 ecx, DWORD PTR _$S2$14[ebp]
  00580	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 4903 :     if (_Left.max_size() - _Left_size < _Right_size) {

  00585	8b 55 b4	 mov	 edx, DWORD PTR _$S1$13[ebp+16]
  00588	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0058d	8b 7d e8	 mov	 edi, DWORD PTR _$S2$14[ebp+16]
  00590	2b c2		 sub	 eax, edx
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 62   : 			const std::string& strAppendName = c_rstrMapName.substr(c_rstrMapName.size() - 2, 2);

  00592	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4903 :     if (_Left.max_size() - _Left_size < _Right_size) {

  00596	3b c7		 cmp	 eax, edi
  00598	0f 82 8a 02 00
	00		 jb	 $LN673@Load

; 2236 :         if (_Large_string_engaged()) {

  0059e	83 7d b8 10	 cmp	 DWORD PTR _$S1$13[ebp+20], 16 ; 00000010H
  005a2	8d 4d a4	 lea	 ecx, DWORD PTR _$S1$13[ebp]

; 4907 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size};

  005a5	57		 push	 edi

; 2236 :         if (_Large_string_engaged()) {

  005a6	0f 43 4d a4	 cmovae	 ecx, DWORD PTR _$S1$13[ebp]

; 2235 :         const value_type* _Result = _Bx._Buf;

  005aa	8d 45 d8	 lea	 eax, DWORD PTR _$S2$14[ebp]

; 2236 :         if (_Large_string_engaged()) {

  005ad	83 7d ec 10	 cmp	 DWORD PTR _$S2$14[ebp+20], 16 ; 00000010H
  005b1	0f 43 45 d8	 cmovae	 eax, DWORD PTR _$S2$14[ebp]

; 4907 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right.c_str(), _Right_size};

  005b5	50		 push	 eax
  005b6	52		 push	 edx
  005b7	51		 push	 ecx
  005b8	8d 45 a4	 lea	 eax, DWORD PTR _$S1$13[ebp]
  005bb	50		 push	 eax
  005bc	ff b5 38 ff ff
	ff		 push	 DWORD PTR $T4[ebp]
  005c2	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  005c8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 3292 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005cd	6a 06		 push	 6
  005cf	68 00 00 00 00	 push	 OFFSET ??_C@_06MANNNLLA@?4msenv@
  005d4	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 63   : 			m_envDataName = c_rstrEnvironmentRoot + strAppendName + ".msenv";

  005da	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3292 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  005de	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  005e3	0f 10 00	 movups	 xmm0, XMMWORD PTR [eax]
  005e6	f3 0f 7e 48 10	 movq	 xmm1, QWORD PTR [eax+16]

; 4821 :         _My_data._Mysize = 0;

  005eb	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

  005f2	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  005f9	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2961 :         if (this == _STD addressof(_Right)) {

  005fc	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00602	66 0f d6 8d 34
	ff ff ff	 movq	 QWORD PTR $T3[ebp], xmm1
  0060a	66 0f d6 8d 6c
	ff ff ff	 movq	 QWORD PTR $T11[ebp+16], xmm1
  00612	0f 11 85 20 ff
	ff ff		 movups	 XMMWORD PTR $T2[ebp], xmm0
  00619	0f 11 85 5c ff
	ff ff		 movups	 XMMWORD PTR $T11[ebp], xmm0

; 2961 :         if (this == _STD addressof(_Right)) {

  00620	3b f0		 cmp	 esi, eax
  00622	74 66		 je	 SHORT $LN660@Load

; 2244 :         return _BUF_SIZE <= _Myres;

  00624	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00627	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  0062a	72 3a		 jb	 SHORT $LN569@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0062c	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0062e	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0062f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00635	72 16		 jb	 SHORT $LN579@Load

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00637	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0063a	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0063d	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0063f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00642	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00645	0f 87 e2 01 00
	00		 ja	 $LN617@Load

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0064b	8b c2		 mov	 eax, edx
$LN579@Load:

; 265  :         ::operator delete(_Ptr, _Bytes);

  0064d	51		 push	 ecx
  0064e	50		 push	 eax
  0064f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00654	0f 10 85 20 ff
	ff ff		 movups	 xmm0, XMMWORD PTR $T2[ebp]
  0065b	83 c4 08	 add	 esp, 8
  0065e	f3 0f 7e 8d 34
	ff ff ff	 movq	 xmm1, QWORD PTR $T3[ebp]
$LN569@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

  00666	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

  0066d	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00672	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00679	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0067c	c6 85 5c ff ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00683	66 0f d6 4e 10	 movq	 QWORD PTR [esi+16], xmm1

; 2961 :         if (this == _STD addressof(_Right)) {

  00688	eb 06		 jmp	 SHORT $LN597@Load
$LN660@Load:
  0068a	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp+20]
$LN597@Load:

; 2244 :         return _BUF_SIZE <= _Myres;

  00690	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  00693	72 2f		 jb	 SHORT $LN610@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00695	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR $T11[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0069b	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0069c	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0069e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  006a4	72 14		 jb	 SHORT $LN620@Load

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  006a6	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  006a9	83 c1 23	 add	 ecx, 35			; 00000023H
  006ac	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  006ae	83 c0 fc	 add	 eax, -4			; fffffffcH
  006b1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  006b4	0f 87 73 01 00
	00		 ja	 $LN617@Load
$LN620@Load:

; 265  :         ::operator delete(_Ptr, _Bytes);

  006ba	51		 push	 ecx
  006bb	52		 push	 edx
  006bc	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  006c1	83 c4 08	 add	 esp, 8
$LN610@Load:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 63   : 			m_envDataName = c_rstrEnvironmentRoot + strAppendName + ".msenv";

  006c4	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  006ca	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  006cf	8b 4d ec	 mov	 ecx, DWORD PTR _$S2$14[ebp+20]
  006d2	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  006d5	72 2c		 jb	 SHORT $LN662@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006d7	8b 55 d8	 mov	 edx, DWORD PTR _$S2$14[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  006da	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006db	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  006dd	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  006e3	72 14		 jb	 SHORT $LN647@Load

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  006e5	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  006e8	83 c1 23	 add	 ecx, 35			; 00000023H
  006eb	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  006ed	83 c0 fc	 add	 eax, -4			; fffffffcH
  006f0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  006f3	0f 87 39 01 00
	00		 ja	 $LN37@Load
$LN647@Load:

; 265  :         ::operator delete(_Ptr, _Bytes);

  006f9	51		 push	 ecx
  006fa	52		 push	 edx
  006fb	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00700	83 c4 08	 add	 esp, 8
$LN662@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  00703	8b 45 b8	 mov	 eax, DWORD PTR _$S1$13[ebp+20]
  00706	8b 4d a4	 mov	 ecx, DWORD PTR _$S1$13[ebp]
  00709	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  0070c	72 2b		 jb	 SHORT $LN325@Load

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0070e	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00711	8b c1		 mov	 eax, ecx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00713	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00719	72 14		 jb	 SHORT $LN335@Load

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0071b	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0071e	83 c2 23	 add	 edx, 35			; 00000023H
  00721	2b c1		 sub	 eax, ecx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00723	83 c0 fc	 add	 eax, -4			; fffffffcH
  00726	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00729	0f 87 03 01 00
	00		 ja	 $LN37@Load
$LN335@Load:

; 265  :         ::operator delete(_Ptr, _Bytes);

  0072f	52		 push	 edx
  00730	51		 push	 ecx
  00731	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
$LN666@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  00736	83 c4 08	 add	 esp, 8
$LN325@Load:
  00739	8b 4d d4	 mov	 ecx, DWORD PTR _local_envDataName$[ebp+20]
  0073c	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  0073f	72 2c		 jb	 SHORT $LN126@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00741	8b 55 c0	 mov	 edx, DWORD PTR _local_envDataName$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00744	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00745	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00747	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0074d	72 14		 jb	 SHORT $LN136@Load

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0074f	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00752	83 c1 23	 add	 ecx, 35			; 00000023H
  00755	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00757	83 c0 fc	 add	 eax, -4			; fffffffcH
  0075a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0075d	0f 87 cf 00 00
	00		 ja	 $LN37@Load
$LN136@Load:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00763	51		 push	 ecx
  00764	52		 push	 edx
  00765	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0076a	83 c4 08	 add	 esp, 8
$LN126@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  0076d	8b 4d a0	 mov	 ecx, DWORD PTR _strFileName$[ebp+20]

; 4841 :         _My_data._Mysize = 0;

  00770	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _local_envDataName$[ebp+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00777	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _local_envDataName$[ebp+20], 15 ; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0077e	c6 45 c0 00	 mov	 BYTE PTR _local_envDataName$[ebp], 0

; 2244 :         return _BUF_SIZE <= _Myres;

  00782	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  00785	72 2c		 jb	 SHORT $LN30@Load
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00787	8b 55 8c	 mov	 edx, DWORD PTR _strFileName$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0078a	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0078b	8b c2		 mov	 eax, edx

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0078d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00793	72 14		 jb	 SHORT $LN40@Load

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00795	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00798	83 c1 23	 add	 ecx, 35			; 00000023H
  0079b	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0079d	83 c0 fc	 add	 eax, -4			; fffffffcH
  007a0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  007a3	0f 87 89 00 00
	00		 ja	 $LN37@Load
$LN40@Load:

; 265  :         ::operator delete(_Ptr, _Bytes);

  007a9	51		 push	 ecx
  007aa	52		 push	 edx
  007ab	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  007b0	83 c4 08	 add	 esp, 8
$LN30@Load:
; File C:\Marty 5.5\Src-Client\Client\GameLib\MapOutdoorLoad.cpp

; 67   : 	return true;

  007b3	b0 01		 mov	 al, 1

; 68   : }

  007b5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  007b8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  007bf	59		 pop	 ecx
  007c0	5f		 pop	 edi
  007c1	5e		 pop	 esi
  007c2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007c5	33 cd		 xor	 ecx, ebp
  007c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007cc	8b e5		 mov	 esp, ebp
  007ce	5d		 pop	 ebp
  007cf	c2 0c 00	 ret	 12			; 0000000cH
$LN668@Load:

; 15   : 	{
; 16   : 		static std::string s_strOldPathName="";

  007d2	68 00 00 00 00	 push	 OFFSET ?$TSS0@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4HA
  007d7	e8 00 00 00 00	 call	 __Init_thread_header
  007dc	83 c4 04	 add	 esp, 4
  007df	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4HA, -1
  007e6	0f 85 73 f8 ff
	ff		 jne	 $LN2@Load
  007ec	68 00 00 00 00	 push	 OFFSET ??__Fs_strOldPathName@?2??Load@CMapOutdoor@@UAE_NMMM@Z@YAXXZ ; `CMapOutdoor::Load'::`3'::`dynamic atexit destructor for 's_strOldPathName''
  007f1	e8 00 00 00 00	 call	 _atexit
  007f6	68 00 00 00 00	 push	 OFFSET ?$TSS0@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4HA
  007fb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00802	e8 00 00 00 00	 call	 __Init_thread_footer
  00807	83 c4 08	 add	 esp, 8
  0080a	e9 50 f8 ff ff	 jmp	 $LN2@Load
$LN657@Load:

; 68   : }

  0080f	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN669@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00814	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN670@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4735 :             _Xlen_string(); // result too long

  00819	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN671@Load:

; 4904 :         _Xlen_string();

  0081e	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN672@Load:

; 2261 :             _Xran();

  00823	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN673@Load:

; 4904 :         _Xlen_string();

  00828	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN617@Load:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0082d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN37@Load:
  00832	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN664@Load:
  00837	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$1:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _c_rstrNewPathName$16[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$2:
  00008	8d 4d 8c	 lea	 ecx, DWORD PTR _strFileName$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$3:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$4:
  00018	8d 4d c0	 lea	 ecx, DWORD PTR _local_envDataName$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$5:
  00020	8d 4d a4	 lea	 ecx, DWORD PTR _$S1$13[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$7:
  00028	8d 4d d8	 lea	 ecx, DWORD PTR _$S2$14[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$8:
  00030	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00036	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CMapOutdoor@@UAE_NMMM@Z$0:
  0003b	68 00 00 00 00	 push	 OFFSET ?$TSS0@?2??Load@CMapOutdoor@@UAE_NMMM@Z@4HA
  00040	e8 00 00 00 00	 call	 __Init_thread_abort
  00045	59		 pop	 ecx
  00046	c3		 ret	 0
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
  0004a	cc		 int	 3
  0004b	cc		 int	 3
__ehhandler$?Load@CMapOutdoor@@UAE_NMMM@Z:
  0004c	90		 npad	 1
  0004d	90		 npad	 1
  0004e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00052	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00055	8b 8a 20 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-224]
  0005b	33 c8		 xor	 ecx, eax
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00065	33 c8		 xor	 ecx, eax
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CMapOutdoor@@UAE_NMMM@Z
  00071	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CMapOutdoor@@UAE_NMMM@Z ENDP			; CMapOutdoor::Load
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 137  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 138  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 139  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 140  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 87   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 141  :         _Throw_bad_array_new_length(); // add overflow
; 142  :     }
; 143  : 
; 144  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 87   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 146  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 147  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 148  : 
; 149  : #ifdef _DEBUG
; 150  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 151  : #endif // _DEBUG
; 152  :     return _Ptr;
; 153  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 145  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT
; _this$ = ecx

; 2610 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	57		 push	 edi

; 2611 :         auto& _My_data = _Mypair._Myval2;
; 2612 :         _STL_INTERNAL_CHECK(!_My_data._Large_string_engaged());
; 2613 : 
; 2614 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2615 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2616 :         } else {
; 2617 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2618 :         }
; 2619 : 
; 2620 :         if (_Count > max_size()) {

  00005	8b 7d 0c	 mov	 edi, DWORD PTR __Count$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00010	0f 87 9f 00 00
	00		 ja	 $LN33@Construct

; 2622 :         }
; 2623 : 
; 2624 :         auto& _Al       = _Getal();
; 2625 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 2626 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 2627 : 
; 2628 :         if (_Count < _BUF_SIZE) {

  00016	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH
  0001d	83 ff 10	 cmp	 edi, 16			; 00000010H
  00020	73 1a		 jae	 SHORT $LN3@Construct

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00022	57		 push	 edi
  00023	ff 75 08	 push	 DWORD PTR __Arg$[ebp]

; 2629 :             _My_data._Mysize = _Count;

  00026	89 7b 10	 mov	 DWORD PTR [ebx+16], edi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00029	53		 push	 ebx
  0002a	e8 00 00 00 00	 call	 _memcpy
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2630 :             _My_data._Myres  = _BUF_SIZE - 1;
; 2631 : 
; 2632 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2633 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2634 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2635 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2636 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2637 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00032	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0
  00036	5f		 pop	 edi

; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

  00037	5b		 pop	 ebx
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN3@Construct:
  0003c	56		 push	 esi

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0003d	8b f7		 mov	 esi, edi
  0003f	83 ce 0f	 or	 esi, 15			; 0000000fH
  00042	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00048	76 15		 jbe	 SHORT $LN10@Construct

; 4716 :             return _Max;

  0004a	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0004f	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0005a	83 c4 04	 add	 esp, 4
  0005d	eb 30		 jmp	 SHORT $LN31@Construct
$LN10@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

  0005f	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00064	3b f0		 cmp	 esi, eax
  00066	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2652 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00069	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0006c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00071	72 0b		 jb	 SHORT $LN18@Construct

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00079	83 c4 04	 add	 esp, 4
  0007c	eb 11		 jmp	 SHORT $LN31@Construct
$LN18@Construct:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

  0007e	85 c0		 test	 eax, eax
  00080	74 0b		 je	 SHORT $LN19@Construct

; 87   :         return ::operator new(_Bytes);

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00088	83 c4 04	 add	 esp, 4

; 245  :         return _Traits::_Allocate(_Bytes);

  0008b	eb 02		 jmp	 SHORT $LN31@Construct
$LN19@Construct:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

  0008d	33 c0		 xor	 eax, eax
$LN31@Construct:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0008f	57		 push	 edi
  00090	ff 75 08	 push	 DWORD PTR __Arg$[ebp]

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00093	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00096	50		 push	 eax

; 2653 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00097	89 03		 mov	 DWORD PTR [ebx], eax

; 2654 : 
; 2655 :         _Start_element_lifetimes(_Unfancy(_New_ptr), _New_capacity + 1);
; 2656 : 
; 2657 :         _My_data._Mysize = _Count;

  00099	89 7b 10	 mov	 DWORD PTR [ebx+16], edi

; 2658 :         _My_data._Myres  = _New_capacity;

  0009c	89 73 14	 mov	 DWORD PTR [ebx+20], esi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0009f	e8 00 00 00 00	 call	 _memcpy

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000a4	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2659 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2660 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2661 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2662 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2663 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2664 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000aa	5e		 pop	 esi
  000ab	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0
  000af	5f		 pop	 edi

; 2665 :         } else { // _Strat == _Construct_strategy::_From_string
; 2666 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2667 :         }
; 2668 : 
; 2669 :         _ASAN_STRING_CREATE(*this);
; 2670 :         _Proxy._Release();
; 2671 :     }

  000b0	5b		 pop	 ebx
  000b1	5d		 pop	 ebp
  000b2	c2 08 00	 ret	 8
$LN33@Construct:

; 2621 :             _Xlen_string(); // result too long

  000b5	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN30@Construct:
  000ba	cc		 int	 3
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z PROC ; std::_Traits_compare<std::char_traits<char> >, COMDAT

; 553  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 383  :         return _CSTD memcmp(_First1, _First2, _Count);

  00003	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]

; 553  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00006	53		 push	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

  00007	8b 5d 14	 mov	 ebx, DWORD PTR __Right_size$[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 553  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  0000a	56		 push	 esi

; 383  :         return _CSTD memcmp(_First1, _First2, _Count);

  0000b	8b 75 10	 mov	 esi, DWORD PTR __Right$[ebp]

; 553  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  0000e	57		 push	 edi
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 70   :     return _Right < _Left ? _Right : _Left;

  0000f	8b 7d 0c	 mov	 edi, DWORD PTR __Left_size$[ebp]
  00012	3b df		 cmp	 ebx, edi
  00014	8b cf		 mov	 ecx, edi
  00016	0f 42 cb	 cmovb	 ecx, ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 383  :         return _CSTD memcmp(_First1, _First2, _Count);

  00019	83 e9 04	 sub	 ecx, 4
  0001c	72 13		 jb	 SHORT $LN12@Traits_com
  0001e	66 90		 npad	 2
$LL13@Traits_com:
  00020	8b 02		 mov	 eax, DWORD PTR [edx]
  00022	3b 06		 cmp	 eax, DWORD PTR [esi]
  00024	75 10		 jne	 SHORT $LN11@Traits_com
  00026	83 c2 04	 add	 edx, 4
  00029	83 c6 04	 add	 esi, 4
  0002c	83 e9 04	 sub	 ecx, 4
  0002f	73 ef		 jae	 SHORT $LL13@Traits_com
$LN12@Traits_com:
  00031	83 f9 fc	 cmp	 ecx, -4			; fffffffcH
  00034	74 34		 je	 SHORT $LN10@Traits_com
$LN11@Traits_com:
  00036	8a 02		 mov	 al, BYTE PTR [edx]
  00038	3a 06		 cmp	 al, BYTE PTR [esi]
  0003a	75 27		 jne	 SHORT $LN14@Traits_com
  0003c	83 f9 fd	 cmp	 ecx, -3			; fffffffdH
  0003f	74 29		 je	 SHORT $LN10@Traits_com
  00041	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  00044	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00047	75 1a		 jne	 SHORT $LN14@Traits_com
  00049	83 f9 fe	 cmp	 ecx, -2			; fffffffeH
  0004c	74 1c		 je	 SHORT $LN10@Traits_com
  0004e	8a 42 02	 mov	 al, BYTE PTR [edx+2]
  00051	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00054	75 0d		 jne	 SHORT $LN14@Traits_com
  00056	83 f9 ff	 cmp	 ecx, -1
  00059	74 0f		 je	 SHORT $LN10@Traits_com
  0005b	8a 42 03	 mov	 al, BYTE PTR [edx+3]
  0005e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00061	74 07		 je	 SHORT $LN10@Traits_com
$LN14@Traits_com:
  00063	1b c0		 sbb	 eax, eax
  00065	83 c8 01	 or	 eax, 1
  00068	eb 02		 jmp	 SHORT $LN15@Traits_com
$LN10@Traits_com:
  0006a	33 c0		 xor	 eax, eax
$LN15@Traits_com:

; 554  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 555  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));
; 556  : 
; 557  :     if (_Ans != 0) {

  0006c	85 c0		 test	 eax, eax
  0006e	75 10		 jne	 SHORT $LN1@Traits_com

; 558  :         return _Ans;
; 559  :     }
; 560  : 
; 561  :     if (_Left_size < _Right_size) {

  00070	3b df		 cmp	 ebx, edi
  00072	76 08		 jbe	 SHORT $LN26@Traits_com

; 566  :         return 1;
; 567  :     }
; 568  : 
; 569  :     return 0;
; 570  : }

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	83 c8 ff	 or	 eax, -1
  00079	5b		 pop	 ebx
  0007a	5d		 pop	 ebp
  0007b	c3		 ret	 0
$LN26@Traits_com:

; 562  :         return -1;
; 563  :     }
; 564  : 
; 565  :     if (_Left_size > _Right_size) {

  0007c	1b c0		 sbb	 eax, eax
  0007e	f7 d8		 neg	 eax
$LN1@Traits_com:

; 566  :         return 1;
; 567  :     }
; 568  : 
; 569  :     return 0;
; 570  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
??$_Traits_compare@U?$char_traits@D@std@@@std@@YAHQBDI0I@Z ENDP ; std::_Traits_compare<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 766  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 2044 :         if (_Myfirst) { // destroy and deallocate old array

  00004	8b 37		 mov	 esi, DWORD PTR [edi]
  00006	85 f6		 test	 esi, esi
  00008	0f 84 a6 00 00
	00		 je	 $LN4@vector
  0000e	53		 push	 ebx

; 2045 :             _Destroy_range(_Myfirst, _Mylast, _Al);

  0000f	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

  00012	3b f3		 cmp	 esi, ebx
  00014	74 47		 je	 SHORT $LN8@vector
$LL9@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2244 :         return _BUF_SIZE <= _Myres;

  00016	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00019	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  0001c	72 27		 jb	 SHORT $LN28@vector
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001e	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00020	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00021	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00027	72 12		 jb	 SHORT $LN38@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00029	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0002c	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002f	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00031	83 c0 fc	 add	 eax, -4			; fffffffcH
  00034	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00037	77 7e		 ja	 SHORT $LN58@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00039	8b c2		 mov	 eax, edx
$LN38@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00042	83 c4 08	 add	 esp, 8
$LN28@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

  00045	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  0004c	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00053	c6 06 00	 mov	 BYTE PTR [esi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 1086 :         for (; _First != _Last; ++_First) {

  00056	83 c6 18	 add	 esi, 24			; 00000018H
  00059	3b f3		 cmp	 esi, ebx
  0005b	75 b9		 jne	 SHORT $LL9@vector
$LN8@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0005d	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00060	b8 ab aa aa 2a	 mov	 eax, 715827883		; 2aaaaaabH
  00065	8b 37		 mov	 esi, DWORD PTR [edi]
  00067	2b ce		 sub	 ecx, esi
  00069	f7 e9		 imul	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0006b	5b		 pop	 ebx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2047 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006c	c1 fa 02	 sar	 edx, 2
  0006f	8b c2		 mov	 eax, edx
  00071	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00074	03 c2		 add	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00076	8d 0c 40	 lea	 ecx, DWORD PTR [eax+eax*2]
  00079	c1 e1 03	 shl	 ecx, 3

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0007c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00082	72 12		 jb	 SHORT $LN61@vector

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00084	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00087	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0008a	2b f2		 sub	 esi, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0008c	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0008f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00092	77 23		 ja	 SHORT $LN58@vector

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00094	8b f2		 mov	 esi, edx
$LN61@vector:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00096	51		 push	 ecx
  00097	56		 push	 esi
  00098	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2049 :             _Myfirst = nullptr;

  0009d	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

  000a3	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vector

; 2050 :             _Mylast  = nullptr;

  000a6	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 2051 :             _Myend   = nullptr;

  000ad	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN4@vector:
  000b4	5f		 pop	 edi

; 772  :     }

  000b5	5e		 pop	 esi
  000b6	c3		 ret	 0
$LN58@vector:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000b7	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN76@vector:
  000bc	cc		 int	 3
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 418  :     _Xlength_error("map/set too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Throw_tree:
  0000a	cc		 int	 3
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4829 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2244 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4830 :         auto& _My_data = _Mypair._Myval2;
; 4831 :         _My_data._Orphan_all();
; 4832 :         if (_My_data._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN10@Tidy_deall
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN20@Tidy_deall

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN17@Tidy_deall

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN20@Tidy_deall:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN10@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 4845 :     }

  00044	c3		 ret	 0
$LN17@Tidy_deall:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN27@Tidy_deall:
  0004a	cc		 int	 3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
tv507 = -12						; size = 4
__Old$1$ = -8						; size = 4
tv519 = -4						; size = 4
__Old_size$1$ = -4					; size = 4
__Ptr$ = 8						; size = 4
tv512 = 12						; size = 4
$T1 = 12						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3268 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 3269 :         // append [_Ptr, _Ptr + _Count)
; 3270 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 3271 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 4f 10	 mov	 ecx, DWORD PTR [edi+16]
  00016	2b c1		 sub	 eax, ecx
  00018	89 4d fc	 mov	 DWORD PTR __Old_size$1$[ebp], ecx
  0001b	89 55 f8	 mov	 DWORD PTR __Old$1$[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 2e		 ja	 SHORT $LN2@append

; 3272 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3273 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2226 :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 2244 :         return _BUF_SIZE <= _Myres;

  0002a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2227 :         if (_Large_string_engaged()) {

  0002d	72 02		 jb	 SHORT $LN5@append

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	53		 push	 ebx
  00032	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 3274 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 3275 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00035	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _memmove
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3276 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00041	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 3289 :     }

  00045	8b c7		 mov	 eax, edi
  00047	5f		 pop	 edi
  00048	5e		 pop	 esi
  00049	5b		 pop	 ebx
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
$LN2@append:

; 4766 :         if (max_size() - _Old_size < _Size_increase) {

  00050	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00055	2b c1		 sub	 eax, ecx
  00057	3b c3		 cmp	 eax, ebx
  00059	0f 82 26 01 00
	00		 jb	 $LN77@append

; 4768 :         }
; 4769 : 
; 4770 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005f	8d 34 19	 lea	 esi, DWORD PTR [ecx+ebx]

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00062	83 ce 0f	 or	 esi, 15			; 0000000fH
  00065	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006b	76 18		 jbe	 SHORT $LN19@append

; 4716 :             return _Max;

  0006d	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00072	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  00080	83 c4 04	 add	 esp, 4
  00083	eb 61		 jmp	 SHORT $LN75@append
$LN19@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00085	8b c2		 mov	 eax, edx
  00087	d1 e8		 shr	 eax, 1
  00089	89 45 0c	 mov	 DWORD PTR tv512[ebp], eax
  0008c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00091	2b 45 0c	 sub	 eax, DWORD PTR tv512[ebp]
  00094	3b d0		 cmp	 edx, eax
  00096	76 18		 jbe	 SHORT $LN20@append

; 4720 :             return _Max;

  00098	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009d	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a8	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000ab	83 c4 04	 add	 esp, 4
  000ae	eb 36		 jmp	 SHORT $LN75@append
$LN20@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR tv512[ebp]
  000b3	03 c2		 add	 eax, edx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

  000b5	3b f0		 cmp	 esi, eax
  000b7	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4774 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000ba	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000bd	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000c2	72 0e		 jb	 SHORT $LN27@append

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]
  000cd	83 c4 04	 add	 esp, 4
  000d0	eb 14		 jmp	 SHORT $LN75@append
$LN27@append:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

  000d2	85 c0		 test	 eax, eax
  000d4	74 0e		 je	 SHORT $LN28@append

; 87   :         return ::operator new(_Bytes);

  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

  000dc	8b 4d fc	 mov	 ecx, DWORD PTR __Old_size$1$[ebp]

; 87   :         return ::operator new(_Bytes);

  000df	83 c4 04	 add	 esp, 4

; 245  :         return _Traits::_Allocate(_Bytes);

  000e2	eb 02		 jmp	 SHORT $LN75@append
$LN28@append:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

  000e4	33 c0		 xor	 eax, eax
$LN75@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4782 :         if (_BUF_SIZE <= _Old_capacity) {

  000e6	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000ea	8d 14 19	 lea	 edx, DWORD PTR [ecx+ebx]
  000ed	89 77 14	 mov	 DWORD PTR [edi+20], esi
  000f0	8d 34 08	 lea	 esi, DWORD PTR [eax+ecx]
  000f3	89 57 10	 mov	 DWORD PTR [edi+16], edx
  000f6	8d 14 1e	 lea	 edx, DWORD PTR [esi+ebx]
  000f9	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
  000fc	89 75 fc	 mov	 DWORD PTR tv519[ebp], esi
  000ff	89 55 f4	 mov	 DWORD PTR tv507[ebp], edx
  00102	51		 push	 ecx
  00103	72 56		 jb	 SHORT $LN13@append

; 4783 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  00105	8b 37		 mov	 esi, DWORD PTR [edi]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00107	56		 push	 esi
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 _memcpy
  0010e	53		 push	 ebx
  0010f	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00112	ff 75 fc	 push	 DWORD PTR tv519[ebp]
  00115	e8 00 00 00 00	 call	 _memcpy

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0011a	8b 45 f4	 mov	 eax, DWORD PTR tv507[ebp]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	83 c4 18	 add	 esp, 24			; 00000018H

; 4785 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00120	8b 4d f8	 mov	 ecx, DWORD PTR __Old$1$[ebp]
  00123	41		 inc	 ecx

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00124	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00127	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0012d	72 12		 jb	 SHORT $LN52@append

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0012f	8b 56 fc	 mov	 edx, DWORD PTR [esi-4]
  00132	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00135	2b f2		 sub	 esi, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00137	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0013a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0013d	77 4b		 ja	 SHORT $LN49@append

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0013f	8b f2		 mov	 esi, edx
$LN52@append:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00141	51		 push	 ecx
  00142	56		 push	 esi
  00143	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3280 :         return _Reallocate_grow_by(

  00148	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 265  :         ::operator delete(_Ptr, _Bytes);

  0014b	83 c4 08	 add	 esp, 8
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 3280 :         return _Reallocate_grow_by(

  0014e	89 07		 mov	 DWORD PTR [edi], eax

; 3289 :     }

  00150	8b c7		 mov	 eax, edi
  00152	5f		 pop	 edi
  00153	5e		 pop	 esi
  00154	5b		 pop	 ebx
  00155	8b e5		 mov	 esp, ebp
  00157	5d		 pop	 ebp
  00158	c2 08 00	 ret	 8
$LN13@append:

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0015b	57		 push	 edi
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	53		 push	 ebx
  00163	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00166	56		 push	 esi
  00167	e8 00 00 00 00	 call	 _memcpy

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0016c	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0016f	83 c4 18	 add	 esp, 24			; 00000018H

; 3286 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00172	c6 00 00	 mov	 BYTE PTR [eax], 0

; 3280 :         return _Reallocate_grow_by(

  00175	8b 45 0c	 mov	 eax, DWORD PTR $T1[ebp]
  00178	89 07		 mov	 DWORD PTR [edi], eax

; 3289 :     }

  0017a	8b c7		 mov	 eax, edi
  0017c	5f		 pop	 edi
  0017d	5e		 pop	 esi
  0017e	5b		 pop	 ebx
  0017f	8b e5		 mov	 esp, ebp
  00181	5d		 pop	 ebp
  00182	c2 08 00	 ret	 8
$LN77@append:

; 4767 :             _Xlen_string(); // result too long

  00185	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN49@append:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0018a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN73@append:
  0018f	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
__Result$1$ = -4					; size = 4
$T1 = 8							; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 3155 :     _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx

; 3156 :         if (this == _STD addressof(_Right)) {

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Right$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	3b f3		 cmp	 esi, ebx
  0000f	0f 84 14 01 00
	00		 je	 $LN22@operator

; 2244 :         return _BUF_SIZE <= _Myres;

  00015	83 7b 14 10	 cmp	 DWORD PTR [ebx+20], 16	; 00000010H

; 2235 :         const value_type* _Result = _Bx._Buf;

  00019	8b c3		 mov	 eax, ebx
  0001b	89 5d fc	 mov	 DWORD PTR __Result$1$[ebp], ebx

; 2236 :         if (_Large_string_engaged()) {

  0001e	72 05		 jb	 SHORT $LN5@operator

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  00020	8b 03		 mov	 eax, DWORD PTR [ebx]
  00022	89 45 fc	 mov	 DWORD PTR __Result$1$[ebp], eax
$LN5@operator:

; 3376 :         if (_Count <= _Mypair._Myval2._Myres) {

  00025	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]

; 3157 :             return *this;
; 3158 :         }
; 3159 : 
; 3160 :         auto& _Al             = _Getal();
; 3161 :         const auto& _Right_al = _Right._Getal();
; 3162 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3163 :             if (_Al != _Right_al) {
; 3164 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3165 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3166 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3167 : 
; 3168 :                 if (_Right._Mypair._Myval2._Large_string_engaged()) {
; 3169 :                     const auto _New_size     = _Right._Mypair._Myval2._Mysize;
; 3170 :                     const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
; 3171 :                     auto _Right_al_non_const = _Right_al;
; 3172 :                     const auto _New_ptr      = _Right_al_non_const.allocate(_New_capacity + 1); // throws
; 3173 : 
; 3174 :                     _Start_element_lifetimes(_Unfancy(_New_ptr), _New_size + 1);
; 3175 : 
; 3176 :                     _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
; 3177 :                     _Tidy_deallocate();
; 3178 :                     _Mypair._Myval2._Bx._Ptr = _New_ptr;
; 3179 :                     _Mypair._Myval2._Mysize  = _New_size;
; 3180 :                     _Mypair._Myval2._Myres   = _New_capacity;
; 3181 :                 } else {
; 3182 :                     _Copy_assign_val_from_small(_Right);
; 3183 :                 }
; 3184 : 
; 3185 :                 _Pocca(_Al, _Right_al);
; 3186 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3187 :                 return *this;
; 3188 :             }
; 3189 :         }
; 3190 : 
; 3191 :         _Pocca(_Al, _Right_al);
; 3192 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00028	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]

; 3376 :         if (_Count <= _Mypair._Myval2._Myres) {

  0002b	89 4d f8	 mov	 DWORD PTR __Old$1$[ebp], ecx
  0002e	57		 push	 edi
  0002f	3b d9		 cmp	 ebx, ecx
  00031	77 26		 ja	 SHORT $LN10@operator

; 2226 :         value_type* _Result = _Bx._Buf;

  00033	8b fe		 mov	 edi, esi

; 2244 :         return _BUF_SIZE <= _Myres;

  00035	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2227 :         if (_Large_string_engaged()) {

  00038	72 02		 jb	 SHORT $LN13@operator

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  0003a	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN13@operator:

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0003c	53		 push	 ebx
  0003d	50		 push	 eax
  0003e	57		 push	 edi

; 3379 :             _Mypair._Myval2._Mysize = _Count;

  0003f	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00042	e8 00 00 00 00	 call	 _memmove
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3381 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0004a	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 3193 :         return *this;

  0004e	8b c6		 mov	 eax, esi
  00050	5f		 pop	 edi

; 3194 :     }

  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c2 04 00	 ret	 4
$LN10@operator:

; 4734 :         if (_New_size > max_size()) {

  00059	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  0005f	0f 87 d3 00 00
	00		 ja	 $LN81@operator

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00065	8b fb		 mov	 edi, ebx
  00067	83 cf 0f	 or	 edi, 15			; 0000000fH
  0006a	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00070	76 15		 jbe	 SHORT $LN27@operator

; 4716 :             return _Max;

  00072	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00077	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00082	83 c4 04	 add	 esp, 4
  00085	eb 52		 jmp	 SHORT $LN79@operator
$LN27@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4719 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00087	8b d1		 mov	 edx, ecx
  00089	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0008e	d1 ea		 shr	 edx, 1
  00090	2b c2		 sub	 eax, edx
  00092	3b c8		 cmp	 ecx, eax
  00094	76 15		 jbe	 SHORT $LN28@operator

; 4720 :             return _Max;

  00096	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0009b	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a6	83 c4 04	 add	 esp, 4
  000a9	eb 2e		 jmp	 SHORT $LN79@operator
$LN28@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4723 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000ab	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

  000ae	3b f8		 cmp	 edi, eax
  000b0	0f 42 f8	 cmovb	 edi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4741 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000b3	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  000b6	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000bb	72 0b		 jb	 SHORT $LN35@operator

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000bd	50		 push	 eax
  000be	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000c3	83 c4 04	 add	 esp, 4
  000c6	eb 11		 jmp	 SHORT $LN79@operator
$LN35@operator:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

  000c8	85 c0		 test	 eax, eax
  000ca	74 0b		 je	 SHORT $LN36@operator

; 87   :         return ::operator new(_Bytes);

  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000d2	83 c4 04	 add	 esp, 4

; 245  :         return _Traits::_Allocate(_Bytes);

  000d5	eb 02		 jmp	 SHORT $LN79@operator
$LN36@operator:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

  000d7	33 c0		 xor	 eax, eax
$LN79@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d9	53		 push	 ebx
  000da	ff 75 fc	 push	 DWORD PTR __Result$1$[ebp]

; 4747 :         _Mypair._Myval2._Myres  = _New_capacity;

  000dd	89 7e 14	 mov	 DWORD PTR [esi+20], edi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000e0	8b f8		 mov	 edi, eax
  000e2	57		 push	 edi

; 4746 :         _Mypair._Myval2._Mysize = _New_size;

  000e3	89 45 08	 mov	 DWORD PTR $T1[ebp], eax
  000e6	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000e9	e8 00 00 00 00	 call	 _memcpy

; 4749 :         if (_BUF_SIZE <= _Old_capacity) {

  000ee	8b 45 f8	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3389 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000f4	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 4749 :         if (_BUF_SIZE <= _Old_capacity) {

  000f8	83 f8 10	 cmp	 eax, 16			; 00000010H
  000fb	72 29		 jb	 SHORT $LN21@operator

; 4750 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000fd	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00100	8b 06		 mov	 eax, DWORD PTR [esi]

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00102	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00108	72 12		 jb	 SHORT $LN58@operator

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0010a	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0010d	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00110	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00112	83 c0 fc	 add	 eax, -4			; fffffffcH
  00115	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00118	77 19		 ja	 SHORT $LN55@operator

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0011a	8b c2		 mov	 eax, edx
$LN58@operator:

; 265  :         ::operator delete(_Ptr, _Bytes);

  0011c	51		 push	 ecx
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00123	83 c4 08	 add	 esp, 8
$LN21@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4753 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00126	89 3e		 mov	 DWORD PTR [esi], edi
  00128	5f		 pop	 edi
$LN22@operator:

; 3193 :         return *this;

  00129	8b c6		 mov	 eax, esi

; 3194 :     }

  0012b	5e		 pop	 esi
  0012c	5b		 pop	 ebx
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 04 00	 ret	 4
$LN55@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00133	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN81@operator:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4735 :             _Xlen_string(); // result too long

  00138	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN78@operator:
  0013d	cc		 int	 3
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3118 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2244 :         return _BUF_SIZE <= _Myres;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 4832 :         if (_My_data._Large_string_engaged()) {

  00009	72 27		 jb	 SHORT $LN12@basic_stri
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 969  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4838 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  0000d	41		 inc	 ecx
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 261  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN22@basic_stri

; 160  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 161  : 
; 162  :     // If the following asserts, it likely means that we are performing
; 163  :     // an aligned delete on memory coming from an unaligned allocation.
; 164  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 165  : 
; 166  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 167  :     // in range [_Min_back_shift, _Non_user_size]
; 168  : #ifdef _DEBUG
; 169  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 170  : #else // ^^^ _DEBUG / !_DEBUG vvv
; 171  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 172  : #endif // _DEBUG
; 173  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN19@basic_stri

; 175  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN22@basic_stri:

; 265  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN12@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 4841 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4842 :         _My_data._Myres  = _BUF_SIZE - 1;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4843 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4844 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3126 :     }

  00044	c3		 ret	 0
$LN19@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 174  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN30@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 2960 :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 2961 :         if (this == _STD addressof(_Right)) {

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 26		 je	 SHORT $LN19@operator

; 2962 :             return *this;
; 2963 :         }
; 2964 : 
; 2965 :         auto& _Al                 = _Getal();
; 2966 :         auto& _Right_al           = _Right._Getal();
; 2967 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
; 2968 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 2969 :             if (_Al != _Right_al) {
; 2970 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 2971 :                 _Mypair._Myval2._Orphan_all();
; 2972 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 2973 :             }
; 2974 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 2975 :             if (_Al != _Right_al) {
; 2976 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 2977 :                 return *this;
; 2978 :             }
; 2979 :         }
; 2980 : 
; 2981 :         _Tidy_deallocate();

  0000e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2999 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00013	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00016	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00019	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  0001e	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 4821 :         _My_data._Mysize = 0;

  00023	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 4822 :         _My_data._Myres  = _BUF_SIZE - 1;

  0002a	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 4823 :         _My_data._Activate_SSO_buffer();
; 4824 : 
; 4825 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4826 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00031	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN19@operator:
  00034	5f		 pop	 edi

; 2982 :         _Pocma(_Al, _Right_al);
; 2983 :         _Take_contents(_Right);
; 2984 :         return *this;
; 2985 :     }

  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
_TEXT	SEGMENT
__New_size$1$ = -4					; size = 4
___formal$ = 8						; size = 1
__Source_of_al$ = 12					; size = 4
__Left_ptr$ = 16					; size = 4
__Left_size$ = 20					; size = 4
__Right_ptr$ = 24					; size = 4
__Right_size$ = 28					; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2783 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2784 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2785 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2786 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2787 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  00004	8b 55 14	 mov	 edx, DWORD PTR __Left_size$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	53		 push	 ebx
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8b 4d 1c	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  00010	56		 push	 esi
  00011	03 ca		 add	 ecx, edx

; 2788 :         size_type _New_capacity = _BUF_SIZE - 1;

  00013	be 0f 00 00 00	 mov	 esi, 15			; 0000000fH
  00018	89 4d fc	 mov	 DWORD PTR __New_size$1$[ebp], ecx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0001b	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

  0001e	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  00025	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0

; 2783 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

  0002c	57		 push	 edi

; 2789 :         auto& _My_data          = _Mypair._Myval2;
; 2790 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  0002d	8b fb		 mov	 edi, ebx

; 2791 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2792 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2793 : 
; 2794 :         if (_New_capacity < _New_size) {

  0002f	3b ce		 cmp	 ecx, esi
  00031	76 59		 jbe	 SHORT $LN2@basic_stri

; 4714 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00033	8b f1		 mov	 esi, ecx
  00035	83 ce 0f	 or	 esi, 15			; 0000000fH
  00038	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH

; 4715 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0003e	76 0a		 jbe	 SHORT $LN17@basic_stri

; 4716 :             return _Max;

  00040	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  00045	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  00048	eb 14		 jmp	 SHORT $LN30@basic_stri
$LN17@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\utility

; 47   :     return _Left < _Right ? _Right : _Left;

  0004a	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  0004f	3b f0		 cmp	 esi, eax
  00051	0f 42 f0	 cmovb	 esi, eax
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2796 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  00054	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00057	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0005c	72 13		 jb	 SHORT $LN25@basic_stri
$LN30@basic_stri:

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00064	8b 4d fc	 mov	 ecx, DWORD PTR __New_size$1$[ebp]
  00067	83 c4 04	 add	 esp, 4
  0006a	8b 55 14	 mov	 edx, DWORD PTR __Left_size$[ebp]
  0006d	8b f8		 mov	 edi, eax
  0006f	eb 19		 jmp	 SHORT $LN24@basic_stri
$LN25@basic_stri:

; 240  :         }
; 241  :     }
; 242  : #endif // defined(_M_IX86) || defined(_M_X64)
; 243  : 
; 244  :     if (_Bytes != 0) {

  00071	85 c0		 test	 eax, eax
  00073	74 13		 je	 SHORT $LN26@basic_stri

; 87   :         return ::operator new(_Bytes);

  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 245  :         return _Traits::_Allocate(_Bytes);

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __New_size$1$[ebp]

; 87   :         return ::operator new(_Bytes);

  0007e	83 c4 04	 add	 esp, 4

; 245  :         return _Traits::_Allocate(_Bytes);

  00081	8b 55 14	 mov	 edx, DWORD PTR __Left_size$[ebp]
  00084	8b f8		 mov	 edi, eax
  00086	eb 02		 jmp	 SHORT $LN24@basic_stri
$LN26@basic_stri:

; 246  :     }
; 247  : 
; 248  :     return nullptr;

  00088	33 ff		 xor	 edi, edi
$LN24@basic_stri:
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring

; 2798 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  0008a	89 3b		 mov	 DWORD PTR [ebx], edi
$LN2@basic_stri:

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0008c	52		 push	 edx
  0008d	ff 75 10	 push	 DWORD PTR __Left_ptr$[ebp]

; 2799 : 
; 2800 :             _Start_element_lifetimes(_Ptr, _New_capacity + 1);
; 2801 :         }
; 2802 : 
; 2803 :         _My_data._Mysize = _New_size;

  00090	89 4b 10	 mov	 DWORD PTR [ebx+16], ecx

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00093	57		 push	 edi

; 2804 :         _My_data._Myres  = _New_capacity;

  00094	89 73 14	 mov	 DWORD PTR [ebx+20], esi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00097	e8 00 00 00 00	 call	 _memcpy
  0009c	ff 75 1c	 push	 DWORD PTR __Right_size$[ebp]

; 2805 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2806 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  0009f	8b 45 14	 mov	 eax, DWORD PTR __Left_size$[ebp]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a2	ff 75 18	 push	 DWORD PTR __Right_ptr$[ebp]

; 2805 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2806 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  000a5	03 c7		 add	 eax, edi

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a7	50		 push	 eax
  000a8	e8 00 00 00 00	 call	 _memcpy

; 2807 :         _Traits::assign(_Ptr[_New_size], _Elem());

  000ad	8b 45 fc	 mov	 eax, DWORD PTR __New_size$1$[ebp]

; 66   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b0	83 c4 18	 add	 esp, 24			; 00000018H

; 2807 :         _Traits::assign(_Ptr[_New_size], _Elem());

  000b3	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0

; 2808 :         _ASAN_STRING_CREATE(*this);
; 2809 :         _Proxy._Release();
; 2810 :     }

  000b7	8b c3		 mov	 eax, ebx
  000b9	5f		 pop	 edi
  000ba	5e		 pop	 esi
  000bb	5b		 pop	 ebx
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c2 18 00	 ret	 24			; 00000018H
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2539 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 2539 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00009	56		 push	 esi
  0000a	8b f1		 mov	 esi, ecx

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000c	8b c2		 mov	 eax, edx

; 2539 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  0000e	57		 push	 edi

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0000f	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0

; 2293 :     size_type _Mysize = 0; // current length of string

  00012	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00019	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 2294 :     size_type _Myres  = 0; // current storage reserved for string

  0001c	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LL13@basic_stri:

; 403  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00023	8a 08		 mov	 cl, BYTE PTR [eax]
  00025	40		 inc	 eax
  00026	84 c9		 test	 cl, cl
  00028	75 f9		 jne	 SHORT $LL13@basic_stri
  0002a	2b c7		 sub	 eax, edi

; 2540 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002c	8b ce		 mov	 ecx, esi
  0002e	50		 push	 eax
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 2541 :     }

  00035	5f		 pop	 edi
  00036	8b c6		 mov	 eax, esi
  00038	5e		 pop	 esi
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2273 :         _Xout_of_range("invalid string position");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00005	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@Xran:
  0000a	cc		 int	 3
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 972  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 238  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 0d		 jb	 SHORT $LN4@allocate

; 239  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00013	83 c4 04	 add	 esp, 4

; 975  :     }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN4@allocate:

; 244  :     if (_Bytes != 0) {

  0001a	85 c0		 test	 eax, eax
  0001c	74 0d		 je	 SHORT $LN5@allocate

; 87   :         return ::operator new(_Bytes);

  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	83 c4 04	 add	 esp, 4

; 975  :     }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
$LN5@allocate:

; 973  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 974  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0002b	33 c0		 xor	 eax, eax

; 975  :     }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2312 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 331  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 332  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.37.32822\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1947 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 10	 push	 DWORD PTR __Format$[ebp]
  0000c	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0000f	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00012	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	83 c9 01	 or	 ecx, 1
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00025	83 c9 ff	 or	 ecx, -1
  00028	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002b	85 c0		 test	 eax, eax
  0002d	0f 48 c1	 cmovs	 eax, ecx

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);
; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
; 1952 :         __crt_va_end(_ArgList);
; 1953 :         return _Result;
; 1954 :     }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1771 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);
; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1777 : 
; 1778 :         __crt_va_end(_ArgList);
; 1779 :         return _Result;
; 1780 :     }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
