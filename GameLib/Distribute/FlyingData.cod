; Listing generated by Microsoft (R) Optimizing Compiler Version 19.43.34808.0 

	TITLE	C:\Marty 5.5\Src-Client\Client\GameLib\Distribute\FlyingData.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCFlyingData@@@@6B@		; CDynamicPool<CFlyingData>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCFlyingData@@@@@8	; CDynamicPool<CFlyingData> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCFlyingData@@@@8		; CDynamicPool<CFlyingData>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCFlyingData@@@@8		; CDynamicPool<CFlyingData>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCFlyingData@@@@8	; CDynamicPool<CFlyingData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPool@VCFlyingData@@@@6B@		; CDynamicPool<CFlyingData>::`vftable'
PUBLIC	??_G?$CDynamicPool@VCFlyingData@@@@UAEPAXI@Z	; CDynamicPool<CFlyingData>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
PUBLIC	??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCFlyingData@@@@UAEPAXI@Z:PROC ; CDynamicPool<CFlyingData>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vector deleting destructor'
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecora'
	DB	'tor@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDeco'
	DB	'rator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCFlyingData@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCFlyingData@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCFlyingData@@@@6B@ ; CDynamicPool<CFlyingData>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCFlyingData@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCFlyingData@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCFlyingData@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCFlyingData@@@@@8 ; CDynamicPool<CFlyingData>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCFlyingData@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCFlyingData@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCFlyingData@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCFlyingData@@@@8 ; CDynamicPool<CFlyingData>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCFlyingData@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCFlyingData@@@@8 DD 00H		; CDynamicPool<CFlyingData>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCFlyingData@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCFlyingData@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCFlyingData@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CFlyingData> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCFlyingData@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCFlyingData@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCFlyingData@@@@6B@ DD 00H		; CDynamicPool<CFlyingData>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCFlyingData@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCFlyingData@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDe'
	DB	'corator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDec'
	DB	'orator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpd'
	DB	'ateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@N'
	DB	'EffectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEff'
	DB	'ectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffe'
	DB	'ctUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1CGotoChild@CTextFileLoader@@QAE@XZ		; CTextFileLoader::CGotoChild::~CGotoChild
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??1TFlyingAttachData@CFlyingData@@QAE@XZ	; CFlyingData::TFlyingAttachData::~TFlyingAttachData
PUBLIC	??0CFlyingData@@QAE@XZ				; CFlyingData::CFlyingData
PUBLIC	??1CFlyingData@@UAE@XZ				; CFlyingData::~CFlyingData
PUBLIC	?Destroy@CFlyingData@@QAEXXZ			; CFlyingData::Destroy
PUBLIC	?LoadScriptFile@CFlyingData@@QAE_NPBD@Z		; CFlyingData::LoadScriptFile
PUBLIC	?SaveScriptFile@CFlyingData@@QAE_NPBD@Z		; CFlyingData::SaveScriptFile
PUBLIC	?SetBombEffect@CFlyingData@@QAEXPBD@Z		; CFlyingData::SetBombEffect
PUBLIC	?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z ; CFlyingData::AttachFlyEffect
PUBLIC	?GetAttachDataReference@CFlyingData@@QAEAAUTFlyingAttachData@1@H@Z ; CFlyingData::GetAttachDataReference
PUBLIC	?DuplicateAttach@CFlyingData@@QAEXH@Z		; CFlyingData::DuplicateAttach
PUBLIC	?RemoveAttach@CFlyingData@@QAEXH@Z		; CFlyingData::RemoveAttach
PUBLIC	?RemoveAllAttach@CFlyingData@@QAEXXZ		; CFlyingData::RemoveAllAttach
PUBLIC	?__Initialize@CFlyingData@@IAEXXZ		; CFlyingData::__Initialize
PUBLIC	??1?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::~vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >
PUBLIC	?_Xlength@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@CAXXZ ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Xlength
PUBLIC	??_GCFlyingData@@UAEPAXI@Z			; CFlyingData::`scalar deleting destructor'
PUBLIC	??1?$CDynamicPool@VCFlyingData@@@@UAE@XZ	; CDynamicPool<CFlyingData>::~CDynamicPool<CFlyingData>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Destroy_range@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAXPAUTFlyingAttachData@CFlyingData@@QAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ; std::_Destroy_range<std::allocator<CFlyingData::TFlyingAttachData> >
PUBLIC	??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Emplace_reallocate<CFlyingData::TFlyingAttachData const &>
PUBLIC	??$construct@UTFlyingAttachData@CFlyingData@@ABU12@@?$_Default_allocator_traits@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@SAXAAV?$allocator@UTFlyingAttachData@CFlyingData@@@1@QAUTFlyingAttachData@CFlyingData@@ABU34@@Z ; std::_Default_allocator_traits<std::allocator<CFlyingData::TFlyingAttachData> >::construct<CFlyingData::TFlyingAttachData,CFlyingData::TFlyingAttachData const &>
PUBLIC	??1_Reallocation_guard@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Reallocation_guard::~_Reallocation_guard
PUBLIC	??$_Uninitialized_move@PAUTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAPAUTFlyingAttachData@CFlyingData@@QAU12@0PAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ; std::_Uninitialized_move<CFlyingData::TFlyingAttachData *,std::allocator<CFlyingData::TFlyingAttachData> >
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
PUBLIC	?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
PUBLIC	?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A ; CFlyingData::ms_kPool
PUBLIC	??_7CFlyingData@@6B@				; CFlyingData::`vftable'
PUBLIC	??_C@_0O@NBBBNDDO@spreadingflag@		; `string'
PUBLIC	??_C@_0BF@IJDOJCHL@maintainparallelflag@	; `string'
PUBLIC	??_C@_0BA@HEDAMPDI@initialvelocity@		; `string'
PUBLIC	??_C@_09KDIMMAIL@coneangle@			; `string'
PUBLIC	??_C@_09LMFNGIPD@rollangle@			; `string'
PUBLIC	??_C@_0BA@LAOKBKDJ@angularvelocity@		; `string'
PUBLIC	??_C@_07GFBFDLBM@gravity@			; `string'
PUBLIC	??_C@_0BA@KECLBPOM@hitonbackground@		; `string'
PUBLIC	??_C@_0BE@CFEKODPK@hitonanothermonster@		; `string'
PUBLIC	??_C@_0M@CFHBGHLK@piercecount@			; `string'
PUBLIC	??_C@_09HBCJNFFH@bombrange@			; `string'
PUBLIC	??_C@_0L@JPKFDMHA@bombeffect@			; `string'
PUBLIC	??_C@_0L@PGFICFIL@homingflag@			; `string'
PUBLIC	??_C@_0BA@BAKAIINA@homingstarttime@		; `string'
PUBLIC	??_C@_0P@MGJJCPHI@homingmaxangle@		; `string'
PUBLIC	??_C@_05CCGOGOBM@range@				; `string'
PUBLIC	??_C@_0N@OKFAMOHD@acceleration@			; `string'
PUBLIC	??_C@_0L@NFEBBADL@attachdata@			; `string'
PUBLIC	??_C@_04GPMDFGEJ@type@				; `string'
PUBLIC	??_C@_07LKHMKNJJ@flytype@			; `string'
PUBLIC	??_C@_0L@BMGMFMHI@attachfile@			; `string'
PUBLIC	??_C@_08MNMLIJJL@tailflag@			; `string'
PUBLIC	??_C@_09JBANPIDH@tailcolor@			; `string'
PUBLIC	??_C@_0L@PJCCBNOK@taillength@			; `string'
PUBLIC	??_C@_08HAFAEPEI@tailsize@			; `string'
PUBLIC	??_C@_0O@DNCKGFAO@tailshaperect@		; `string'
PUBLIC	??_C@_04FBAPEKPH@roll@				; `string'
PUBLIC	??_C@_08LHFODBFO@distance@			; `string'
PUBLIC	??_C@_06FBOEEHNL@period@			; `string'
PUBLIC	??_C@_09EHCGJNBI@amplitude@			; `string'
PUBLIC	??_C@_0CM@NJMDEMJE@CFlyingData?3?3LoadScriptFile?5Wro@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_0BM@EKJFFBKN@SpreadingFlag?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BM@NGIIEBBO@MaintainParallelFlag?5?5?5?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BM@HFDPOBJA@InitialVelocity?5?5?5?5?5?5?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0BM@GGIANCOJ@ConeAngle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0BM@OAKALGPC@RollAngle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0CC@LMNGANIH@AngularVelocity?5?5?5?5?5?5?5?5?5?$CFf?5?$CFf?5?$CF@ ; `string'
PUBLIC	??_C@_0BM@GMCHDOFC@Gravity?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0BM@MIBEIPGM@HitOnBackground?5?5?5?5?5?5?5?5?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BM@DIMAIAMO@HitOnAnotherMonster?5?5?5?5?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BM@KJEBPHJO@PierceCount?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BM@BLFFPBNI@CollisionSphereRadius?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0BM@PKMAPKGM@BombRange?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0BO@BNDAHANN@BombEffect?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0BM@BPPBPLIE@HomingFlag?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BM@DFAFEFEK@HomingStartTime?5?5?5?5?5?5?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0BM@DJOJIKLN@HomingMaxAngle?5?5?5?5?5?5?5?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0BM@JPLBDGMP@Range?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0CC@KJGNOCOO@Acceleration?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?5?$CFf?5?$CF@ ; `string'
PUBLIC	??_C@_0BC@HICIMFMI@Group?5AttachData?6@		; `string'
PUBLIC	??_C@_02KCPFEJNG@?$HL?6@			; `string'
PUBLIC	??_C@_0BC@FDNPIKOA@Type?5?5?5?5?5?5?5?5?5?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BC@BLGHHPCB@FlyType?5?5?5?5?5?5?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BE@KGOGOAGA@AttachFile?5?5?5?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0BC@OICNGABA@TailFlag?5?5?5?5?5?5?$CFd?6@	; `string'
PUBLIC	??_C@_0BD@GDEIOKGL@TailColor?5?5?5?5?5?$CFud?6@	; `string'
PUBLIC	??_C@_0BC@BJCKHMFB@TailLength?5?5?5?5?$CFf?6@	; `string'
PUBLIC	??_C@_0BC@DBHBKFFP@TailSize?5?5?5?5?5?5?$CFf?6@	; `string'
PUBLIC	??_C@_0BC@GIAPEHPE@TailShapeRect?5?$CFd?6@	; `string'
PUBLIC	??_C@_0BC@NJDFDGEH@Roll?5?5?5?5?5?5?5?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0BC@MGMHDAIP@Distance?5?5?5?5?5?5?$CFf?6@	; `string'
PUBLIC	??_C@_0BC@HBPGEMBJ@Period?5?5?5?5?5?5?5?5?$CFf?6@ ; `string'
PUBLIC	??_C@_0BC@BECPBEGP@Amplitude?5?5?5?5?5?$CFf?6@	; `string'
PUBLIC	??_C@_02KGHIDFGE@?$HN?6@			; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CFlyingData@@6B@				; CFlyingData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCFlyingData@@@8				; CFlyingData `RTTI Type Descriptor'
PUBLIC	??_R3CFlyingData@@8				; CFlyingData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CFlyingData@@8				; CFlyingData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CFlyingData@@8			; CFlyingData::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	?GetCaseCRC32@@YAKPBDI@Z:PROC			; GetCaseCRC32
EXTRN	?GetOnlyPathName@@YAPBDPBD@Z:PROC		; GetOnlyPathName
EXTRN	?GetLocalFileName@@YA_NPBD0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; GetLocalFileName
EXTRN	?StringPath@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; StringPath
EXTRN	?StringPath@@YAXPBDAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; StringPath
EXTRN	?IsGlobalFileName@@YA_NPBD@Z:PROC		; IsGlobalFileName
EXTRN	?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ:PROC		; PrintfTabs
EXTRN	??0CTextFileLoader@@QAE@XZ:PROC			; CTextFileLoader::CTextFileLoader
EXTRN	??1CTextFileLoader@@UAE@XZ:PROC			; CTextFileLoader::~CTextFileLoader
EXTRN	?Load@CTextFileLoader@@QAE_NPBD@Z:PROC		; CTextFileLoader::Load
EXTRN	?GetFileName@CTextFileLoader@@QAEPBDXZ:PROC	; CTextFileLoader::GetFileName
EXTRN	?SetTop@CTextFileLoader@@QAEXXZ:PROC		; CTextFileLoader::SetTop
EXTRN	?GetChildNodeCount@CTextFileLoader@@QAEKXZ:PROC	; CTextFileLoader::GetChildNodeCount
EXTRN	?SetChildNode@CTextFileLoader@@QAEHK@Z:PROC	; CTextFileLoader::SetChildNode
EXTRN	?SetParentNode@CTextFileLoader@@QAEHXZ:PROC	; CTextFileLoader::SetParentNode
EXTRN	?GetCurrentNodeName@CTextFileLoader@@QAEHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CTextFileLoader::GetCurrentNodeName
EXTRN	?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z:PROC ; CTextFileLoader::GetTokenInteger
EXTRN	?GetTokenDoubleWord@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAK@Z:PROC ; CTextFileLoader::GetTokenDoubleWord
EXTRN	?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z:PROC ; CTextFileLoader::GetTokenFloat
EXTRN	?GetTokenVector3@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXVECTOR3@@@Z:PROC ; CTextFileLoader::GetTokenVector3
EXTRN	?GetTokenString@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV23@@Z:PROC ; CTextFileLoader::GetTokenString
EXTRN	?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z:PROC ; CEffectManager::RegisterEffect
EXTRN	?RegisterEffect2@CEffectManager@@QAEHPBDPAK_N@Z:PROC ; CEffectManager::RegisterEffect2
EXTRN	??_ECFlyingData@@UAEPAXI@Z:PROC			; CFlyingData::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A DD 01H DUP (?) ; CSingleton<CEffectManager>::ms_singleton
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CFlyingData@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CFlyingData@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT ??_R1A@?0A@EA@CFlyingData@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CFlyingData@@8 DD FLAT:??_R0?AVCFlyingData@@@8 ; CFlyingData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CFlyingData@@8
rdata$r	ENDS
;	COMDAT ??_R2CFlyingData@@8
rdata$r	SEGMENT
??_R2CFlyingData@@8 DD FLAT:??_R1A@?0A@EA@CFlyingData@@8 ; CFlyingData::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CFlyingData@@8
rdata$r	SEGMENT
??_R3CFlyingData@@8 DD 00H				; CFlyingData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CFlyingData@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCFlyingData@@@8
data$rs	SEGMENT
??_R0?AVCFlyingData@@@8 DD FLAT:??_7type_info@@6B@	; CFlyingData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCFlyingData@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CFlyingData@@6B@
rdata$r	SEGMENT
??_R4CFlyingData@@6B@ DD 00H				; CFlyingData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCFlyingData@@@8
	DD	FLAT:??_R3CFlyingData@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KGHIDFGE@?$HN?6@
CONST	SEGMENT
??_C@_02KGHIDFGE@?$HN?6@ DB '}', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BECPBEGP@Amplitude?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BC@BECPBEGP@Amplitude?5?5?5?5?5?$CFf?6@ DB 'Amplitude     %f', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HBPGEMBJ@Period?5?5?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BC@HBPGEMBJ@Period?5?5?5?5?5?5?5?5?$CFf?6@ DB 'Period        %f', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MGMHDAIP@Distance?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BC@MGMHDAIP@Distance?5?5?5?5?5?5?$CFf?6@ DB 'Distance      %f', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NJDFDGEH@Roll?5?5?5?5?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BC@NJDFDGEH@Roll?5?5?5?5?5?5?5?5?5?5?$CFf?6@ DB 'Roll          %f', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GIAPEHPE@TailShapeRect?5?$CFd?6@
CONST	SEGMENT
??_C@_0BC@GIAPEHPE@TailShapeRect?5?$CFd?6@ DB 'TailShapeRect %d', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DBHBKFFP@TailSize?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BC@DBHBKFFP@TailSize?5?5?5?5?5?5?$CFf?6@ DB 'TailSize      %f', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BJCKHMFB@TailLength?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BC@BJCKHMFB@TailLength?5?5?5?5?$CFf?6@ DB 'TailLength    %f', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GDEIOKGL@TailColor?5?5?5?5?5?$CFud?6@
CONST	SEGMENT
??_C@_0BD@GDEIOKGL@TailColor?5?5?5?5?5?$CFud?6@ DB 'TailColor     %ud', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OICNGABA@TailFlag?5?5?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BC@OICNGABA@TailFlag?5?5?5?5?5?5?$CFd?6@ DB 'TailFlag      %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KGOGOAGA@AttachFile?5?5?5?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BE@KGOGOAGA@AttachFile?5?5?5?5?$CC?$CFs?$CC?6@ DB 'AttachFile    "'
	DB	'%s"', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@BLGHHPCB@FlyType?5?5?5?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BC@BLGHHPCB@FlyType?5?5?5?5?5?5?5?$CFd?6@ DB 'FlyType       %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FDNPIKOA@Type?5?5?5?5?5?5?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BC@FDNPIKOA@Type?5?5?5?5?5?5?5?5?5?5?$CFd?6@ DB 'Type          %d', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCPFEJNG@?$HL?6@
CONST	SEGMENT
??_C@_02KCPFEJNG@?$HL?6@ DB '{', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HICIMFMI@Group?5AttachData?6@
CONST	SEGMENT
??_C@_0BC@HICIMFMI@Group?5AttachData?6@ DB 'Group AttachData', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KJGNOCOO@Acceleration?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?5?$CFf?5?$CF@
CONST	SEGMENT
??_C@_0CC@KJGNOCOO@Acceleration?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?5?$CFf?5?$CF@ DB 'A'
	DB	'cceleration            %f %f %f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JPLBDGMP@Range?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BM@JPLBDGMP@Range?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@ DB 'R'
	DB	'ange                   %f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DJOJIKLN@HomingMaxAngle?5?5?5?5?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BM@DJOJIKLN@HomingMaxAngle?5?5?5?5?5?5?5?5?5?5?$CFf?6@ DB 'HomingM'
	DB	'axAngle          %f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DFAFEFEK@HomingStartTime?5?5?5?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BM@DFAFEFEK@HomingStartTime?5?5?5?5?5?5?5?5?5?$CFf?6@ DB 'HomingSt'
	DB	'artTime         %f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BPPBPLIE@HomingFlag?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BM@BPPBPLIE@HomingFlag?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@ DB 'Hom'
	DB	'ingFlag              %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BNDAHANN@BombEffect?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BO@BNDAHANN@BombEffect?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CC?$CFs?$CC?6@ DB 'B'
	DB	'ombEffect              "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PKMAPKGM@BombRange?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BM@PKMAPKGM@BombRange?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@ DB 'Bo'
	DB	'mbRange               %f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@BLFFPBNI@CollisionSphereRadius?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BM@BLFFPBNI@CollisionSphereRadius?5?5?5?$CFf?6@ DB 'CollisionSpher'
	DB	'eRadius   %f', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KJEBPHJO@PierceCount?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BM@KJEBPHJO@PierceCount?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@ DB 'Pier'
	DB	'ceCount             %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@DIMAIAMO@HitOnAnotherMonster?5?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BM@DIMAIAMO@HitOnAnotherMonster?5?5?5?5?5?$CFd?6@ DB 'HitOnAnother'
	DB	'Monster     %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MIBEIPGM@HitOnBackground?5?5?5?5?5?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BM@MIBEIPGM@HitOnBackground?5?5?5?5?5?5?5?5?5?$CFd?6@ DB 'HitOnBac'
	DB	'kground         %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GMCHDOFC@Gravity?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BM@GMCHDOFC@Gravity?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@ DB 'G'
	DB	'ravity                 %f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@LMNGANIH@AngularVelocity?5?5?5?5?5?5?5?5?5?$CFf?5?$CFf?5?$CF@
CONST	SEGMENT
??_C@_0CC@LMNGANIH@AngularVelocity?5?5?5?5?5?5?5?5?5?$CFf?5?$CFf?5?$CF@ DB 'A'
	DB	'ngularVelocity         %f %f %f', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OAKALGPC@RollAngle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BM@OAKALGPC@RollAngle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@ DB 'Ro'
	DB	'llAngle               %f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GGIANCOJ@ConeAngle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BM@GGIANCOJ@ConeAngle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@ DB 'Co'
	DB	'neAngle               %f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@HFDPOBJA@InitialVelocity?5?5?5?5?5?5?5?5?5?$CFf?6@
CONST	SEGMENT
??_C@_0BM@HFDPOBJA@InitialVelocity?5?5?5?5?5?5?5?5?5?$CFf?6@ DB 'InitialV'
	DB	'elocity         %f', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NGIIEBBO@MaintainParallelFlag?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BM@NGIIEBBO@MaintainParallelFlag?5?5?5?5?$CFd?6@ DB 'MaintainParal'
	DB	'lelFlag    %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EKJFFBKN@SpreadingFlag?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BM@EKJFFBKN@SpreadingFlag?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@ DB 'Spread'
	DB	'ingFlag           %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@NJMDEMJE@CFlyingData?3?3LoadScriptFile?5Wro@
CONST	SEGMENT
??_C@_0CM@NJMDEMJE@CFlyingData?3?3LoadScriptFile?5Wro@ DB 'CFlyingData::L'
	DB	'oadScriptFile Wrong Data : %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09EHCGJNBI@amplitude@
CONST	SEGMENT
??_C@_09EHCGJNBI@amplitude@ DB 'amplitude', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FBOEEHNL@period@
CONST	SEGMENT
??_C@_06FBOEEHNL@period@ DB 'period', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LHFODBFO@distance@
CONST	SEGMENT
??_C@_08LHFODBFO@distance@ DB 'distance', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04FBAPEKPH@roll@
CONST	SEGMENT
??_C@_04FBAPEKPH@roll@ DB 'roll', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DNCKGFAO@tailshaperect@
CONST	SEGMENT
??_C@_0O@DNCKGFAO@tailshaperect@ DB 'tailshaperect', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08HAFAEPEI@tailsize@
CONST	SEGMENT
??_C@_08HAFAEPEI@tailsize@ DB 'tailsize', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PJCCBNOK@taillength@
CONST	SEGMENT
??_C@_0L@PJCCBNOK@taillength@ DB 'taillength', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JBANPIDH@tailcolor@
CONST	SEGMENT
??_C@_09JBANPIDH@tailcolor@ DB 'tailcolor', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08MNMLIJJL@tailflag@
CONST	SEGMENT
??_C@_08MNMLIJJL@tailflag@ DB 'tailflag', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@BMGMFMHI@attachfile@
CONST	SEGMENT
??_C@_0L@BMGMFMHI@attachfile@ DB 'attachfile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LKHMKNJJ@flytype@
CONST	SEGMENT
??_C@_07LKHMKNJJ@flytype@ DB 'flytype', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPMDFGEJ@type@
CONST	SEGMENT
??_C@_04GPMDFGEJ@type@ DB 'type', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NFEBBADL@attachdata@
CONST	SEGMENT
??_C@_0L@NFEBBADL@attachdata@ DB 'attachdata', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OKFAMOHD@acceleration@
CONST	SEGMENT
??_C@_0N@OKFAMOHD@acceleration@ DB 'acceleration', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCGOGOBM@range@
CONST	SEGMENT
??_C@_05CCGOGOBM@range@ DB 'range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MGJJCPHI@homingmaxangle@
CONST	SEGMENT
??_C@_0P@MGJJCPHI@homingmaxangle@ DB 'homingmaxangle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BAKAIINA@homingstarttime@
CONST	SEGMENT
??_C@_0BA@BAKAIINA@homingstarttime@ DB 'homingstarttime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PGFICFIL@homingflag@
CONST	SEGMENT
??_C@_0L@PGFICFIL@homingflag@ DB 'homingflag', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JPKFDMHA@bombeffect@
CONST	SEGMENT
??_C@_0L@JPKFDMHA@bombeffect@ DB 'bombeffect', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HBCJNFFH@bombrange@
CONST	SEGMENT
??_C@_09HBCJNFFH@bombrange@ DB 'bombrange', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CFHBGHLK@piercecount@
CONST	SEGMENT
??_C@_0M@CFHBGHLK@piercecount@ DB 'piercecount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CFEKODPK@hitonanothermonster@
CONST	SEGMENT
??_C@_0BE@CFEKODPK@hitonanothermonster@ DB 'hitonanothermonster', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KECLBPOM@hitonbackground@
CONST	SEGMENT
??_C@_0BA@KECLBPOM@hitonbackground@ DB 'hitonbackground', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07GFBFDLBM@gravity@
CONST	SEGMENT
??_C@_07GFBFDLBM@gravity@ DB 'gravity', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LAOKBKDJ@angularvelocity@
CONST	SEGMENT
??_C@_0BA@LAOKBKDJ@angularvelocity@ DB 'angularvelocity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMFNGIPD@rollangle@
CONST	SEGMENT
??_C@_09LMFNGIPD@rollangle@ DB 'rollangle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09KDIMMAIL@coneangle@
CONST	SEGMENT
??_C@_09KDIMMAIL@coneangle@ DB 'coneangle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HEDAMPDI@initialvelocity@
CONST	SEGMENT
??_C@_0BA@HEDAMPDI@initialvelocity@ DB 'initialvelocity', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@IJDOJCHL@maintainparallelflag@
CONST	SEGMENT
??_C@_0BF@IJDOJCHL@maintainparallelflag@ DB 'maintainparallelflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NBBBNDDO@spreadingflag@
CONST	SEGMENT
??_C@_0O@NBBBNDDO@spreadingflag@ DB 'spreadingflag', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CFlyingData@@6B@
CONST	SEGMENT
??_7CFlyingData@@6B@ DD FLAT:??_R4CFlyingData@@6B@	; CFlyingData::`vftable'
	DD	FLAT:??_ECFlyingData@@UAEPAXI@Z
CONST	ENDS
_DATA	SEGMENT
?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A DD FLAT:??_7?$CDynamicPool@VCFlyingData@@@@6B@ ; CFlyingData::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A
_DATA	SEGMENT
?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A DD FLAT:??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_DATA	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z$0
__ehfuncinfo$??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z$0
__ehfuncinfo$?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SaveScriptFile@CFlyingData@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveScriptFile@CFlyingData@@QAE_NPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SaveScriptFile@CFlyingData@@QAE_NPBD@Z$1
__ehfuncinfo$?SaveScriptFile@CFlyingData@@QAE_NPBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SaveScriptFile@CFlyingData@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z DD 019930522H
	DD	023H
	DD	FLAT:__unwindtable$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$9
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$10
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$11
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$12
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$15
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$16
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$17
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$18
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$19
	DD	012H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$20
	DD	013H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$21
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$22
	DD	00H
	DD	FLAT:___std_terminate
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$23
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$24
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$26
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$27
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$28
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$29
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$30
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$31
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$32
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$33
	DD	014H
	DD	FLAT:__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$34
	DD	00H
	DD	FLAT:___std_terminate
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CFlyingData@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CFlyingData@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CFlyingData@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CFlyingData@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CFlyingData@@QAE@XZ$2
__ehfuncinfo$??0CFlyingData@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CFlyingData@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CGotoChild@CTextFileLoader@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAPAUTFlyingAttachData@CFlyingData@@QAU12@0PAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAPAUTFlyingAttachData@CFlyingData@@QAU12@0PAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z PROC ; std::_Uninitialized_move<CFlyingData::TFlyingAttachData *,std::allocator<CFlyingData::TFlyingAttachData> >, COMDAT

; 1940 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	53		 push	 ebx
  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000a	56		 push	 esi

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  0000b	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  0000e	3b c3		 cmp	 eax, ebx
  00010	0f 84 9d 00 00
	00		 je	 $LN3@Uninitiali
  00016	57		 push	 edi

; 1796 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00017	8b fe		 mov	 edi, esi
  00019	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  0001c	8d 48 1c	 lea	 ecx, DWORD PTR [eax+28]
  0001f	2b f8		 sub	 edi, eax
$LL4@Uninitiali:
  00021	8b 41 e4	 mov	 eax, DWORD PTR [ecx-28]

; 1808 :         ++_Last;

  00024	8d 49 44	 lea	 ecx, DWORD PTR [ecx+68]
  00027	89 06		 mov	 DWORD PTR [esi], eax
  00029	8d 52 44	 lea	 edx, DWORD PTR [edx+68]
  0002c	8b 41 a4	 mov	 eax, DWORD PTR [ecx-92]
  0002f	0f 57 c0	 xorps	 xmm0, xmm0
  00032	89 42 b8	 mov	 DWORD PTR [edx-72], eax
  00035	83 c6 44	 add	 esi, 68			; 00000044H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00038	0f 11 42 bc	 movups	 XMMWORD PTR [edx-68], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  0003c	c7 42 cc 00 00
	00 00		 mov	 DWORD PTR [edx-52], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00043	c7 44 39 bc 00
	00 00 00	 mov	 DWORD PTR [ecx+edi-68], 0

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004b	0f 10 41 a8	 movups	 xmm0, XMMWORD PTR [ecx-88]
  0004f	0f 11 42 bc	 movups	 XMMWORD PTR [edx-68], xmm0
  00053	f3 0f 7e 41 b8	 movq	 xmm0, QWORD PTR [ecx-72]
  00058	66 0f d6 42 cc	 movq	 QWORD PTR [edx-52], xmm0

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

  0005d	c7 41 b8 00 00
	00 00		 mov	 DWORD PTR [ecx-72], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  00064	c7 41 bc 0f 00
	00 00		 mov	 DWORD PTR [ecx-68], 15	; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  0006b	c6 41 a8 00	 mov	 BYTE PTR [ecx-88], 0
  0006f	0f b6 41 c0	 movzx	 eax, BYTE PTR [ecx-64]
  00073	88 42 d4	 mov	 BYTE PTR [edx-44], al
  00076	8b 41 c4	 mov	 eax, DWORD PTR [ecx-60]
  00079	89 42 d8	 mov	 DWORD PTR [edx-40], eax
  0007c	8b 41 c8	 mov	 eax, DWORD PTR [ecx-56]
  0007f	89 42 dc	 mov	 DWORD PTR [edx-36], eax
  00082	8b 41 cc	 mov	 eax, DWORD PTR [ecx-52]
  00085	89 42 e0	 mov	 DWORD PTR [edx-32], eax
  00088	0f b6 41 d0	 movzx	 eax, BYTE PTR [ecx-48]
  0008c	88 42 e4	 mov	 BYTE PTR [edx-28], al
  0008f	8b 41 d4	 mov	 eax, DWORD PTR [ecx-44]
  00092	89 42 e8	 mov	 DWORD PTR [edx-24], eax
  00095	8b 41 d8	 mov	 eax, DWORD PTR [ecx-40]
  00098	89 42 ec	 mov	 DWORD PTR [edx-20], eax
  0009b	8b 41 dc	 mov	 eax, DWORD PTR [ecx-36]
  0009e	89 42 f0	 mov	 DWORD PTR [edx-16], eax
  000a1	8b 41 e0	 mov	 eax, DWORD PTR [ecx-32]
  000a4	89 42 f4	 mov	 DWORD PTR [edx-12], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1961 :     for (; _UFirst != _ULast; ++_UFirst) {

  000a7	8d 41 e4	 lea	 eax, DWORD PTR [ecx-28]
  000aa	3b c3		 cmp	 eax, ebx
  000ac	0f 85 6f ff ff
	ff		 jne	 $LL4@Uninitiali
  000b2	5f		 pop	 edi
$LN3@Uninitiali:

; 1802 :         _STD _Destroy_range(_First, _Last, _Al);

  000b3	ff 75 14	 push	 DWORD PTR __Al$[ebp]
  000b6	56		 push	 esi
  000b7	56		 push	 esi
  000b8	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAXPAUTFlyingAttachData@CFlyingData@@QAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ; std::_Destroy_range<std::allocator<CFlyingData::TFlyingAttachData> >
  000bd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1962 :         _Backout._Emplace_back(_STD move(*_UFirst));
; 1963 :     }
; 1964 : 
; 1965 :     return _Backout._Release();

  000c0	8b c6		 mov	 eax, esi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx

; 1966 : }

  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
??$_Uninitialized_move@PAUTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAPAUTFlyingAttachData@CFlyingData@@QAU12@0PAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ENDP ; std::_Uninitialized_move<CFlyingData::TFlyingAttachData *,std::allocator<CFlyingData::TFlyingAttachData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1_Reallocation_guard@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Reallocation_guard@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ PROC ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Reallocation_guard::~_Reallocation_guard, COMDAT
; _this$ = ecx

; 605  :         _CONSTEXPR20 ~_Reallocation_guard() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 606  :             if (_New_begin != nullptr) {

  00003	83 7e 04 00	 cmp	 DWORD PTR [esi+4], 0
  00007	74 43		 je	 SHORT $LN10@Reallocati

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

  00009	ff 36		 push	 DWORD PTR [esi]
  0000b	ff 76 10	 push	 DWORD PTR [esi+16]
  0000e	ff 76 0c	 push	 DWORD PTR [esi+12]
  00011	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAXPAUTFlyingAttachData@CFlyingData@@QAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ; std::_Destroy_range<std::allocator<CFlyingData::TFlyingAttachData> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00016	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 607  :                 _STD _Destroy_range(_Constructed_first, _Constructed_last, _Al);

  00019	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	c1 e1 04	 shl	 ecx, 4
  00022	03 4e 08	 add	 ecx, DWORD PTR [esi+8]
  00025	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00028	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0002e	72 12		 jb	 SHORT $LN21@Reallocati

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00030	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00033	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00036	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00038	83 c0 fc	 add	 eax, -4			; fffffffcH
  0003b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0003e	77 0e		 ja	 SHORT $LN18@Reallocati

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00040	8b c2		 mov	 eax, edx
$LN21@Reallocati:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00042	51		 push	 ecx
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00049	83 c4 08	 add	 esp, 8
$LN10@Reallocati:
  0004c	5e		 pop	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 610  :         }

  0004d	c3		 ret	 0
$LN18@Reallocati:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004e	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@Reallocati:
  00053	cc		 int	 3
??1_Reallocation_guard@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ ENDP ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Reallocation_guard::~_Reallocation_guard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$construct@UTFlyingAttachData@CFlyingData@@ABU12@@?$_Default_allocator_traits@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@SAXAAV?$allocator@UTFlyingAttachData@CFlyingData@@@1@QAUTFlyingAttachData@CFlyingData@@ABU34@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Result$1$ = 12					; size = 4
_<_Args_0>$ = 16					; size = 4
__Count$1$ = 16						; size = 4
??$construct@UTFlyingAttachData@CFlyingData@@ABU12@@?$_Default_allocator_traits@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@SAXAAV?$allocator@UTFlyingAttachData@CFlyingData@@@1@QAUTFlyingAttachData@CFlyingData@@ABU34@@Z PROC ; std::_Default_allocator_traits<std::allocator<CFlyingData::TFlyingAttachData> >::construct<CFlyingData::TFlyingAttachData,CFlyingData::TFlyingAttachData const &>, COMDAT

; 728  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 10	 mov	 ebx, DWORD PTR _<_Args_0>$[ebp]
  00007	0f 57 c0	 xorps	 xmm0, xmm0
  0000a	56		 push	 esi
  0000b	8b 75 0c	 mov	 esi, DWORD PTR __Ptr$[ebp]
  0000e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00010	89 06		 mov	 DWORD PTR [esi], eax
  00012	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00015	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00018	8d 43 08	 lea	 eax, DWORD PTR [ebx+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0001b	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  0001f	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 425  :         const value_type* _Result = _Bx._Buf;

  00026	8b c8		 mov	 ecx, eax

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00028	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 434  :         return _Myres > _Small_string_capacity;

  0002f	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00033	89 45 0c	 mov	 DWORD PTR __Result$1$[ebp], eax

; 426  :         if (_Large_mode_engaged()) {

  00036	76 05		 jbe	 SHORT $LN22@construct

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	89 4d 0c	 mov	 DWORD PTR __Result$1$[ebp], ecx
$LN22@construct:

; 694  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0003d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00040	89 45 10	 mov	 DWORD PTR __Count$1$[ebp], eax

; 857  :         if (_Count > max_size()) {

  00043	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00048	0f 87 bb 00 00
	00		 ja	 $LN70@construct

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();
; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

  0004e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00051	77 13		 ja	 SHORT $LN30@construct

; 866  :             _My_data._Mysize = _Count;

  00053	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 867  :             _My_data._Myres  = _Small_string_capacity;

  00056	c7 46 1c 0f 00
	00 00		 mov	 DWORD PTR [esi+28], 15	; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0005d	0f 10 01	 movups	 xmm0, XMMWORD PTR [ecx]
  00060	0f 11 46 08	 movups	 XMMWORD PTR [esi+8], xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 884  :             return;

  00064	eb 67		 jmp	 SHORT $LN56@construct
$LN30@construct:
  00066	57		 push	 edi

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00067	8b f8		 mov	 edi, eax
  00069	83 cf 0f	 or	 edi, 15			; 0000000fH
  0006c	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00072	76 12		 jbe	 SHORT $LN36@construct

; 2944 :             return _Max;

  00074	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00079	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00084	eb 27		 jmp	 SHORT $LN68@construct
$LN36@construct:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00086	b9 16 00 00 00	 mov	 ecx, 22			; 00000016H
  0008b	3b f9		 cmp	 edi, ecx
  0008d	0f 42 f9	 cmovb	 edi, ecx

; 801  :         ++_Capacity; // Take null terminator into consideration

  00090	8d 4f 01	 lea	 ecx, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  00093	85 c9		 test	 ecx, ecx
  00095	74 1e		 je	 SHORT $LN49@construct
$LN50@construct:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00097	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0009d	72 08		 jb	 SHORT $LN51@construct

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a5	eb 06		 jmp	 SHORT $LN68@construct
$LN51@construct:

; 136  :         return ::operator new(_Bytes);

  000a7	51		 push	 ecx
  000a8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN68@construct:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000ad	8b c8		 mov	 ecx, eax
  000af	83 c4 04	 add	 esp, 4
  000b2	8b 45 10	 mov	 eax, DWORD PTR __Count$1$[ebp]
$LN49@construct:

; 890  : 
; 891  :         _My_data._Mysize = _Count;

  000b5	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 893  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 894  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 895  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 896  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 897  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 899  :         } else { // _Strat == _Construct_strategy::_From_string
; 900  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  000b8	40		 inc	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b9	50		 push	 eax
  000ba	ff 75 0c	 push	 DWORD PTR __Result$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000bd	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c0	51		 push	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 892  :         _My_data._Myres  = _New_capacity;

  000c1	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c4	e8 00 00 00 00	 call	 _memcpy
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cc	5f		 pop	 edi
$LN56@construct:
  000cd	0f b6 43 20	 movzx	 eax, BYTE PTR [ebx+32]
  000d1	88 46 20	 mov	 BYTE PTR [esi+32], al
  000d4	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  000d7	89 46 24	 mov	 DWORD PTR [esi+36], eax
  000da	8b 43 28	 mov	 eax, DWORD PTR [ebx+40]
  000dd	89 46 28	 mov	 DWORD PTR [esi+40], eax
  000e0	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  000e3	89 46 2c	 mov	 DWORD PTR [esi+44], eax
  000e6	0f b6 43 30	 movzx	 eax, BYTE PTR [ebx+48]
  000ea	88 46 30	 mov	 BYTE PTR [esi+48], al
  000ed	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  000f0	89 46 34	 mov	 DWORD PTR [esi+52], eax
  000f3	8b 43 38	 mov	 eax, DWORD PTR [ebx+56]
  000f6	89 46 38	 mov	 DWORD PTR [esi+56], eax
  000f9	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  000fc	89 46 3c	 mov	 DWORD PTR [esi+60], eax
  000ff	8b 43 40	 mov	 eax, DWORD PTR [ebx+64]
  00102	89 46 40	 mov	 DWORD PTR [esi+64], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 734  :     }

  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx
  00107	5d		 pop	 ebp
  00108	c3		 ret	 0
$LN70@construct:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 858  :             _Xlen_string(); // result too long

  00109	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN67@construct:
  0010e	cc		 int	 3
??$construct@UTFlyingAttachData@CFlyingData@@ABU12@@?$_Default_allocator_traits@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@SAXAAV?$allocator@UTFlyingAttachData@CFlyingData@@@1@QAUTFlyingAttachData@CFlyingData@@ABU34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<CFlyingData::TFlyingAttachData> >::construct<CFlyingData::TFlyingAttachData,CFlyingData::TFlyingAttachData const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Guard$ = -44						; size = 20
__Oldsize$1$ = -24					; size = 4
__Whereoff$1$ = -20					; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
tv517 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z PROC ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Emplace_reallocate<CFlyingData::TFlyingAttachData const &>, COMDAT
; _this$ = ecx

; 860  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	8b f1		 mov	 esi, ecx

; 861  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 862  :         _Alty& _Al        = _Getal();
; 863  :         auto& _My_data    = _Mypair._Myval2;
; 864  :         pointer& _Myfirst = _My_data._Myfirst;
; 865  :         pointer& _Mylast  = _My_data._Mylast;
; 866  : 
; 867  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 868  : 
; 869  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0002a	8b 3e		 mov	 edi, DWORD PTR [esi]
  0002c	b8 79 78 78 78	 mov	 eax, 2021161081		; 78787879H
  00031	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]

; 870  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00034	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00037	2b d7		 sub	 edx, edi
  00039	f7 ea		 imul	 edx
  0003b	2b cf		 sub	 ecx, edi
  0003d	c1 fa 05	 sar	 edx, 5
  00040	8b c2		 mov	 eax, edx
  00042	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00045	03 c2		 add	 eax, edx
  00047	89 45 ec	 mov	 DWORD PTR __Whereoff$1$[ebp], eax
  0004a	b8 79 78 78 78	 mov	 eax, 2021161081		; 78787879H
  0004f	f7 e9		 imul	 ecx
  00051	c1 fa 05	 sar	 edx, 5
  00054	8b c2		 mov	 eax, edx
  00056	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00059	03 c2		 add	 eax, edx
  0005b	89 45 e8	 mov	 DWORD PTR __Oldsize$1$[ebp], eax

; 871  : 
; 872  :         if (_Oldsize == max_size()) {

  0005e	3d c3 c3 c3 03	 cmp	 eax, 63161283		; 03c3c3c3H
  00063	0f 84 7f 01 00
	00		 je	 $LN84@Emplace_re

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00069	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 874  :         }
; 875  : 
; 876  :         const size_type _Newsize = _Oldsize + 1;

  0006c	8d 58 01	 lea	 ebx, DWORD PTR [eax+1]

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0006f	2b cf		 sub	 ecx, edi
  00071	b8 79 78 78 78	 mov	 eax, 2021161081		; 78787879H
  00076	f7 e9		 imul	 ecx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00078	b8 c3 c3 c3 03	 mov	 eax, 63161283		; 03c3c3c3H

; 1909 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0007d	c1 fa 05	 sar	 edx, 5
  00080	8b ca		 mov	 ecx, edx
  00082	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00085	03 ca		 add	 ecx, edx

; 1996 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00087	8b d1		 mov	 edx, ecx
  00089	d1 ea		 shr	 edx, 1
  0008b	2b c2		 sub	 eax, edx
  0008d	3b c8		 cmp	 ecx, eax
  0008f	76 16		 jbe	 SHORT $LN8@Emplace_re

; 1997 :             return _Max; // geometric growth would overflow

  00091	bb cc ff ff ff	 mov	 ebx, -52		; ffffffccH
  00096	c7 45 f0 c3 c3
	c3 03		 mov	 DWORD PTR $T3[ebp], 63161283 ; 03c3c3c3H
  0009d	8b c3		 mov	 eax, ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a5	eb 42		 jmp	 SHORT $LN82@Emplace_re
$LN8@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2000 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  000a7	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 117  :         if (_Count > _Max_possible) {

  000aa	8b cb		 mov	 ecx, ebx
  000ac	3b c3		 cmp	 eax, ebx
  000ae	0f 43 c8	 cmovae	 ecx, eax
  000b1	89 4d f0	 mov	 DWORD PTR $T3[ebp], ecx
  000b4	81 f9 c3 c3 c3
	03		 cmp	 ecx, 63161283		; 03c3c3c3H
  000ba	0f 87 2d 01 00
	00		 ja	 $LN85@Emplace_re

; 119  :         }
; 120  :     }
; 121  : 
; 122  :     return _Count * _Ty_size;

  000c0	8b d9		 mov	 ebx, ecx
  000c2	c1 e3 04	 shl	 ebx, 4
  000c5	03 d9		 add	 ebx, ecx
  000c7	c1 e3 02	 shl	 ebx, 2

; 986  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000ca	8b c3		 mov	 eax, ebx

; 227  :     if (_Bytes == 0) {

  000cc	85 c0		 test	 eax, eax
  000ce	75 04		 jne	 SHORT $LN23@Emplace_re

; 228  :         return nullptr;

  000d0	33 ff		 xor	 edi, edi
  000d2	eb 1d		 jmp	 SHORT $LN22@Emplace_re
$LN23@Emplace_re:

; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  000d4	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  000d9	72 08		 jb	 SHORT $LN24@Emplace_re

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000e1	eb 06		 jmp	 SHORT $LN82@Emplace_re
$LN24@Emplace_re:

; 136  :         return ::operator new(_Bytes);

  000e3	50		 push	 eax
  000e4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN82@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 880  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000e9	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  000ec	8b f8		 mov	 edi, eax
  000ee	83 c4 04	 add	 esp, 4
$LN22@Emplace_re:
  000f1	8b 45 ec	 mov	 eax, DWORD PTR __Whereoff$1$[ebp]
  000f4	c1 e0 04	 shl	 eax, 4
  000f7	03 45 ec	 add	 eax, DWORD PTR __Whereoff$1$[ebp]

; 881  : 
; 882  :         _Reallocation_guard _Guard{_Al, _Newvec, _Newcapacity, _Constructed_last, _Constructed_last};

  000fa	89 75 d4	 mov	 DWORD PTR __Guard$[ebp], esi
  000fd	89 7d d8	 mov	 DWORD PTR __Guard$[ebp+4], edi
  00100	89 4d dc	 mov	 DWORD PTR __Guard$[ebp+8], ecx
  00103	8d 14 87	 lea	 edx, DWORD PTR [edi+eax*4]
  00106	8d 42 44	 lea	 eax, DWORD PTR [edx+68]
  00109	89 55 f0	 mov	 DWORD PTR tv517[ebp], edx
  0010c	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  0010f	89 45 e0	 mov	 DWORD PTR __Guard$[ebp+12], eax
  00112	89 45 e4	 mov	 DWORD PTR __Guard$[ebp+16], eax

; 883  :         auto& _Constructed_first = _Guard._Constructed_first;
; 884  : 
; 885  :         _Alty_traits::construct(_Al, _STD _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00115	ff 75 0c	 push	 DWORD PTR _<_Val_0>$[ebp]
  00118	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0011f	52		 push	 edx
  00120	56		 push	 esi
  00121	e8 00 00 00 00	 call	 ??$construct@UTFlyingAttachData@CFlyingData@@ABU12@@?$_Default_allocator_traits@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@SAXAAV?$allocator@UTFlyingAttachData@CFlyingData@@@1@QAUTFlyingAttachData@CFlyingData@@ABU34@@Z ; std::_Default_allocator_traits<std::allocator<CFlyingData::TFlyingAttachData> >::construct<CFlyingData::TFlyingAttachData,CFlyingData::TFlyingAttachData const &>

; 886  :         _Constructed_first = _Newvec + _Whereoff;
; 887  : 
; 888  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00126	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00129	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012c	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  0012f	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00131	3b c2		 cmp	 eax, edx
  00133	75 04		 jne	 SHORT $LN3@Emplace_re

; 889  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 890  :                 _STD _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

  00135	8b c7		 mov	 eax, edi

; 891  :             } else {
; 892  :                 _STD _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 893  :             }
; 894  :         } else { // provide basic guarantee

  00137	eb 15		 jmp	 SHORT $LN4@Emplace_re
$LN3@Emplace_re:

; 895  :             _STD _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

  00139	56		 push	 esi
  0013a	57		 push	 edi
  0013b	50		 push	 eax
  0013c	51		 push	 ecx
  0013d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAPAUTFlyingAttachData@CFlyingData@@QAU12@0PAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ; std::_Uninitialized_move<CFlyingData::TFlyingAttachData *,std::allocator<CFlyingData::TFlyingAttachData> >

; 896  :             _Constructed_first = _Newvec;
; 897  :             _STD _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  00142	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00145	83 c4 10	 add	 esp, 16			; 00000010H
  00148	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0014b	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
$LN4@Emplace_re:

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  0014e	56		 push	 esi
  0014f	50		 push	 eax
  00150	52		 push	 edx
  00151	51		 push	 ecx
  00152	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAPAUTFlyingAttachData@CFlyingData@@QAU12@0PAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ; std::_Uninitialized_move<CFlyingData::TFlyingAttachData *,std::allocator<CFlyingData::TFlyingAttachData> >

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  00157	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 898  :         }
; 899  : 
; 900  :         _Guard._New_begin = nullptr;

  00159	83 c4 10	 add	 esp, 16			; 00000010H

; 2054 :         if (_Myfirst) { // destroy and deallocate old array

  0015c	85 c9		 test	 ecx, ecx
  0015e	74 53		 je	 SHORT $LN39@Emplace_re

; 2055 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  00160	56		 push	 esi
  00161	ff 76 04	 push	 DWORD PTR [esi+4]
  00164	51		 push	 ecx
  00165	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAXPAUTFlyingAttachData@CFlyingData@@QAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ; std::_Destroy_range<std::allocator<CFlyingData::TFlyingAttachData> >

; 2056 :             _ASAN_VECTOR_REMOVE;
; 2057 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0016a	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0016d	b8 79 78 78 78	 mov	 eax, 2021161081		; 78787879H
  00172	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00174	83 c4 0c	 add	 esp, 12			; 0000000cH
  00177	f7 e9		 imul	 ecx
  00179	c1 fa 05	 sar	 edx, 5
  0017c	8b c2		 mov	 eax, edx
  0017e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00181	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00183	8b c8		 mov	 ecx, eax
  00185	c1 e1 04	 shl	 ecx, 4
  00188	03 c8		 add	 ecx, eax

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0018a	8b 06		 mov	 eax, DWORD PTR [esi]

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0018c	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0018f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00195	72 12		 jb	 SHORT $LN50@Emplace_re

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00197	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0019a	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0019d	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0019f	83 c0 fc	 add	 eax, -4			; fffffffcH
  001a2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001a5	77 3c		 ja	 SHORT $LN47@Emplace_re

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  001a7	8b c2		 mov	 eax, edx
$LN50@Emplace_re:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001a9	51		 push	 ecx
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001b0	83 c4 08	 add	 esp, 8
$LN39@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2061 :         _Mylast  = _Newvec + _Newsize;

  001b3	8b 55 e8	 mov	 edx, DWORD PTR __Oldsize$1$[ebp]

; 901  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 902  :         return _Newvec + _Whereoff;

  001b6	8b 45 f0	 mov	 eax, DWORD PTR tv517[ebp]

; 2061 :         _Mylast  = _Newvec + _Newsize;

  001b9	42		 inc	 edx
  001ba	8b ca		 mov	 ecx, edx
  001bc	89 3e		 mov	 DWORD PTR [esi], edi
  001be	c1 e1 04	 shl	 ecx, 4
  001c1	03 ca		 add	 ecx, edx
  001c3	8d 0c 8f	 lea	 ecx, DWORD PTR [edi+ecx*4]
  001c6	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 2062 :         _Myend   = _Newvec + _Newcapacity;

  001c9	8d 0c 3b	 lea	 ecx, DWORD PTR [ebx+edi]
  001cc	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 903  :     }

  001cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d9	59		 pop	 ecx
  001da	5f		 pop	 edi
  001db	5e		 pop	 esi
  001dc	5b		 pop	 ebx
  001dd	8b e5		 mov	 esp, ebp
  001df	5d		 pop	 ebp
  001e0	c2 08 00	 ret	 8
$LN47@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001e3	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN84@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 873  :             _Xlength();

  001e8	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@CAXXZ ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Xlength
$LN85@Emplace_re:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 118  :             _Throw_bad_array_new_length(); // multiply overflow

  001ed	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN81@Emplace_re:
  001f2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Reallocation_guard@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Reallocation_guard::~_Reallocation_guard
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z ENDP ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Emplace_reallocate<CFlyingData::TFlyingAttachData const &>
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT

; 274  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT

; 274  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT

; 274  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT

; 274  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT

; 274  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT

; 274  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT

; 274  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT

; 274  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 133  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@

; 161  : 			for (auto v : m_kVct_pkData)

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00011	3b f3		 cmp	 esi, ebx
  00013	74 11		 je	 SHORT $LN6@CDynamicPo
$LL7@CDynamicPo:

; 226  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 161  : 			for (auto v : m_kVct_pkData)

  0001c	83 c6 04	 add	 esi, 4

; 226  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4

; 161  : 			for (auto v : m_kVct_pkData)

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL7@CDynamicPo
$LN6@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00026	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00029	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0002c	74 03		 je	 SHORT $LN11@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0002e	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN11@CDynamicPo:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00034	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  00037	74 03		 je	 SHORT $LN15@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00039	89 47 14	 mov	 DWORD PTR [edi+20], eax
$LN15@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0003c	85 c0		 test	 eax, eax
  0003e	74 41		 je	 SHORT $LN23@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00040	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00043	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00045	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00048	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004e	72 12		 jb	 SHORT $LN42@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00050	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00053	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00056	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	83 c0 fc	 add	 eax, -4			; fffffffcH
  0005b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005e	77 6d		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00060	8b c2		 mov	 eax, edx
$LN42@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00062	51		 push	 ecx
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00069	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00070	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00073	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 2082 :             _Myend   = nullptr;

  0007a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN23@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00081	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00084	85 c0		 test	 eax, eax
  00086	74 41		 je	 SHORT $LN52@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0008b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00096	72 12		 jb	 SHORT $LN71@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00098	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0009b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0009e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a6	77 25		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000a8	8b c2		 mov	 eax, edx
$LN71@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  000b1	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b8	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000bb	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 2082 :             _Myend   = nullptr;

  000c2	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000c9	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 143  : 		}

  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	c3		 ret	 0
$LN68@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN89@CDynamicPo:
  000d2	cc		 int	 3
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 133  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@

; 161  : 			for (auto v : m_kVct_pkData)

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00011	3b f3		 cmp	 esi, ebx
  00013	74 11		 je	 SHORT $LN6@CDynamicPo
$LL7@CDynamicPo:

; 226  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 161  : 			for (auto v : m_kVct_pkData)

  0001c	83 c6 04	 add	 esi, 4

; 226  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4

; 161  : 			for (auto v : m_kVct_pkData)

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL7@CDynamicPo
$LN6@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00026	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00029	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0002c	74 03		 je	 SHORT $LN11@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0002e	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN11@CDynamicPo:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00034	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  00037	74 03		 je	 SHORT $LN15@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00039	89 47 14	 mov	 DWORD PTR [edi+20], eax
$LN15@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0003c	85 c0		 test	 eax, eax
  0003e	74 41		 je	 SHORT $LN23@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00040	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00043	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00045	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00048	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004e	72 12		 jb	 SHORT $LN42@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00050	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00053	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00056	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	83 c0 fc	 add	 eax, -4			; fffffffcH
  0005b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005e	77 6d		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00060	8b c2		 mov	 eax, edx
$LN42@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00062	51		 push	 ecx
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00069	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00070	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00073	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 2082 :             _Myend   = nullptr;

  0007a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN23@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00081	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00084	85 c0		 test	 eax, eax
  00086	74 41		 je	 SHORT $LN52@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0008b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00096	72 12		 jb	 SHORT $LN71@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00098	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0009b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0009e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a6	77 25		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000a8	8b c2		 mov	 eax, edx
$LN71@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  000b1	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b8	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000bb	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 2082 :             _Myend   = nullptr;

  000c2	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000c9	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 143  : 		}

  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	c3		 ret	 0
$LN68@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN89@CDynamicPo:
  000d2	cc		 int	 3
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 133  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@

; 161  : 			for (auto v : m_kVct_pkData)

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00011	3b f3		 cmp	 esi, ebx
  00013	74 11		 je	 SHORT $LN6@CDynamicPo
$LL7@CDynamicPo:

; 226  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 161  : 			for (auto v : m_kVct_pkData)

  0001c	83 c6 04	 add	 esi, 4

; 226  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4

; 161  : 			for (auto v : m_kVct_pkData)

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL7@CDynamicPo
$LN6@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00026	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00029	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0002c	74 03		 je	 SHORT $LN11@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0002e	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN11@CDynamicPo:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00034	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  00037	74 03		 je	 SHORT $LN15@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00039	89 47 14	 mov	 DWORD PTR [edi+20], eax
$LN15@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0003c	85 c0		 test	 eax, eax
  0003e	74 41		 je	 SHORT $LN23@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00040	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00043	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00045	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00048	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004e	72 12		 jb	 SHORT $LN42@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00050	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00053	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00056	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	83 c0 fc	 add	 eax, -4			; fffffffcH
  0005b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005e	77 6d		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00060	8b c2		 mov	 eax, edx
$LN42@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00062	51		 push	 ecx
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00069	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00070	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00073	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 2082 :             _Myend   = nullptr;

  0007a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN23@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00081	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00084	85 c0		 test	 eax, eax
  00086	74 41		 je	 SHORT $LN52@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0008b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00096	72 12		 jb	 SHORT $LN71@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00098	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0009b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0009e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a6	77 25		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000a8	8b c2		 mov	 eax, edx
$LN71@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  000b1	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b8	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000bb	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 2082 :             _Myend   = nullptr;

  000c2	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000c9	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 143  : 		}

  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	c3		 ret	 0
$LN68@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN89@CDynamicPo:
  000d2	cc		 int	 3
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 133  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@

; 161  : 			for (auto v : m_kVct_pkData)

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00011	3b f3		 cmp	 esi, ebx
  00013	74 11		 je	 SHORT $LN6@CDynamicPo
$LL7@CDynamicPo:

; 226  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 161  : 			for (auto v : m_kVct_pkData)

  0001c	83 c6 04	 add	 esi, 4

; 226  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4

; 161  : 			for (auto v : m_kVct_pkData)

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL7@CDynamicPo
$LN6@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00026	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00029	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0002c	74 03		 je	 SHORT $LN11@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0002e	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN11@CDynamicPo:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00034	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  00037	74 03		 je	 SHORT $LN15@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00039	89 47 14	 mov	 DWORD PTR [edi+20], eax
$LN15@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0003c	85 c0		 test	 eax, eax
  0003e	74 41		 je	 SHORT $LN23@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00040	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00043	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00045	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00048	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004e	72 12		 jb	 SHORT $LN42@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00050	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00053	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00056	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	83 c0 fc	 add	 eax, -4			; fffffffcH
  0005b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005e	77 6d		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00060	8b c2		 mov	 eax, edx
$LN42@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00062	51		 push	 ecx
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00069	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00070	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00073	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 2082 :             _Myend   = nullptr;

  0007a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN23@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00081	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00084	85 c0		 test	 eax, eax
  00086	74 41		 je	 SHORT $LN52@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0008b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00096	72 12		 jb	 SHORT $LN71@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00098	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0009b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0009e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a6	77 25		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000a8	8b c2		 mov	 eax, edx
$LN71@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  000b1	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b8	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000bb	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 2082 :             _Myend   = nullptr;

  000c2	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000c9	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 143  : 		}

  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	c3		 ret	 0
$LN68@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN89@CDynamicPo:
  000d2	cc		 int	 3
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 133  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@

; 161  : 			for (auto v : m_kVct_pkData)

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00011	3b f3		 cmp	 esi, ebx
  00013	74 11		 je	 SHORT $LN6@CDynamicPo
$LL7@CDynamicPo:

; 226  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 161  : 			for (auto v : m_kVct_pkData)

  0001c	83 c6 04	 add	 esi, 4

; 226  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4

; 161  : 			for (auto v : m_kVct_pkData)

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL7@CDynamicPo
$LN6@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00026	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00029	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0002c	74 03		 je	 SHORT $LN11@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0002e	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN11@CDynamicPo:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00034	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  00037	74 03		 je	 SHORT $LN15@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00039	89 47 14	 mov	 DWORD PTR [edi+20], eax
$LN15@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0003c	85 c0		 test	 eax, eax
  0003e	74 41		 je	 SHORT $LN23@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00040	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00043	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00045	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00048	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004e	72 12		 jb	 SHORT $LN42@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00050	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00053	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00056	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	83 c0 fc	 add	 eax, -4			; fffffffcH
  0005b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005e	77 6d		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00060	8b c2		 mov	 eax, edx
$LN42@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00062	51		 push	 ecx
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00069	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00070	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00073	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 2082 :             _Myend   = nullptr;

  0007a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN23@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00081	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00084	85 c0		 test	 eax, eax
  00086	74 41		 je	 SHORT $LN52@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0008b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00096	72 12		 jb	 SHORT $LN71@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00098	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0009b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0009e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a6	77 25		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000a8	8b c2		 mov	 eax, edx
$LN71@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  000b1	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b8	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000bb	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 2082 :             _Myend   = nullptr;

  000c2	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000c9	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 143  : 		}

  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	c3		 ret	 0
$LN68@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN89@CDynamicPo:
  000d2	cc		 int	 3
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 133  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@

; 161  : 			for (auto v : m_kVct_pkData)

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00011	3b f3		 cmp	 esi, ebx
  00013	74 11		 je	 SHORT $LN6@CDynamicPo
$LL7@CDynamicPo:

; 226  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 161  : 			for (auto v : m_kVct_pkData)

  0001c	83 c6 04	 add	 esi, 4

; 226  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4

; 161  : 			for (auto v : m_kVct_pkData)

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL7@CDynamicPo
$LN6@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00026	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00029	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0002c	74 03		 je	 SHORT $LN11@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0002e	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN11@CDynamicPo:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00034	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  00037	74 03		 je	 SHORT $LN15@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00039	89 47 14	 mov	 DWORD PTR [edi+20], eax
$LN15@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0003c	85 c0		 test	 eax, eax
  0003e	74 41		 je	 SHORT $LN23@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00040	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00043	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00045	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00048	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004e	72 12		 jb	 SHORT $LN42@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00050	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00053	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00056	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	83 c0 fc	 add	 eax, -4			; fffffffcH
  0005b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005e	77 6d		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00060	8b c2		 mov	 eax, edx
$LN42@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00062	51		 push	 ecx
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00069	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00070	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00073	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 2082 :             _Myend   = nullptr;

  0007a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN23@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00081	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00084	85 c0		 test	 eax, eax
  00086	74 41		 je	 SHORT $LN52@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0008b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00096	72 12		 jb	 SHORT $LN71@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00098	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0009b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0009e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a6	77 25		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000a8	8b c2		 mov	 eax, edx
$LN71@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  000b1	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b8	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000bb	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 2082 :             _Myend   = nullptr;

  000c2	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000c9	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 143  : 		}

  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	c3		 ret	 0
$LN68@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN89@CDynamicPo:
  000d2	cc		 int	 3
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 133  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@

; 161  : 			for (auto v : m_kVct_pkData)

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00011	3b f3		 cmp	 esi, ebx
  00013	74 11		 je	 SHORT $LN6@CDynamicPo
$LL7@CDynamicPo:

; 226  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 161  : 			for (auto v : m_kVct_pkData)

  0001c	83 c6 04	 add	 esi, 4

; 226  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4

; 161  : 			for (auto v : m_kVct_pkData)

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL7@CDynamicPo
$LN6@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00026	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00029	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0002c	74 03		 je	 SHORT $LN11@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0002e	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN11@CDynamicPo:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00034	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  00037	74 03		 je	 SHORT $LN15@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00039	89 47 14	 mov	 DWORD PTR [edi+20], eax
$LN15@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0003c	85 c0		 test	 eax, eax
  0003e	74 41		 je	 SHORT $LN23@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00040	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00043	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00045	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00048	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004e	72 12		 jb	 SHORT $LN42@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00050	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00053	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00056	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	83 c0 fc	 add	 eax, -4			; fffffffcH
  0005b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005e	77 6d		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00060	8b c2		 mov	 eax, edx
$LN42@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00062	51		 push	 ecx
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00069	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00070	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00073	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 2082 :             _Myend   = nullptr;

  0007a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN23@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00081	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00084	85 c0		 test	 eax, eax
  00086	74 41		 je	 SHORT $LN52@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0008b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00096	72 12		 jb	 SHORT $LN71@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00098	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0009b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0009e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a6	77 25		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000a8	8b c2		 mov	 eax, edx
$LN71@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  000b1	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b8	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000bb	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 2082 :             _Myend   = nullptr;

  000c2	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000c9	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 143  : 		}

  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	c3		 ret	 0
$LN68@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN89@CDynamicPo:
  000d2	cc		 int	 3
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 133  : 		{

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx
  00005	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@

; 161  : 			for (auto v : m_kVct_pkData)

  0000b	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]
  0000e	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
  00011	3b f3		 cmp	 esi, ebx
  00013	74 11		 je	 SHORT $LN6@CDynamicPo
$LL7@CDynamicPo:

; 226  : 			::operator delete(pkData);

  00015	ff 36		 push	 DWORD PTR [esi]
  00017	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete

; 161  : 			for (auto v : m_kVct_pkData)

  0001c	83 c6 04	 add	 esi, 4

; 226  : 			::operator delete(pkData);

  0001f	83 c4 04	 add	 esp, 4

; 161  : 			for (auto v : m_kVct_pkData)

  00022	3b f3		 cmp	 esi, ebx
  00024	75 ef		 jne	 SHORT $LL7@CDynamicPo
$LN6@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00026	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00029	3b 47 08	 cmp	 eax, DWORD PTR [edi+8]
  0002c	74 03		 je	 SHORT $LN11@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0002e	89 47 08	 mov	 DWORD PTR [edi+8], eax
$LN11@CDynamicPo:

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00031	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00034	3b 47 14	 cmp	 eax, DWORD PTR [edi+20]
  00037	74 03		 je	 SHORT $LN15@CDynamicPo

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());
; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00039	89 47 14	 mov	 DWORD PTR [edi+20], eax
$LN15@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  0003c	85 c0		 test	 eax, eax
  0003e	74 41		 je	 SHORT $LN23@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00040	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00043	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00045	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00048	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004e	72 12		 jb	 SHORT $LN42@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00050	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00053	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00056	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00058	83 c0 fc	 add	 eax, -4			; fffffffcH
  0005b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005e	77 6d		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00060	8b c2		 mov	 eax, edx
$LN42@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00062	51		 push	 ecx
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00069	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00070	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00073	c7 47 14 00 00
	00 00		 mov	 DWORD PTR [edi+20], 0

; 2082 :             _Myend   = nullptr;

  0007a	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
$LN23@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00081	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00084	85 c0		 test	 eax, eax
  00086	74 41		 je	 SHORT $LN52@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  0008b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0008d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00090	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00096	72 12		 jb	 SHORT $LN71@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00098	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0009b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0009e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000a0	83 c0 fc	 add	 eax, -4			; fffffffcH
  000a3	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000a6	77 25		 ja	 SHORT $LN68@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000a8	8b c2		 mov	 eax, edx
$LN71@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000aa	51		 push	 ecx
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  000b1	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  000b8	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  000bb	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0

; 2082 :             _Myend   = nullptr;

  000c2	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
$LN52@CDynamicPo:
  000c9	5f		 pop	 edi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 143  : 		}

  000ca	5e		 pop	 esi
  000cb	5b		 pop	 ebx
  000cc	c3		 ret	 0
$LN68@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cd	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN89@CDynamicPo:
  000d2	cc		 int	 3
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAXPAUTFlyingAttachData@CFlyingData@@QAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAXPAUTFlyingAttachData@CFlyingData@@QAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CFlyingData::TFlyingAttachData> >, COMDAT

; 1094 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1098 :         for (; _First != _Last; ++_First) {

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  00007	56		 push	 esi
  00008	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0000b	3b f3		 cmp	 esi, ebx
  0000d	74 4f		 je	 SHORT $LN61@Destroy_ra
  0000f	83 c6 1c	 add	 esi, 28			; 0000001cH
  00012	57		 push	 edi
$LL4@Destroy_ra:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00013	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00015	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00018	76 28		 jbe	 SHORT $LN64@Destroy_ra
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001a	8b 46 ec	 mov	 eax, DWORD PTR [esi-20]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0001d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0001e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00024	72 12		 jb	 SHORT $LN49@Destroy_ra

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00026	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00029	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0002c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0002e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00031	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00034	77 2c		 ja	 SHORT $LN46@Destroy_ra

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00036	8b c2		 mov	 eax, edx
$LN49@Destroy_ra:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00038	51		 push	 ecx
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003f	83 c4 08	 add	 esp, 8
$LN64@Destroy_ra:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00042	c7 46 fc 00 00
	00 00		 mov	 DWORD PTR [esi-4], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00049	c7 06 0f 00 00
	00		 mov	 DWORD PTR [esi], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0004f	c6 46 ec 00	 mov	 BYTE PTR [esi-20], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 1098 :         for (; _First != _Last; ++_First) {

  00053	83 c6 44	 add	 esi, 68			; 00000044H
  00056	8d 46 e4	 lea	 eax, DWORD PTR [esi-28]
  00059	3b c3		 cmp	 eax, ebx
  0005b	75 b6		 jne	 SHORT $LL4@Destroy_ra
  0005d	5f		 pop	 edi
$LN61@Destroy_ra:
  0005e	5e		 pop	 esi

; 1099 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1100 :         }
; 1101 :     }
; 1102 : }

  0005f	5b		 pop	 ebx
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
$LN46@Destroy_ra:

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00062	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN70@Destroy_ra:
  00067	cc		 int	 3
??$_Destroy_range@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAXPAUTFlyingAttachData@CFlyingData@@QAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CFlyingData::TFlyingAttachData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
_TEXT	SEGMENT
__Right_size$1$ = -8					; size = 4
__New_size$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
__Ptr$1$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3124 :     _In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00008	8b 75 0c	 mov	 esi, DWORD PTR __Left$[ebp]
  0000b	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
  0000e	66 90		 npad	 2
$LL62@operator:
  00010	8a 06		 mov	 al, BYTE PTR [esi]
  00012	46		 inc	 esi
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL62@operator
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3128 :     if (_Right.max_size() - _Right_size < _Left_size) {

  00017	8b 5d 10	 mov	 ebx, DWORD PTR __Right$[ebp]
  0001a	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0001f	2b f1		 sub	 esi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3127 :     const auto _Right_size = _Right.size();

  00021	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]

; 3128 :     if (_Right.max_size() - _Right_size < _Left_size) {

  00024	2b c2		 sub	 eax, edx
  00026	89 55 f8	 mov	 DWORD PTR __Right_size$1$[ebp], edx
  00029	3b c6		 cmp	 eax, esi
  0002b	0f 82 ba 00 00
	00		 jb	 $LN73@operator

; 434  :         return _Myres > _Small_string_capacity;

  00031	83 7b 14 0f	 cmp	 DWORD PTR [ebx+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00035	76 02		 jbe	 SHORT $LN13@operator

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00037	8b 1b		 mov	 ebx, DWORD PTR [ebx]
$LN13@operator:

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00039	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]

; 1032 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  0003c	03 d6		 add	 edx, esi
  0003e	57		 push	 edi
  0003f	0f 57 c0	 xorps	 xmm0, xmm0
  00042	89 55 fc	 mov	 DWORD PTR __New_size$1$[ebp], edx

; 1033 :         size_type _New_capacity = _Small_string_capacity;

  00045	bf 0f 00 00 00	 mov	 edi, 15			; 0000000fH

; 1034 :         auto& _My_data          = _Mypair._Myval2;
; 1035 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  0004a	8b c1		 mov	 eax, ecx
  0004c	89 45 10	 mov	 DWORD PTR __Ptr$1$[ebp], eax

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  0004f	0f 11 01	 movups	 XMMWORD PTR [ecx], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00052	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00059	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 1039 :         if (_New_capacity < _New_size) {

  00060	3b d7		 cmp	 edx, edi
  00062	76 53		 jbe	 SHORT $LN20@operator

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00064	8b fa		 mov	 edi, edx
  00066	83 cf 0f	 or	 edi, 15			; 0000000fH
  00069	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006f	76 12		 jbe	 SHORT $LN36@operator

; 2944 :             return _Max;

  00071	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00076	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00081	eb 26		 jmp	 SHORT $LN71@operator
$LN36@operator:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00083	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00088	3b f8		 cmp	 edi, eax
  0008a	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0008d	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  00090	85 c0		 test	 eax, eax
  00092	74 1e		 je	 SHORT $LN70@operator
$LN50@operator:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00094	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00099	72 08		 jb	 SHORT $LN51@operator

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a1	eb 06		 jmp	 SHORT $LN71@operator
$LN51@operator:

; 136  :         return ::operator new(_Bytes);

  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN71@operator:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1043 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  000a9	8b 55 fc	 mov	 edx, DWORD PTR __New_size$1$[ebp]
  000ac	83 c4 04	 add	 esp, 4
  000af	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
$LN70@operator:
  000b2	89 45 10	 mov	 DWORD PTR __Ptr$1$[ebp], eax
  000b5	89 01		 mov	 DWORD PTR [ecx], eax
$LN20@operator:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b7	56		 push	 esi
  000b8	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1046 :         _My_data._Mysize = _New_size;

  000bb	89 51 10	 mov	 DWORD PTR [ecx+16], edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000be	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1047 :         _My_data._Myres  = _New_capacity;

  000bf	89 79 14	 mov	 DWORD PTR [ecx+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c2	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1049 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  000c7	8b 7d 10	 mov	 edi, DWORD PTR __Ptr$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ca	ff 75 f8	 push	 DWORD PTR __Right_size$1$[ebp]
  000cd	53		 push	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1049 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  000ce	8d 0c 37	 lea	 ecx, DWORD PTR [edi+esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d1	51		 push	 ecx
  000d2	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1050 :         _Traits::assign(_Ptr[_New_size], _Elem());

  000d7	8b 45 fc	 mov	 eax, DWORD PTR __New_size$1$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000da	83 c4 18	 add	 esp, 24			; 00000018H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1050 :         _Traits::assign(_Ptr[_New_size], _Elem());

  000dd	c6 04 07 00	 mov	 BYTE PTR [edi+eax], 0

; 3130 :     }
; 3131 : 
; 3132 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

  000e1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e4	5f		 pop	 edi

; 3133 : }

  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
$LN73@operator:

; 3129 :         _Xlen_string();

  000eb	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN69@operator:
  000f0	cc		 int	 3
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CFlyingData::ms_kPool'', COMDAT
  00000	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A ; CFlyingData::ms_kPool
  00005	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCFlyingData@@@@UAE@XZ ; CDynamicPool<CFlyingData>::~CDynamicPool<CFlyingData>
??__F?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CFlyingData::ms_kPool''
text$yd	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ??__E?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CFlyingData::ms_kPool'', COMDAT

; 6    : CDynamicPool<CFlyingData> CFlyingData::ms_kPool;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CFlyingData::ms_kPool''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_kPool@CFlyingData@@2V?$CDynamicPool@VCFlyingData@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CFlyingData::ms_kPool''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_G?$CDynamicPool@VCFlyingData@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCFlyingData@@@@UAEPAXI@Z PROC	; CDynamicPool<CFlyingData>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCFlyingData@@@@UAE@XZ ; CDynamicPool<CFlyingData>::~CDynamicPool<CFlyingData>
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0b		 je	 SHORT $LN5@scalar
  00011	6a 24		 push	 36			; 00000024H
  00013	56		 push	 esi
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001c	8b c6		 mov	 eax, esi
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCFlyingData@@@@UAEPAXI@Z ENDP	; CDynamicPool<CFlyingData>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCFlyingData@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CDynamicPool@VCFlyingData@@@@UAE@XZ PROC		; CDynamicPool<CFlyingData>::~CDynamicPool<CFlyingData>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CDynamicPool@VCFlyingData@@@@6B@
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00009	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0000c	85 c0		 test	 eax, eax
  0000e	74 41		 je	 SHORT $LN8@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00010	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00013	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00015	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00018	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001e	72 12		 jb	 SHORT $LN27@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00020	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00023	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00026	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00028	83 c0 fc	 add	 eax, -4			; fffffffcH
  0002b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0002e	77 6b		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00030	8b c2		 mov	 eax, edx
$LN27@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00032	51		 push	 ecx
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00039	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00040	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  00043	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 2082 :             _Myend   = nullptr;

  0004a	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN8@CDynamicPo:

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00051	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00054	85 c0		 test	 eax, eax
  00056	74 41		 je	 SHORT $LN37@CDynamicPo

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);
; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00058	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0005b	2b c8		 sub	 ecx, eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005d	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00060	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00066	72 12		 jb	 SHORT $LN56@CDynamicPo

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00068	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0006b	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0006e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00070	83 c0 fc	 add	 eax, -4			; fffffffcH
  00073	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00076	77 23		 ja	 SHORT $LN53@CDynamicPo

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00078	8b c2		 mov	 eax, edx
$LN56@CDynamicPo:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0007a	51		 push	 ecx
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  00081	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 289  :         ::operator delete(_Ptr, _Bytes);

  00088	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2081 :             _Mylast  = nullptr;

  0008b	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 2082 :             _Myend   = nullptr;

  00092	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
$LN37@CDynamicPo:
  00099	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\eterLib\Pool.h

; 26   : 		}

  0009a	c3		 ret	 0
$LN53@CDynamicPo:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0009b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN67@CDynamicPo:
  000a0	cc		 int	 3
??1?$CDynamicPool@VCFlyingData@@@@UAE@XZ ENDP		; CDynamicPool<CFlyingData>::~CDynamicPool<CFlyingData>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCFlyingData@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCFlyingData@@UAEPAXI@Z PROC				; CFlyingData::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CFlyingData@@UAE@XZ	; CFlyingData::~CFlyingData
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN5@scalar
  00011	68 90 00 00 00	 push	 144			; 00000090H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN5@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCFlyingData@@UAEPAXI@Z ENDP				; CFlyingData::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ?_Xlength@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@CAXXZ PROC ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Xlength, COMDAT

; 2169 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@CAXXZ ENDP ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
;	COMDAT ??1?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ PROC ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::~vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >, COMDAT
; _this$ = ecx

; 814  :     _CONSTEXPR20 ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2075 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 69		 je	 SHORT $LN5@vector
  00009	57		 push	 edi

; 2076 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  0000a	56		 push	 esi
  0000b	ff 76 04	 push	 DWORD PTR [esi+4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAXPAUTFlyingAttachData@CFlyingData@@QAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ; std::_Destroy_range<std::allocator<CFlyingData::TFlyingAttachData> >

; 2077 :             _ASAN_VECTOR_REMOVE;
; 2078 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00014	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00017	b8 79 78 78 78	 mov	 eax, 2021161081		; 78787879H
  0001c	8b 3e		 mov	 edi, DWORD PTR [esi]
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	2b cf		 sub	 ecx, edi
  00023	f7 e9		 imul	 ecx
  00025	c1 fa 05	 sar	 edx, 5
  00028	8b c2		 mov	 eax, edx
  0002a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002d	03 c2		 add	 eax, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0002f	8b c8		 mov	 ecx, eax
  00031	c1 e1 04	 shl	 ecx, 4
  00034	03 c8		 add	 ecx, eax
  00036	c1 e1 02	 shl	 ecx, 2

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00039	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0003f	72 12		 jb	 SHORT $LN24@vector

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00041	8b 57 fc	 mov	 edx, DWORD PTR [edi-4]
  00044	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00047	2b fa		 sub	 edi, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00049	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  0004c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0004f	77 23		 ja	 SHORT $LN21@vector

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00051	8b fa		 mov	 edi, edx
$LN24@vector:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00053	51		 push	 ecx
  00054	57		 push	 edi
  00055	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005a	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 2080 :             _Myfirst = nullptr;

  0005d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0

; 2081 :             _Mylast  = nullptr;

  00063	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 2082 :             _Myend   = nullptr;

  0006a	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
  00071	5f		 pop	 edi
$LN5@vector:
  00072	5e		 pop	 esi

; 820  :     }

  00073	c3		 ret	 0
$LN21@vector:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00074	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN32@vector:
  00079	cc		 int	 3
??1?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ ENDP ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::~vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?__Initialize@CFlyingData@@IAEXXZ
_TEXT	SEGMENT
?__Initialize@CFlyingData@@IAEXXZ PROC			; CFlyingData::__Initialize, COMDAT
; _this$ = ecx

; 15   : 	m_v3AngVel = D3DXVECTOR3(0.0f,0.0f,0.0f);

  00000	c7 41 2c 00 00
	00 00		 mov	 DWORD PTR [ecx+44], 0
  00007	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
  0000e	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 16   : 	m_bIsHoming = false;

  00015	c6 41 5c 00	 mov	 BYTE PTR [ecx+92], 0

; 17   : 	m_fInitVel = 200.0f;

  00019	c7 41 20 00 00
	48 43		 mov	 DWORD PTR [ecx+32], 1128792064 ; 43480000H

; 18   : 	m_fConeAngle = (0.0f);

  00020	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0

; 19   : 	m_fRollAngle = 0.0f;

  00027	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 20   : 	m_fRange = 500.0f;

  0002e	c7 41 74 00 00
	fa 43		 mov	 DWORD PTR [ecx+116], 1140457472 ; 43fa0000H

; 21   : 	m_v3Accel = D3DXVECTOR3(0,0,0.0f);// gravity direction :-z

  00035	c7 41 78 00 00
	00 00		 mov	 DWORD PTR [ecx+120], 0
  0003c	c7 41 7c 00 00
	00 00		 mov	 DWORD PTR [ecx+124], 0
  00043	c7 81 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+128], 0

; 22   : 	m_fHomingMaxAngle = 3.0f;
; 23   : 	m_fHomingStartTime = 0.0f;
; 24   : 	m_fGravity = 0;
; 25   : 	m_bSpreading = false;
; 26   : 	m_bMaintainParallel = false;
; 27   : 
; 28   : 	m_bHitOnBackground = false;
; 29   : 	m_bHitOnAnotherMonster = false;
; 30   : 	m_iPierceCount = 0;
; 31   : 	m_fCollisionSphereRadius = 0.0f;
; 32   : 
; 33   : 	m_fBombRange = 10.0f;
; 34   : 	SetBombEffect("");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00052	c7 41 60 00 00
	40 40		 mov	 DWORD PTR [ecx+96], 1077936128 ; 40400000H
  00059	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0
  00060	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
  00067	66 c7 41 1c 00
	00		 mov	 WORD PTR [ecx+28], 0
  0006d	66 c7 41 68 00
	00		 mov	 WORD PTR [ecx+104], 0
  00073	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0
  0007a	c7 41 70 00 00
	00 00		 mov	 DWORD PTR [ecx+112], 0
  00081	c7 41 3c 00 00
	20 41		 mov	 DWORD PTR [ecx+60], 1092616192 ; 41200000H
  00088	e8 00 00 00 00	 call	 ?SetBombEffect@CFlyingData@@QAEXPBD@Z ; CFlyingData::SetBombEffect

; 35   : }

  0008d	c3		 ret	 0
?__Initialize@CFlyingData@@IAEXXZ ENDP			; CFlyingData::__Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?RemoveAllAttach@CFlyingData@@QAEXXZ
_TEXT	SEGMENT
?RemoveAllAttach@CFlyingData@@QAEXXZ PROC		; CFlyingData::RemoveAllAttach, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00000	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 115  : {

  00006	56		 push	 esi

; 116  : 	m_AttachDataVector.clear();

  00007	8d b1 84 00 00
	00		 lea	 esi, DWORD PTR [ecx+132]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  0000d	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00010	3b c1		 cmp	 eax, ecx
  00012	74 10		 je	 SHORT $LN3@RemoveAllA

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  00014	56		 push	 esi
  00015	51		 push	 ecx
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAXPAUTFlyingAttachData@CFlyingData@@QAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ; std::_Destroy_range<std::allocator<CFlyingData::TFlyingAttachData> >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  0001c	8b 06		 mov	 eax, DWORD PTR [esi]
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00021	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN3@RemoveAllA:
  00024	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 117  : }

  00025	c3		 ret	 0
?RemoveAllAttach@CFlyingData@@QAEXXZ ENDP		; CFlyingData::RemoveAllAttach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?RemoveAttach@CFlyingData@@QAEXH@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
__Last$1$ = -4						; size = 4
_iIndex$ = 8						; size = 4
__Dest$1$ = 8						; size = 4
?RemoveAttach@CFlyingData@@QAEXH@Z PROC			; CFlyingData::RemoveAttach, COMDAT
; _this$ = ecx

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 129  :         _Ptr += _Off;

  00006	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 109  : {

  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 129  :         _Ptr += _Off;

  0000e	c1 e2 04	 shl	 edx, 4
  00011	03 55 08	 add	 edx, DWORD PTR _iIndex$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 109  : {

  00014	89 7d f8	 mov	 DWORD PTR _this$1$[ebp], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 129  :         _Ptr += _Off;

  00017	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
  0001d	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]

; 1760 :         _STD _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

  00020	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
  00026	8d 59 44	 lea	 ebx, DWORD PTR [ecx+68]

; 129  :         _Ptr += _Off;

  00029	89 4d 08	 mov	 DWORD PTR __Dest$1$[ebp], ecx

; 1760 :         _STD _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

  0002c	89 45 fc	 mov	 DWORD PTR __Last$1$[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 5167 :         for (; _First != _Last; ++_Dest, (void) ++_First) {

  0002f	3b d8		 cmp	 ebx, eax
  00031	0f 84 95 00 00
	00		 je	 $LN26@RemoveAtta
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00037	8d 79 08	 lea	 edi, DWORD PTR [ecx+8]
  0003a	8d 73 08	 lea	 esi, DWORD PTR [ebx+8]
  0003d	0f 1f 00	 npad	 3
$LL27@RemoveAtta:
  00040	8b 03		 mov	 eax, DWORD PTR [ebx]
  00042	89 01		 mov	 DWORD PTR [ecx], eax
  00044	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00047	89 47 fc	 mov	 DWORD PTR [edi-4], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1202 :         if (this == _STD addressof(_Right)) {

  0004a	3b fe		 cmp	 edi, esi
  0004c	74 2b		 je	 SHORT $LN39@RemoveAtta

; 1203 :             return *this;
; 1204 :         }
; 1205 : 
; 1206 :         auto& _Al                 = _Getal();
; 1207 :         auto& _Right_al           = _Right._Getal();
; 1208 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
; 1209 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 1210 :             if (_Al != _Right_al) {
; 1211 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 1212 :                 _Mypair._Myval2._Orphan_all();
; 1213 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1214 :             }
; 1215 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 1216 :             if (_Al != _Right_al) {
; 1217 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 1218 :                 return *this;
; 1219 :             }
; 1220 :         }
; 1221 : 
; 1222 :         _Tidy_deallocate();

  0004e	8b cf		 mov	 ecx, edi
  00050	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00055	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  00058	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$1$[ebp]
  0005b	0f 11 07	 movups	 XMMWORD PTR [edi], xmm0
  0005e	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  00063	66 0f d6 47 10	 movq	 QWORD PTR [edi+16], xmm0

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

  00068	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  0006f	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00076	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN39@RemoveAtta:
  00079	0f b6 46 18	 movzx	 eax, BYTE PTR [esi+24]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xutility

; 5167 :         for (; _First != _Last; ++_Dest, (void) ++_First) {

  0007d	83 c1 44	 add	 ecx, 68			; 00000044H
  00080	88 47 18	 mov	 BYTE PTR [edi+24], al
  00083	83 c3 44	 add	 ebx, 68			; 00000044H
  00086	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00089	89 47 1c	 mov	 DWORD PTR [edi+28], eax
  0008c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0008f	89 47 20	 mov	 DWORD PTR [edi+32], eax
  00092	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00095	89 47 24	 mov	 DWORD PTR [edi+36], eax
  00098	0f b6 46 28	 movzx	 eax, BYTE PTR [esi+40]
  0009c	88 47 28	 mov	 BYTE PTR [edi+40], al
  0009f	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000a2	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  000a5	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000a8	89 47 30	 mov	 DWORD PTR [edi+48], eax
  000ab	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  000ae	89 47 34	 mov	 DWORD PTR [edi+52], eax
  000b1	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  000b4	83 c6 44	 add	 esi, 68			; 00000044H
  000b7	89 47 38	 mov	 DWORD PTR [edi+56], eax
  000ba	83 c7 44	 add	 edi, 68			; 00000044H
  000bd	89 4d 08	 mov	 DWORD PTR __Dest$1$[ebp], ecx
  000c0	3b 5d fc	 cmp	 ebx, DWORD PTR __Last$1$[ebp]
  000c3	0f 85 77 ff ff
	ff		 jne	 $LL27@RemoveAtta
  000c9	8b 7d f8	 mov	 edi, DWORD PTR _this$1$[ebp]
$LN26@RemoveAtta:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1761 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000cc	8b b7 88 00 00
	00		 mov	 esi, DWORD PTR [edi+136]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000d2	8b 4e d8	 mov	 ecx, DWORD PTR [esi-40]
  000d5	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  000d8	76 28		 jbe	 SHORT $LN81@RemoveAtta
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000da	8b 46 c4	 mov	 eax, DWORD PTR [esi-60]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000dd	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000de	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000e4	72 12		 jb	 SHORT $LN92@RemoveAtta

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000e6	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000e9	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000ec	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ee	83 c0 fc	 add	 eax, -4			; fffffffcH
  000f1	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f4	77 2e		 ja	 SHORT $LN89@RemoveAtta

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000f6	8b c2		 mov	 eax, edx
$LN92@RemoveAtta:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000f8	51		 push	 ecx
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000ff	83 c4 08	 add	 esp, 8
$LN81@RemoveAtta:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00102	c7 46 d4 00 00
	00 00		 mov	 DWORD PTR [esi-44], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00109	c7 46 d8 0f 00
	00 00		 mov	 DWORD PTR [esi-40], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00110	c6 46 c4 00	 mov	 BYTE PTR [esi-60], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1763 :         --_Mylast;

  00114	83 87 88 00 00
	00 bc		 add	 DWORD PTR [edi+136], -68 ; ffffffbcH
  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 112  : }

  0011e	8b e5		 mov	 esp, ebp
  00120	5d		 pop	 ebp
  00121	c2 04 00	 ret	 4
$LN89@RemoveAtta:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00124	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN119@RemoveAtta:
  00129	cc		 int	 3
?RemoveAttach@CFlyingData@@QAEXH@Z ENDP			; CFlyingData::RemoveAttach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?DuplicateAttach@CFlyingData@@QAEXH@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?DuplicateAttach@CFlyingData@@QAEXH@Z PROC		; CFlyingData::DuplicateAttach, COMDAT
; _this$ = ecx

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00003	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 120  : {

  00009	56		 push	 esi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  0000a	8d b1 84 00 00
	00		 lea	 esi, DWORD PTR [ecx+132]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _iIndex$[ebp]
  00013	c1 e1 04	 shl	 ecx, 4
  00016	03 4d 08	 add	 ecx, DWORD PTR _iIndex$[ebp]
  00019	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]

; 829  :         if (_Mylast != _My_data._Myend) {

  0001c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001f	51		 push	 ecx
  00020	50		 push	 eax
  00021	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00024	74 12		 je	 SHORT $LN9@DuplicateA

; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00026	56		 push	 esi
  00027	e8 00 00 00 00	 call	 ??$construct@UTFlyingAttachData@CFlyingData@@ABU12@@?$_Default_allocator_traits@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@SAXAAV?$allocator@UTFlyingAttachData@CFlyingData@@@1@QAUTFlyingAttachData@CFlyingData@@ABU34@@Z ; std::_Default_allocator_traits<std::allocator<CFlyingData::TFlyingAttachData> >::construct<CFlyingData::TFlyingAttachData,CFlyingData::TFlyingAttachData const &>
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  0002f	83 46 04 44	 add	 DWORD PTR [esi+4], 68	; 00000044H
  00033	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 123  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN9@DuplicateA:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00038	8b ce		 mov	 ecx, esi
  0003a	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Emplace_reallocate<CFlyingData::TFlyingAttachData const &>
  0003f	5e		 pop	 esi
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 123  : }

  00040	5d		 pop	 ebp
  00041	c2 04 00	 ret	 4
?DuplicateAttach@CFlyingData@@QAEXH@Z ENDP		; CFlyingData::DuplicateAttach
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?GetAttachDataReference@CFlyingData@@QAEAAUTFlyingAttachData@1@H@Z
_TEXT	SEGMENT
_iIndex$ = 8						; size = 4
?GetAttachDataReference@CFlyingData@@QAEAAUTFlyingAttachData@1@H@Z PROC ; CFlyingData::GetAttachDataReference, COMDAT
; _this$ = ecx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1919 :         return _My_data._Myfirst[_Pos];

  00003	8b 55 08	 mov	 edx, DWORD PTR _iIndex$[ebp]
  00006	8b 81 84 00 00
	00		 mov	 eax, DWORD PTR [ecx+132]
  0000c	c1 e2 04	 shl	 edx, 4
  0000f	03 55 08	 add	 edx, DWORD PTR _iIndex$[ebp]
  00012	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 72   : }

  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?GetAttachDataReference@CFlyingData@@QAEAAUTFlyingAttachData@1@H@Z ENDP ; CFlyingData::GetAttachDataReference
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z
_TEXT	SEGMENT
_fad$ = -84						; size = 68
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iType$ = 8						; size = 4
_strFilename$ = 12					; size = 4
_fRoll$ = 16						; size = 4
_fArg1$ = 20						; size = 4
_fArg2$ = 24						; size = 4
?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z PROC ; CFlyingData::AttachFlyEffect, COMDAT
; _this$ = ecx

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	8b 7d 0c	 mov	 edi, DWORD PTR _strFilename$[ebp]

; 77   : 	memset(&fad,0, sizeof(fad));

  00030	6a 44		 push	 68			; 00000044H
  00032	8d 45 ac	 lea	 eax, DWORD PTR _fad$[ebp]
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	6a 00		 push	 0
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 _memset

; 79   : 	fad.iFlyType = iType;

  00044	8b 75 08	 mov	 esi, DWORD PTR _iType$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1371 :         if (this == _STD addressof(_Right)) {

  00047	8d 45 b4	 lea	 eax, DWORD PTR _fad$[ebp+8]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 77   : 	memset(&fad,0, sizeof(fad));

  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 78   : 	fad.iType = FLY_ATTACH_EFFECT;

  0004d	c7 45 ac 01 00
	00 00		 mov	 DWORD PTR _fad$[ebp], 1

; 79   : 	fad.iFlyType = iType;

  00054	89 75 b0	 mov	 DWORD PTR _fad$[ebp+4], esi

; 80   : 	fad.fPeriod = 1.0f;

  00057	c7 45 e8 00 00
	80 3f		 mov	 DWORD PTR _fad$[ebp+60], 1065353216 ; 3f800000H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1371 :         if (this == _STD addressof(_Right)) {

  0005e	3b c7		 cmp	 eax, edi
  00060	74 16		 je	 SHORT $LN37@AttachFlyE

; 434  :         return _Myres > _Small_string_capacity;

  00062	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00066	8b c7		 mov	 eax, edi

; 426  :         if (_Large_mode_engaged()) {

  00068	76 02		 jbe	 SHORT $LN41@AttachFlyE

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0006a	8b 07		 mov	 eax, DWORD PTR [edi]
$LN41@AttachFlyE:

; 1410 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0006c	ff 77 10	 push	 DWORD PTR [edi+16]
  0006f	8d 4d b4	 lea	 ecx, DWORD PTR _fad$[ebp+8]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN37@AttachFlyE:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 82   : 	fad.fRoll = fRoll;

  00078	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fRoll$[ebp]
  0007d	f3 0f 11 45 e0	 movss	 DWORD PTR _fad$[ebp+52], xmm0

; 83   : 	fad.dwTailColor = 0xffffffff;

  00082	c7 45 d0 ff ff
	ff ff		 mov	 DWORD PTR _fad$[ebp+36], -1

; 84   : 	fad.fTailLength = 1.0f;

  00089	c7 45 d4 00 00
	80 3f		 mov	 DWORD PTR _fad$[ebp+40], 1065353216 ; 3f800000H

; 85   : 	fad.fTailSize = 10.0f;

  00090	c7 45 d8 00 00
	20 41		 mov	 DWORD PTR _fad$[ebp+44], 1092616192 ; 41200000H

; 86   : 
; 87   : 	switch(iType)

  00097	83 ee 02	 sub	 esi, 2
  0009a	74 20		 je	 SHORT $LN4@AttachFlyE
  0009c	83 ee 01	 sub	 esi, 1
  0009f	74 05		 je	 SHORT $LN5@AttachFlyE
  000a1	83 ee 01	 sub	 esi, 1
  000a4	75 20		 jne	 SHORT $LN7@AttachFlyE
$LN5@AttachFlyE:

; 91   : 		break;
; 92   : 	case FLY_ATTACH_TYPE_SINE:
; 93   : 	case FLY_ATTACH_TYPE_EXP:
; 94   : 		fad.fPeriod=fArg1;

  000a6	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fArg1$[ebp]
  000ab	f3 0f 11 45 e8	 movss	 DWORD PTR _fad$[ebp+60], xmm0

; 95   : 		fad.fAmplitude=fArg2;

  000b0	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _fArg2$[ebp]
  000b5	f3 0f 11 45 ec	 movss	 DWORD PTR _fad$[ebp+64], xmm0

; 96   : 		break;

  000ba	eb 0a		 jmp	 SHORT $LN7@AttachFlyE
$LN4@AttachFlyE:

; 88   : 	{
; 89   : 	case FLY_ATTACH_TYPE_MULTI_LINE:
; 90   : 		fad.fDistance = fArg1;

  000bc	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fArg1$[ebp]
  000c1	f3 0f 11 45 e4	 movss	 DWORD PTR _fad$[ebp+56], xmm0
$LN7@AttachFlyE:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  000c6	8b 83 88 00 00
	00		 mov	 eax, DWORD PTR [ebx+136]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 104  : 	m_AttachDataVector.push_back(fad);

  000cc	8d b3 84 00 00
	00		 lea	 esi, DWORD PTR [ebx+132]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  000d2	8d 4d ac	 lea	 ecx, DWORD PTR _fad$[ebp]
  000d5	51		 push	 ecx
  000d6	50		 push	 eax
  000d7	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  000da	74 0f		 je	 SHORT $LN50@AttachFlyE

; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  000dc	56		 push	 esi
  000dd	e8 00 00 00 00	 call	 ??$construct@UTFlyingAttachData@CFlyingData@@ABU12@@?$_Default_allocator_traits@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@SAXAAV?$allocator@UTFlyingAttachData@CFlyingData@@@1@QAUTFlyingAttachData@CFlyingData@@ABU34@@Z ; std::_Default_allocator_traits<std::allocator<CFlyingData::TFlyingAttachData> >::construct<CFlyingData::TFlyingAttachData,CFlyingData::TFlyingAttachData const &>
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  000e5	83 46 04 44	 add	 DWORD PTR [esi+4], 68	; 00000044H

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  000e9	eb 07		 jmp	 SHORT $LN49@AttachFlyE
$LN50@AttachFlyE:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  000eb	8b ce		 mov	 ecx, esi
  000ed	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Emplace_reallocate<CFlyingData::TFlyingAttachData const &>
$LN49@AttachFlyE:

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000f2	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000f5	b8 79 78 78 78	 mov	 eax, 2021161081		; 78787879H
  000fa	2b 0e		 sub	 ecx, DWORD PTR [esi]
  000fc	f7 e9		 imul	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000fe	8b 4d c8	 mov	 ecx, DWORD PTR _fad$[ebp+28]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1900 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00101	c1 fa 05	 sar	 edx, 5
  00104	8b f2		 mov	 esi, edx
  00106	c1 ee 1f	 shr	 esi, 31			; 0000001fH
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 105  : 	return m_AttachDataVector.size()-1;

  00109	03 f2		 add	 esi, edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0010b	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0010e	76 28		 jbe	 SHORT $LN82@AttachFlyE
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00110	8b 55 b4	 mov	 edx, DWORD PTR _fad$[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00113	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00114	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00116	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0011c	72 10		 jb	 SHORT $LN93@AttachFlyE

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0011e	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00121	83 c1 23	 add	 ecx, 35			; 00000023H
  00124	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00126	83 c0 fc	 add	 eax, -4			; fffffffcH
  00129	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0012c	77 2b		 ja	 SHORT $LN104@AttachFlyE
$LN93@AttachFlyE:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0012e	51		 push	 ecx
  0012f	52		 push	 edx
  00130	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00135	83 c4 08	 add	 esp, 8
$LN82@AttachFlyE:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 105  : 	return m_AttachDataVector.size()-1;

  00138	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]

; 106  : }

  0013b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00145	59		 pop	 ecx
  00146	5f		 pop	 edi
  00147	5e		 pop	 esi
  00148	5b		 pop	 ebx
  00149	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014c	33 cd		 xor	 ecx, ebp
  0014e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00153	8b e5		 mov	 esp, ebp
  00155	5d		 pop	 ebp
  00156	c2 14 00	 ret	 20			; 00000014H
$LN104@AttachFlyE:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00159	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN102@AttachFlyE:
  0015e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z$0:
  00000	8d 4d ac	 lea	 ecx, DWORD PTR _fad$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TFlyingAttachData@CFlyingData@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AttachFlyEffect@CFlyingData@@QAEKHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MMM@Z ENDP ; CFlyingData::AttachFlyEffect
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?SetBombEffect@CFlyingData@@QAEXPBD@Z
_TEXT	SEGMENT
_szEffectName$ = 8					; size = 4
?SetBombEffect@CFlyingData@@QAEXPBD@Z PROC		; CFlyingData::SetBombEffect, COMDAT
; _this$ = ecx

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _szEffectName$[ebp]
  0000a	8b d1		 mov	 edx, ecx
  0000c	8d 72 01	 lea	 esi, DWORD PTR [edx+1]
  0000f	90		 npad	 1
$LL38@SetBombEff:
  00010	8a 02		 mov	 al, BYTE PTR [edx]
  00012	42		 inc	 edx
  00013	84 c0		 test	 al, al
  00015	75 f9		 jne	 SHORT $LL38@SetBombEff
  00017	2b d6		 sub	 edx, esi
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 51   : 	m_strBombEffectName = szEffectName;

  00019	8d 77 40	 lea	 esi, DWORD PTR [edi+64]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001c	52		 push	 edx
  0001d	51		 push	 ecx
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2458 :         return _Mypair._Myval2._Mysize == 0;

  00025	83 7f 50 00	 cmp	 DWORD PTR [edi+80], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 52   : 	if (m_strBombEffectName.empty())

  00029	75 0d		 jne	 SHORT $LN2@SetBombEff

; 61   : 	}
; 62   : 	else
; 63   : 	{
; 64   : 		m_dwBombEffectID = 0;
; 65   : 	}
; 66   : 
; 67   : }

  0002b	c7 47 58 00 00
	00 00		 mov	 DWORD PTR [edi+88], 0
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN2@SetBombEff:

; 53   : 	{
; 54   : 		m_dwBombEffectID = 0;
; 55   : 		return;
; 56   : 	}
; 57   : 	StringPath(m_strBombEffectName);

  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 ?StringPath@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; StringPath
  0003e	83 c4 04	 add	 esp, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  00041	8b c6		 mov	 eax, esi

; 434  :         return _Myres > _Small_string_capacity;

  00043	83 7e 14 0f	 cmp	 DWORD PTR [esi+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00047	76 02		 jbe	 SHORT $LN37@SetBombEff

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00049	8b 06		 mov	 eax, DWORD PTR [esi]
$LN37@SetBombEff:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 58   : 	if (CEffectManager::Instance().RegisterEffect(m_strBombEffectName.c_str()),true)

  0004b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z ; CEffectManager::RegisterEffect
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0005b	83 7e 14 0f	 cmp	 DWORD PTR [esi+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0005f	76 02		 jbe	 SHORT $LN30@SetBombEff

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00061	8b 36		 mov	 esi, DWORD PTR [esi]
$LN30@SetBombEff:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 60   : 		m_dwBombEffectID = GetCaseCRC32(m_strBombEffectName.c_str(),m_strBombEffectName.size());

  00063	ff 77 50	 push	 DWORD PTR [edi+80]
  00066	56		 push	 esi
  00067	e8 00 00 00 00	 call	 ?GetCaseCRC32@@YAKPBDI@Z ; GetCaseCRC32
  0006c	83 c4 08	 add	 esp, 8

; 61   : 	}
; 62   : 	else
; 63   : 	{
; 64   : 		m_dwBombEffectID = 0;
; 65   : 	}
; 66   : 
; 67   : }

  0006f	89 47 58	 mov	 DWORD PTR [edi+88], eax
  00072	5f		 pop	 edi
  00073	5e		 pop	 esi
  00074	5d		 pop	 ebp
  00075	c2 04 00	 ret	 4
?SetBombEffect@CFlyingData@@QAEXPBD@Z ENDP		; CFlyingData::SetBombEffect
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?SaveScriptFile@CFlyingData@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$GSCopy$1$ = -76					; size = 4
_c_szFilename$GSCopy$1$ = -72				; size = 4
_fp$1$ = -68						; size = 4
_strGlobalPathName$ = -64				; size = 24
_strLocalFileName$ = -40				; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFilename$ = 8					; size = 4
?SaveScriptFile@CFlyingData@@QAE_NPBD@Z PROC		; CFlyingData::SaveScriptFile, COMDAT
; _this$ = ecx

; 284  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SaveScriptFile@CFlyingData@@QAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 40	 sub	 esp, 64			; 00000040H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	8b f9		 mov	 edi, ecx
  0002c	89 7d b4	 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  0002f	8b 45 08	 mov	 eax, DWORD PTR _c_szFilename$[ebp]

; 285  : 	FILE* fp = fopen(c_szFilename,"w");

  00032	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w@
  00037	50		 push	 eax
  00038	89 45 b8	 mov	 DWORD PTR _c_szFilename$GSCopy$1$[ebp], eax
  0003b	e8 00 00 00 00	 call	 _fopen
  00040	8b f0		 mov	 esi, eax
  00042	83 c4 08	 add	 esp, 8
  00045	89 75 bc	 mov	 DWORD PTR _fp$1$[ebp], esi

; 286  : 	if (!fp) return false;

  00048	85 f6		 test	 esi, esi
  0004a	75 07		 jne	 SHORT $LN5@SaveScript
  0004c	32 c0		 xor	 al, al
  0004e	e9 fd 04 00 00	 jmp	 $LN1@SaveScript
$LN5@SaveScript:

; 287  : 
; 288  : 	PrintfTabs(fp, 0, "SpreadingFlag           %d\n", m_bSpreading?1:0);

  00053	33 c0		 xor	 eax, eax
  00055	38 47 1c	 cmp	 BYTE PTR [edi+28], al
  00058	0f 95 c0	 setne	 al
  0005b	50		 push	 eax
  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@EKJFFBKN@SpreadingFlag?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@
  00061	6a 00		 push	 0
  00063	56		 push	 esi
  00064	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs

; 289  : 	PrintfTabs(fp, 0, "MaintainParallelFlag    %d\n", m_bMaintainParallel?1:0);

  00069	33 c0		 xor	 eax, eax
  0006b	38 47 1d	 cmp	 BYTE PTR [edi+29], al
  0006e	0f 95 c0	 setne	 al
  00071	50		 push	 eax
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@NGIIEBBO@MaintainParallelFlag?5?5?5?5?$CFd?6@
  00077	6a 00		 push	 0
  00079	56		 push	 esi
  0007a	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  0007f	f3 0f 10 47 20	 movss	 xmm0, DWORD PTR [edi+32]

; 290  : 
; 291  : 	PrintfTabs(fp, 0, "InitialVelocity         %f\n", m_fInitVel);

  00084	83 c4 18	 add	 esp, 24			; 00000018H
  00087	0f 5a c0	 cvtps2pd xmm0, xmm0
  0008a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@HFDPOBJA@InitialVelocity?5?5?5?5?5?5?5?5?5?$CFf?6@
  00094	6a 00		 push	 0
  00096	56		 push	 esi
  00097	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  0009c	f3 0f 10 47 24	 movss	 xmm0, DWORD PTR [edi+36]

; 292  : 	PrintfTabs(fp, 0, "ConeAngle               %f\n", m_fConeAngle);

  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	0f 5a c0	 cvtps2pd xmm0, xmm0
  000a7	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GGIANCOJ@ConeAngle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@
  000b1	6a 00		 push	 0
  000b3	56		 push	 esi
  000b4	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  000b9	f3 0f 10 47 28	 movss	 xmm0, DWORD PTR [edi+40]

; 293  : 	PrintfTabs(fp, 0, "RollAngle               %f\n", m_fRollAngle);

  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	0f 5a c0	 cvtps2pd xmm0, xmm0
  000c4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@OAKALGPC@RollAngle?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@
  000ce	6a 00		 push	 0
  000d0	56		 push	 esi
  000d1	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  000d6	f3 0f 10 47 34	 movss	 xmm0, DWORD PTR [edi+52]

; 294  : 	PrintfTabs(fp, 0, "AngularVelocity         %f %f %f\n", m_v3AngVel.x, m_v3AngVel.y, m_v3AngVel.z);

  000db	0f 5a c0	 cvtps2pd xmm0, xmm0
  000de	51		 push	 ecx
  000df	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  000e5	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]
  000ea	0f 5a c0	 cvtps2pd xmm0, xmm0
  000ed	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  000f3	f3 0f 10 47 2c	 movss	 xmm0, DWORD PTR [edi+44]
  000f8	0f 5a c0	 cvtps2pd xmm0, xmm0
  000fb	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@LMNGANIH@AngularVelocity?5?5?5?5?5?5?5?5?5?$CFf?5?$CFf?5?$CF@
  00105	6a 00		 push	 0
  00107	56		 push	 esi
  00108	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  0010d	f3 0f 10 47 38	 movss	 xmm0, DWORD PTR [edi+56]

; 295  : 	PrintfTabs(fp, 0, "Gravity                 %f\n", m_fGravity);

  00112	83 c4 1c	 add	 esp, 28			; 0000001cH
  00115	0f 5a c0	 cvtps2pd xmm0, xmm0
  00118	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0011d	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GMCHDOFC@Gravity?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@
  00122	6a 00		 push	 0
  00124	56		 push	 esi
  00125	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs

; 296  : 
; 297  : 	PrintfTabs(fp, 0, "HitOnBackground         %d\n",m_bHitOnBackground?1:0);

  0012a	33 c0		 xor	 eax, eax
  0012c	38 47 68	 cmp	 BYTE PTR [edi+104], al
  0012f	0f 95 c0	 setne	 al
  00132	50		 push	 eax
  00133	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@MIBEIPGM@HitOnBackground?5?5?5?5?5?5?5?5?5?$CFd?6@
  00138	6a 00		 push	 0
  0013a	56		 push	 esi
  0013b	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs

; 298  : 	PrintfTabs(fp, 0, "HitOnAnotherMonster     %d\n",m_bHitOnAnotherMonster?1:0);

  00140	33 c0		 xor	 eax, eax
  00142	38 47 69	 cmp	 BYTE PTR [edi+105], al
  00145	0f 95 c0	 setne	 al
  00148	50		 push	 eax
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DIMAIAMO@HitOnAnotherMonster?5?5?5?5?5?$CFd?6@
  0014e	6a 00		 push	 0
  00150	56		 push	 esi
  00151	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs

; 299  : 	PrintfTabs(fp, 0, "PierceCount             %d\n",m_iPierceCount);

  00156	ff 77 6c	 push	 DWORD PTR [edi+108]
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@KJEBPHJO@PierceCount?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@
  0015e	6a 00		 push	 0
  00160	56		 push	 esi
  00161	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  00166	f3 0f 10 47 70	 movss	 xmm0, DWORD PTR [edi+112]
  0016b	83 c4 44	 add	 esp, 68			; 00000044H

; 300  : 	PrintfTabs(fp, 0, "CollisionSphereRadius   %f\n",m_fCollisionSphereRadius);

  0016e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00171	83 ec 08	 sub	 esp, 8
  00174	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00179	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BLFFPBNI@CollisionSphereRadius?5?5?5?$CFf?6@
  0017e	6a 00		 push	 0
  00180	56		 push	 esi
  00181	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  00186	f3 0f 10 47 3c	 movss	 xmm0, DWORD PTR [edi+60]

; 302  : 	PrintfTabs(fp, 0, "BombRange               %f\n", m_fBombRange);

  0018b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0018e	0f 5a c0	 cvtps2pd xmm0, xmm0
  00191	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@PKMAPKGM@BombRange?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@
  0019b	6a 00		 push	 0
  0019d	56		 push	 esi
  0019e	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  001a3	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  001a6	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strGlobalPathName$[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  001ad	0f 11 45 c0	 movups	 XMMWORD PTR _strGlobalPathName$[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 302  : 	PrintfTabs(fp, 0, "BombRange               %f\n", m_fBombRange);

  001b1	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 837  :         _My_data._Myres  = _Small_string_capacity;

  001b4	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strGlobalPathName$[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  001bb	c6 45 c0 00	 mov	 BYTE PTR _strGlobalPathName$[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 305  : 	StringPath(GetOnlyPathName(c_szFilename), strGlobalPathName);

  001bf	8d 45 c0	 lea	 eax, DWORD PTR _strGlobalPathName$[ebp]
  001c2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  001c9	50		 push	 eax
  001ca	ff 75 b8	 push	 DWORD PTR _c_szFilename$GSCopy$1$[ebp]
  001cd	e8 00 00 00 00	 call	 ?GetOnlyPathName@@YAPBDPBD@Z ; GetOnlyPathName
  001d2	83 c4 04	 add	 esp, 4
  001d5	50		 push	 eax
  001d6	e8 00 00 00 00	 call	 ?StringPath@@YAXPBDAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; StringPath
  001db	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  001de	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strLocalFileName$[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  001e5	0f 11 45 d8	 movups	 XMMWORD PTR _strLocalFileName$[ebp], xmm0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 305  : 	StringPath(GetOnlyPathName(c_szFilename), strGlobalPathName);

  001e9	83 c4 08	 add	 esp, 8
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 837  :         _My_data._Myres  = _Small_string_capacity;

  001ec	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strLocalFileName$[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  001f3	c6 45 d8 00	 mov	 BYTE PTR _strLocalFileName$[ebp], 0

; 434  :         return _Myres > _Small_string_capacity;

  001f7	83 7f 54 0f	 cmp	 DWORD PTR [edi+84], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  001fb	8d 4f 40	 lea	 ecx, DWORD PTR [edi+64]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 307  : 	std::string strLocalFileName;

  001fe	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  00202	76 03		 jbe	 SHORT $LN276@SaveScript

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00204	8b 4f 40	 mov	 ecx, DWORD PTR [edi+64]
$LN276@SaveScript:

; 434  :         return _Myres > _Small_string_capacity;

  00207	83 7d d4 0f	 cmp	 DWORD PTR _strGlobalPathName$[ebp+20], 15 ; 0000000fH
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 308  : 	if (GetLocalFileName(strGlobalPathName.c_str(), m_strBombEffectName.c_str(), &strLocalFileName))

  0020b	8d 55 d8	 lea	 edx, DWORD PTR _strLocalFileName$[ebp]
  0020e	52		 push	 edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  0020f	8d 45 c0	 lea	 eax, DWORD PTR _strGlobalPathName$[ebp]

; 426  :         if (_Large_mode_engaged()) {

  00212	0f 47 45 c0	 cmova	 eax, DWORD PTR _strGlobalPathName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 308  : 	if (GetLocalFileName(strGlobalPathName.c_str(), m_strBombEffectName.c_str(), &strLocalFileName))

  00216	51		 push	 ecx
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 ?GetLocalFileName@@YA_NPBD0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetLocalFileName
  0021d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00220	84 c0		 test	 al, al
  00222	74 0d		 je	 SHORT $LN6@SaveScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00224	83 7d ec 0f	 cmp	 DWORD PTR _strLocalFileName$[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00228	8d 45 d8	 lea	 eax, DWORD PTR _strLocalFileName$[ebp]

; 426  :         if (_Large_mode_engaged()) {

  0022b	0f 47 45 d8	 cmova	 eax, DWORD PTR _strLocalFileName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 309  : 		PrintfTabs(fp, 0, "BombEffect              \"%s\"\n", strLocalFileName.c_str());

  0022f	eb 0b		 jmp	 SHORT $LN263@SaveScript
$LN6@SaveScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00231	83 7f 54 0f	 cmp	 DWORD PTR [edi+84], 15	; 0000000fH
  00235	8d 47 40	 lea	 eax, DWORD PTR [edi+64]

; 426  :         if (_Large_mode_engaged()) {

  00238	76 02		 jbe	 SHORT $LN263@SaveScript

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0023a	8b 00		 mov	 eax, DWORD PTR [eax]
$LN263@SaveScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 313  : 	PrintfTabs(fp, 0, "HomingFlag              %d\n", m_bIsHoming?1:0);

  0023c	50		 push	 eax
  0023d	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BNDAHANN@BombEffect?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CC?$CFs?$CC?6@
  00242	6a 00		 push	 0
  00244	56		 push	 esi
  00245	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  0024a	33 c0		 xor	 eax, eax
  0024c	38 47 5c	 cmp	 BYTE PTR [edi+92], al
  0024f	0f 95 c0	 setne	 al
  00252	50		 push	 eax
  00253	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@BPPBPLIE@HomingFlag?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFd?6@
  00258	6a 00		 push	 0
  0025a	56		 push	 esi
  0025b	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  00260	f3 0f 10 47 64	 movss	 xmm0, DWORD PTR [edi+100]

; 314  : 	PrintfTabs(fp, 0, "HomingStartTime         %f\n", m_fHomingStartTime);

  00265	83 c4 18	 add	 esp, 24			; 00000018H
  00268	0f 5a c0	 cvtps2pd xmm0, xmm0
  0026b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00270	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DFAFEFEK@HomingStartTime?5?5?5?5?5?5?5?5?5?$CFf?6@
  00275	6a 00		 push	 0
  00277	56		 push	 esi
  00278	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  0027d	f3 0f 10 47 60	 movss	 xmm0, DWORD PTR [edi+96]

; 315  : 	PrintfTabs(fp, 0, "HomingMaxAngle          %f\n", m_fHomingMaxAngle);

  00282	83 c4 0c	 add	 esp, 12			; 0000000cH
  00285	0f 5a c0	 cvtps2pd xmm0, xmm0
  00288	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0028d	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DJOJIKLN@HomingMaxAngle?5?5?5?5?5?5?5?5?5?5?$CFf?6@
  00292	6a 00		 push	 0
  00294	56		 push	 esi
  00295	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  0029a	f3 0f 10 47 74	 movss	 xmm0, DWORD PTR [edi+116]

; 316  : 	PrintfTabs(fp, 0, "Range                   %f\n", m_fRange);

  0029f	83 c4 0c	 add	 esp, 12			; 0000000cH
  002a2	0f 5a c0	 cvtps2pd xmm0, xmm0
  002a5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002aa	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@JPLBDGMP@Range?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?6@
  002af	6a 00		 push	 0
  002b1	56		 push	 esi
  002b2	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  002b7	f3 0f 10 87 80
	00 00 00	 movss	 xmm0, DWORD PTR [edi+128]

; 317  : 	PrintfTabs(fp, 0, "Acceleration            %f %f %f\n", m_v3Accel.x, m_v3Accel.y, m_v3Accel.z);

  002bf	0f 5a c0	 cvtps2pd xmm0, xmm0
  002c2	51		 push	 ecx
  002c3	f2 0f 11 44 24
	10		 movsd	 QWORD PTR [esp+16], xmm0
  002c9	f3 0f 10 47 7c	 movss	 xmm0, DWORD PTR [edi+124]
  002ce	0f 5a c0	 cvtps2pd xmm0, xmm0
  002d1	f2 0f 11 44 24
	08		 movsd	 QWORD PTR [esp+8], xmm0
  002d7	f3 0f 10 47 78	 movss	 xmm0, DWORD PTR [edi+120]
  002dc	0f 5a c0	 cvtps2pd xmm0, xmm0
  002df	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002e4	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@KJGNOCOO@Acceleration?5?5?5?5?5?5?5?5?5?5?5?5?$CFf?5?$CFf?5?$CF@
  002e9	6a 00		 push	 0
  002eb	56		 push	 esi
  002ec	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  002f1	8b b7 84 00 00
	00		 mov	 esi, DWORD PTR [edi+132]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 317  : 	PrintfTabs(fp, 0, "Acceleration            %f %f %f\n", m_v3Accel.x, m_v3Accel.y, m_v3Accel.z);

  002f7	83 c4 24	 add	 esp, 36			; 00000024H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  002fa	3b b7 88 00 00
	00		 cmp	 esi, DWORD PTR [edi+136]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 320  : 	for(it = m_AttachDataVector.begin();it!=m_AttachDataVector.end();++it)

  00300	0f 84 cb 01 00
	00		 je	 $LN3@SaveScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00306	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  00309	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@SaveScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 322  : 		PrintfTabs(fp, 0, "Group AttachData\n");

  00310	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HICIMFMI@Group?5AttachData?6@
  00315	6a 00		 push	 0
  00317	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  0031a	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs

; 323  : 		PrintfTabs(fp, 0, "{\n");

  0031f	68 00 00 00 00	 push	 OFFSET ??_C@_02KCPFEJNG@?$HL?6@
  00324	6a 00		 push	 0
  00326	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  00329	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs

; 324  : 		PrintfTabs(fp, 1, "Type          %d\n", it->iType);

  0032e	ff 36		 push	 DWORD PTR [esi]
  00330	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@FDNPIKOA@Type?5?5?5?5?5?5?5?5?5?5?$CFd?6@
  00335	6a 01		 push	 1
  00337	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  0033a	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs

; 325  : 		PrintfTabs(fp, 1, "FlyType       %d\n", it->iFlyType);

  0033f	ff 77 fc	 push	 DWORD PTR [edi-4]
  00342	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BLGHHPCB@FlyType?5?5?5?5?5?5?5?$CFd?6@
  00347	6a 01		 push	 1
  00349	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  0034c	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  00351	83 c4 38	 add	 esp, 56			; 00000038H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  00354	8b cf		 mov	 ecx, edi

; 434  :         return _Myres > _Small_string_capacity;

  00356	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  0035a	76 02		 jbe	 SHORT $LN278@SaveScript

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0035c	8b 0f		 mov	 ecx, DWORD PTR [edi]
$LN278@SaveScript:

; 434  :         return _Myres > _Small_string_capacity;

  0035e	83 7d d4 0f	 cmp	 DWORD PTR _strGlobalPathName$[ebp+20], 15 ; 0000000fH
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 326  : 		if (GetLocalFileName(strGlobalPathName.c_str(), it->strFilename.c_str(), &strLocalFileName))

  00362	8d 55 d8	 lea	 edx, DWORD PTR _strLocalFileName$[ebp]
  00365	52		 push	 edx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 425  :         const value_type* _Result = _Bx._Buf;

  00366	8d 45 c0	 lea	 eax, DWORD PTR _strGlobalPathName$[ebp]

; 426  :         if (_Large_mode_engaged()) {

  00369	0f 47 45 c0	 cmova	 eax, DWORD PTR _strGlobalPathName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 326  : 		if (GetLocalFileName(strGlobalPathName.c_str(), it->strFilename.c_str(), &strLocalFileName))

  0036d	51		 push	 ecx
  0036e	50		 push	 eax
  0036f	e8 00 00 00 00	 call	 ?GetLocalFileName@@YA_NPBD0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; GetLocalFileName
  00374	83 c4 0c	 add	 esp, 12			; 0000000cH
  00377	84 c0		 test	 al, al
  00379	74 0d		 je	 SHORT $LN8@SaveScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0037b	83 7d ec 0f	 cmp	 DWORD PTR _strLocalFileName$[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  0037f	8d 45 d8	 lea	 eax, DWORD PTR _strLocalFileName$[ebp]

; 426  :         if (_Large_mode_engaged()) {

  00382	0f 47 45 d8	 cmova	 eax, DWORD PTR _strLocalFileName$[ebp]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 327  : 			PrintfTabs(fp, 1, "AttachFile    \"%s\"\n", strLocalFileName.c_str());

  00386	eb 0a		 jmp	 SHORT $LN277@SaveScript
$LN8@SaveScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00388	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  0038c	8b c7		 mov	 eax, edi

; 426  :         if (_Large_mode_engaged()) {

  0038e	76 02		 jbe	 SHORT $LN277@SaveScript

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00390	8b 07		 mov	 eax, DWORD PTR [edi]
$LN277@SaveScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 332  : 		PrintfTabs(fp, 1, "TailFlag      %d\n", it->bHasTail?1:0);

  00392	50		 push	 eax
  00393	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@KGOGOAGA@AttachFile?5?5?5?5?$CC?$CFs?$CC?6@
  00398	6a 01		 push	 1
  0039a	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  0039d	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  003a2	33 c0		 xor	 eax, eax
  003a4	38 47 18	 cmp	 BYTE PTR [edi+24], al
  003a7	0f 95 c0	 setne	 al
  003aa	50		 push	 eax
  003ab	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OICNGABA@TailFlag?5?5?5?5?5?5?$CFd?6@
  003b0	6a 01		 push	 1
  003b2	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  003b5	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  003ba	83 c4 20	 add	 esp, 32			; 00000020H

; 333  : 		if (it->bHasTail)

  003bd	80 7f 18 00	 cmp	 BYTE PTR [edi+24], 0
  003c1	74 6b		 je	 SHORT $LN10@SaveScript

; 334  : 		{
; 335  : 			PrintfTabs(fp, 1, "TailColor     %ud\n", it->dwTailColor);

  003c3	ff 77 1c	 push	 DWORD PTR [edi+28]
  003c6	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GDEIOKGL@TailColor?5?5?5?5?5?$CFud?6@
  003cb	6a 01		 push	 1
  003cd	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  003d0	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  003d5	f3 0f 10 47 20	 movss	 xmm0, DWORD PTR [edi+32]

; 336  : 			PrintfTabs(fp, 1, "TailLength    %f\n", it->fTailLength);

  003da	83 c4 08	 add	 esp, 8
  003dd	0f 5a c0	 cvtps2pd xmm0, xmm0
  003e0	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  003e5	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BJCKHMFB@TailLength?5?5?5?5?$CFf?6@
  003ea	6a 01		 push	 1
  003ec	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  003ef	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  003f4	f3 0f 10 47 24	 movss	 xmm0, DWORD PTR [edi+36]

; 337  : 			PrintfTabs(fp, 1, "TailSize      %f\n", it->fTailSize);

  003f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  003fc	0f 5a c0	 cvtps2pd xmm0, xmm0
  003ff	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00404	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DBHBKFFP@TailSize?5?5?5?5?5?5?$CFf?6@
  00409	6a 01		 push	 1
  0040b	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  0040e	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs

; 338  : 			PrintfTabs(fp, 1, "TailShapeRect %d\n", it->bRectShape?1:0);

  00413	33 c0		 xor	 eax, eax
  00415	38 47 28	 cmp	 BYTE PTR [edi+40], al
  00418	0f 95 c0	 setne	 al
  0041b	50		 push	 eax
  0041c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@GIAPEHPE@TailShapeRect?5?$CFd?6@
  00421	6a 01		 push	 1
  00423	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  00426	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  0042b	83 c4 24	 add	 esp, 36			; 00000024H
$LN10@SaveScript:

; 339  : 		}
; 340  : 
; 341  : 		PrintfTabs(fp, 1, "Roll          %f\n",it->fRoll );

  0042e	f3 0f 10 47 2c	 movss	 xmm0, DWORD PTR [edi+44]
  00433	83 ec 08	 sub	 esp, 8
  00436	0f 5a c0	 cvtps2pd xmm0, xmm0
  00439	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0043e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NJDFDGEH@Roll?5?5?5?5?5?5?5?5?5?5?$CFf?6@
  00443	6a 01		 push	 1
  00445	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  00448	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  0044d	f3 0f 10 47 30	 movss	 xmm0, DWORD PTR [edi+48]

; 342  : 		PrintfTabs(fp, 1, "Distance      %f\n",it->fDistance );

  00452	83 c4 0c	 add	 esp, 12			; 0000000cH
  00455	0f 5a c0	 cvtps2pd xmm0, xmm0
  00458	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0045d	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MGMHDAIP@Distance?5?5?5?5?5?5?$CFf?6@
  00462	6a 01		 push	 1
  00464	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  00467	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  0046c	f3 0f 10 47 34	 movss	 xmm0, DWORD PTR [edi+52]

; 343  : 		PrintfTabs(fp, 1, "Period        %f\n",it->fPeriod );

  00471	83 c4 0c	 add	 esp, 12			; 0000000cH
  00474	0f 5a c0	 cvtps2pd xmm0, xmm0
  00477	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0047c	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HBPGEMBJ@Period?5?5?5?5?5?5?5?5?$CFf?6@
  00481	6a 01		 push	 1
  00483	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  00486	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
  0048b	f3 0f 10 47 38	 movss	 xmm0, DWORD PTR [edi+56]

; 344  : 		PrintfTabs(fp, 1, "Amplitude     %f\n",it->fAmplitude );

  00490	83 c4 0c	 add	 esp, 12			; 0000000cH
  00493	0f 5a c0	 cvtps2pd xmm0, xmm0
  00496	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0049b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@BECPBEGP@Amplitude?5?5?5?5?5?$CFf?6@
  004a0	6a 01		 push	 1
  004a2	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  004a5	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs

; 346  : 		PrintfTabs(fp, 0, "}\n");

  004aa	68 00 00 00 00	 push	 OFFSET ??_C@_02KGHIDFGE@?$HN?6@
  004af	6a 00		 push	 0
  004b1	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  004b4	e8 00 00 00 00	 call	 ?PrintfTabs@@YAXPAU_iobuf@@HPBDZZ ; PrintfTabs
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 166  :         return _Ptr == _Right._Ptr;

  004b9	8b 45 b4	 mov	 eax, DWORD PTR _this$GSCopy$1$[ebp]

; 82   :         ++_Ptr;

  004bc	83 c6 44	 add	 esi, 68			; 00000044H
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 346  : 		PrintfTabs(fp, 0, "}\n");

  004bf	83 c4 20	 add	 esp, 32			; 00000020H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 82   :         ++_Ptr;

  004c2	83 c7 44	 add	 edi, 68			; 00000044H

; 166  :         return _Ptr == _Right._Ptr;

  004c5	3b b0 88 00 00
	00		 cmp	 esi, DWORD PTR [eax+136]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 320  : 	for(it = m_AttachDataVector.begin();it!=m_AttachDataVector.end();++it)

  004cb	0f 85 3f fe ff
	ff		 jne	 $LL4@SaveScript
$LN3@SaveScript:

; 349  : 	fclose(fp);

  004d1	ff 75 bc	 push	 DWORD PTR _fp$1$[ebp]
  004d4	e8 00 00 00 00	 call	 _fclose
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  004d9	8b 4d ec	 mov	 ecx, DWORD PTR _strLocalFileName$[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 349  : 	fclose(fp);

  004dc	83 c4 04	 add	 esp, 4
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  004df	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  004e2	76 28		 jbe	 SHORT $LN90@SaveScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004e4	8b 55 d8	 mov	 edx, DWORD PTR _strLocalFileName$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  004e7	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  004e8	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  004ea	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  004f0	72 10		 jb	 SHORT $LN101@SaveScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  004f2	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  004f5	83 c1 23	 add	 ecx, 35			; 00000023H
  004f8	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  004fa	83 c0 fc	 add	 eax, -4			; fffffffcH
  004fd	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00500	77 6b		 ja	 SHORT $LN136@SaveScript
$LN101@SaveScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00502	51		 push	 ecx
  00503	52		 push	 edx
  00504	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00509	83 c4 08	 add	 esp, 8
$LN90@SaveScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0050c	8b 4d d4	 mov	 ecx, DWORD PTR _strGlobalPathName$[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  0050f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _strLocalFileName$[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00516	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR _strLocalFileName$[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0051d	c6 45 d8 00	 mov	 BYTE PTR _strLocalFileName$[ebp], 0

; 434  :         return _Myres > _Small_string_capacity;

  00521	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00524	76 28		 jbe	 SHORT $LN128@SaveScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00526	8b 55 c0	 mov	 edx, DWORD PTR _strGlobalPathName$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00529	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0052a	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0052c	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00532	72 10		 jb	 SHORT $LN139@SaveScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00534	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00537	83 c1 23	 add	 ecx, 35			; 00000023H
  0053a	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0053c	83 c0 fc	 add	 eax, -4			; fffffffcH
  0053f	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00542	77 29		 ja	 SHORT $LN136@SaveScript
$LN139@SaveScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00544	51		 push	 ecx
  00545	52		 push	 edx
  00546	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0054b	83 c4 08	 add	 esp, 8
$LN128@SaveScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 350  : 	return true;

  0054e	b0 01		 mov	 al, 1
$LN1@SaveScript:

; 351  : }

  00550	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00553	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0055a	59		 pop	 ecx
  0055b	5f		 pop	 edi
  0055c	5e		 pop	 esi
  0055d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00560	33 cd		 xor	 ecx, ebp
  00562	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00567	8b e5		 mov	 esp, ebp
  00569	5d		 pop	 ebp
  0056a	c2 04 00	 ret	 4
$LN136@SaveScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0056d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN280@SaveScript:
  00572	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveScriptFile@CFlyingData@@QAE_NPBD@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _strGlobalPathName$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveScriptFile@CFlyingData@@QAE_NPBD@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR _strLocalFileName$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?SaveScriptFile@CFlyingData@@QAE_NPBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SaveScriptFile@CFlyingData@@QAE_NPBD@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SaveScriptFile@CFlyingData@@QAE_NPBD@Z ENDP		; CFlyingData::SaveScriptFile
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?LoadScriptFile@CFlyingData@@QAE_NPBD@Z
_TEXT	SEGMENT
_GotoChild$2 = -280					; size = 4
_this$GSCopy$1$ = -276					; size = 4
_i$1$ = -272						; size = 4
_c_szFilename$GSCopy$1$ = -272				; size = 4
$T3 = -265						; size = 1
_temp$ = -264						; size = 4
_TextFileLoader$ = -260					; size = 128
_fad$4 = -132						; size = 68
_strNodeName$5 = -64					; size = 24
$T6 = -40						; size = 24
$T7 = -40						; size = 24
$T8 = -40						; size = 24
$T9 = -40						; size = 24
$T10 = -40						; size = 24
$T11 = -40						; size = 24
$T12 = -40						; size = 24
$T13 = -40						; size = 24
$T14 = -40						; size = 24
$T15 = -40						; size = 24
$T16 = -40						; size = 24
$T17 = -40						; size = 24
$T18 = -40						; size = 24
$T19 = -40						; size = 24
$T20 = -40						; size = 24
$T21 = -40						; size = 24
$T22 = -40						; size = 24
$T23 = -40						; size = 24
$T24 = -40						; size = 24
$T25 = -40						; size = 24
$T26 = -40						; size = 24
$T27 = -40						; size = 24
$T28 = -40						; size = 24
$T29 = -40						; size = 24
$T30 = -40						; size = 24
$T31 = -40						; size = 24
$T32 = -40						; size = 24
$T33 = -40						; size = 24
$T34 = -40						; size = 24
$T35 = -40						; size = 24
$T36 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szFilename$ = 8					; size = 4
?LoadScriptFile@CFlyingData@@QAE_NPBD@Z PROC		; CFlyingData::LoadScriptFile, COMDAT
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	8b f9		 mov	 edi, ecx
  0002f	89 bd ec fe ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], edi
  00035	8b 75 08	 mov	 esi, DWORD PTR _c_szFilename$[ebp]
  00038	89 b5 f0 fe ff
	ff		 mov	 DWORD PTR _c_szFilename$GSCopy$1$[ebp], esi

; 127  : 	Destroy();

  0003e	e8 00 00 00 00	 call	 ?Destroy@CFlyingData@@QAEXXZ ; CFlyingData::Destroy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00043	8b ce		 mov	 ecx, esi
  00045	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL1135@LoadScript:
  00048	8a 01		 mov	 al, BYTE PTR [ecx]
  0004a	41		 inc	 ecx
  0004b	84 c0		 test	 al, al
  0004d	75 f9		 jne	 SHORT $LL1135@LoadScript
  0004f	2b ca		 sub	 ecx, edx
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 129  : 	m_strFilename = c_szFilename;

  00051	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00054	51		 push	 ecx
  00055	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _c_szFilename$GSCopy$1$[ebp]
  0005b	8b ce		 mov	 ecx, esi
  0005d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 130  : 	StringPath(m_strFilename);

  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ?StringPath@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; StringPath
  00068	83 c4 04	 add	 esp, 4

; 131  : 	CTextFileLoader TextFileLoader;

  0006b	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00071	e8 00 00 00 00	 call	 ??0CTextFileLoader@@QAE@XZ ; CTextFileLoader::CTextFileLoader
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00076	83 7e 14 0f	 cmp	 DWORD PTR [esi+20], 15	; 0000000fH
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 131  : 	CTextFileLoader TextFileLoader;

  0007a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  00081	76 02		 jbe	 SHORT $LN85@LoadScript

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00083	8b 36		 mov	 esi, DWORD PTR [esi]
$LN85@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 132  : 	if (!TextFileLoader.Load(m_strFilename.c_str()))

  00085	56		 push	 esi
  00086	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  0008c	e8 00 00 00 00	 call	 ?Load@CTextFileLoader@@QAE_NPBD@Z ; CTextFileLoader::Load
  00091	84 c0		 test	 al, al
  00093	0f 84 5c 0d 00
	00		 je	 $LN72@LoadScript

; 133  : 		return false;
; 134  : 
; 135  : 	TextFileLoader.SetTop();

  00099	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  0009f	e8 00 00 00 00	 call	 ?SetTop@CTextFileLoader@@QAEXXZ ; CTextFileLoader::SetTop

; 138  : 	if (!TextFileLoader.GetTokenInteger("spreadingflag",&temp))

  000a4	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NBBBNDDO@spreadingflag@
  000a9	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
  000ac	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000b1	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  000b7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000bb	50		 push	 eax
  000bc	8d 45 d8	 lea	 eax, DWORD PTR $T27[ebp]
  000bf	50		 push	 eax
  000c0	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  000c6	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000cb	8b 4d ec	 mov	 ecx, DWORD PTR $T27[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 138  : 	if (!TextFileLoader.GetTokenInteger("spreadingflag",&temp))

  000ce	8b f0		 mov	 esi, eax
  000d0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  000d4	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  000d7	76 2c		 jbe	 SHORT $LN157@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d9	8b 55 d8	 mov	 edx, DWORD PTR $T27[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000dc	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000dd	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000df	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000e5	72 14		 jb	 SHORT $LN168@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000e7	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000ea	83 c1 23	 add	 ecx, 35			; 00000023H
  000ed	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000ef	83 c0 fc	 add	 eax, -4			; fffffffcH
  000f2	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f5	0f 87 2f 0d 00
	00		 ja	 $LN329@LoadScript
$LN168@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000fb	51		 push	 ecx
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00102	83 c4 08	 add	 esp, 8
$LN157@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 138  : 	if (!TextFileLoader.GetTokenInteger("spreadingflag",&temp))

  00105	85 f6		 test	 esi, esi
  00107	75 04		 jne	 SHORT $LN6@LoadScript

; 139  : 	{
; 140  : 		m_bSpreading = false;

  00109	32 c0		 xor	 al, al

; 141  : 	}

  0010b	eb 0a		 jmp	 SHORT $LN7@LoadScript
$LN6@LoadScript:

; 142  : 	else
; 143  : 	{
; 144  : 		m_bSpreading = temp?true:false;

  0010d	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _temp$[ebp], 0
  00114	0f 95 c0	 setne	 al
$LN7@LoadScript:

; 147  : 	if (!TextFileLoader.GetTokenInteger("maintainparallelflag", &temp))

  00117	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@IJDOJCHL@maintainparallelflag@
  0011c	8d 4d d8	 lea	 ecx, DWORD PTR $T19[ebp]
  0011f	88 47 1c	 mov	 BYTE PTR [edi+28], al
  00122	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00127	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  0012d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00131	50		 push	 eax
  00132	8d 45 d8	 lea	 eax, DWORD PTR $T19[ebp]
  00135	50		 push	 eax
  00136	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  0013c	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00141	8b 4d ec	 mov	 ecx, DWORD PTR $T19[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 147  : 	if (!TextFileLoader.GetTokenInteger("maintainparallelflag", &temp))

  00144	8b f0		 mov	 esi, eax
  00146	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0014a	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  0014d	76 2c		 jbe	 SHORT $LN232@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0014f	8b 55 d8	 mov	 edx, DWORD PTR $T19[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00152	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00153	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00155	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0015b	72 14		 jb	 SHORT $LN243@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0015d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00160	83 c1 23	 add	 ecx, 35			; 00000023H
  00163	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00165	83 c0 fc	 add	 eax, -4			; fffffffcH
  00168	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0016b	0f 87 be 0c 00
	00		 ja	 $LN1147@LoadScript
$LN243@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00171	51		 push	 ecx
  00172	52		 push	 edx
  00173	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00178	83 c4 08	 add	 esp, 8
$LN232@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 147  : 	if (!TextFileLoader.GetTokenInteger("maintainparallelflag", &temp))

  0017b	85 f6		 test	 esi, esi
  0017d	75 04		 jne	 SHORT $LN8@LoadScript

; 148  : 	{
; 149  : 		m_bMaintainParallel = false;

  0017f	32 c0		 xor	 al, al

; 150  : 	}

  00181	eb 0a		 jmp	 SHORT $LN9@LoadScript
$LN8@LoadScript:

; 151  : 	else
; 152  : 	{
; 153  : 		m_bMaintainParallel = temp?true:false;

  00183	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _temp$[ebp], 0
  0018a	0f 95 c0	 setne	 al
$LN9@LoadScript:

; 156  : 	if (!TextFileLoader.GetTokenFloat("initialvelocity",&m_fInitVel))

  0018d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HEDAMPDI@initialvelocity@
  00192	8d 4d d8	 lea	 ecx, DWORD PTR $T34[ebp]
  00195	88 47 1d	 mov	 BYTE PTR [edi+29], al
  00198	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0019d	8d 47 20	 lea	 eax, DWORD PTR [edi+32]
  001a0	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  001a4	50		 push	 eax
  001a5	8d 45 d8	 lea	 eax, DWORD PTR $T34[ebp]
  001a8	50		 push	 eax
  001a9	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  001af	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  001b4	8b 4d ec	 mov	 ecx, DWORD PTR $T34[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 156  : 	if (!TextFileLoader.GetTokenFloat("initialvelocity",&m_fInitVel))

  001b7	8b f0		 mov	 esi, eax
  001b9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  001bd	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  001c0	76 2c		 jbe	 SHORT $LN195@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001c2	8b 55 d8	 mov	 edx, DWORD PTR $T34[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  001c5	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001c6	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  001c8	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  001ce	72 14		 jb	 SHORT $LN206@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  001d0	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  001d3	83 c1 23	 add	 ecx, 35			; 00000023H
  001d6	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  001d8	83 c0 fc	 add	 eax, -4			; fffffffcH
  001db	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  001de	0f 87 50 0c 00
	00		 ja	 $LN1148@LoadScript
$LN206@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  001e4	51		 push	 ecx
  001e5	52		 push	 edx
  001e6	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  001eb	83 c4 08	 add	 esp, 8
$LN195@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 156  : 	if (!TextFileLoader.GetTokenFloat("initialvelocity",&m_fInitVel))

  001ee	85 f6		 test	 esi, esi
  001f0	0f 84 ff 0b 00
	00		 je	 $LN72@LoadScript

; 157  : 	{
; 158  : 		return false;
; 159  : 	}
; 160  : 
; 161  : 	TextFileLoader.GetTokenFloat("coneangle", &m_fConeAngle);

  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_09KDIMMAIL@coneangle@
  001fb	8d 4d d8	 lea	 ecx, DWORD PTR $T35[ebp]
  001fe	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00203	8d 47 24	 lea	 eax, DWORD PTR [edi+36]
  00206	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0020a	50		 push	 eax
  0020b	8d 45 d8	 lea	 eax, DWORD PTR $T35[ebp]
  0020e	50		 push	 eax
  0020f	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00215	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
  0021a	8d 4d d8	 lea	 ecx, DWORD PTR $T35[ebp]
  0021d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00221	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 162  : 	//if (!TextFileLoader.GetTokenFloat("coneangle", &m_fConeAngle))
; 163  : 	//	m_fConeAngle = 0.0f;
; 164  : 
; 165  : 	TextFileLoader.GetTokenFloat("rollangle", &m_fRollAngle);

  00226	68 00 00 00 00	 push	 OFFSET ??_C@_09LMFNGIPD@rollangle@
  0022b	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0022e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00233	8d 47 28	 lea	 eax, DWORD PTR [edi+40]
  00236	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0023a	50		 push	 eax
  0023b	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  0023e	50		 push	 eax
  0023f	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00245	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
  0024a	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0024d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00251	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 166  : 	//if (!TextFileLoader.GetTokenFloat("rollangle", &m_fRollAngle))
; 167  : 	//	m_fRollAngle = 0.0f;
; 168  : 
; 169  : 	TextFileLoader.GetTokenVector3("angularvelocity",&m_v3AngVel);

  00256	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@LAOKBKDJ@angularvelocity@
  0025b	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  0025e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00263	8d 47 2c	 lea	 eax, DWORD PTR [edi+44]
  00266	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0026a	50		 push	 eax
  0026b	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  0026e	50		 push	 eax
  0026f	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00275	e8 00 00 00 00	 call	 ?GetTokenVector3@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXVECTOR3@@@Z ; CTextFileLoader::GetTokenVector3
  0027a	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  0027d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00281	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 170  : 	//if (!TextFileLoader.GetTokenVector3("angularvelocity",&m_v3AngVel))
; 171  : 	//	m_v3AngVel = D3DXVECTOR3(0.0f,0.0f,0.0f);
; 172  : 
; 173  : 	TextFileLoader.GetTokenFloat("gravity",&m_fGravity);

  00286	68 00 00 00 00	 push	 OFFSET ??_C@_07GFBFDLBM@gravity@
  0028b	8d 4d d8	 lea	 ecx, DWORD PTR $T33[ebp]
  0028e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00293	8d 47 38	 lea	 eax, DWORD PTR [edi+56]
  00296	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0029a	50		 push	 eax
  0029b	8d 45 d8	 lea	 eax, DWORD PTR $T33[ebp]
  0029e	50		 push	 eax
  0029f	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  002a5	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
  002aa	8d 4d d8	 lea	 ecx, DWORD PTR $T33[ebp]
  002ad	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002b1	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 174  : 	//if (!TextFileLoader.GetTokenFloat("gravity",&m_fGravity))
; 175  : 		//m_fGravity = 0.0f;
; 176  : 
; 177  : 	if (TextFileLoader.GetTokenInteger("hitonbackground",&temp))

  002b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KECLBPOM@hitonbackground@
  002bb	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  002be	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002c3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  002c9	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  002cd	50		 push	 eax
  002ce	8d 45 d8	 lea	 eax, DWORD PTR $T8[ebp]
  002d1	50		 push	 eax
  002d2	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  002d8	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
  002dd	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  002e0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002e4	8b f0		 mov	 esi, eax
  002e6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002eb	85 f6		 test	 esi, esi
  002ed	74 0c		 je	 SHORT $LN11@LoadScript

; 178  : 		m_bHitOnBackground = temp?true:false;

  002ef	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _temp$[ebp], 0
  002f6	0f 95 c0	 setne	 al
  002f9	eb 02		 jmp	 SHORT $LN12@LoadScript
$LN11@LoadScript:

; 179  : 	else
; 180  : 		m_bHitOnBackground = false;

  002fb	32 c0		 xor	 al, al
$LN12@LoadScript:

; 181  : 
; 182  : 	if (TextFileLoader.GetTokenInteger("hitonanothermonster",&temp))

  002fd	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@CFEKODPK@hitonanothermonster@
  00302	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  00305	88 47 68	 mov	 BYTE PTR [edi+104], al
  00308	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0030d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  00313	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00317	50		 push	 eax
  00318	8d 45 d8	 lea	 eax, DWORD PTR $T9[ebp]
  0031b	50		 push	 eax
  0031c	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00322	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
  00327	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  0032a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0032e	8b f0		 mov	 esi, eax
  00330	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00335	85 f6		 test	 esi, esi
  00337	74 0c		 je	 SHORT $LN13@LoadScript

; 183  : 		m_bHitOnAnotherMonster = temp?true:false;

  00339	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _temp$[ebp], 0
  00340	0f 95 c0	 setne	 al
  00343	eb 02		 jmp	 SHORT $LN14@LoadScript
$LN13@LoadScript:

; 184  : 	else
; 185  : 		m_bHitOnAnotherMonster = false;

  00345	32 c0		 xor	 al, al
$LN14@LoadScript:

; 186  : 
; 187  : 	if (!TextFileLoader.GetTokenInteger("piercecount",&m_iPierceCount))

  00347	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CFHBGHLK@piercecount@
  0034c	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]
  0034f	88 47 69	 mov	 BYTE PTR [edi+105], al
  00352	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00357	8d 47 6c	 lea	 eax, DWORD PTR [edi+108]
  0035a	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  0035e	50		 push	 eax
  0035f	8d 45 d8	 lea	 eax, DWORD PTR $T10[ebp]
  00362	50		 push	 eax
  00363	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00369	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
  0036e	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]
  00371	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00375	8b f0		 mov	 esi, eax
  00377	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0037c	85 f6		 test	 esi, esi
  0037e	75 03		 jne	 SHORT $LN15@LoadScript

; 188  : 		m_iPierceCount = 0;

  00380	89 77 6c	 mov	 DWORD PTR [edi+108], esi
$LN15@LoadScript:

; 189  : 
; 190  : //	if (!TextFileLoader.GetTokenFloat("collisionsphereradius",&m_fCollisionSphereRadius))
; 191  : //		m_fCollisionSphereRadius = 0.0f;
; 192  : 
; 193  : 	TextFileLoader.GetTokenFloat("bombrange",&m_fBombRange);

  00383	68 00 00 00 00	 push	 OFFSET ??_C@_09HBCJNFFH@bombrange@
  00388	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  0038b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00390	8d 47 3c	 lea	 eax, DWORD PTR [edi+60]
  00393	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00397	50		 push	 eax
  00398	8d 45 d8	 lea	 eax, DWORD PTR $T11[ebp]
  0039b	50		 push	 eax
  0039c	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  003a2	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
  003a7	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  003aa	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003ae	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 194  : 	//if (!TextFileLoader.GetTokenFloat("bombrange",&m_fBombRange))
; 195  : 	//	m_fBombRange = 10.0f;
; 196  : 
; 197  : 	if (!TextFileLoader.GetTokenString("bombeffect",&m_strBombEffectName))

  003b3	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JPKFDMHA@bombeffect@
  003b8	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  003bb	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003c0	83 c7 40	 add	 edi, 64			; 00000040H
  003c3	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  003c7	57		 push	 edi
  003c8	8d 45 d8	 lea	 eax, DWORD PTR $T12[ebp]
  003cb	50		 push	 eax
  003cc	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  003d2	e8 00 00 00 00	 call	 ?GetTokenString@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV23@@Z ; CTextFileLoader::GetTokenString
  003d7	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  003da	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003de	8b f0		 mov	 esi, eax
  003e0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  003e5	85 f6		 test	 esi, esi
  003e7	75 0f		 jne	 SHORT $LN16@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1614 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003e9	56		 push	 esi
  003ea	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  003ef	8b cf		 mov	 ecx, edi
  003f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 200  : 	}

  003f6	eb 6f		 jmp	 SHORT $LN18@LoadScript
$LN16@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2458 :         return _Mypair._Myval2._Mysize == 0;

  003f8	8b b5 ec fe ff
	ff		 mov	 esi, DWORD PTR _this$GSCopy$1$[ebp]
  003fe	83 7e 50 00	 cmp	 DWORD PTR [esi+80], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 201  : 	else if (!m_strBombEffectName.empty())

  00402	74 63		 je	 SHORT $LN18@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00404	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00408	8b c7		 mov	 eax, edi

; 426  :         if (_Large_mode_engaged()) {

  0040a	76 02		 jbe	 SHORT $LN1134@LoadScript

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0040c	8b 07		 mov	 eax, DWORD PTR [edi]
$LN1134@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 203  : 		if (!IsGlobalFileName(m_strBombEffectName.c_str()))

  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ?IsGlobalFileName@@YA_NPBD@Z ; IsGlobalFileName
  00414	83 c4 04	 add	 esp, 4
  00417	84 c0		 test	 al, al
  00419	75 32		 jne	 SHORT $LN19@LoadScript

; 204  : 			m_strBombEffectName = GetOnlyPathName(TextFileLoader.GetFileName()) + m_strBombEffectName;

  0041b	57		 push	 edi
  0041c	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00422	e8 00 00 00 00	 call	 ?GetFileName@CTextFileLoader@@QAEPBDXZ ; CTextFileLoader::GetFileName
  00427	50		 push	 eax
  00428	e8 00 00 00 00	 call	 ?GetOnlyPathName@@YAPBDPBD@Z ; GetOnlyPathName
  0042d	83 c4 04	 add	 esp, 4
  00430	50		 push	 eax
  00431	8d 45 d8	 lea	 eax, DWORD PTR $T13[ebp]
  00434	50		 push	 eax
  00435	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0043a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0043d	8b cf		 mov	 ecx, edi
  0043f	50		 push	 eax
  00440	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  00445	8d 4d d8	 lea	 ecx, DWORD PTR $T13[ebp]
  00448	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN19@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0044d	83 7f 14 0f	 cmp	 DWORD PTR [edi+20], 15	; 0000000fH

; 426  :         if (_Large_mode_engaged()) {

  00451	76 02		 jbe	 SHORT $LN1014@LoadScript

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00453	8b 3f		 mov	 edi, DWORD PTR [edi]
$LN1014@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 205  : 		CEffectManager::Instance().RegisterEffect2(m_strBombEffectName.c_str(),&m_dwBombEffectID);

  00455	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  0045b	8d 46 58	 lea	 eax, DWORD PTR [esi+88]
  0045e	6a 00		 push	 0
  00460	50		 push	 eax
  00461	57		 push	 edi
  00462	e8 00 00 00 00	 call	 ?RegisterEffect2@CEffectManager@@QAEHPBDPAK_N@Z ; CEffectManager::RegisterEffect2
$LN18@LoadScript:

; 206  : 	}
; 207  : 
; 208  : 	if (!TextFileLoader.GetTokenInteger("homingflag", &temp))

  00467	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PGFICFIL@homingflag@
  0046c	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  0046f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00474	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  0047a	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  0047e	50		 push	 eax
  0047f	8d 45 d8	 lea	 eax, DWORD PTR $T14[ebp]
  00482	50		 push	 eax
  00483	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00489	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
  0048e	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  00491	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00495	8b f0		 mov	 esi, eax
  00497	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0049c	85 f6		 test	 esi, esi
  0049e	75 04		 jne	 SHORT $LN20@LoadScript

; 209  : 		m_bIsHoming = false;

  004a0	32 c0		 xor	 al, al
  004a2	eb 0a		 jmp	 SHORT $LN21@LoadScript
$LN20@LoadScript:

; 210  : 	else
; 211  : 		m_bIsHoming = temp?true:false;

  004a4	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _temp$[ebp], 0
  004ab	0f 95 c0	 setne	 al
$LN21@LoadScript:

; 212  : 
; 213  : 	if (!TextFileLoader.GetTokenFloat("homingstarttime",&m_fHomingStartTime))

  004ae	8b bd ec fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
  004b4	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  004b7	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BAKAIINA@homingstarttime@
  004bc	88 47 5c	 mov	 BYTE PTR [edi+92], al
  004bf	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  004c4	8d 47 64	 lea	 eax, DWORD PTR [edi+100]
  004c7	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  004cb	50		 push	 eax
  004cc	8d 45 d8	 lea	 eax, DWORD PTR $T15[ebp]
  004cf	50		 push	 eax
  004d0	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  004d6	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
  004db	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  004de	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  004e2	8b f0		 mov	 esi, eax
  004e4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  004e9	85 f6		 test	 esi, esi
  004eb	75 03		 jne	 SHORT $LN22@LoadScript

; 214  : 		m_fHomingStartTime = 0.0f;

  004ed	89 77 64	 mov	 DWORD PTR [edi+100], esi
$LN22@LoadScript:

; 215  : 
; 216  : 	if (!TextFileLoader.GetTokenFloat("homingmaxangle",&m_fHomingMaxAngle))

  004f0	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MGJJCPHI@homingmaxangle@
  004f5	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  004f8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  004fd	8d 47 60	 lea	 eax, DWORD PTR [edi+96]
  00500	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  00504	50		 push	 eax
  00505	8d 45 d8	 lea	 eax, DWORD PTR $T16[ebp]
  00508	50		 push	 eax
  00509	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  0050f	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
  00514	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  00517	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0051b	8b f0		 mov	 esi, eax
  0051d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00522	85 f6		 test	 esi, esi
  00524	75 03		 jne	 SHORT $LN23@LoadScript

; 217  : 		m_fHomingMaxAngle = 0.0f;

  00526	89 77 60	 mov	 DWORD PTR [edi+96], esi
$LN23@LoadScript:

; 218  : 
; 219  : 	if (!TextFileLoader.GetTokenFloat("range",&m_fRange))

  00529	68 00 00 00 00	 push	 OFFSET ??_C@_05CCGOGOBM@range@
  0052e	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  00531	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00536	8d 47 74	 lea	 eax, DWORD PTR [edi+116]
  00539	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  0053d	50		 push	 eax
  0053e	8d 45 d8	 lea	 eax, DWORD PTR $T17[ebp]
  00541	50		 push	 eax
  00542	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00548	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
  0054d	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  00550	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00554	8b f0		 mov	 esi, eax
  00556	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0055b	85 f6		 test	 esi, esi
  0055d	0f 84 92 08 00
	00		 je	 $LN72@LoadScript

; 220  : 		return false;
; 221  : 
; 222  : 	if (!TextFileLoader.GetTokenVector3("acceleration",&m_v3Accel))

  00563	68 00 00 00 00	 push	 OFFSET ??_C@_0N@OKFAMOHD@acceleration@
  00568	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  0056b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00570	83 c7 78	 add	 edi, 120		; 00000078H
  00573	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  00577	57		 push	 edi
  00578	8d 45 d8	 lea	 eax, DWORD PTR $T18[ebp]
  0057b	50		 push	 eax
  0057c	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00582	e8 00 00 00 00	 call	 ?GetTokenVector3@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUD3DXVECTOR3@@@Z ; CTextFileLoader::GetTokenVector3
  00587	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  0058a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0058e	8b f0		 mov	 esi, eax
  00590	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00595	85 f6		 test	 esi, esi
  00597	75 08		 jne	 SHORT $LN25@LoadScript

; 223  : 		m_v3Accel = D3DXVECTOR3(0.0f,0.0f,0.0f);

  00599	89 37		 mov	 DWORD PTR [edi], esi
  0059b	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0059e	89 77 08	 mov	 DWORD PTR [edi+8], esi
$LN25@LoadScript:

; 226  : 	for(i=0;i<TextFileLoader.GetChildNodeCount();i++)

  005a1	33 f6		 xor	 esi, esi
  005a3	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  005a9	89 b5 f0 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  005af	e8 00 00 00 00	 call	 ?GetChildNodeCount@CTextFileLoader@@QAEKXZ ; CTextFileLoader::GetChildNodeCount
  005b4	85 c0		 test	 eax, eax
  005b6	0f 84 30 08 00
	00		 je	 $LN1129@LoadScript
  005bc	8b bd ec fe ff
	ff		 mov	 edi, DWORD PTR _this$GSCopy$1$[ebp]
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h

; 49   : 			CGotoChild(CTextFileLoader * pOwner, DWORD dwIndex) : m_pOwner(pOwner)

  005c2	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _TextFileLoader$[ebp]
  005c8	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _GotoChild$2[ebp], eax
  005ce	66 90		 npad	 2
$LL4@LoadScript:

; 50   : 			{
; 51   : 				m_pOwner->SetChildNode(dwIndex);

  005d0	56		 push	 esi
  005d1	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  005d7	e8 00 00 00 00	 call	 ?SetChildNode@CTextFileLoader@@QAEHK@Z ; CTextFileLoader::SetChildNode
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 228  : 		CTextFileLoader::CGotoChild GotoChild(&TextFileLoader, i);

  005dc	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  005df	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strNodeName$5[ebp+16], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  005e6	0f 11 45 c0	 movups	 XMMWORD PTR _strNodeName$5[ebp], xmm0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  005ea	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strNodeName$5[ebp+20], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  005f1	c6 45 c0 00	 mov	 BYTE PTR _strNodeName$5[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 232  : 		TextFileLoader.GetCurrentNodeName(&strNodeName);

  005f5	8d 45 c0	 lea	 eax, DWORD PTR _strNodeName$5[ebp]
  005f8	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  005fc	50		 push	 eax
  005fd	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00603	e8 00 00 00 00	 call	 ?GetCurrentNodeName@CTextFileLoader@@QAEHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CTextFileLoader::GetCurrentNodeName
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00608	83 7d d4 0f	 cmp	 DWORD PTR _strNodeName$5[ebp+20], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  0060c	8d 4d c0	 lea	 ecx, DWORD PTR _strNodeName$5[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 578  :     if (_Left_size != _Right_size) {

  0060f	8b 55 d0	 mov	 edx, DWORD PTR _strNodeName$5[ebp+16]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  00612	0f 47 4d c0	 cmova	 ecx, DWORD PTR _strNodeName$5[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 578  :     if (_Left_size != _Right_size) {

  00616	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00619	0f 85 36 07 00
	00		 jne	 $LN26@LoadScript

; 579  :         return false;
; 580  :     }
; 581  : 
; 582  :     if (_Left_size == 0u) {

  0061f	85 d2		 test	 edx, edx
  00621	74 66		 je	 SHORT $LN1133@LoadScript

; 413  :         return _CSTD memcmp(_First1, _First2, _Count);

  00623	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_0L@NFEBBADL@attachdata@
  00628	83 ea 04	 sub	 edx, 4
  0062b	72 14		 jb	 SHORT $LN1138@LoadScript
  0062d	0f 1f 00	 npad	 3
$LL1139@LoadScript:
  00630	8b 01		 mov	 eax, DWORD PTR [ecx]
  00632	3b 06		 cmp	 eax, DWORD PTR [esi]
  00634	75 10		 jne	 SHORT $LN1137@LoadScript
  00636	83 c1 04	 add	 ecx, 4
  00639	83 c6 04	 add	 esi, 4
  0063c	83 ea 04	 sub	 edx, 4
  0063f	73 ef		 jae	 SHORT $LL1139@LoadScript
$LN1138@LoadScript:
  00641	83 fa fc	 cmp	 edx, -4			; fffffffcH
  00644	74 34		 je	 SHORT $LN1136@LoadScript
$LN1137@LoadScript:
  00646	8a 01		 mov	 al, BYTE PTR [ecx]
  00648	3a 06		 cmp	 al, BYTE PTR [esi]
  0064a	75 27		 jne	 SHORT $LN1140@LoadScript
  0064c	83 fa fd	 cmp	 edx, -3			; fffffffdH
  0064f	74 29		 je	 SHORT $LN1136@LoadScript
  00651	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00654	3a 46 01	 cmp	 al, BYTE PTR [esi+1]
  00657	75 1a		 jne	 SHORT $LN1140@LoadScript
  00659	83 fa fe	 cmp	 edx, -2			; fffffffeH
  0065c	74 1c		 je	 SHORT $LN1136@LoadScript
  0065e	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  00661	3a 46 02	 cmp	 al, BYTE PTR [esi+2]
  00664	75 0d		 jne	 SHORT $LN1140@LoadScript
  00666	83 fa ff	 cmp	 edx, -1
  00669	74 0f		 je	 SHORT $LN1136@LoadScript
  0066b	8a 41 03	 mov	 al, BYTE PTR [ecx+3]
  0066e	3a 46 03	 cmp	 al, BYTE PTR [esi+3]
  00671	74 07		 je	 SHORT $LN1136@LoadScript
$LN1140@LoadScript:
  00673	1b c0		 sbb	 eax, eax
  00675	83 c8 01	 or	 eax, 1
  00678	eb 02		 jmp	 SHORT $LN1141@LoadScript
$LN1136@LoadScript:
  0067a	33 c0		 xor	 eax, eax
$LN1141@LoadScript:

; 586  :     return _Traits::compare(_Left, _Right, _Left_size) == 0;

  0067c	85 c0		 test	 eax, eax
  0067e	0f 94 c0	 sete	 al
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 234  : 		if (strNodeName=="attachdata")

  00681	84 c0		 test	 al, al
  00683	0f 84 cc 06 00
	00		 je	 $LN26@LoadScript
$LN1133@LoadScript:
  00689	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 836  :         _My_data._Mysize = 0;

  0068c	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _fad$4[ebp+24], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00693	0f 11 45 84	 movups	 XMMWORD PTR _fad$4[ebp+8], xmm0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00697	c7 45 98 0f 00
	00 00		 mov	 DWORD PTR _fad$4[ebp+28], 15 ; 0000000fH

; 838  :         _My_data._Activate_SSO_buffer();
; 839  : 
; 840  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0069e	c6 45 84 00	 mov	 BYTE PTR _fad$4[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 238  : 			if (!TextFileLoader.GetTokenInteger("type",&fad.iType))

  006a2	68 00 00 00 00	 push	 OFFSET ??_C@_04GPMDFGEJ@type@
  006a7	8d 4d d8	 lea	 ecx, DWORD PTR $T20[ebp]
  006aa	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  006ae	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  006b3	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _fad$4[ebp]
  006b9	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  006bd	50		 push	 eax
  006be	8d 45 d8	 lea	 eax, DWORD PTR $T20[ebp]
  006c1	50		 push	 eax
  006c2	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  006c8	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  006cd	8b 4d ec	 mov	 ecx, DWORD PTR $T20[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 238  : 			if (!TextFileLoader.GetTokenInteger("type",&fad.iType))

  006d0	8b f0		 mov	 esi, eax
  006d2	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  006d6	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  006d9	76 2c		 jbe	 SHORT $LN321@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006db	8b 55 d8	 mov	 edx, DWORD PTR $T20[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  006de	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  006df	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  006e1	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  006e7	72 14		 jb	 SHORT $LN332@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  006e9	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  006ec	83 c1 23	 add	 ecx, 35			; 00000023H
  006ef	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  006f1	83 c0 fc	 add	 eax, -4			; fffffffcH
  006f4	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  006f7	0f 87 2d 07 00
	00		 ja	 $LN329@LoadScript
$LN332@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  006fd	51		 push	 ecx
  006fe	52		 push	 edx
  006ff	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00704	83 c4 08	 add	 esp, 8
$LN321@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 238  : 			if (!TextFileLoader.GetTokenInteger("type",&fad.iType))

  00707	85 f6		 test	 esi, esi
  00709	0f 85 9d 00 00
	00		 jne	 $LN28@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0070f	8b 4d 98	 mov	 ecx, DWORD PTR _fad$4[ebp+28]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 239  : 				continue;

  00712	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00716	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00719	76 2c		 jbe	 SHORT $LN425@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0071b	8b 55 84	 mov	 edx, DWORD PTR _fad$4[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0071e	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0071f	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00721	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00727	72 14		 jb	 SHORT $LN436@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00729	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0072c	83 c1 23	 add	 ecx, 35			; 00000023H
  0072f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00731	83 c0 fc	 add	 eax, -4			; fffffffcH
  00734	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00737	0f 87 ed 06 00
	00		 ja	 $LN329@LoadScript
$LN436@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0073d	51		 push	 ecx
  0073e	52		 push	 edx
  0073f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00744	83 c4 08	 add	 esp, 8
$LN425@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00747	8b 4d d4	 mov	 ecx, DWORD PTR _strNodeName$5[ebp+20]

; 3054 :         _My_data._Mysize = 0;

  0074a	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _fad$4[ebp+24], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00751	c7 45 98 0f 00
	00 00		 mov	 DWORD PTR _fad$4[ebp+28], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00758	c6 45 84 00	 mov	 BYTE PTR _fad$4[ebp+8], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 239  : 				continue;

  0075c	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00760	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00763	76 2c		 jbe	 SHORT $LN463@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00765	8b 55 c0	 mov	 edx, DWORD PTR _strNodeName$5[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00768	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00769	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0076b	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00771	72 14		 jb	 SHORT $LN474@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00773	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00776	83 c1 23	 add	 ecx, 35			; 00000023H
  00779	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0077b	83 c0 fc	 add	 eax, -4			; fffffffcH
  0077e	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00781	0f 87 a3 06 00
	00		 ja	 $LN329@LoadScript
$LN474@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00787	51		 push	 ecx
  00788	52		 push	 edx
  00789	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0078e	83 c4 08	 add	 esp, 8
$LN463@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00791	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strNodeName$5[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00798	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strNodeName$5[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0079f	c6 45 c0 00	 mov	 BYTE PTR _strNodeName$5[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h

; 54   : 			{

  007a3	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 239  : 				continue;

  007a7	e9 11 06 00 00	 jmp	 $LN1144@LoadScript
$LN28@LoadScript:

; 240  : 			TextFileLoader.GetTokenInteger("flytype",&fad.iFlyType);

  007ac	68 00 00 00 00	 push	 OFFSET ??_C@_07LKHMKNJJ@flytype@
  007b1	8d 4d d8	 lea	 ecx, DWORD PTR $T21[ebp]
  007b4	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  007b9	8d 45 80	 lea	 eax, DWORD PTR _fad$4[ebp+4]
  007bc	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
  007c0	50		 push	 eax
  007c1	8d 45 d8	 lea	 eax, DWORD PTR $T21[ebp]
  007c4	50		 push	 eax
  007c5	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  007cb	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  007d0	8b 4d ec	 mov	 ecx, DWORD PTR $T21[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 240  : 			TextFileLoader.GetTokenInteger("flytype",&fad.iFlyType);

  007d3	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  007d7	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  007da	76 2c		 jbe	 SHORT $LN383@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007dc	8b 55 d8	 mov	 edx, DWORD PTR $T21[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  007df	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  007e0	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  007e2	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  007e8	72 14		 jb	 SHORT $LN394@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  007ea	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  007ed	83 c1 23	 add	 ecx, 35			; 00000023H
  007f0	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  007f2	83 c0 fc	 add	 eax, -4			; fffffffcH
  007f5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  007f8	0f 87 2c 06 00
	00		 ja	 $LN329@LoadScript
$LN394@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  007fe	51		 push	 ecx
  007ff	52		 push	 edx
  00800	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00805	83 c4 08	 add	 esp, 8
$LN383@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 241  : 			if (!TextFileLoader.GetTokenString("attachfile",&fad.strFilename))

  00808	68 00 00 00 00	 push	 OFFSET ??_C@_0L@BMGMFMHI@attachfile@
  0080d	8d 4d d8	 lea	 ecx, DWORD PTR $T22[ebp]
  00810	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00815	8d 45 84	 lea	 eax, DWORD PTR _fad$4[ebp+8]
  00818	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  0081c	50		 push	 eax
  0081d	8d 45 d8	 lea	 eax, DWORD PTR $T22[ebp]
  00820	50		 push	 eax
  00821	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00827	e8 00 00 00 00	 call	 ?GetTokenString@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV23@@Z ; CTextFileLoader::GetTokenString
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0082c	8b 4d ec	 mov	 ecx, DWORD PTR $T22[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 241  : 			if (!TextFileLoader.GetTokenString("attachfile",&fad.strFilename))

  0082f	8b f0		 mov	 esi, eax
  00831	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00835	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00838	76 2c		 jbe	 SHORT $LN505@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0083a	8b 55 d8	 mov	 edx, DWORD PTR $T22[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0083d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0083e	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00840	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00846	72 14		 jb	 SHORT $LN516@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00848	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0084b	83 c1 23	 add	 ecx, 35			; 00000023H
  0084e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00850	83 c0 fc	 add	 eax, -4			; fffffffcH
  00853	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00856	0f 87 ce 05 00
	00		 ja	 $LN329@LoadScript
$LN516@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  0085c	51		 push	 ecx
  0085d	52		 push	 edx
  0085e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00863	83 c4 08	 add	 esp, 8
$LN505@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 241  : 			if (!TextFileLoader.GetTokenString("attachfile",&fad.strFilename))

  00866	85 f6		 test	 esi, esi
  00868	75 16		 jne	 SHORT $LN29@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0086a	83 7d 98 0f	 cmp	 DWORD PTR _fad$4[ebp+28], 15 ; 0000000fH

; 416  :         value_type* _Result = _Bx._Buf;

  0086e	8d 45 84	 lea	 eax, DWORD PTR _fad$4[ebp+8]

; 1597 :             _Mypair._Myval2._Mysize = _Count;

  00871	89 75 94	 mov	 DWORD PTR _fad$4[ebp+24], esi

; 417  :         if (_Large_mode_engaged()) {

  00874	0f 47 45 84	 cmova	 eax, DWORD PTR _fad$4[ebp+8]

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00878	c6 00 00	 mov	 BYTE PTR [eax], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 244  : 			}

  0087b	e9 0b 01 00 00	 jmp	 $LN31@LoadScript
$LN29@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2458 :         return _Mypair._Myval2._Mysize == 0;

  00880	83 7d 94 00	 cmp	 DWORD PTR _fad$4[ebp+24], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 245  : 			else if (!fad.strFilename.empty())

  00884	0f 84 01 01 00
	00		 je	 $LN31@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0088a	83 7d 98 0f	 cmp	 DWORD PTR _fad$4[ebp+28], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  0088e	8d 45 84	 lea	 eax, DWORD PTR _fad$4[ebp+8]

; 426  :         if (_Large_mode_engaged()) {

  00891	0f 47 45 84	 cmova	 eax, DWORD PTR _fad$4[ebp+8]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 247  : 				if (!IsGlobalFileName(fad.strFilename.c_str()))

  00895	50		 push	 eax
  00896	e8 00 00 00 00	 call	 ?IsGlobalFileName@@YA_NPBD@Z ; IsGlobalFileName
  0089b	83 c4 04	 add	 esp, 4
  0089e	84 c0		 test	 al, al
  008a0	0f 85 ca 00 00
	00		 jne	 $LN1109@LoadScript

; 248  : 					fad.strFilename = GetOnlyPathName(TextFileLoader.GetFileName()) + fad.strFilename;

  008a6	8d 45 84	 lea	 eax, DWORD PTR _fad$4[ebp+8]
  008a9	50		 push	 eax
  008aa	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  008b0	e8 00 00 00 00	 call	 ?GetFileName@CTextFileLoader@@QAEPBDXZ ; CTextFileLoader::GetFileName
  008b5	50		 push	 eax
  008b6	e8 00 00 00 00	 call	 ?GetOnlyPathName@@YAPBDPBD@Z ; GetOnlyPathName
  008bb	83 c4 04	 add	 esp, 4
  008be	50		 push	 eax
  008bf	8d 45 d8	 lea	 eax, DWORD PTR $T23[ebp]
  008c2	50		 push	 eax
  008c3	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  008c8	8b f0		 mov	 esi, eax
  008ca	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1202 :         if (this == _STD addressof(_Right)) {

  008cd	8d 45 84	 lea	 eax, DWORD PTR _fad$4[ebp+8]
  008d0	3b c6		 cmp	 eax, esi
  008d2	74 68		 je	 SHORT $LN1078@LoadScript

; 434  :         return _Myres > _Small_string_capacity;

  008d4	8b 4d 98	 mov	 ecx, DWORD PTR _fad$4[ebp+28]
  008d7	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  008da	76 2c		 jbe	 SHORT $LN1061@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008dc	8b 55 84	 mov	 edx, DWORD PTR _fad$4[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  008df	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  008e0	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  008e2	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  008e8	72 14		 jb	 SHORT $LN1072@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  008ea	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  008ed	83 c1 23	 add	 ecx, 35			; 00000023H
  008f0	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  008f2	83 c0 fc	 add	 eax, -4			; fffffffcH
  008f5	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  008f8	0f 87 2c 05 00
	00		 ja	 $LN329@LoadScript
$LN1072@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  008fe	51		 push	 ecx
  008ff	52		 push	 edx
  00900	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00905	83 c4 08	 add	 esp, 8
$LN1061@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00908	c7 45 94 00 00
	00 00		 mov	 DWORD PTR _fad$4[ebp+24], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  0090f	c7 45 98 0f 00
	00 00		 mov	 DWORD PTR _fad$4[ebp+28], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00916	c6 45 84 00	 mov	 BYTE PTR _fad$4[ebp+8], 0

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0091a	0f 10 06	 movups	 xmm0, XMMWORD PTR [esi]
  0091d	0f 11 45 84	 movups	 XMMWORD PTR _fad$4[ebp+8], xmm0
  00921	f3 0f 7e 46 10	 movq	 xmm0, QWORD PTR [esi+16]
  00926	66 0f d6 45 94	 movq	 QWORD PTR _fad$4[ebp+24], xmm0

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

  0092b	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  00932	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00939	c6 06 00	 mov	 BYTE PTR [esi], 0
$LN1078@LoadScript:

; 434  :         return _Myres > _Small_string_capacity;

  0093c	8b 4d ec	 mov	 ecx, DWORD PTR $T23[ebp+20]
  0093f	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00942	76 2c		 jbe	 SHORT $LN1109@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00944	8b 55 d8	 mov	 edx, DWORD PTR $T23[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00947	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00948	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0094a	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00950	72 14		 jb	 SHORT $LN1120@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00952	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00955	83 c1 23	 add	 ecx, 35			; 00000023H
  00958	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0095a	83 c0 fc	 add	 eax, -4			; fffffffcH
  0095d	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00960	0f 87 c4 04 00
	00		 ja	 $LN329@LoadScript
$LN1120@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00966	51		 push	 ecx
  00967	52		 push	 edx
  00968	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0096d	83 c4 08	 add	 esp, 8
$LN1109@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00970	83 7d 98 0f	 cmp	 DWORD PTR _fad$4[ebp+28], 15 ; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00974	8d 45 84	 lea	 eax, DWORD PTR _fad$4[ebp+8]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 249  : 				CEffectManager::Instance().RegisterEffect(fad.strFilename.c_str());

  00977	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 426  :         if (_Large_mode_engaged()) {

  0097d	0f 47 45 84	 cmova	 eax, DWORD PTR _fad$4[ebp+8]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 249  : 				CEffectManager::Instance().RegisterEffect(fad.strFilename.c_str());

  00981	6a 00		 push	 0
  00983	6a 00		 push	 0
  00985	50		 push	 eax
  00986	e8 00 00 00 00	 call	 ?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z ; CEffectManager::RegisterEffect
$LN31@LoadScript:

; 252  : 			TextFileLoader.GetTokenInteger("tailflag",&temp);

  0098b	68 00 00 00 00	 push	 OFFSET ??_C@_08MNMLIJJL@tailflag@
  00990	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  00993	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00998	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  0099e	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
  009a2	50		 push	 eax
  009a3	8d 45 d8	 lea	 eax, DWORD PTR $T24[ebp]
  009a6	50		 push	 eax
  009a7	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  009ad	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  009b2	8b 4d ec	 mov	 ecx, DWORD PTR $T24[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 252  : 			TextFileLoader.GetTokenInteger("tailflag",&temp);

  009b5	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  009b9	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  009bc	76 2c		 jbe	 SHORT $LN542@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009be	8b 55 d8	 mov	 edx, DWORD PTR $T24[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  009c1	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  009c2	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  009c4	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  009ca	72 14		 jb	 SHORT $LN553@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  009cc	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  009cf	83 c1 23	 add	 ecx, 35			; 00000023H
  009d2	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  009d4	83 c0 fc	 add	 eax, -4			; fffffffcH
  009d7	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  009da	0f 87 4a 04 00
	00		 ja	 $LN329@LoadScript
$LN553@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  009e0	51		 push	 ecx
  009e1	52		 push	 edx
  009e2	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  009e7	83 c4 08	 add	 esp, 8
$LN542@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 253  : 			if (temp)

  009ea	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _temp$[ebp], 0
  009f1	0f 84 84 01 00
	00		 je	 $LN33@LoadScript

; 256  : 				TextFileLoader.GetTokenDoubleWord("tailcolor",&fad.dwTailColor);

  009f7	68 00 00 00 00	 push	 OFFSET ??_C@_09JBANPIDH@tailcolor@
  009fc	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  009ff	c6 45 9c 01	 mov	 BYTE PTR _fad$4[ebp+32], 1
  00a03	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a08	8d 45 a0	 lea	 eax, DWORD PTR _fad$4[ebp+36]
  00a0b	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  00a0f	50		 push	 eax
  00a10	8d 45 d8	 lea	 eax, DWORD PTR $T25[ebp]
  00a13	50		 push	 eax
  00a14	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00a1a	e8 00 00 00 00	 call	 ?GetTokenDoubleWord@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAK@Z ; CTextFileLoader::GetTokenDoubleWord
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00a1f	8b 4d ec	 mov	 ecx, DWORD PTR $T25[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 256  : 				TextFileLoader.GetTokenDoubleWord("tailcolor",&fad.dwTailColor);

  00a22	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00a26	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00a29	76 2c		 jbe	 SHORT $LN787@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a2b	8b 55 d8	 mov	 edx, DWORD PTR $T25[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00a2e	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a2f	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00a31	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00a37	72 14		 jb	 SHORT $LN798@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a39	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00a3c	83 c1 23	 add	 ecx, 35			; 00000023H
  00a3f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a41	83 c0 fc	 add	 eax, -4			; fffffffcH
  00a44	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00a47	0f 87 dd 03 00
	00		 ja	 $LN329@LoadScript
$LN798@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00a4d	51		 push	 ecx
  00a4e	52		 push	 edx
  00a4f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00a54	83 c4 08	 add	 esp, 8
$LN787@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 257  : 				TextFileLoader.GetTokenFloat("taillength",&fad.fTailLength);

  00a57	68 00 00 00 00	 push	 OFFSET ??_C@_0L@PJCCBNOK@taillength@
  00a5c	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
  00a5f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00a64	8d 45 a4	 lea	 eax, DWORD PTR _fad$4[ebp+40]
  00a67	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  00a6b	50		 push	 eax
  00a6c	8d 45 d8	 lea	 eax, DWORD PTR $T26[ebp]
  00a6f	50		 push	 eax
  00a70	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00a76	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00a7b	8b 4d ec	 mov	 ecx, DWORD PTR $T26[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 257  : 				TextFileLoader.GetTokenFloat("taillength",&fad.fTailLength);

  00a7e	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00a82	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00a85	76 2c		 jbe	 SHORT $LN824@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a87	8b 55 d8	 mov	 edx, DWORD PTR $T26[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00a8a	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00a8b	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00a8d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00a93	72 14		 jb	 SHORT $LN835@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00a95	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00a98	83 c1 23	 add	 ecx, 35			; 00000023H
  00a9b	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00a9d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00aa0	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00aa3	0f 87 81 03 00
	00		 ja	 $LN329@LoadScript
$LN835@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00aa9	51		 push	 ecx
  00aaa	52		 push	 edx
  00aab	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00ab0	83 c4 08	 add	 esp, 8
$LN824@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 258  : 				TextFileLoader.GetTokenFloat("tailsize",&fad.fTailSize);

  00ab3	68 00 00 00 00	 push	 OFFSET ??_C@_08HAFAEPEI@tailsize@
  00ab8	8d 4d d8	 lea	 ecx, DWORD PTR $T32[ebp]
  00abb	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ac0	8d 45 a8	 lea	 eax, DWORD PTR _fad$4[ebp+44]
  00ac3	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  00ac7	50		 push	 eax
  00ac8	8d 45 d8	 lea	 eax, DWORD PTR $T32[ebp]
  00acb	50		 push	 eax
  00acc	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00ad2	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00ad7	8b 4d ec	 mov	 ecx, DWORD PTR $T32[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 258  : 				TextFileLoader.GetTokenFloat("tailsize",&fad.fTailSize);

  00ada	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00ade	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00ae1	76 2c		 jbe	 SHORT $LN861@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00ae3	8b 55 d8	 mov	 edx, DWORD PTR $T32[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00ae6	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00ae7	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00ae9	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00aef	72 14		 jb	 SHORT $LN872@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00af1	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00af4	83 c1 23	 add	 ecx, 35			; 00000023H
  00af7	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00af9	83 c0 fc	 add	 eax, -4			; fffffffcH
  00afc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00aff	0f 87 25 03 00
	00		 ja	 $LN329@LoadScript
$LN872@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00b05	51		 push	 ecx
  00b06	52		 push	 edx
  00b07	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b0c	83 c4 08	 add	 esp, 8
$LN861@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 259  : 				TextFileLoader.GetTokenInteger("tailshaperect",&temp);

  00b0f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@DNCKGFAO@tailshaperect@
  00b14	8d 4d d8	 lea	 ecx, DWORD PTR $T28[ebp]
  00b17	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b1c	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  00b22	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  00b26	50		 push	 eax
  00b27	8d 45 d8	 lea	 eax, DWORD PTR $T28[ebp]
  00b2a	50		 push	 eax
  00b2b	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00b31	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00b36	8b 4d ec	 mov	 ecx, DWORD PTR $T28[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 259  : 				TextFileLoader.GetTokenInteger("tailshaperect",&temp);

  00b39	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00b3d	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00b40	76 2c		 jbe	 SHORT $LN898@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b42	8b 55 d8	 mov	 edx, DWORD PTR $T28[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00b45	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00b46	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00b48	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00b4e	72 14		 jb	 SHORT $LN909@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00b50	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00b53	83 c1 23	 add	 ecx, 35			; 00000023H
  00b56	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00b58	83 c0 fc	 add	 eax, -4			; fffffffcH
  00b5b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00b5e	0f 87 c6 02 00
	00		 ja	 $LN329@LoadScript
$LN909@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00b64	51		 push	 ecx
  00b65	52		 push	 edx
  00b66	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00b6b	83 c4 08	 add	 esp, 8
$LN898@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 260  : 				fad.bRectShape = temp?true:false;

  00b6e	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR _temp$[ebp], 0
  00b75	0f 95 45 ac	 setne	 BYTE PTR _fad$4[ebp+48]

; 261  : 			}

  00b79	eb 04		 jmp	 SHORT $LN34@LoadScript
$LN33@LoadScript:

; 262  : 			else
; 263  : 			{
; 264  : 				fad.bHasTail = false;

  00b7b	c6 45 9c 00	 mov	 BYTE PTR _fad$4[ebp+32], 0
$LN34@LoadScript:

; 267  : 			TextFileLoader.GetTokenFloat("roll",&fad.fRoll);

  00b7f	68 00 00 00 00	 push	 OFFSET ??_C@_04FBAPEKPH@roll@
  00b84	8d 4d d8	 lea	 ecx, DWORD PTR $T29[ebp]
  00b87	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00b8c	8d 45 b0	 lea	 eax, DWORD PTR _fad$4[ebp+52]
  00b8f	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  00b93	50		 push	 eax
  00b94	8d 45 d8	 lea	 eax, DWORD PTR $T29[ebp]
  00b97	50		 push	 eax
  00b98	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00b9e	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00ba3	8b 4d ec	 mov	 ecx, DWORD PTR $T29[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 267  : 			TextFileLoader.GetTokenFloat("roll",&fad.fRoll);

  00ba6	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00baa	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00bad	76 2c		 jbe	 SHORT $LN740@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00baf	8b 55 d8	 mov	 edx, DWORD PTR $T29[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00bb2	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00bb3	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00bb5	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00bbb	72 14		 jb	 SHORT $LN751@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00bbd	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00bc0	83 c1 23	 add	 ecx, 35			; 00000023H
  00bc3	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00bc5	83 c0 fc	 add	 eax, -4			; fffffffcH
  00bc8	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00bcb	0f 87 59 02 00
	00		 ja	 $LN329@LoadScript
$LN751@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00bd1	51		 push	 ecx
  00bd2	52		 push	 edx
  00bd3	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00bd8	83 c4 08	 add	 esp, 8
$LN740@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 268  : 			TextFileLoader.GetTokenFloat("distance",&fad.fDistance);

  00bdb	68 00 00 00 00	 push	 OFFSET ??_C@_08LHFODBFO@distance@
  00be0	8d 4d d8	 lea	 ecx, DWORD PTR $T30[ebp]
  00be3	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00be8	8d 45 b4	 lea	 eax, DWORD PTR _fad$4[ebp+56]
  00beb	c6 45 fc 1f	 mov	 BYTE PTR __$EHRec$[ebp+8], 31 ; 0000001fH
  00bef	50		 push	 eax
  00bf0	8d 45 d8	 lea	 eax, DWORD PTR $T30[ebp]
  00bf3	50		 push	 eax
  00bf4	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00bfa	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00bff	8b 4d ec	 mov	 ecx, DWORD PTR $T30[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 268  : 			TextFileLoader.GetTokenFloat("distance",&fad.fDistance);

  00c02	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00c06	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00c09	76 2c		 jbe	 SHORT $LN579@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00c0b	8b 55 d8	 mov	 edx, DWORD PTR $T30[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00c0e	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00c0f	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00c11	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00c17	72 14		 jb	 SHORT $LN590@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00c19	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00c1c	83 c1 23	 add	 ecx, 35			; 00000023H
  00c1f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00c21	83 c0 fc	 add	 eax, -4			; fffffffcH
  00c24	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00c27	0f 87 fd 01 00
	00		 ja	 $LN329@LoadScript
$LN590@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00c2d	51		 push	 ecx
  00c2e	52		 push	 edx
  00c2f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00c34	83 c4 08	 add	 esp, 8
$LN579@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 269  : 			TextFileLoader.GetTokenFloat("period",&fad.fPeriod);

  00c37	68 00 00 00 00	 push	 OFFSET ??_C@_06FBOEEHNL@period@
  00c3c	8d 4d d8	 lea	 ecx, DWORD PTR $T31[ebp]
  00c3f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00c44	8d 45 b8	 lea	 eax, DWORD PTR _fad$4[ebp+60]
  00c47	c6 45 fc 20	 mov	 BYTE PTR __$EHRec$[ebp+8], 32 ; 00000020H
  00c4b	50		 push	 eax
  00c4c	8d 45 d8	 lea	 eax, DWORD PTR $T31[ebp]
  00c4f	50		 push	 eax
  00c50	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00c56	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00c5b	8b 4d ec	 mov	 ecx, DWORD PTR $T31[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 269  : 			TextFileLoader.GetTokenFloat("period",&fad.fPeriod);

  00c5e	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00c62	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00c65	76 2c		 jbe	 SHORT $LN616@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00c67	8b 55 d8	 mov	 edx, DWORD PTR $T31[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00c6a	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00c6b	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00c6d	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00c73	72 14		 jb	 SHORT $LN627@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00c75	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00c78	83 c1 23	 add	 ecx, 35			; 00000023H
  00c7b	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00c7d	83 c0 fc	 add	 eax, -4			; fffffffcH
  00c80	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00c83	0f 87 a1 01 00
	00		 ja	 $LN329@LoadScript
$LN627@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00c89	51		 push	 ecx
  00c8a	52		 push	 edx
  00c8b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00c90	83 c4 08	 add	 esp, 8
$LN616@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 270  : 			TextFileLoader.GetTokenFloat("amplitude",&fad.fAmplitude);

  00c93	68 00 00 00 00	 push	 OFFSET ??_C@_09EHCGJNBI@amplitude@
  00c98	8d 4d d8	 lea	 ecx, DWORD PTR $T36[ebp]
  00c9b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00ca0	8d 45 bc	 lea	 eax, DWORD PTR _fad$4[ebp+64]
  00ca3	c6 45 fc 21	 mov	 BYTE PTR __$EHRec$[ebp+8], 33 ; 00000021H
  00ca7	50		 push	 eax
  00ca8	8d 45 d8	 lea	 eax, DWORD PTR $T36[ebp]
  00cab	50		 push	 eax
  00cac	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00cb2	e8 00 00 00 00	 call	 ?GetTokenFloat@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAM@Z ; CTextFileLoader::GetTokenFloat
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00cb7	8b 4d ec	 mov	 ecx, DWORD PTR $T36[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 270  : 			TextFileLoader.GetTokenFloat("amplitude",&fad.fAmplitude);

  00cba	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00cbe	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00cc1	76 2c		 jbe	 SHORT $LN653@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00cc3	8b 55 d8	 mov	 edx, DWORD PTR $T36[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00cc6	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00cc7	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00cc9	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00ccf	72 14		 jb	 SHORT $LN664@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00cd1	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00cd4	83 c1 23	 add	 ecx, 35			; 00000023H
  00cd7	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00cd9	83 c0 fc	 add	 eax, -4			; fffffffcH
  00cdc	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00cdf	0f 87 45 01 00
	00		 ja	 $LN329@LoadScript
$LN664@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00ce5	51		 push	 ecx
  00ce6	52		 push	 edx
  00ce7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00cec	83 c4 08	 add	 esp, 8
$LN653@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00cef	8b 87 88 00 00
	00		 mov	 eax, DWORD PTR [edi+136]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 272  : 			m_AttachDataVector.push_back(fad);

  00cf5	8d b7 84 00 00
	00		 lea	 esi, DWORD PTR [edi+132]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 829  :         if (_Mylast != _My_data._Myend) {

  00cfb	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _fad$4[ebp]
  00d01	51		 push	 ecx
  00d02	50		 push	 eax
  00d03	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  00d06	74 0f		 je	 SHORT $LN673@LoadScript

; 848  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00d08	56		 push	 esi
  00d09	e8 00 00 00 00	 call	 ??$construct@UTFlyingAttachData@CFlyingData@@ABU12@@?$_Default_allocator_traits@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@SAXAAV?$allocator@UTFlyingAttachData@CFlyingData@@@1@QAUTFlyingAttachData@CFlyingData@@ABU34@@Z ; std::_Default_allocator_traits<std::allocator<CFlyingData::TFlyingAttachData> >::construct<CFlyingData::TFlyingAttachData,CFlyingData::TFlyingAttachData const &>
  00d0e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 849  :             _ASAN_VECTOR_RELEASE_GUARD;
; 850  :         }
; 851  : 
; 852  :         _Orphan_range(_Mylast, _Mylast);
; 853  :         _Ty& _Result = *_Mylast;
; 854  :         ++_Mylast;

  00d11	83 46 04 44	 add	 DWORD PTR [esi+4], 68	; 00000044H

; 830  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00d15	eb 07		 jmp	 SHORT $LN672@LoadScript
$LN673@LoadScript:

; 831  :         }
; 832  : 
; 833  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00d17	8b ce		 mov	 ecx, esi
  00d19	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUTFlyingAttachData@CFlyingData@@@?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@AAEPAUTFlyingAttachData@CFlyingData@@QAU23@ABU23@@Z ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::_Emplace_reallocate<CFlyingData::TFlyingAttachData const &>
$LN672@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00d1e	8b 4d 98	 mov	 ecx, DWORD PTR _fad$4[ebp+28]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 273  : 		}

  00d21	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00d25	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00d28	76 45		 jbe	 SHORT $LN27@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d2a	8b 55 84	 mov	 edx, DWORD PTR _fad$4[ebp+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00d2d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d2e	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00d30	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00d36	72 14		 jb	 SHORT $LN713@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00d38	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00d3b	83 c1 23	 add	 ecx, 35			; 00000023H
  00d3e	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00d40	83 c0 fc	 add	 eax, -4			; fffffffcH
  00d43	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00d46	0f 87 de 00 00
	00		 ja	 $LN329@LoadScript
$LN713@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00d4c	51		 push	 ecx
  00d4d	52		 push	 edx
  00d4e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 273  : 		}

  00d53	eb 17		 jmp	 SHORT $LN1145@LoadScript
$LN26@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00d55	83 7f 18 0f	 cmp	 DWORD PTR [edi+24], 15	; 0000000fH

; 425  :         const value_type* _Result = _Bx._Buf;

  00d59	8d 47 04	 lea	 eax, DWORD PTR [edi+4]

; 426  :         if (_Large_mode_engaged()) {

  00d5c	76 03		 jbe	 SHORT $LN295@LoadScript

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  00d5e	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
$LN295@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 276  : 			TraceError("CFlyingData::LoadScriptFile Wrong Data : %s", m_strFilename.c_str());

  00d61	50		 push	 eax
  00d62	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@NJMDEMJE@CFlyingData?3?3LoadScriptFile?5Wro@
  00d67	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
$LN1145@LoadScript:

; 278  : 	}

  00d6c	83 c4 08	 add	 esp, 8
$LN27@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00d6f	8b 4d d4	 mov	 ecx, DWORD PTR _strNodeName$5[ebp+20]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 278  : 	}

  00d72	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00d76	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00d79	76 2c		 jbe	 SHORT $LN269@LoadScript
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d7b	8b 55 c0	 mov	 edx, DWORD PTR _strNodeName$5[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00d7e	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00d7f	8b c2		 mov	 eax, edx

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00d81	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00d87	72 14		 jb	 SHORT $LN280@LoadScript

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00d89	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00d8c	83 c1 23	 add	 ecx, 35			; 00000023H
  00d8f	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00d91	83 c0 fc	 add	 eax, -4			; fffffffcH
  00d94	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00d97	0f 87 8d 00 00
	00		 ja	 $LN329@LoadScript
$LN280@LoadScript:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00d9d	51		 push	 ecx
  00d9e	52		 push	 edx
  00d9f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00da4	83 c4 08	 add	 esp, 8
$LN269@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00da7	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _strNodeName$5[ebp+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00dae	c7 45 d4 0f 00
	00 00		 mov	 DWORD PTR _strNodeName$5[ebp+20], 15 ; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00db5	c6 45 c0 00	 mov	 BYTE PTR _strNodeName$5[ebp], 0
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h

; 54   : 			{

  00db9	c6 45 fc 22	 mov	 BYTE PTR __$EHRec$[ebp+8], 34 ; 00000022H
$LN1144@LoadScript:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 226  : 	for(i=0;i<TextFileLoader.GetChildNodeCount();i++)

  00dbd	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00dc3	e8 00 00 00 00	 call	 ?SetParentNode@CTextFileLoader@@QAEHXZ ; CTextFileLoader::SetParentNode
  00dc8	8b b5 f0 fe ff
	ff		 mov	 esi, DWORD PTR _i$1$[ebp]
  00dce	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00dd4	46		 inc	 esi
  00dd5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00dd9	89 b5 f0 fe ff
	ff		 mov	 DWORD PTR _i$1$[ebp], esi
  00ddf	e8 00 00 00 00	 call	 ?GetChildNodeCount@CTextFileLoader@@QAEKXZ ; CTextFileLoader::GetChildNodeCount
  00de4	3b f0		 cmp	 esi, eax
  00de6	0f 82 e4 f7 ff
	ff		 jb	 $LL4@LoadScript
$LN1129@LoadScript:

; 279  : 
; 280  : 	return true;

  00dec	c6 85 f7 fe ff
	ff 01		 mov	 BYTE PTR $T3[ebp], 1
  00df3	eb 07		 jmp	 SHORT $LN73@LoadScript
$LN72@LoadScript:
  00df5	c6 85 f7 fe ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
$LN73@LoadScript:
  00dfc	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00e02	e8 00 00 00 00	 call	 ??1CTextFileLoader@@UAE@XZ ; CTextFileLoader::~CTextFileLoader
  00e07	8a 85 f7 fe ff
	ff		 mov	 al, BYTE PTR $T3[ebp]

; 281  : }

  00e0d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00e10	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00e17	59		 pop	 ecx
  00e18	5f		 pop	 edi
  00e19	5e		 pop	 esi
  00e1a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00e1d	33 cd		 xor	 ecx, ebp
  00e1f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00e24	8b e5		 mov	 esp, ebp
  00e26	5d		 pop	 ebp
  00e27	c2 04 00	 ret	 4
$LN329@LoadScript:
  00e2a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1147@LoadScript:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00e2f	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1148@LoadScript:
  00e34	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN1143@LoadScript:
  00e39	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$0:
  00000	8d 8d fc fe ff
	ff		 lea	 ecx, DWORD PTR _TextFileLoader$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CTextFileLoader@@UAE@XZ ; CTextFileLoader::~CTextFileLoader
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$1:
  0000b	8d 4d d8	 lea	 ecx, DWORD PTR $T27[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$2:
  00013	8d 4d d8	 lea	 ecx, DWORD PTR $T19[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$3:
  0001b	8d 4d d8	 lea	 ecx, DWORD PTR $T34[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$4:
  00023	8d 4d d8	 lea	 ecx, DWORD PTR $T35[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$5:
  0002b	8d 4d d8	 lea	 ecx, DWORD PTR $T6[ebp]
  0002e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$6:
  00033	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  00036	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$7:
  0003b	8d 4d d8	 lea	 ecx, DWORD PTR $T33[ebp]
  0003e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$8:
  00043	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  00046	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$9:
  0004b	8d 4d d8	 lea	 ecx, DWORD PTR $T9[ebp]
  0004e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$10:
  00053	8d 4d d8	 lea	 ecx, DWORD PTR $T10[ebp]
  00056	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$11:
  0005b	8d 4d d8	 lea	 ecx, DWORD PTR $T11[ebp]
  0005e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$12:
  00063	8d 4d d8	 lea	 ecx, DWORD PTR $T12[ebp]
  00066	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$14:
  0006b	8d 4d d8	 lea	 ecx, DWORD PTR $T14[ebp]
  0006e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$15:
  00073	8d 4d d8	 lea	 ecx, DWORD PTR $T15[ebp]
  00076	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$16:
  0007b	8d 4d d8	 lea	 ecx, DWORD PTR $T16[ebp]
  0007e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$17:
  00083	8d 4d d8	 lea	 ecx, DWORD PTR $T17[ebp]
  00086	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$18:
  0008b	8d 4d d8	 lea	 ecx, DWORD PTR $T18[ebp]
  0008e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$19:
  00093	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR _GotoChild$2[ebp]
  00099	e9 00 00 00 00	 jmp	 ??1CGotoChild@CTextFileLoader@@QAE@XZ ; CTextFileLoader::CGotoChild::~CGotoChild
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$20:
  0009e	8d 4d c0	 lea	 ecx, DWORD PTR _strNodeName$5[ebp]
  000a1	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$21:
  000a6	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _fad$4[ebp]
  000ac	e9 00 00 00 00	 jmp	 ??1TFlyingAttachData@CFlyingData@@QAE@XZ
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$22:
  000b1	8d 4d d8	 lea	 ecx, DWORD PTR $T20[ebp]
  000b4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$23:
  000b9	8d 4d d8	 lea	 ecx, DWORD PTR $T21[ebp]
  000bc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$24:
  000c1	8d 4d d8	 lea	 ecx, DWORD PTR $T22[ebp]
  000c4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$26:
  000c9	8d 4d d8	 lea	 ecx, DWORD PTR $T24[ebp]
  000cc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$27:
  000d1	8d 4d d8	 lea	 ecx, DWORD PTR $T25[ebp]
  000d4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$28:
  000d9	8d 4d d8	 lea	 ecx, DWORD PTR $T26[ebp]
  000dc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$29:
  000e1	8d 4d d8	 lea	 ecx, DWORD PTR $T32[ebp]
  000e4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$30:
  000e9	8d 4d d8	 lea	 ecx, DWORD PTR $T28[ebp]
  000ec	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$31:
  000f1	8d 4d d8	 lea	 ecx, DWORD PTR $T29[ebp]
  000f4	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$32:
  000f9	8d 4d d8	 lea	 ecx, DWORD PTR $T30[ebp]
  000fc	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$33:
  00101	8d 4d d8	 lea	 ecx, DWORD PTR $T31[ebp]
  00104	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z$34:
  00109	8d 4d d8	 lea	 ecx, DWORD PTR $T36[ebp]
  0010c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00111	cc		 int	 3
  00112	cc		 int	 3
  00113	cc		 int	 3
  00114	cc		 int	 3
  00115	cc		 int	 3
__ehhandler$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z:
  00116	90		 npad	 1
  00117	90		 npad	 1
  00118	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0011c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0011f	8b 8a e8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-280]
  00125	33 c8		 xor	 ecx, eax
  00127	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0012f	33 c8		 xor	 ecx, eax
  00131	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00136	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadScriptFile@CFlyingData@@QAE_NPBD@Z
  0013b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadScriptFile@CFlyingData@@QAE_NPBD@Z ENDP		; CFlyingData::LoadScriptFile
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?Destroy@CFlyingData@@QAEXXZ
_TEXT	SEGMENT
?Destroy@CFlyingData@@QAEXXZ PROC			; CFlyingData::Destroy, COMDAT
; _this$ = ecx

; 38   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00004	8b 8f 88 00 00
	00		 mov	 ecx, DWORD PTR [edi+136]
  0000a	8b 87 84 00 00
	00		 mov	 eax, DWORD PTR [edi+132]
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 39   : 	m_AttachDataVector.clear();

  00010	8d b7 84 00 00
	00		 lea	 esi, DWORD PTR [edi+132]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 1797 :         if (_Myfirst == _Mylast) { // already empty, nothing to do

  00016	3b c1		 cmp	 eax, ecx
  00018	74 10		 je	 SHORT $LN3@Destroy

; 1798 :             // This is an optimization for debug mode: we can avoid taking the debug lock to invalidate iterators.
; 1799 :             // Note that when clearing an empty vector, this will preserve past-the-end iterators, which is allowed by
; 1800 :             // N4950 [sequence.reqmts]/54 "a.clear() [...] may invalidate the past-the-end iterator".
; 1801 :             return;
; 1802 :         }
; 1803 : 
; 1804 :         _My_data._Orphan_all();
; 1805 :         _Destroy_range(_Myfirst, _Mylast, _Getal());

  0001a	56		 push	 esi
  0001b	51		 push	 ecx
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@YAXPAUTFlyingAttachData@CFlyingData@@QAU12@AAV?$allocator@UTFlyingAttachData@CFlyingData@@@0@@Z ; std::_Destroy_range<std::allocator<CFlyingData::TFlyingAttachData> >

; 1806 :         _ASAN_VECTOR_MODIFY(static_cast<difference_type>(_Myfirst - _Mylast)); // negative when destroying elements
; 1807 :         _Mylast = _Myfirst;

  00022	8b 06		 mov	 eax, DWORD PTR [esi]
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN3@Destroy:
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 41   : 	__Initialize();

  0002a	8b cf		 mov	 ecx, edi
  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	e9 00 00 00 00	 jmp	 ?__Initialize@CFlyingData@@IAEXXZ ; CFlyingData::__Initialize
?Destroy@CFlyingData@@QAEXXZ ENDP			; CFlyingData::Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ??1CFlyingData@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CFlyingData@@UAE@XZ PROC				; CFlyingData::~CFlyingData, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CFlyingData@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	8b f1		 mov	 esi, ecx
  00025	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CFlyingData@@6B@

; 46   : 	Destroy();

  0002b	e8 00 00 00 00	 call	 ?Destroy@CFlyingData@@QAEXXZ ; CFlyingData::Destroy

; 47   : }

  00030	8d 8e 84 00 00
	00		 lea	 ecx, DWORD PTR [esi+132]
  00036	e8 00 00 00 00	 call	 ??1?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::~vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  0003b	8b 4e 54	 mov	 ecx, DWORD PTR [esi+84]
  0003e	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00041	76 28		 jbe	 SHORT $LN24@CFlyingDat
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00043	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00046	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00047	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0004d	72 12		 jb	 SHORT $LN35@CFlyingDat

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0004f	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00052	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00055	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00057	83 c0 fc	 add	 eax, -4			; fffffffcH
  0005a	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0005d	77 70		 ja	 SHORT $LN70@CFlyingDat

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0005f	8b c2		 mov	 eax, edx
$LN35@CFlyingDat:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00061	51		 push	 ecx
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00068	83 c4 08	 add	 esp, 8
$LN24@CFlyingDat:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  0006b	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00072	c7 46 54 0f 00
	00 00		 mov	 DWORD PTR [esi+84], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00079	c6 46 40 00	 mov	 BYTE PTR [esi+64], 0

; 434  :         return _Myres > _Small_string_capacity;

  0007d	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00080	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00083	76 28		 jbe	 SHORT $LN62@CFlyingDat
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00085	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00088	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  00089	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0008f	72 12		 jb	 SHORT $LN73@CFlyingDat

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00091	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00094	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00097	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00099	83 c0 fc	 add	 eax, -4			; fffffffcH
  0009c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0009f	77 2e		 ja	 SHORT $LN70@CFlyingDat

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000a1	8b c2		 mov	 eax, edx
$LN73@CFlyingDat:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000a3	51		 push	 ecx
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000aa	83 c4 08	 add	 esp, 8
$LN62@CFlyingDat:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  000ad	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  000b4	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000bb	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 47   : }

  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c9	59		 pop	 ecx
  000ca	5e		 pop	 esi
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
$LN70@CFlyingDat:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000cf	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN80@CFlyingDat:
  000d4	cc		 int	 3
  000d5	cc		 int	 3
  000d6	cc		 int	 3
  000d7	cc		 int	 3
  000d8	cc		 int	 3
  000d9	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CFlyingData@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CFlyingData@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CFlyingData@@UAE@XZ ENDP				; CFlyingData::~CFlyingData
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ??0CFlyingData@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CFlyingData@@QAE@XZ PROC				; CFlyingData::CFlyingData, COMDAT
; _this$ = ecx

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CFlyingData@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f1		 mov	 esi, ecx
  00026	89 75 f0	 mov	 DWORD PTR _this$[ebp], esi
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CFlyingData@@6B@
  0002f	0f 57 c0	 xorps	 xmm0, xmm0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00032	0f 11 46 04	 movups	 XMMWORD PTR [esi+4], xmm0

; 836  :         _My_data._Mysize = 0;

  00036	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  0003d	c7 46 18 0f 00
	00 00		 mov	 DWORD PTR [esi+24], 15	; 0000000fH

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00044	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00048	0f 11 46 40	 movups	 XMMWORD PTR [esi+64], xmm0

; 836  :         _My_data._Mysize = 0;

  0004c	c7 46 50 00 00
	00 00		 mov	 DWORD PTR [esi+80], 0

; 837  :         _My_data._Myres  = _Small_string_capacity;

  00053	c7 46 54 0f 00
	00 00		 mov	 DWORD PTR [esi+84], 15	; 0000000fH
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 9    : {

  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 841  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00061	c6 46 40 00	 mov	 BYTE PTR [esi+64], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vector

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00065	c7 86 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+132], 0
  0006f	c7 86 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+136], 0
  00079	c7 86 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+140], 0
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp

; 9    : {

  00083	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 10   : 	__Initialize();

  00087	e8 00 00 00 00	 call	 ?__Initialize@CFlyingData@@IAEXXZ ; CFlyingData::__Initialize

; 11   : }

  0008c	8b c6		 mov	 eax, esi
  0008e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00091	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00098	59		 pop	 ecx
  00099	5e		 pop	 esi
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CFlyingData@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CFlyingData@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 40	 add	 ecx, 64			; 00000040H
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CFlyingData@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0001f	e9 00 00 00 00	 jmp	 ??1?$vector@UTFlyingAttachData@CFlyingData@@V?$allocator@UTFlyingAttachData@CFlyingData@@@std@@@std@@QAE@XZ ; std::vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >::~vector<CFlyingData::TFlyingAttachData,std::allocator<CFlyingData::TFlyingAttachData> >
  00024	cc		 int	 3
  00025	cc		 int	 3
  00026	cc		 int	 3
  00027	cc		 int	 3
  00028	cc		 int	 3
__ehhandler$??0CFlyingData@@QAE@XZ:
  00029	90		 npad	 1
  0002a	90		 npad	 1
  0002b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00032	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00035	33 c8		 xor	 ecx, eax
  00037	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CFlyingData@@QAE@XZ
  00041	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CFlyingData@@QAE@XZ ENDP				; CFlyingData::CFlyingData
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??1TFlyingAttachData@CFlyingData@@QAE@XZ
_TEXT	SEGMENT
??1TFlyingAttachData@CFlyingData@@QAE@XZ PROC		; CFlyingData::TFlyingAttachData::~TFlyingAttachData, COMDAT
; _this$ = ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 434  :         return _Myres > _Small_string_capacity;

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 28		 jbe	 SHORT $LN24@TFlyingAtt
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000e	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00015	72 12		 jb	 SHORT $LN35@TFlyingAtt

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00017	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001a	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001d	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00022	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00025	77 20		 ja	 SHORT $LN32@TFlyingAtt

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00027	8b c2		 mov	 eax, edx
$LN35@TFlyingAtt:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	83 c4 08	 add	 esp, 8
$LN24@TFlyingAtt:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00033	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  0003a	c7 46 1c 0f 00
	00 00		 mov	 DWORD PTR [esi+28], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00041	c6 46 08 00	 mov	 BYTE PTR [esi+8], 0
  00045	5e		 pop	 esi
  00046	c3		 ret	 0
$LN32@TFlyingAtt:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00047	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN45@TFlyingAtt:
  0004c	cc		 int	 3
??1TFlyingAttachData@CFlyingData@@QAE@XZ ENDP		; CFlyingData::TFlyingAttachData::~TFlyingAttachData
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 182  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 183  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 184  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 185  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 136  :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 186  :         _Throw_bad_array_new_length(); // add overflow
; 187  :     }
; 188  : 
; 189  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 136  :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 191  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 192  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 193  : 
; 194  : #ifdef _DEBUG
; 195  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 196  : #endif // defined(_DEBUG)
; 197  :     return _Ptr;
; 198  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 190  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\eterLib\TextFileLoader.h
;	COMDAT ??1CGotoChild@CTextFileLoader@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CGotoChild@CTextFileLoader@@QAE@XZ PROC		; CTextFileLoader::CGotoChild::~CGotoChild, COMDAT
; _this$ = ecx

; 54   : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGotoChild@CTextFileLoader@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 55   : 				m_pOwner->SetParentNode();

  00022	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00024	e8 00 00 00 00	 call	 ?SetParentNode@CTextFileLoader@@QAEHXZ ; CTextFileLoader::SetParentNode

; 56   : 			}

  00029	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0002c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00033	59		 pop	 ecx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
  00038	cc		 int	 3
  00039	cc		 int	 3
  0003a	cc		 int	 3
  0003b	cc		 int	 3
  0003c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CGotoChild@CTextFileLoader@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGotoChild@CTextFileLoader@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGotoChild@CTextFileLoader@@QAE@XZ ENDP		; CTextFileLoader::CGotoChild::~CGotoChild
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3044 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3045 :         auto& _My_data = _Mypair._Myval2;
; 3046 :         _My_data._Orphan_all();
; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 27		 jbe	 SHORT $LN16@Tidy_deall
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN27@Tidy_deall

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN24@Tidy_deall

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN27@Tidy_deall:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN16@Tidy_deall:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 3058 :     }

  00044	c3		 ret	 0
$LN24@Tidy_deall:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN35@Tidy_deall:
  0004a	cc		 int	 3
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
$T1 = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1592 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 1593 :         // assign [_Ptr, _Ptr + _Count)
; 1594 :         if (_Count <= _Mypair._Myval2._Myres) {

  00005	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  00008	56		 push	 esi
  00009	8b f1		 mov	 esi, ecx
  0000b	57		 push	 edi
  0000c	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  0000f	89 4d fc	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00012	3b d9		 cmp	 ebx, ecx
  00014	77 28		 ja	 SHORT $LN2@assign

; 416  :         value_type* _Result = _Bx._Buf;

  00016	8b fe		 mov	 edi, esi

; 434  :         return _Myres > _Small_string_capacity;

  00018	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 417  :         if (_Large_mode_engaged()) {

  0001b	76 02		 jbe	 SHORT $LN5@assign

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  0001d	8b 3e		 mov	 edi, DWORD PTR [esi]
$LN5@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0001f	53		 push	 ebx
  00020	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1597 :             _Mypair._Myval2._Mysize = _Count;

  00023	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 148  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00026	57		 push	 edi
  00027	e8 00 00 00 00	 call	 _memmove
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1599 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0002f	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 1609 :             },
; 1610 :             _Ptr);
; 1611 :     }

  00033	8b c6		 mov	 eax, esi
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 08 00	 ret	 8
$LN2@assign:

; 2962 :         if (_New_size > max_size()) {

  0003e	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00044	0f 87 c7 00 00
	00		 ja	 $LN87@assign

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  0004a	8b fb		 mov	 edi, ebx
  0004c	83 cf 0f	 or	 edi, 15			; 0000000fH
  0004f	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00055	76 12		 jbe	 SHORT $LN23@assign

; 2944 :             return _Max;

  00057	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0005c	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00061	50		 push	 eax
  00062	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00067	eb 45		 jmp	 SHORT $LN85@assign
$LN23@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2947 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00069	8b d1		 mov	 edx, ecx
  0006b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00070	d1 ea		 shr	 edx, 1
  00072	2b c2		 sub	 eax, edx
  00074	3b c8		 cmp	 ecx, eax
  00076	76 12		 jbe	 SHORT $LN24@assign

; 2948 :             return _Max;

  00078	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0007d	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00088	eb 24		 jmp	 SHORT $LN85@assign
$LN24@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0008a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
  0008d	3b f8		 cmp	 edi, eax
  0008f	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  00092	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  00095	85 c0		 test	 eax, eax
  00097	74 18		 je	 SHORT $LN84@assign
$LN37@assign:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00099	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0009e	72 08		 jb	 SHORT $LN38@assign

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a6	eb 06		 jmp	 SHORT $LN85@assign
$LN38@assign:

; 136  :         return ::operator new(_Bytes);

  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN85@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000ae	83 c4 04	 add	 esp, 4
$LN84@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b1	53		 push	 ebx
  000b2	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000b5	89 45 0c	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b8	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2973 :         _Mypair._Myval2._Mysize = _New_size;

  000b9	89 5e 10	 mov	 DWORD PTR [esi+16], ebx

; 2974 :         _Mypair._Myval2._Myres  = _New_capacity;

  000bc	89 7e 14	 mov	 DWORD PTR [esi+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bf	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000c4	8b 7d 0c	 mov	 edi, DWORD PTR $T1[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  000ca	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 1608 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000cd	c6 04 1f 00	 mov	 BYTE PTR [edi+ebx], 0

; 2976 :         if (_Old_capacity > _Small_string_capacity) {

  000d1	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  000d4	76 29		 jbe	 SHORT $LN16@assign

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  000d6	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d9	8b 06		 mov	 eax, DWORD PTR [esi]

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  000db	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000e1	72 12		 jb	 SHORT $LN66@assign

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000e3	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000e6	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000e9	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000eb	83 c0 fc	 add	 eax, -4			; fffffffcH
  000ee	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000f1	77 19		 ja	 SHORT $LN63@assign

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  000f3	8b c2		 mov	 eax, edx
$LN66@assign:

; 289  :         ::operator delete(_Ptr, _Bytes);

  000f5	51		 push	 ecx
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000fc	83 c4 08	 add	 esp, 8
$LN16@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 1604 :         return _Reallocate_for(

  000ff	89 3e		 mov	 DWORD PTR [esi], edi

; 1609 :             },
; 1610 :             _Ptr);
; 1611 :     }

  00101	8b c6		 mov	 eax, esi
  00103	5f		 pop	 edi
  00104	5e		 pop	 esi
  00105	5b		 pop	 ebx
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 08 00	 ret	 8
$LN63@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0010c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN87@assign:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2963 :             _Xlen_string(); // result too long

  00111	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN82@assign:
  00116	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1358 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 434  :         return _Myres > _Small_string_capacity;

  00003	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00006	83 f9 0f	 cmp	 ecx, 15			; 0000000fH

; 3047 :         if (_My_data._Large_mode_engaged()) {

  00009	76 27		 jbe	 SHORT $LN19@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 981  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8b 06		 mov	 eax, DWORD PTR [esi]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 828  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  0000d	41		 inc	 ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 284  :         if (_Bytes >= _Big_allocation_threshold) {

  0000e	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00014	72 12		 jb	 SHORT $LN30@basic_stri

; 205  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00016	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  00019	83 c1 23	 add	 ecx, 35			; 00000023H

; 206  : 
; 207  :     // If the following asserts, it likely means that we are performing
; 208  :     // an aligned delete on memory coming from an unaligned allocation.
; 209  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 210  : 
; 211  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 212  :     // in range [_Min_back_shift, _Non_user_size]
; 213  : #ifdef _DEBUG
; 214  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 215  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 216  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 217  : #endif // ^^^ !defined(_DEBUG) ^^^
; 218  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001c	2b c2		 sub	 eax, edx

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001e	83 c0 fc	 add	 eax, -4			; fffffffcH
  00021	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00024	77 1f		 ja	 SHORT $LN27@basic_stri

; 220  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00026	8b c2		 mov	 eax, edx
$LN30@basic_stri:

; 289  :         ::operator delete(_Ptr, _Bytes);

  00028	51		 push	 ecx
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	83 c4 08	 add	 esp, 8
$LN19@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 3054 :         _My_data._Mysize = 0;

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 3055 :         _My_data._Myres  = _Small_string_capacity;

  00039	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 3056 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3057 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00040	c6 06 00	 mov	 BYTE PTR [esi], 0
  00043	5e		 pop	 esi

; 1366 :     }

  00044	c3		 ret	 0
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 219  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00045	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN39@basic_stri:
  0004a	cc		 int	 3
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1201 :         noexcept(_Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1202 :         if (this == _STD addressof(_Right)) {

  00005	8b 7d 08	 mov	 edi, DWORD PTR __Right$[ebp]
  00008	8b f1		 mov	 esi, ecx
  0000a	3b f7		 cmp	 esi, edi
  0000c	74 26		 je	 SHORT $LN20@operator

; 1203 :             return *this;
; 1204 :         }
; 1205 : 
; 1206 :         auto& _Al                 = _Getal();
; 1207 :         auto& _Right_al           = _Right._Getal();
; 1208 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;
; 1209 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 1210 :             if (_Al != _Right_al) {
; 1211 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 1212 :                 _Mypair._Myval2._Orphan_all();
; 1213 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1214 :             }
; 1215 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 1216 :             if (_Al != _Right_al) {
; 1217 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 1218 :                 return *this;
; 1219 :             }
; 1220 :         }
; 1221 : 
; 1222 :         _Tidy_deallocate();

  0000e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1262 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00013	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00016	0f 11 06	 movups	 XMMWORD PTR [esi], xmm0
  00019	f3 0f 7e 47 10	 movq	 xmm0, QWORD PTR [edi+16]
  0001e	66 0f d6 46 10	 movq	 QWORD PTR [esi+16], xmm0

; 1263 : 
; 1264 :                 _Right_data._Mysize = 0;

  00023	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0

; 1265 :                 _Right_data._Myres  = _Small_string_capacity;

  0002a	c7 47 14 0f 00
	00 00		 mov	 DWORD PTR [edi+20], 15	; 0000000fH

; 1266 :                 _Right_data._Activate_SSO_buffer();
; 1267 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00031	c6 07 00	 mov	 BYTE PTR [edi], 0
$LN20@operator:
  00034	5f		 pop	 edi

; 1223 :         _Pocma(_Al, _Right_al);
; 1224 :         _Take_contents(_Right);
; 1225 :         return *this;
; 1226 :     }

  00035	8b c6		 mov	 eax, esi
  00037	5e		 pop	 esi
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 744  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b d9		 mov	 ebx, ecx
  00008	0f 57 c0	 xorps	 xmm0, xmm0
  0000b	57		 push	 edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000c	8b 7d 08	 mov	 edi, DWORD PTR __Ptr$[ebp]
  0000f	8b f7		 mov	 esi, edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00011	0f 11 03	 movups	 XMMWORD PTR [ebx], xmm0

; 498  :     size_type _Mysize = 0; // current length of string (size)

  00014	c7 43 10 00 00
	00 00		 mov	 DWORD PTR [ebx+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  0001b	c7 43 14 00 00
	00 00		 mov	 DWORD PTR [ebx+20], 0
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 433  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00022	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL51@basic_stri:
  00025	8a 06		 mov	 al, BYTE PTR [esi]
  00027	46		 inc	 esi
  00028	84 c0		 test	 al, al
  0002a	75 f9		 jne	 SHORT $LL51@basic_stri
  0002c	2b f1		 sub	 esi, ecx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 857  :         if (_Count > max_size()) {

  0002e	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00034	0f 87 9b 00 00
	00		 ja	 $LN62@basic_stri

; 859  :         }
; 860  : 
; 861  :         auto& _Al       = _Getal();
; 862  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 863  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
; 864  : 
; 865  :         if (_Count <= _Small_string_capacity) {

  0003a	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0003d	77 24		 ja	 SHORT $LN21@basic_stri
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0003f	56		 push	 esi
  00040	57		 push	 edi
  00041	53		 push	 ebx
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 866  :             _My_data._Mysize = _Count;

  00042	89 73 10	 mov	 DWORD PTR [ebx+16], esi

; 867  :             _My_data._Myres  = _Small_string_capacity;

  00045	c7 43 14 0f 00
	00 00		 mov	 DWORD PTR [ebx+20], 15	; 0000000fH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0004c	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 874  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00051	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 746  :     }

  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	8b c3		 mov	 eax, ebx
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN21@basic_stri:

; 2942 :         const size_type _Masked = _Requested | _Alloc_mask;

  00063	8b fe		 mov	 edi, esi
  00065	83 cf 0f	 or	 edi, 15			; 0000000fH
  00068	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH

; 2943 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006e	76 12		 jbe	 SHORT $LN27@basic_stri

; 2944 :             return _Max;

  00070	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  00075	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00080	eb 26		 jmp	 SHORT $LN60@basic_stri
$LN27@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 2951 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00082	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  00087	3b f8		 cmp	 edi, eax
  00089	0f 42 f8	 cmovb	 edi, eax

; 801  :         ++_Capacity; // Take null terminator into consideration

  0008c	8d 47 01	 lea	 eax, DWORD PTR [edi+1]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory

; 227  :     if (_Bytes == 0) {

  0008f	85 c0		 test	 eax, eax
  00091	74 18		 je	 SHORT $LN59@basic_stri
$LN41@basic_stri:

; 228  :         return nullptr;
; 229  :     }
; 230  : 
; 231  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 232  :     if (_STD is_constant_evaluated()) {
; 233  :         return _Traits::_Allocate(_Bytes);
; 234  :     }
; 235  : #endif // _HAS_CXX20
; 236  : 
; 237  : #ifdef __cpp_aligned_new
; 238  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 239  :         size_t _Passed_align = _Align;
; 240  : #if defined(_M_IX86) || defined(_M_X64)
; 241  :         if (_Bytes >= _Big_allocation_threshold) {
; 242  :             // boost the alignment of big allocations to help autovectorization
; 243  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 244  :         }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 247  :     } else
; 248  : #endif // defined(__cpp_aligned_new)
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) {

  00093	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00098	72 08		 jb	 SHORT $LN42@basic_stri

; 253  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  000a0	eb 06		 jmp	 SHORT $LN60@basic_stri
$LN42@basic_stri:

; 136  :         return ::operator new(_Bytes);

  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
$LN60@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000a8	83 c4 04	 add	 esp, 4
$LN59@basic_stri:
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ab	56		 push	 esi
  000ac	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000af	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b2	50		 push	 eax
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 889  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000b3	89 03		 mov	 DWORD PTR [ebx], eax

; 890  : 
; 891  :         _My_data._Mysize = _Count;

  000b5	89 73 10	 mov	 DWORD PTR [ebx+16], esi

; 892  :         _My_data._Myres  = _New_capacity;

  000b8	89 7b 14	 mov	 DWORD PTR [ebx+20], edi
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\__msvc_string_view.hpp

; 95   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000bb	e8 00 00 00 00	 call	 _memcpy
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000c0	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 746  :     }

  000c3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c6	5f		 pop	 edi

; 898  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  000c7	c6 04 30 00	 mov	 BYTE PTR [eax+esi], 0

; 745  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
; 746  :     }

  000cb	8b c3		 mov	 eax, ebx
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	8b e5		 mov	 esp, ebp
  000d1	5d		 pop	 ebp
  000d2	c2 04 00	 ret	 4
$LN62@basic_stri:

; 858  :             _Xlen_string(); // result too long

  000d5	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN57@basic_stri:
  000da	cc		 int	 3
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 512  :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 107  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 108  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN18@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN18@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 145  :     }

  00003	8b c1		 mov	 eax, ecx

; 66   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 67   :     {
; 68   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 144  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN13@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN13@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 72   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 91   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN8@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN8@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 97   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 91   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 92   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.43.34808\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 75   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Marty 5.5\Src-Client\Client\GameLib\FlyingData.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
